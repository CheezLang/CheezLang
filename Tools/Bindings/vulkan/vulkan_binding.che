
#lib("./lib/Bindings.lib")

#export_scope

VK_MAKE_VERSION :: (major: u32, minor: u32, patch: u32) #macro {
    @bin_or(@bin_lsl(major, 16), @bin_lsl(minor, 8), patch)
}

uintptr_t :: u64
size_t :: u64
int8_t :: i8
int16_t :: i16
int32_t :: i32
int64_t :: i64
uint8_t :: u8
uint16_t :: u16
uint32_t :: u32
uint64_t :: u64
VkBool32 :: uint32_t
VkDeviceAddress :: uint64_t
VkDeviceSize :: uint64_t
VkFlags :: uint32_t
VkSampleMask :: uint32_t
VkBuffer_T :: struct #copy {}
VkBuffer :: ^mut VkBuffer_T
VkImage_T :: struct #copy {}
VkImage :: ^mut VkImage_T
VkInstance_T :: struct #copy {}
VkInstance :: ^mut VkInstance_T
VkPhysicalDevice_T :: struct #copy {}
VkPhysicalDevice :: ^mut VkPhysicalDevice_T
VkDevice_T :: struct #copy {}
VkDevice :: ^mut VkDevice_T
VkQueue_T :: struct #copy {}
VkQueue :: ^mut VkQueue_T
VkSemaphore_T :: struct #copy {}
VkSemaphore :: ^mut VkSemaphore_T
VkCommandBuffer_T :: struct #copy {}
VkCommandBuffer :: ^mut VkCommandBuffer_T
VkFence_T :: struct #copy {}
VkFence :: ^mut VkFence_T
VkDeviceMemory_T :: struct #copy {}
VkDeviceMemory :: ^mut VkDeviceMemory_T
VkEvent_T :: struct #copy {}
VkEvent :: ^mut VkEvent_T
VkQueryPool_T :: struct #copy {}
VkQueryPool :: ^mut VkQueryPool_T
VkBufferView_T :: struct #copy {}
VkBufferView :: ^mut VkBufferView_T
VkImageView_T :: struct #copy {}
VkImageView :: ^mut VkImageView_T
VkShaderModule_T :: struct #copy {}
VkShaderModule :: ^mut VkShaderModule_T
VkPipelineCache_T :: struct #copy {}
VkPipelineCache :: ^mut VkPipelineCache_T
VkPipelineLayout_T :: struct #copy {}
VkPipelineLayout :: ^mut VkPipelineLayout_T
VkPipeline_T :: struct #copy {}
VkPipeline :: ^mut VkPipeline_T
VkRenderPass_T :: struct #copy {}
VkRenderPass :: ^mut VkRenderPass_T
VkDescriptorSetLayout_T :: struct #copy {}
VkDescriptorSetLayout :: ^mut VkDescriptorSetLayout_T
VkSampler_T :: struct #copy {}
VkSampler :: ^mut VkSampler_T
VkDescriptorSet_T :: struct #copy {}
VkDescriptorSet :: ^mut VkDescriptorSet_T
VkDescriptorPool_T :: struct #copy {}
VkDescriptorPool :: ^mut VkDescriptorPool_T
VkFramebuffer_T :: struct #copy {}
VkFramebuffer :: ^mut VkFramebuffer_T
VkCommandPool_T :: struct #copy {}
VkCommandPool :: ^mut VkCommandPool_T
VkAccessFlags :: VkFlags
VkImageAspectFlags :: VkFlags
VkFormatFeatureFlags :: VkFlags
VkImageCreateFlags :: VkFlags
VkSampleCountFlags :: VkFlags
VkImageUsageFlags :: VkFlags
VkInstanceCreateFlags :: VkFlags
VkMemoryHeapFlags :: VkFlags
VkMemoryPropertyFlags :: VkFlags
VkQueueFlags :: VkFlags
VkDeviceCreateFlags :: VkFlags
VkDeviceQueueCreateFlags :: VkFlags
VkPipelineStageFlags :: VkFlags
VkMemoryMapFlags :: VkFlags
VkSparseMemoryBindFlags :: VkFlags
VkSparseImageFormatFlags :: VkFlags
VkFenceCreateFlags :: VkFlags
VkSemaphoreCreateFlags :: VkFlags
VkEventCreateFlags :: VkFlags
VkQueryPipelineStatisticFlags :: VkFlags
VkQueryPoolCreateFlags :: VkFlags
VkQueryResultFlags :: VkFlags
VkBufferCreateFlags :: VkFlags
VkBufferUsageFlags :: VkFlags
VkBufferViewCreateFlags :: VkFlags
VkImageViewCreateFlags :: VkFlags
VkShaderModuleCreateFlags :: VkFlags
VkPipelineCacheCreateFlags :: VkFlags
VkColorComponentFlags :: VkFlags
VkPipelineCreateFlags :: VkFlags
VkPipelineShaderStageCreateFlags :: VkFlags
VkCullModeFlags :: VkFlags
VkPipelineVertexInputStateCreateFlags :: VkFlags
VkPipelineInputAssemblyStateCreateFlags :: VkFlags
VkPipelineTessellationStateCreateFlags :: VkFlags
VkPipelineViewportStateCreateFlags :: VkFlags
VkPipelineRasterizationStateCreateFlags :: VkFlags
VkPipelineMultisampleStateCreateFlags :: VkFlags
VkPipelineDepthStencilStateCreateFlags :: VkFlags
VkPipelineColorBlendStateCreateFlags :: VkFlags
VkPipelineDynamicStateCreateFlags :: VkFlags
VkPipelineLayoutCreateFlags :: VkFlags
VkShaderStageFlags :: VkFlags
VkSamplerCreateFlags :: VkFlags
VkDescriptorPoolCreateFlags :: VkFlags
VkDescriptorPoolResetFlags :: VkFlags
VkDescriptorSetLayoutCreateFlags :: VkFlags
VkAttachmentDescriptionFlags :: VkFlags
VkDependencyFlags :: VkFlags
VkFramebufferCreateFlags :: VkFlags
VkRenderPassCreateFlags :: VkFlags
VkSubpassDescriptionFlags :: VkFlags
VkCommandPoolCreateFlags :: VkFlags
VkCommandPoolResetFlags :: VkFlags
VkCommandBufferUsageFlags :: VkFlags
VkQueryControlFlags :: VkFlags
VkCommandBufferResetFlags :: VkFlags
VkStencilFaceFlags :: VkFlags
PFN_vkAllocationFunction :: fn(^mut void, size_t, size_t, VkSystemAllocationScope) -> ^mut void
PFN_vkFreeFunction :: fn(^mut void, ^mut void) -> void
PFN_vkInternalAllocationNotification :: fn(^mut void, size_t, VkInternalAllocationType, VkSystemAllocationScope) -> void
PFN_vkInternalFreeNotification :: fn(^mut void, size_t, VkInternalAllocationType, VkSystemAllocationScope) -> void
PFN_vkReallocationFunction :: fn(^mut void, ^mut void, size_t, size_t, VkSystemAllocationScope) -> ^mut void
PFN_vkVoidFunction :: fn() -> void
PFN_vkCreateInstance :: fn(^mut VkInstanceCreateInfo, ^mut VkAllocationCallbacks, ^mut VkInstance) -> VkResult
PFN_vkDestroyInstance :: fn(VkInstance, ^mut VkAllocationCallbacks) -> void
PFN_vkEnumeratePhysicalDevices :: fn(VkInstance, ^mut uint32_t, ^mut VkPhysicalDevice) -> VkResult
PFN_vkGetPhysicalDeviceFeatures :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceFeatures) -> void
PFN_vkGetPhysicalDeviceFormatProperties :: fn(VkPhysicalDevice, VkFormat, ^mut VkFormatProperties) -> void
PFN_vkGetPhysicalDeviceImageFormatProperties :: fn(VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, ^mut VkImageFormatProperties) -> VkResult
PFN_vkGetPhysicalDeviceProperties :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceProperties) -> void
PFN_vkGetPhysicalDeviceQueueFamilyProperties :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkQueueFamilyProperties) -> void
PFN_vkGetPhysicalDeviceMemoryProperties :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceMemoryProperties) -> void
PFN_vkGetInstanceProcAddr :: fn(VkInstance, ^mut char8) -> PFN_vkVoidFunction
PFN_vkGetDeviceProcAddr :: fn(VkDevice, ^mut char8) -> PFN_vkVoidFunction
PFN_vkCreateDevice :: fn(VkPhysicalDevice, ^mut VkDeviceCreateInfo, ^mut VkAllocationCallbacks, ^mut VkDevice) -> VkResult
PFN_vkDestroyDevice :: fn(VkDevice, ^mut VkAllocationCallbacks) -> void
PFN_vkEnumerateInstanceExtensionProperties :: fn(^mut char8, ^mut uint32_t, ^mut VkExtensionProperties) -> VkResult
PFN_vkEnumerateDeviceExtensionProperties :: fn(VkPhysicalDevice, ^mut char8, ^mut uint32_t, ^mut VkExtensionProperties) -> VkResult
PFN_vkEnumerateInstanceLayerProperties :: fn(^mut uint32_t, ^mut VkLayerProperties) -> VkResult
PFN_vkEnumerateDeviceLayerProperties :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkLayerProperties) -> VkResult
PFN_vkGetDeviceQueue :: fn(VkDevice, uint32_t, uint32_t, ^mut VkQueue) -> void
PFN_vkQueueSubmit :: fn(VkQueue, uint32_t, ^mut VkSubmitInfo, VkFence) -> VkResult
PFN_vkQueueWaitIdle :: fn(VkQueue) -> VkResult
PFN_vkDeviceWaitIdle :: fn(VkDevice) -> VkResult
PFN_vkAllocateMemory :: fn(VkDevice, ^mut VkMemoryAllocateInfo, ^mut VkAllocationCallbacks, ^mut VkDeviceMemory) -> VkResult
PFN_vkFreeMemory :: fn(VkDevice, VkDeviceMemory, ^mut VkAllocationCallbacks) -> void
PFN_vkMapMemory :: fn(VkDevice, VkDeviceMemory, VkDeviceSize, VkDeviceSize, VkMemoryMapFlags, ^mut ^mut void) -> VkResult
PFN_vkUnmapMemory :: fn(VkDevice, VkDeviceMemory) -> void
PFN_vkFlushMappedMemoryRanges :: fn(VkDevice, uint32_t, ^mut VkMappedMemoryRange) -> VkResult
PFN_vkInvalidateMappedMemoryRanges :: fn(VkDevice, uint32_t, ^mut VkMappedMemoryRange) -> VkResult
PFN_vkGetDeviceMemoryCommitment :: fn(VkDevice, VkDeviceMemory, ^mut VkDeviceSize) -> void
PFN_vkBindBufferMemory :: fn(VkDevice, VkBuffer, VkDeviceMemory, VkDeviceSize) -> VkResult
PFN_vkBindImageMemory :: fn(VkDevice, VkImage, VkDeviceMemory, VkDeviceSize) -> VkResult
PFN_vkGetBufferMemoryRequirements :: fn(VkDevice, VkBuffer, ^mut VkMemoryRequirements) -> void
PFN_vkGetImageMemoryRequirements :: fn(VkDevice, VkImage, ^mut VkMemoryRequirements) -> void
PFN_vkGetImageSparseMemoryRequirements :: fn(VkDevice, VkImage, ^mut uint32_t, ^mut VkSparseImageMemoryRequirements) -> void
PFN_vkGetPhysicalDeviceSparseImageFormatProperties :: fn(VkPhysicalDevice, VkFormat, VkImageType, VkSampleCountFlagBits, VkImageUsageFlags, VkImageTiling, ^mut uint32_t, ^mut VkSparseImageFormatProperties) -> void
PFN_vkQueueBindSparse :: fn(VkQueue, uint32_t, ^mut VkBindSparseInfo, VkFence) -> VkResult
PFN_vkCreateFence :: fn(VkDevice, ^mut VkFenceCreateInfo, ^mut VkAllocationCallbacks, ^mut VkFence) -> VkResult
PFN_vkDestroyFence :: fn(VkDevice, VkFence, ^mut VkAllocationCallbacks) -> void
PFN_vkResetFences :: fn(VkDevice, uint32_t, ^mut VkFence) -> VkResult
PFN_vkGetFenceStatus :: fn(VkDevice, VkFence) -> VkResult
PFN_vkWaitForFences :: fn(VkDevice, uint32_t, ^mut VkFence, VkBool32, uint64_t) -> VkResult
PFN_vkCreateSemaphore :: fn(VkDevice, ^mut VkSemaphoreCreateInfo, ^mut VkAllocationCallbacks, ^mut VkSemaphore) -> VkResult
PFN_vkDestroySemaphore :: fn(VkDevice, VkSemaphore, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateEvent :: fn(VkDevice, ^mut VkEventCreateInfo, ^mut VkAllocationCallbacks, ^mut VkEvent) -> VkResult
PFN_vkDestroyEvent :: fn(VkDevice, VkEvent, ^mut VkAllocationCallbacks) -> void
PFN_vkGetEventStatus :: fn(VkDevice, VkEvent) -> VkResult
PFN_vkSetEvent :: fn(VkDevice, VkEvent) -> VkResult
PFN_vkResetEvent :: fn(VkDevice, VkEvent) -> VkResult
PFN_vkCreateQueryPool :: fn(VkDevice, ^mut VkQueryPoolCreateInfo, ^mut VkAllocationCallbacks, ^mut VkQueryPool) -> VkResult
PFN_vkDestroyQueryPool :: fn(VkDevice, VkQueryPool, ^mut VkAllocationCallbacks) -> void
PFN_vkGetQueryPoolResults :: fn(VkDevice, VkQueryPool, uint32_t, uint32_t, size_t, ^mut void, VkDeviceSize, VkQueryResultFlags) -> VkResult
PFN_vkCreateBuffer :: fn(VkDevice, ^mut VkBufferCreateInfo, ^mut VkAllocationCallbacks, ^mut VkBuffer) -> VkResult
PFN_vkDestroyBuffer :: fn(VkDevice, VkBuffer, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateBufferView :: fn(VkDevice, ^mut VkBufferViewCreateInfo, ^mut VkAllocationCallbacks, ^mut VkBufferView) -> VkResult
PFN_vkDestroyBufferView :: fn(VkDevice, VkBufferView, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateImage :: fn(VkDevice, ^mut VkImageCreateInfo, ^mut VkAllocationCallbacks, ^mut VkImage) -> VkResult
PFN_vkDestroyImage :: fn(VkDevice, VkImage, ^mut VkAllocationCallbacks) -> void
PFN_vkGetImageSubresourceLayout :: fn(VkDevice, VkImage, ^mut VkImageSubresource, ^mut VkSubresourceLayout) -> void
PFN_vkCreateImageView :: fn(VkDevice, ^mut VkImageViewCreateInfo, ^mut VkAllocationCallbacks, ^mut VkImageView) -> VkResult
PFN_vkDestroyImageView :: fn(VkDevice, VkImageView, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateShaderModule :: fn(VkDevice, ^mut VkShaderModuleCreateInfo, ^mut VkAllocationCallbacks, ^mut VkShaderModule) -> VkResult
PFN_vkDestroyShaderModule :: fn(VkDevice, VkShaderModule, ^mut VkAllocationCallbacks) -> void
PFN_vkCreatePipelineCache :: fn(VkDevice, ^mut VkPipelineCacheCreateInfo, ^mut VkAllocationCallbacks, ^mut VkPipelineCache) -> VkResult
PFN_vkDestroyPipelineCache :: fn(VkDevice, VkPipelineCache, ^mut VkAllocationCallbacks) -> void
PFN_vkGetPipelineCacheData :: fn(VkDevice, VkPipelineCache, ^mut size_t, ^mut void) -> VkResult
PFN_vkMergePipelineCaches :: fn(VkDevice, VkPipelineCache, uint32_t, ^mut VkPipelineCache) -> VkResult
PFN_vkCreateGraphicsPipelines :: fn(VkDevice, VkPipelineCache, uint32_t, ^mut VkGraphicsPipelineCreateInfo, ^mut VkAllocationCallbacks, ^mut VkPipeline) -> VkResult
PFN_vkCreateComputePipelines :: fn(VkDevice, VkPipelineCache, uint32_t, ^mut VkComputePipelineCreateInfo, ^mut VkAllocationCallbacks, ^mut VkPipeline) -> VkResult
PFN_vkDestroyPipeline :: fn(VkDevice, VkPipeline, ^mut VkAllocationCallbacks) -> void
PFN_vkCreatePipelineLayout :: fn(VkDevice, ^mut VkPipelineLayoutCreateInfo, ^mut VkAllocationCallbacks, ^mut VkPipelineLayout) -> VkResult
PFN_vkDestroyPipelineLayout :: fn(VkDevice, VkPipelineLayout, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateSampler :: fn(VkDevice, ^mut VkSamplerCreateInfo, ^mut VkAllocationCallbacks, ^mut VkSampler) -> VkResult
PFN_vkDestroySampler :: fn(VkDevice, VkSampler, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateDescriptorSetLayout :: fn(VkDevice, ^mut VkDescriptorSetLayoutCreateInfo, ^mut VkAllocationCallbacks, ^mut VkDescriptorSetLayout) -> VkResult
PFN_vkDestroyDescriptorSetLayout :: fn(VkDevice, VkDescriptorSetLayout, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateDescriptorPool :: fn(VkDevice, ^mut VkDescriptorPoolCreateInfo, ^mut VkAllocationCallbacks, ^mut VkDescriptorPool) -> VkResult
PFN_vkDestroyDescriptorPool :: fn(VkDevice, VkDescriptorPool, ^mut VkAllocationCallbacks) -> void
PFN_vkResetDescriptorPool :: fn(VkDevice, VkDescriptorPool, VkDescriptorPoolResetFlags) -> VkResult
PFN_vkAllocateDescriptorSets :: fn(VkDevice, ^mut VkDescriptorSetAllocateInfo, ^mut VkDescriptorSet) -> VkResult
PFN_vkFreeDescriptorSets :: fn(VkDevice, VkDescriptorPool, uint32_t, ^mut VkDescriptorSet) -> VkResult
PFN_vkUpdateDescriptorSets :: fn(VkDevice, uint32_t, ^mut VkWriteDescriptorSet, uint32_t, ^mut VkCopyDescriptorSet) -> void
PFN_vkCreateFramebuffer :: fn(VkDevice, ^mut VkFramebufferCreateInfo, ^mut VkAllocationCallbacks, ^mut VkFramebuffer) -> VkResult
PFN_vkDestroyFramebuffer :: fn(VkDevice, VkFramebuffer, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateRenderPass :: fn(VkDevice, ^mut VkRenderPassCreateInfo, ^mut VkAllocationCallbacks, ^mut VkRenderPass) -> VkResult
PFN_vkDestroyRenderPass :: fn(VkDevice, VkRenderPass, ^mut VkAllocationCallbacks) -> void
PFN_vkGetRenderAreaGranularity :: fn(VkDevice, VkRenderPass, ^mut VkExtent2D) -> void
PFN_vkCreateCommandPool :: fn(VkDevice, ^mut VkCommandPoolCreateInfo, ^mut VkAllocationCallbacks, ^mut VkCommandPool) -> VkResult
PFN_vkDestroyCommandPool :: fn(VkDevice, VkCommandPool, ^mut VkAllocationCallbacks) -> void
PFN_vkResetCommandPool :: fn(VkDevice, VkCommandPool, VkCommandPoolResetFlags) -> VkResult
PFN_vkAllocateCommandBuffers :: fn(VkDevice, ^mut VkCommandBufferAllocateInfo, ^mut VkCommandBuffer) -> VkResult
PFN_vkFreeCommandBuffers :: fn(VkDevice, VkCommandPool, uint32_t, ^mut VkCommandBuffer) -> void
PFN_vkBeginCommandBuffer :: fn(VkCommandBuffer, ^mut VkCommandBufferBeginInfo) -> VkResult
PFN_vkEndCommandBuffer :: fn(VkCommandBuffer) -> VkResult
PFN_vkResetCommandBuffer :: fn(VkCommandBuffer, VkCommandBufferResetFlags) -> VkResult
PFN_vkCmdBindPipeline :: fn(VkCommandBuffer, VkPipelineBindPoint, VkPipeline) -> void
PFN_vkCmdSetViewport :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkViewport) -> void
PFN_vkCmdSetScissor :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkRect2D) -> void
PFN_vkCmdSetLineWidth :: fn(VkCommandBuffer, f32) -> void
PFN_vkCmdSetDepthBias :: fn(VkCommandBuffer, f32, f32, f32) -> void
PFN_vkCmdSetBlendConstants :: fn(VkCommandBuffer, ^mut f32) -> void
PFN_vkCmdSetDepthBounds :: fn(VkCommandBuffer, f32, f32) -> void
PFN_vkCmdSetStencilCompareMask :: fn(VkCommandBuffer, VkStencilFaceFlags, uint32_t) -> void
PFN_vkCmdSetStencilWriteMask :: fn(VkCommandBuffer, VkStencilFaceFlags, uint32_t) -> void
PFN_vkCmdSetStencilReference :: fn(VkCommandBuffer, VkStencilFaceFlags, uint32_t) -> void
PFN_vkCmdBindDescriptorSets :: fn(VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, uint32_t, uint32_t, ^mut VkDescriptorSet, uint32_t, ^mut uint32_t) -> void
PFN_vkCmdBindIndexBuffer :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkIndexType) -> void
PFN_vkCmdBindVertexBuffers :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkBuffer, ^mut VkDeviceSize) -> void
PFN_vkCmdDraw :: fn(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndexed :: fn(VkCommandBuffer, uint32_t, uint32_t, uint32_t, int32_t, uint32_t) -> void
PFN_vkCmdDrawIndirect :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndexedIndirect :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDispatch :: fn(VkCommandBuffer, uint32_t, uint32_t, uint32_t) -> void
PFN_vkCmdDispatchIndirect :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize) -> void
PFN_vkCmdCopyBuffer :: fn(VkCommandBuffer, VkBuffer, VkBuffer, uint32_t, ^mut VkBufferCopy) -> void
PFN_vkCmdCopyImage :: fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, uint32_t, ^mut VkImageCopy) -> void
PFN_vkCmdBlitImage :: fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, uint32_t, ^mut VkImageBlit, VkFilter) -> void
PFN_vkCmdCopyBufferToImage :: fn(VkCommandBuffer, VkBuffer, VkImage, VkImageLayout, uint32_t, ^mut VkBufferImageCopy) -> void
PFN_vkCmdCopyImageToBuffer :: fn(VkCommandBuffer, VkImage, VkImageLayout, VkBuffer, uint32_t, ^mut VkBufferImageCopy) -> void
PFN_vkCmdUpdateBuffer :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, ^mut void) -> void
PFN_vkCmdFillBuffer :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkDeviceSize, uint32_t) -> void
PFN_vkCmdClearColorImage :: fn(VkCommandBuffer, VkImage, VkImageLayout, ^mut VkClearColorValue, uint32_t, ^mut VkImageSubresourceRange) -> void
PFN_vkCmdClearDepthStencilImage :: fn(VkCommandBuffer, VkImage, VkImageLayout, ^mut VkClearDepthStencilValue, uint32_t, ^mut VkImageSubresourceRange) -> void
PFN_vkCmdClearAttachments :: fn(VkCommandBuffer, uint32_t, ^mut VkClearAttachment, uint32_t, ^mut VkClearRect) -> void
PFN_vkCmdResolveImage :: fn(VkCommandBuffer, VkImage, VkImageLayout, VkImage, VkImageLayout, uint32_t, ^mut VkImageResolve) -> void
PFN_vkCmdSetEvent :: fn(VkCommandBuffer, VkEvent, VkPipelineStageFlags) -> void
PFN_vkCmdResetEvent :: fn(VkCommandBuffer, VkEvent, VkPipelineStageFlags) -> void
PFN_vkCmdWaitEvents :: fn(VkCommandBuffer, uint32_t, ^mut VkEvent, VkPipelineStageFlags, VkPipelineStageFlags, uint32_t, ^mut VkMemoryBarrier, uint32_t, ^mut VkBufferMemoryBarrier, uint32_t, ^mut VkImageMemoryBarrier) -> void
PFN_vkCmdPipelineBarrier :: fn(VkCommandBuffer, VkPipelineStageFlags, VkPipelineStageFlags, VkDependencyFlags, uint32_t, ^mut VkMemoryBarrier, uint32_t, ^mut VkBufferMemoryBarrier, uint32_t, ^mut VkImageMemoryBarrier) -> void
PFN_vkCmdBeginQuery :: fn(VkCommandBuffer, VkQueryPool, uint32_t, VkQueryControlFlags) -> void
PFN_vkCmdEndQuery :: fn(VkCommandBuffer, VkQueryPool, uint32_t) -> void
PFN_vkCmdResetQueryPool :: fn(VkCommandBuffer, VkQueryPool, uint32_t, uint32_t) -> void
PFN_vkCmdWriteTimestamp :: fn(VkCommandBuffer, VkPipelineStageFlagBits, VkQueryPool, uint32_t) -> void
PFN_vkCmdCopyQueryPoolResults :: fn(VkCommandBuffer, VkQueryPool, uint32_t, uint32_t, VkBuffer, VkDeviceSize, VkDeviceSize, VkQueryResultFlags) -> void
PFN_vkCmdPushConstants :: fn(VkCommandBuffer, VkPipelineLayout, VkShaderStageFlags, uint32_t, uint32_t, ^mut void) -> void
PFN_vkCmdBeginRenderPass :: fn(VkCommandBuffer, ^mut VkRenderPassBeginInfo, VkSubpassContents) -> void
PFN_vkCmdNextSubpass :: fn(VkCommandBuffer, VkSubpassContents) -> void
PFN_vkCmdEndRenderPass :: fn(VkCommandBuffer) -> void
PFN_vkCmdExecuteCommands :: fn(VkCommandBuffer, uint32_t, ^mut VkCommandBuffer) -> void
VkSamplerYcbcrConversion_T :: struct #copy {}
VkSamplerYcbcrConversion :: ^mut VkSamplerYcbcrConversion_T
VkDescriptorUpdateTemplate_T :: struct #copy {}
VkDescriptorUpdateTemplate :: ^mut VkDescriptorUpdateTemplate_T
VkSubgroupFeatureFlags :: VkFlags
VkPeerMemoryFeatureFlags :: VkFlags
VkMemoryAllocateFlags :: VkFlags
VkCommandPoolTrimFlags :: VkFlags
VkDescriptorUpdateTemplateCreateFlags :: VkFlags
VkExternalMemoryHandleTypeFlags :: VkFlags
VkExternalMemoryFeatureFlags :: VkFlags
VkExternalFenceHandleTypeFlags :: VkFlags
VkExternalFenceFeatureFlags :: VkFlags
VkFenceImportFlags :: VkFlags
VkSemaphoreImportFlags :: VkFlags
VkExternalSemaphoreHandleTypeFlags :: VkFlags
VkExternalSemaphoreFeatureFlags :: VkFlags
VkPhysicalDeviceVariablePointerFeatures :: VkPhysicalDeviceVariablePointersFeatures
VkPhysicalDeviceShaderDrawParameterFeatures :: VkPhysicalDeviceShaderDrawParametersFeatures
PFN_vkEnumerateInstanceVersion :: fn(^mut uint32_t) -> VkResult
PFN_vkBindBufferMemory2 :: fn(VkDevice, uint32_t, ^mut VkBindBufferMemoryInfo) -> VkResult
PFN_vkBindImageMemory2 :: fn(VkDevice, uint32_t, ^mut VkBindImageMemoryInfo) -> VkResult
PFN_vkGetDeviceGroupPeerMemoryFeatures :: fn(VkDevice, uint32_t, uint32_t, uint32_t, ^mut VkPeerMemoryFeatureFlags) -> void
PFN_vkCmdSetDeviceMask :: fn(VkCommandBuffer, uint32_t) -> void
PFN_vkCmdDispatchBase :: fn(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) -> void
PFN_vkEnumeratePhysicalDeviceGroups :: fn(VkInstance, ^mut uint32_t, ^mut VkPhysicalDeviceGroupProperties) -> VkResult
PFN_vkGetImageMemoryRequirements2 :: fn(VkDevice, ^mut VkImageMemoryRequirementsInfo2, ^mut VkMemoryRequirements2) -> void
PFN_vkGetBufferMemoryRequirements2 :: fn(VkDevice, ^mut VkBufferMemoryRequirementsInfo2, ^mut VkMemoryRequirements2) -> void
PFN_vkGetImageSparseMemoryRequirements2 :: fn(VkDevice, ^mut VkImageSparseMemoryRequirementsInfo2, ^mut uint32_t, ^mut VkSparseImageMemoryRequirements2) -> void
PFN_vkGetPhysicalDeviceFeatures2 :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceFeatures2) -> void
PFN_vkGetPhysicalDeviceProperties2 :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceProperties2) -> void
PFN_vkGetPhysicalDeviceFormatProperties2 :: fn(VkPhysicalDevice, VkFormat, ^mut VkFormatProperties2) -> void
PFN_vkGetPhysicalDeviceImageFormatProperties2 :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceImageFormatInfo2, ^mut VkImageFormatProperties2) -> VkResult
PFN_vkGetPhysicalDeviceQueueFamilyProperties2 :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkQueueFamilyProperties2) -> void
PFN_vkGetPhysicalDeviceMemoryProperties2 :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceMemoryProperties2) -> void
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceSparseImageFormatInfo2, ^mut uint32_t, ^mut VkSparseImageFormatProperties2) -> void
PFN_vkTrimCommandPool :: fn(VkDevice, VkCommandPool, VkCommandPoolTrimFlags) -> void
PFN_vkGetDeviceQueue2 :: fn(VkDevice, ^mut VkDeviceQueueInfo2, ^mut VkQueue) -> void
PFN_vkCreateSamplerYcbcrConversion :: fn(VkDevice, ^mut VkSamplerYcbcrConversionCreateInfo, ^mut VkAllocationCallbacks, ^mut VkSamplerYcbcrConversion) -> VkResult
PFN_vkDestroySamplerYcbcrConversion :: fn(VkDevice, VkSamplerYcbcrConversion, ^mut VkAllocationCallbacks) -> void
PFN_vkCreateDescriptorUpdateTemplate :: fn(VkDevice, ^mut VkDescriptorUpdateTemplateCreateInfo, ^mut VkAllocationCallbacks, ^mut VkDescriptorUpdateTemplate) -> VkResult
PFN_vkDestroyDescriptorUpdateTemplate :: fn(VkDevice, VkDescriptorUpdateTemplate, ^mut VkAllocationCallbacks) -> void
PFN_vkUpdateDescriptorSetWithTemplate :: fn(VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, ^mut void) -> void
PFN_vkGetPhysicalDeviceExternalBufferProperties :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalBufferInfo, ^mut VkExternalBufferProperties) -> void
PFN_vkGetPhysicalDeviceExternalFenceProperties :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalFenceInfo, ^mut VkExternalFenceProperties) -> void
PFN_vkGetPhysicalDeviceExternalSemaphoreProperties :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalSemaphoreInfo, ^mut VkExternalSemaphoreProperties) -> void
PFN_vkGetDescriptorSetLayoutSupport :: fn(VkDevice, ^mut VkDescriptorSetLayoutCreateInfo, ^mut VkDescriptorSetLayoutSupport) -> void
VkResolveModeFlags :: VkFlags
VkDescriptorBindingFlags :: VkFlags
VkSemaphoreWaitFlags :: VkFlags
PFN_vkCmdDrawIndirectCount :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndexedIndirectCount :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCreateRenderPass2 :: fn(VkDevice, ^mut VkRenderPassCreateInfo2, ^mut VkAllocationCallbacks, ^mut VkRenderPass) -> VkResult
PFN_vkCmdBeginRenderPass2 :: fn(VkCommandBuffer, ^mut VkRenderPassBeginInfo, ^mut VkSubpassBeginInfo) -> void
PFN_vkCmdNextSubpass2 :: fn(VkCommandBuffer, ^mut VkSubpassBeginInfo, ^mut VkSubpassEndInfo) -> void
PFN_vkCmdEndRenderPass2 :: fn(VkCommandBuffer, ^mut VkSubpassEndInfo) -> void
PFN_vkResetQueryPool :: fn(VkDevice, VkQueryPool, uint32_t, uint32_t) -> void
PFN_vkGetSemaphoreCounterValue :: fn(VkDevice, VkSemaphore, ^mut uint64_t) -> VkResult
PFN_vkWaitSemaphores :: fn(VkDevice, ^mut VkSemaphoreWaitInfo, uint64_t) -> VkResult
PFN_vkSignalSemaphore :: fn(VkDevice, ^mut VkSemaphoreSignalInfo) -> VkResult
PFN_vkGetBufferDeviceAddress :: fn(VkDevice, ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress
PFN_vkGetBufferOpaqueCaptureAddress :: fn(VkDevice, ^mut VkBufferDeviceAddressInfo) -> uint64_t
PFN_vkGetDeviceMemoryOpaqueCaptureAddress :: fn(VkDevice, ^mut VkDeviceMemoryOpaqueCaptureAddressInfo) -> uint64_t
VkSurfaceKHR_T :: struct #copy {}
VkSurfaceKHR :: ^mut VkSurfaceKHR_T
VkCompositeAlphaFlagsKHR :: VkFlags
VkSurfaceTransformFlagsKHR :: VkFlags
PFN_vkDestroySurfaceKHR :: fn(VkInstance, VkSurfaceKHR, ^mut VkAllocationCallbacks) -> void
PFN_vkGetPhysicalDeviceSurfaceSupportKHR :: fn(VkPhysicalDevice, uint32_t, VkSurfaceKHR, ^mut VkBool32) -> VkResult
PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: fn(VkPhysicalDevice, VkSurfaceKHR, ^mut VkSurfaceCapabilitiesKHR) -> VkResult
PFN_vkGetPhysicalDeviceSurfaceFormatsKHR :: fn(VkPhysicalDevice, VkSurfaceKHR, ^mut uint32_t, ^mut VkSurfaceFormatKHR) -> VkResult
PFN_vkGetPhysicalDeviceSurfacePresentModesKHR :: fn(VkPhysicalDevice, VkSurfaceKHR, ^mut uint32_t, ^mut VkPresentModeKHR) -> VkResult
VkSwapchainKHR_T :: struct #copy {}
VkSwapchainKHR :: ^mut VkSwapchainKHR_T
VkSwapchainCreateFlagsKHR :: VkFlags
VkDeviceGroupPresentModeFlagsKHR :: VkFlags
PFN_vkCreateSwapchainKHR :: fn(VkDevice, ^mut VkSwapchainCreateInfoKHR, ^mut VkAllocationCallbacks, ^mut VkSwapchainKHR) -> VkResult
PFN_vkDestroySwapchainKHR :: fn(VkDevice, VkSwapchainKHR, ^mut VkAllocationCallbacks) -> void
PFN_vkGetSwapchainImagesKHR :: fn(VkDevice, VkSwapchainKHR, ^mut uint32_t, ^mut VkImage) -> VkResult
PFN_vkAcquireNextImageKHR :: fn(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, ^mut uint32_t) -> VkResult
PFN_vkQueuePresentKHR :: fn(VkQueue, ^mut VkPresentInfoKHR) -> VkResult
PFN_vkGetDeviceGroupPresentCapabilitiesKHR :: fn(VkDevice, ^mut VkDeviceGroupPresentCapabilitiesKHR) -> VkResult
PFN_vkGetDeviceGroupSurfacePresentModesKHR :: fn(VkDevice, VkSurfaceKHR, ^mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult
PFN_vkGetPhysicalDevicePresentRectanglesKHR :: fn(VkPhysicalDevice, VkSurfaceKHR, ^mut uint32_t, ^mut VkRect2D) -> VkResult
PFN_vkAcquireNextImage2KHR :: fn(VkDevice, ^mut VkAcquireNextImageInfoKHR, ^mut uint32_t) -> VkResult
VkDisplayKHR_T :: struct #copy {}
VkDisplayKHR :: ^mut VkDisplayKHR_T
VkDisplayModeKHR_T :: struct #copy {}
VkDisplayModeKHR :: ^mut VkDisplayModeKHR_T
VkDisplayModeCreateFlagsKHR :: VkFlags
VkDisplayPlaneAlphaFlagsKHR :: VkFlags
VkDisplaySurfaceCreateFlagsKHR :: VkFlags
PFN_vkGetPhysicalDeviceDisplayPropertiesKHR :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkDisplayPropertiesKHR) -> VkResult
PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkDisplayPlanePropertiesKHR) -> VkResult
PFN_vkGetDisplayPlaneSupportedDisplaysKHR :: fn(VkPhysicalDevice, uint32_t, ^mut uint32_t, ^mut VkDisplayKHR) -> VkResult
PFN_vkGetDisplayModePropertiesKHR :: fn(VkPhysicalDevice, VkDisplayKHR, ^mut uint32_t, ^mut VkDisplayModePropertiesKHR) -> VkResult
PFN_vkCreateDisplayModeKHR :: fn(VkPhysicalDevice, VkDisplayKHR, ^mut VkDisplayModeCreateInfoKHR, ^mut VkAllocationCallbacks, ^mut VkDisplayModeKHR) -> VkResult
PFN_vkGetDisplayPlaneCapabilitiesKHR :: fn(VkPhysicalDevice, VkDisplayModeKHR, uint32_t, ^mut VkDisplayPlaneCapabilitiesKHR) -> VkResult
PFN_vkCreateDisplayPlaneSurfaceKHR :: fn(VkInstance, ^mut VkDisplaySurfaceCreateInfoKHR, ^mut VkAllocationCallbacks, ^mut VkSurfaceKHR) -> VkResult
PFN_vkCreateSharedSwapchainsKHR :: fn(VkDevice, uint32_t, ^mut VkSwapchainCreateInfoKHR, ^mut VkAllocationCallbacks, ^mut VkSwapchainKHR) -> VkResult
VkRenderPassMultiviewCreateInfoKHR :: VkRenderPassMultiviewCreateInfo
VkPhysicalDeviceMultiviewFeaturesKHR :: VkPhysicalDeviceMultiviewFeatures
VkPhysicalDeviceMultiviewPropertiesKHR :: VkPhysicalDeviceMultiviewProperties
VkPhysicalDeviceFeatures2KHR :: VkPhysicalDeviceFeatures2
VkPhysicalDeviceProperties2KHR :: VkPhysicalDeviceProperties2
VkFormatProperties2KHR :: VkFormatProperties2
VkImageFormatProperties2KHR :: VkImageFormatProperties2
VkPhysicalDeviceImageFormatInfo2KHR :: VkPhysicalDeviceImageFormatInfo2
VkQueueFamilyProperties2KHR :: VkQueueFamilyProperties2
VkPhysicalDeviceMemoryProperties2KHR :: VkPhysicalDeviceMemoryProperties2
VkSparseImageFormatProperties2KHR :: VkSparseImageFormatProperties2
VkPhysicalDeviceSparseImageFormatInfo2KHR :: VkPhysicalDeviceSparseImageFormatInfo2
PFN_vkGetPhysicalDeviceFeatures2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceFeatures2) -> void
PFN_vkGetPhysicalDeviceProperties2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceProperties2) -> void
PFN_vkGetPhysicalDeviceFormatProperties2KHR :: fn(VkPhysicalDevice, VkFormat, ^mut VkFormatProperties2) -> void
PFN_vkGetPhysicalDeviceImageFormatProperties2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceImageFormatInfo2, ^mut VkImageFormatProperties2) -> VkResult
PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkQueueFamilyProperties2) -> void
PFN_vkGetPhysicalDeviceMemoryProperties2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceMemoryProperties2) -> void
PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceSparseImageFormatInfo2, ^mut uint32_t, ^mut VkSparseImageFormatProperties2) -> void
VkPeerMemoryFeatureFlagsKHR :: VkPeerMemoryFeatureFlags
VkPeerMemoryFeatureFlagBitsKHR :: VkPeerMemoryFeatureFlagBits
VkMemoryAllocateFlagsKHR :: VkMemoryAllocateFlags
VkMemoryAllocateFlagBitsKHR :: VkMemoryAllocateFlagBits
VkMemoryAllocateFlagsInfoKHR :: VkMemoryAllocateFlagsInfo
VkDeviceGroupRenderPassBeginInfoKHR :: VkDeviceGroupRenderPassBeginInfo
VkDeviceGroupCommandBufferBeginInfoKHR :: VkDeviceGroupCommandBufferBeginInfo
VkDeviceGroupSubmitInfoKHR :: VkDeviceGroupSubmitInfo
VkDeviceGroupBindSparseInfoKHR :: VkDeviceGroupBindSparseInfo
VkBindBufferMemoryDeviceGroupInfoKHR :: VkBindBufferMemoryDeviceGroupInfo
VkBindImageMemoryDeviceGroupInfoKHR :: VkBindImageMemoryDeviceGroupInfo
PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR :: fn(VkDevice, uint32_t, uint32_t, uint32_t, ^mut VkPeerMemoryFeatureFlags) -> void
PFN_vkCmdSetDeviceMaskKHR :: fn(VkCommandBuffer, uint32_t) -> void
PFN_vkCmdDispatchBaseKHR :: fn(VkCommandBuffer, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t) -> void
VkCommandPoolTrimFlagsKHR :: VkCommandPoolTrimFlags
PFN_vkTrimCommandPoolKHR :: fn(VkDevice, VkCommandPool, VkCommandPoolTrimFlags) -> void
VkPhysicalDeviceGroupPropertiesKHR :: VkPhysicalDeviceGroupProperties
VkDeviceGroupDeviceCreateInfoKHR :: VkDeviceGroupDeviceCreateInfo
PFN_vkEnumeratePhysicalDeviceGroupsKHR :: fn(VkInstance, ^mut uint32_t, ^mut VkPhysicalDeviceGroupProperties) -> VkResult
VkExternalMemoryHandleTypeFlagsKHR :: VkExternalMemoryHandleTypeFlags
VkExternalMemoryHandleTypeFlagBitsKHR :: VkExternalMemoryHandleTypeFlagBits
VkExternalMemoryFeatureFlagsKHR :: VkExternalMemoryFeatureFlags
VkExternalMemoryFeatureFlagBitsKHR :: VkExternalMemoryFeatureFlagBits
VkExternalMemoryPropertiesKHR :: VkExternalMemoryProperties
VkPhysicalDeviceExternalImageFormatInfoKHR :: VkPhysicalDeviceExternalImageFormatInfo
VkExternalImageFormatPropertiesKHR :: VkExternalImageFormatProperties
VkPhysicalDeviceExternalBufferInfoKHR :: VkPhysicalDeviceExternalBufferInfo
VkExternalBufferPropertiesKHR :: VkExternalBufferProperties
VkPhysicalDeviceIDPropertiesKHR :: VkPhysicalDeviceIDProperties
PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalBufferInfo, ^mut VkExternalBufferProperties) -> void
VkExternalMemoryImageCreateInfoKHR :: VkExternalMemoryImageCreateInfo
VkExternalMemoryBufferCreateInfoKHR :: VkExternalMemoryBufferCreateInfo
VkExportMemoryAllocateInfoKHR :: VkExportMemoryAllocateInfo
PFN_vkGetMemoryFdKHR :: fn(VkDevice, ^mut VkMemoryGetFdInfoKHR, ^mut i32) -> VkResult
PFN_vkGetMemoryFdPropertiesKHR :: fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, i32, ^mut VkMemoryFdPropertiesKHR) -> VkResult
VkExternalSemaphoreHandleTypeFlagsKHR :: VkExternalSemaphoreHandleTypeFlags
VkExternalSemaphoreHandleTypeFlagBitsKHR :: VkExternalSemaphoreHandleTypeFlagBits
VkExternalSemaphoreFeatureFlagsKHR :: VkExternalSemaphoreFeatureFlags
VkExternalSemaphoreFeatureFlagBitsKHR :: VkExternalSemaphoreFeatureFlagBits
VkPhysicalDeviceExternalSemaphoreInfoKHR :: VkPhysicalDeviceExternalSemaphoreInfo
VkExternalSemaphorePropertiesKHR :: VkExternalSemaphoreProperties
PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalSemaphoreInfo, ^mut VkExternalSemaphoreProperties) -> void
VkSemaphoreImportFlagsKHR :: VkSemaphoreImportFlags
VkSemaphoreImportFlagBitsKHR :: VkSemaphoreImportFlagBits
VkExportSemaphoreCreateInfoKHR :: VkExportSemaphoreCreateInfo
PFN_vkImportSemaphoreFdKHR :: fn(VkDevice, ^mut VkImportSemaphoreFdInfoKHR) -> VkResult
PFN_vkGetSemaphoreFdKHR :: fn(VkDevice, ^mut VkSemaphoreGetFdInfoKHR, ^mut i32) -> VkResult
PFN_vkCmdPushDescriptorSetKHR :: fn(VkCommandBuffer, VkPipelineBindPoint, VkPipelineLayout, uint32_t, uint32_t, ^mut VkWriteDescriptorSet) -> void
PFN_vkCmdPushDescriptorSetWithTemplateKHR :: fn(VkCommandBuffer, VkDescriptorUpdateTemplate, VkPipelineLayout, uint32_t, ^mut void) -> void
VkPhysicalDeviceShaderFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features
VkPhysicalDeviceFloat16Int8FeaturesKHR :: VkPhysicalDeviceShaderFloat16Int8Features
VkPhysicalDevice16BitStorageFeaturesKHR :: VkPhysicalDevice16BitStorageFeatures
VkDescriptorUpdateTemplateKHR :: VkDescriptorUpdateTemplate
VkDescriptorUpdateTemplateTypeKHR :: VkDescriptorUpdateTemplateType
VkDescriptorUpdateTemplateCreateFlagsKHR :: VkDescriptorUpdateTemplateCreateFlags
VkDescriptorUpdateTemplateEntryKHR :: VkDescriptorUpdateTemplateEntry
VkDescriptorUpdateTemplateCreateInfoKHR :: VkDescriptorUpdateTemplateCreateInfo
PFN_vkCreateDescriptorUpdateTemplateKHR :: fn(VkDevice, ^mut VkDescriptorUpdateTemplateCreateInfo, ^mut VkAllocationCallbacks, ^mut VkDescriptorUpdateTemplate) -> VkResult
PFN_vkDestroyDescriptorUpdateTemplateKHR :: fn(VkDevice, VkDescriptorUpdateTemplate, ^mut VkAllocationCallbacks) -> void
PFN_vkUpdateDescriptorSetWithTemplateKHR :: fn(VkDevice, VkDescriptorSet, VkDescriptorUpdateTemplate, ^mut void) -> void
VkPhysicalDeviceImagelessFramebufferFeaturesKHR :: VkPhysicalDeviceImagelessFramebufferFeatures
VkFramebufferAttachmentsCreateInfoKHR :: VkFramebufferAttachmentsCreateInfo
VkFramebufferAttachmentImageInfoKHR :: VkFramebufferAttachmentImageInfo
VkRenderPassAttachmentBeginInfoKHR :: VkRenderPassAttachmentBeginInfo
VkRenderPassCreateInfo2KHR :: VkRenderPassCreateInfo2
VkAttachmentDescription2KHR :: VkAttachmentDescription2
VkAttachmentReference2KHR :: VkAttachmentReference2
VkSubpassDescription2KHR :: VkSubpassDescription2
VkSubpassDependency2KHR :: VkSubpassDependency2
VkSubpassBeginInfoKHR :: VkSubpassBeginInfo
VkSubpassEndInfoKHR :: VkSubpassEndInfo
PFN_vkCreateRenderPass2KHR :: fn(VkDevice, ^mut VkRenderPassCreateInfo2, ^mut VkAllocationCallbacks, ^mut VkRenderPass) -> VkResult
PFN_vkCmdBeginRenderPass2KHR :: fn(VkCommandBuffer, ^mut VkRenderPassBeginInfo, ^mut VkSubpassBeginInfo) -> void
PFN_vkCmdNextSubpass2KHR :: fn(VkCommandBuffer, ^mut VkSubpassBeginInfo, ^mut VkSubpassEndInfo) -> void
PFN_vkCmdEndRenderPass2KHR :: fn(VkCommandBuffer, ^mut VkSubpassEndInfo) -> void
PFN_vkGetSwapchainStatusKHR :: fn(VkDevice, VkSwapchainKHR) -> VkResult
VkExternalFenceHandleTypeFlagsKHR :: VkExternalFenceHandleTypeFlags
VkExternalFenceHandleTypeFlagBitsKHR :: VkExternalFenceHandleTypeFlagBits
VkExternalFenceFeatureFlagsKHR :: VkExternalFenceFeatureFlags
VkExternalFenceFeatureFlagBitsKHR :: VkExternalFenceFeatureFlagBits
VkPhysicalDeviceExternalFenceInfoKHR :: VkPhysicalDeviceExternalFenceInfo
VkExternalFencePropertiesKHR :: VkExternalFenceProperties
PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceExternalFenceInfo, ^mut VkExternalFenceProperties) -> void
VkFenceImportFlagsKHR :: VkFenceImportFlags
VkFenceImportFlagBitsKHR :: VkFenceImportFlagBits
VkExportFenceCreateInfoKHR :: VkExportFenceCreateInfo
PFN_vkImportFenceFdKHR :: fn(VkDevice, ^mut VkImportFenceFdInfoKHR) -> VkResult
PFN_vkGetFenceFdKHR :: fn(VkDevice, ^mut VkFenceGetFdInfoKHR, ^mut i32) -> VkResult
VkPerformanceCounterDescriptionFlagsKHR :: VkFlags
VkAcquireProfilingLockFlagsKHR :: VkFlags
PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: fn(VkPhysicalDevice, uint32_t, ^mut uint32_t, ^mut VkPerformanceCounterKHR, ^mut VkPerformanceCounterDescriptionKHR) -> VkResult
PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: fn(VkPhysicalDevice, ^mut VkQueryPoolPerformanceCreateInfoKHR, ^mut uint32_t) -> void
PFN_vkAcquireProfilingLockKHR :: fn(VkDevice, ^mut VkAcquireProfilingLockInfoKHR) -> VkResult
PFN_vkReleaseProfilingLockKHR :: fn(VkDevice) -> void
VkPointClippingBehaviorKHR :: VkPointClippingBehavior
VkTessellationDomainOriginKHR :: VkTessellationDomainOrigin
VkPhysicalDevicePointClippingPropertiesKHR :: VkPhysicalDevicePointClippingProperties
VkRenderPassInputAttachmentAspectCreateInfoKHR :: VkRenderPassInputAttachmentAspectCreateInfo
VkInputAttachmentAspectReferenceKHR :: VkInputAttachmentAspectReference
VkImageViewUsageCreateInfoKHR :: VkImageViewUsageCreateInfo
VkPipelineTessellationDomainOriginStateCreateInfoKHR :: VkPipelineTessellationDomainOriginStateCreateInfo
PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceSurfaceInfo2KHR, ^mut VkSurfaceCapabilities2KHR) -> VkResult
PFN_vkGetPhysicalDeviceSurfaceFormats2KHR :: fn(VkPhysicalDevice, ^mut VkPhysicalDeviceSurfaceInfo2KHR, ^mut uint32_t, ^mut VkSurfaceFormat2KHR) -> VkResult
VkPhysicalDeviceVariablePointerFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures
VkPhysicalDeviceVariablePointersFeaturesKHR :: VkPhysicalDeviceVariablePointersFeatures
PFN_vkGetPhysicalDeviceDisplayProperties2KHR :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkDisplayProperties2KHR) -> VkResult
PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkDisplayPlaneProperties2KHR) -> VkResult
PFN_vkGetDisplayModeProperties2KHR :: fn(VkPhysicalDevice, VkDisplayKHR, ^mut uint32_t, ^mut VkDisplayModeProperties2KHR) -> VkResult
PFN_vkGetDisplayPlaneCapabilities2KHR :: fn(VkPhysicalDevice, ^mut VkDisplayPlaneInfo2KHR, ^mut VkDisplayPlaneCapabilities2KHR) -> VkResult
VkMemoryDedicatedRequirementsKHR :: VkMemoryDedicatedRequirements
VkMemoryDedicatedAllocateInfoKHR :: VkMemoryDedicatedAllocateInfo
VkBufferMemoryRequirementsInfo2KHR :: VkBufferMemoryRequirementsInfo2
VkImageMemoryRequirementsInfo2KHR :: VkImageMemoryRequirementsInfo2
VkImageSparseMemoryRequirementsInfo2KHR :: VkImageSparseMemoryRequirementsInfo2
VkMemoryRequirements2KHR :: VkMemoryRequirements2
VkSparseImageMemoryRequirements2KHR :: VkSparseImageMemoryRequirements2
PFN_vkGetImageMemoryRequirements2KHR :: fn(VkDevice, ^mut VkImageMemoryRequirementsInfo2, ^mut VkMemoryRequirements2) -> void
PFN_vkGetBufferMemoryRequirements2KHR :: fn(VkDevice, ^mut VkBufferMemoryRequirementsInfo2, ^mut VkMemoryRequirements2) -> void
PFN_vkGetImageSparseMemoryRequirements2KHR :: fn(VkDevice, ^mut VkImageSparseMemoryRequirementsInfo2, ^mut uint32_t, ^mut VkSparseImageMemoryRequirements2) -> void
VkImageFormatListCreateInfoKHR :: VkImageFormatListCreateInfo
VkSamplerYcbcrConversionKHR :: VkSamplerYcbcrConversion
VkSamplerYcbcrModelConversionKHR :: VkSamplerYcbcrModelConversion
VkSamplerYcbcrRangeKHR :: VkSamplerYcbcrRange
VkChromaLocationKHR :: VkChromaLocation
VkSamplerYcbcrConversionCreateInfoKHR :: VkSamplerYcbcrConversionCreateInfo
VkSamplerYcbcrConversionInfoKHR :: VkSamplerYcbcrConversionInfo
VkBindImagePlaneMemoryInfoKHR :: VkBindImagePlaneMemoryInfo
VkImagePlaneMemoryRequirementsInfoKHR :: VkImagePlaneMemoryRequirementsInfo
VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR :: VkPhysicalDeviceSamplerYcbcrConversionFeatures
VkSamplerYcbcrConversionImageFormatPropertiesKHR :: VkSamplerYcbcrConversionImageFormatProperties
PFN_vkCreateSamplerYcbcrConversionKHR :: fn(VkDevice, ^mut VkSamplerYcbcrConversionCreateInfo, ^mut VkAllocationCallbacks, ^mut VkSamplerYcbcrConversion) -> VkResult
PFN_vkDestroySamplerYcbcrConversionKHR :: fn(VkDevice, VkSamplerYcbcrConversion, ^mut VkAllocationCallbacks) -> void
VkBindBufferMemoryInfoKHR :: VkBindBufferMemoryInfo
VkBindImageMemoryInfoKHR :: VkBindImageMemoryInfo
PFN_vkBindBufferMemory2KHR :: fn(VkDevice, uint32_t, ^mut VkBindBufferMemoryInfo) -> VkResult
PFN_vkBindImageMemory2KHR :: fn(VkDevice, uint32_t, ^mut VkBindImageMemoryInfo) -> VkResult
VkPhysicalDeviceMaintenance3PropertiesKHR :: VkPhysicalDeviceMaintenance3Properties
VkDescriptorSetLayoutSupportKHR :: VkDescriptorSetLayoutSupport
PFN_vkGetDescriptorSetLayoutSupportKHR :: fn(VkDevice, ^mut VkDescriptorSetLayoutCreateInfo, ^mut VkDescriptorSetLayoutSupport) -> void
PFN_vkCmdDrawIndirectCountKHR :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndexedIndirectCountKHR :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR :: VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures
VkPhysicalDevice8BitStorageFeaturesKHR :: VkPhysicalDevice8BitStorageFeatures
VkPhysicalDeviceShaderAtomicInt64FeaturesKHR :: VkPhysicalDeviceShaderAtomicInt64Features
VkDriverIdKHR :: VkDriverId
VkConformanceVersionKHR :: VkConformanceVersion
VkPhysicalDeviceDriverPropertiesKHR :: VkPhysicalDeviceDriverProperties
VkShaderFloatControlsIndependenceKHR :: VkShaderFloatControlsIndependence
VkPhysicalDeviceFloatControlsPropertiesKHR :: VkPhysicalDeviceFloatControlsProperties
VkResolveModeFlagBitsKHR :: VkResolveModeFlagBits
VkResolveModeFlagsKHR :: VkResolveModeFlags
VkSubpassDescriptionDepthStencilResolveKHR :: VkSubpassDescriptionDepthStencilResolve
VkPhysicalDeviceDepthStencilResolvePropertiesKHR :: VkPhysicalDeviceDepthStencilResolveProperties
VkSemaphoreTypeKHR :: VkSemaphoreType
VkSemaphoreWaitFlagBitsKHR :: VkSemaphoreWaitFlagBits
VkSemaphoreWaitFlagsKHR :: VkSemaphoreWaitFlags
VkPhysicalDeviceTimelineSemaphoreFeaturesKHR :: VkPhysicalDeviceTimelineSemaphoreFeatures
VkPhysicalDeviceTimelineSemaphorePropertiesKHR :: VkPhysicalDeviceTimelineSemaphoreProperties
VkSemaphoreTypeCreateInfoKHR :: VkSemaphoreTypeCreateInfo
VkTimelineSemaphoreSubmitInfoKHR :: VkTimelineSemaphoreSubmitInfo
VkSemaphoreWaitInfoKHR :: VkSemaphoreWaitInfo
VkSemaphoreSignalInfoKHR :: VkSemaphoreSignalInfo
PFN_vkGetSemaphoreCounterValueKHR :: fn(VkDevice, VkSemaphore, ^mut uint64_t) -> VkResult
PFN_vkWaitSemaphoresKHR :: fn(VkDevice, ^mut VkSemaphoreWaitInfo, uint64_t) -> VkResult
PFN_vkSignalSemaphoreKHR :: fn(VkDevice, ^mut VkSemaphoreSignalInfo) -> VkResult
VkPhysicalDeviceVulkanMemoryModelFeaturesKHR :: VkPhysicalDeviceVulkanMemoryModelFeatures
VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR :: VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures
VkAttachmentReferenceStencilLayoutKHR :: VkAttachmentReferenceStencilLayout
VkAttachmentDescriptionStencilLayoutKHR :: VkAttachmentDescriptionStencilLayout
VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR :: VkPhysicalDeviceUniformBufferStandardLayoutFeatures
VkPhysicalDeviceBufferDeviceAddressFeaturesKHR :: VkPhysicalDeviceBufferDeviceAddressFeatures
VkBufferDeviceAddressInfoKHR :: VkBufferDeviceAddressInfo
VkBufferOpaqueCaptureAddressCreateInfoKHR :: VkBufferOpaqueCaptureAddressCreateInfo
VkMemoryOpaqueCaptureAddressAllocateInfoKHR :: VkMemoryOpaqueCaptureAddressAllocateInfo
VkDeviceMemoryOpaqueCaptureAddressInfoKHR :: VkDeviceMemoryOpaqueCaptureAddressInfo
PFN_vkGetBufferDeviceAddressKHR :: fn(VkDevice, ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress
PFN_vkGetBufferOpaqueCaptureAddressKHR :: fn(VkDevice, ^mut VkBufferDeviceAddressInfo) -> uint64_t
PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR :: fn(VkDevice, ^mut VkDeviceMemoryOpaqueCaptureAddressInfo) -> uint64_t
PFN_vkGetPipelineExecutablePropertiesKHR :: fn(VkDevice, ^mut VkPipelineInfoKHR, ^mut uint32_t, ^mut VkPipelineExecutablePropertiesKHR) -> VkResult
PFN_vkGetPipelineExecutableStatisticsKHR :: fn(VkDevice, ^mut VkPipelineExecutableInfoKHR, ^mut uint32_t, ^mut VkPipelineExecutableStatisticKHR) -> VkResult
PFN_vkGetPipelineExecutableInternalRepresentationsKHR :: fn(VkDevice, ^mut VkPipelineExecutableInfoKHR, ^mut uint32_t, ^mut VkPipelineExecutableInternalRepresentationKHR) -> VkResult
VkDebugReportCallbackEXT_T :: struct #copy {}
VkDebugReportCallbackEXT :: ^mut VkDebugReportCallbackEXT_T
VkDebugReportFlagsEXT :: VkFlags
PFN_vkDebugReportCallbackEXT :: fn(VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, uint64_t, size_t, int32_t, ^mut char8, ^mut char8, ^mut void) -> VkBool32
PFN_vkCreateDebugReportCallbackEXT :: fn(VkInstance, ^mut VkDebugReportCallbackCreateInfoEXT, ^mut VkAllocationCallbacks, ^mut VkDebugReportCallbackEXT) -> VkResult
PFN_vkDestroyDebugReportCallbackEXT :: fn(VkInstance, VkDebugReportCallbackEXT, ^mut VkAllocationCallbacks) -> void
PFN_vkDebugReportMessageEXT :: fn(VkInstance, VkDebugReportFlagsEXT, VkDebugReportObjectTypeEXT, uint64_t, size_t, int32_t, ^mut char8, ^mut char8) -> void
PFN_vkDebugMarkerSetObjectTagEXT :: fn(VkDevice, ^mut VkDebugMarkerObjectTagInfoEXT) -> VkResult
PFN_vkDebugMarkerSetObjectNameEXT :: fn(VkDevice, ^mut VkDebugMarkerObjectNameInfoEXT) -> VkResult
PFN_vkCmdDebugMarkerBeginEXT :: fn(VkCommandBuffer, ^mut VkDebugMarkerMarkerInfoEXT) -> void
PFN_vkCmdDebugMarkerEndEXT :: fn(VkCommandBuffer) -> void
PFN_vkCmdDebugMarkerInsertEXT :: fn(VkCommandBuffer, ^mut VkDebugMarkerMarkerInfoEXT) -> void
VkPipelineRasterizationStateStreamCreateFlagsEXT :: VkFlags
PFN_vkCmdBindTransformFeedbackBuffersEXT :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkBuffer, ^mut VkDeviceSize, ^mut VkDeviceSize) -> void
PFN_vkCmdBeginTransformFeedbackEXT :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkBuffer, ^mut VkDeviceSize) -> void
PFN_vkCmdEndTransformFeedbackEXT :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkBuffer, ^mut VkDeviceSize) -> void
PFN_vkCmdBeginQueryIndexedEXT :: fn(VkCommandBuffer, VkQueryPool, uint32_t, VkQueryControlFlags, uint32_t) -> void
PFN_vkCmdEndQueryIndexedEXT :: fn(VkCommandBuffer, VkQueryPool, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndirectByteCountEXT :: fn(VkCommandBuffer, uint32_t, uint32_t, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkGetImageViewHandleNVX :: fn(VkDevice, ^mut VkImageViewHandleInfoNVX) -> uint32_t
PFN_vkGetImageViewAddressNVX :: fn(VkDevice, VkImageView, ^mut VkImageViewAddressPropertiesNVX) -> VkResult
PFN_vkCmdDrawIndirectCountAMD :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDrawIndexedIndirectCountAMD :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkGetShaderInfoAMD :: fn(VkDevice, VkPipeline, VkShaderStageFlagBits, VkShaderInfoTypeAMD, ^mut size_t, ^mut void) -> VkResult
VkExternalMemoryHandleTypeFlagsNV :: VkFlags
VkExternalMemoryFeatureFlagsNV :: VkFlags
PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: fn(VkPhysicalDevice, VkFormat, VkImageType, VkImageTiling, VkImageUsageFlags, VkImageCreateFlags, VkExternalMemoryHandleTypeFlagsNV, ^mut VkExternalImageFormatPropertiesNV) -> VkResult
VkConditionalRenderingFlagsEXT :: VkFlags
PFN_vkCmdBeginConditionalRenderingEXT :: fn(VkCommandBuffer, ^mut VkConditionalRenderingBeginInfoEXT) -> void
PFN_vkCmdEndConditionalRenderingEXT :: fn(VkCommandBuffer) -> void
PFN_vkCmdSetViewportWScalingNV :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkViewportWScalingNV) -> void
PFN_vkReleaseDisplayEXT :: fn(VkPhysicalDevice, VkDisplayKHR) -> VkResult
VkSurfaceCounterFlagsEXT :: VkFlags
PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT :: fn(VkPhysicalDevice, VkSurfaceKHR, ^mut VkSurfaceCapabilities2EXT) -> VkResult
PFN_vkDisplayPowerControlEXT :: fn(VkDevice, VkDisplayKHR, ^mut VkDisplayPowerInfoEXT) -> VkResult
PFN_vkRegisterDeviceEventEXT :: fn(VkDevice, ^mut VkDeviceEventInfoEXT, ^mut VkAllocationCallbacks, ^mut VkFence) -> VkResult
PFN_vkRegisterDisplayEventEXT :: fn(VkDevice, VkDisplayKHR, ^mut VkDisplayEventInfoEXT, ^mut VkAllocationCallbacks, ^mut VkFence) -> VkResult
PFN_vkGetSwapchainCounterEXT :: fn(VkDevice, VkSwapchainKHR, VkSurfaceCounterFlagBitsEXT, ^mut uint64_t) -> VkResult
PFN_vkGetRefreshCycleDurationGOOGLE :: fn(VkDevice, VkSwapchainKHR, ^mut VkRefreshCycleDurationGOOGLE) -> VkResult
PFN_vkGetPastPresentationTimingGOOGLE :: fn(VkDevice, VkSwapchainKHR, ^mut uint32_t, ^mut VkPastPresentationTimingGOOGLE) -> VkResult
VkPipelineViewportSwizzleStateCreateFlagsNV :: VkFlags
VkPipelineDiscardRectangleStateCreateFlagsEXT :: VkFlags
PFN_vkCmdSetDiscardRectangleEXT :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkRect2D) -> void
VkPipelineRasterizationConservativeStateCreateFlagsEXT :: VkFlags
VkPipelineRasterizationDepthClipStateCreateFlagsEXT :: VkFlags
PFN_vkSetHdrMetadataEXT :: fn(VkDevice, uint32_t, ^mut VkSwapchainKHR, ^mut VkHdrMetadataEXT) -> void
VkDebugUtilsMessengerEXT_T :: struct #copy {}
VkDebugUtilsMessengerEXT :: ^mut VkDebugUtilsMessengerEXT_T
VkDebugUtilsMessengerCallbackDataFlagsEXT :: VkFlags
VkDebugUtilsMessageTypeFlagsEXT :: VkFlags
VkDebugUtilsMessageSeverityFlagsEXT :: VkFlags
VkDebugUtilsMessengerCreateFlagsEXT :: VkFlags
PFN_vkDebugUtilsMessengerCallbackEXT :: fn(VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, ^mut VkDebugUtilsMessengerCallbackDataEXT, ^mut void) -> VkBool32
PFN_vkSetDebugUtilsObjectNameEXT :: fn(VkDevice, ^mut VkDebugUtilsObjectNameInfoEXT) -> VkResult
PFN_vkSetDebugUtilsObjectTagEXT :: fn(VkDevice, ^mut VkDebugUtilsObjectTagInfoEXT) -> VkResult
PFN_vkQueueBeginDebugUtilsLabelEXT :: fn(VkQueue, ^mut VkDebugUtilsLabelEXT) -> void
PFN_vkQueueEndDebugUtilsLabelEXT :: fn(VkQueue) -> void
PFN_vkQueueInsertDebugUtilsLabelEXT :: fn(VkQueue, ^mut VkDebugUtilsLabelEXT) -> void
PFN_vkCmdBeginDebugUtilsLabelEXT :: fn(VkCommandBuffer, ^mut VkDebugUtilsLabelEXT) -> void
PFN_vkCmdEndDebugUtilsLabelEXT :: fn(VkCommandBuffer) -> void
PFN_vkCmdInsertDebugUtilsLabelEXT :: fn(VkCommandBuffer, ^mut VkDebugUtilsLabelEXT) -> void
PFN_vkCreateDebugUtilsMessengerEXT :: fn(VkInstance, ^mut VkDebugUtilsMessengerCreateInfoEXT, ^mut VkAllocationCallbacks, ^mut VkDebugUtilsMessengerEXT) -> VkResult
PFN_vkDestroyDebugUtilsMessengerEXT :: fn(VkInstance, VkDebugUtilsMessengerEXT, ^mut VkAllocationCallbacks) -> void
PFN_vkSubmitDebugUtilsMessageEXT :: fn(VkInstance, VkDebugUtilsMessageSeverityFlagBitsEXT, VkDebugUtilsMessageTypeFlagsEXT, ^mut VkDebugUtilsMessengerCallbackDataEXT) -> void
VkSamplerReductionModeEXT :: VkSamplerReductionMode
VkSamplerReductionModeCreateInfoEXT :: VkSamplerReductionModeCreateInfo
VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT :: VkPhysicalDeviceSamplerFilterMinmaxProperties
PFN_vkCmdSetSampleLocationsEXT :: fn(VkCommandBuffer, ^mut VkSampleLocationsInfoEXT) -> void
PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT :: fn(VkPhysicalDevice, VkSampleCountFlagBits, ^mut VkMultisamplePropertiesEXT) -> void
VkPipelineCoverageToColorStateCreateFlagsNV :: VkFlags
VkPipelineCoverageModulationStateCreateFlagsNV :: VkFlags
PFN_vkGetImageDrmFormatModifierPropertiesEXT :: fn(VkDevice, VkImage, ^mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult
VkValidationCacheEXT_T :: struct #copy {}
VkValidationCacheEXT :: ^mut VkValidationCacheEXT_T
VkValidationCacheCreateFlagsEXT :: VkFlags
PFN_vkCreateValidationCacheEXT :: fn(VkDevice, ^mut VkValidationCacheCreateInfoEXT, ^mut VkAllocationCallbacks, ^mut VkValidationCacheEXT) -> VkResult
PFN_vkDestroyValidationCacheEXT :: fn(VkDevice, VkValidationCacheEXT, ^mut VkAllocationCallbacks) -> void
PFN_vkMergeValidationCachesEXT :: fn(VkDevice, VkValidationCacheEXT, uint32_t, ^mut VkValidationCacheEXT) -> VkResult
PFN_vkGetValidationCacheDataEXT :: fn(VkDevice, VkValidationCacheEXT, ^mut size_t, ^mut void) -> VkResult
VkDescriptorBindingFlagBitsEXT :: VkDescriptorBindingFlagBits
VkDescriptorBindingFlagsEXT :: VkDescriptorBindingFlags
VkDescriptorSetLayoutBindingFlagsCreateInfoEXT :: VkDescriptorSetLayoutBindingFlagsCreateInfo
VkPhysicalDeviceDescriptorIndexingFeaturesEXT :: VkPhysicalDeviceDescriptorIndexingFeatures
VkPhysicalDeviceDescriptorIndexingPropertiesEXT :: VkPhysicalDeviceDescriptorIndexingProperties
VkDescriptorSetVariableDescriptorCountAllocateInfoEXT :: VkDescriptorSetVariableDescriptorCountAllocateInfo
VkDescriptorSetVariableDescriptorCountLayoutSupportEXT :: VkDescriptorSetVariableDescriptorCountLayoutSupport
PFN_vkCmdBindShadingRateImageNV :: fn(VkCommandBuffer, VkImageView, VkImageLayout) -> void
PFN_vkCmdSetViewportShadingRatePaletteNV :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkShadingRatePaletteNV) -> void
PFN_vkCmdSetCoarseSampleOrderNV :: fn(VkCommandBuffer, VkCoarseSampleOrderTypeNV, uint32_t, ^mut VkCoarseSampleOrderCustomNV) -> void
VkAccelerationStructureKHR_T :: struct #copy {}
VkAccelerationStructureKHR :: ^mut VkAccelerationStructureKHR_T
VkAccelerationStructureNV :: VkAccelerationStructureKHR
VkRayTracingShaderGroupTypeNV :: VkRayTracingShaderGroupTypeKHR
VkGeometryTypeNV :: VkGeometryTypeKHR
VkAccelerationStructureTypeNV :: VkAccelerationStructureTypeKHR
VkCopyAccelerationStructureModeNV :: VkCopyAccelerationStructureModeKHR
VkAccelerationStructureMemoryRequirementsTypeNV :: VkAccelerationStructureMemoryRequirementsTypeKHR
VkGeometryFlagsKHR :: VkFlags
VkGeometryFlagsNV :: VkGeometryFlagsKHR
VkGeometryFlagBitsNV :: VkGeometryFlagBitsKHR
VkGeometryInstanceFlagsKHR :: VkFlags
VkGeometryInstanceFlagsNV :: VkGeometryInstanceFlagsKHR
VkGeometryInstanceFlagBitsNV :: VkGeometryInstanceFlagBitsKHR
VkBuildAccelerationStructureFlagsKHR :: VkFlags
VkBuildAccelerationStructureFlagsNV :: VkBuildAccelerationStructureFlagsKHR
VkBuildAccelerationStructureFlagBitsNV :: VkBuildAccelerationStructureFlagBitsKHR
VkBindAccelerationStructureMemoryInfoNV :: VkBindAccelerationStructureMemoryInfoKHR
VkWriteDescriptorSetAccelerationStructureNV :: VkWriteDescriptorSetAccelerationStructureKHR
VkTransformMatrixNV :: VkTransformMatrixKHR
VkAabbPositionsNV :: VkAabbPositionsKHR
VkAccelerationStructureInstanceNV :: VkAccelerationStructureInstanceKHR
PFN_vkCreateAccelerationStructureNV :: fn(VkDevice, ^mut VkAccelerationStructureCreateInfoNV, ^mut VkAllocationCallbacks, ^mut VkAccelerationStructureNV) -> VkResult
PFN_vkDestroyAccelerationStructureKHR :: fn(VkDevice, VkAccelerationStructureKHR, ^mut VkAllocationCallbacks) -> void
PFN_vkDestroyAccelerationStructureNV :: fn(VkDevice, VkAccelerationStructureKHR, ^mut VkAllocationCallbacks) -> void
PFN_vkGetAccelerationStructureMemoryRequirementsNV :: fn(VkDevice, ^mut VkAccelerationStructureMemoryRequirementsInfoNV, ^mut VkMemoryRequirements2KHR) -> void
PFN_vkBindAccelerationStructureMemoryKHR :: fn(VkDevice, uint32_t, ^mut VkBindAccelerationStructureMemoryInfoKHR) -> VkResult
PFN_vkBindAccelerationStructureMemoryNV :: fn(VkDevice, uint32_t, ^mut VkBindAccelerationStructureMemoryInfoKHR) -> VkResult
PFN_vkCmdBuildAccelerationStructureNV :: fn(VkCommandBuffer, ^mut VkAccelerationStructureInfoNV, VkBuffer, VkDeviceSize, VkBool32, VkAccelerationStructureKHR, VkAccelerationStructureKHR, VkBuffer, VkDeviceSize) -> void
PFN_vkCmdCopyAccelerationStructureNV :: fn(VkCommandBuffer, VkAccelerationStructureKHR, VkAccelerationStructureKHR, VkCopyAccelerationStructureModeKHR) -> void
PFN_vkCmdTraceRaysNV :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, VkBuffer, VkDeviceSize, VkDeviceSize, uint32_t, uint32_t, uint32_t) -> void
PFN_vkCreateRayTracingPipelinesNV :: fn(VkDevice, VkPipelineCache, uint32_t, ^mut VkRayTracingPipelineCreateInfoNV, ^mut VkAllocationCallbacks, ^mut VkPipeline) -> VkResult
PFN_vkGetRayTracingShaderGroupHandlesKHR :: fn(VkDevice, VkPipeline, uint32_t, uint32_t, size_t, ^mut void) -> VkResult
PFN_vkGetRayTracingShaderGroupHandlesNV :: fn(VkDevice, VkPipeline, uint32_t, uint32_t, size_t, ^mut void) -> VkResult
PFN_vkGetAccelerationStructureHandleNV :: fn(VkDevice, VkAccelerationStructureKHR, size_t, ^mut void) -> VkResult
PFN_vkCmdWriteAccelerationStructuresPropertiesKHR :: fn(VkCommandBuffer, uint32_t, ^mut VkAccelerationStructureKHR, VkQueryType, VkQueryPool, uint32_t) -> void
PFN_vkCmdWriteAccelerationStructuresPropertiesNV :: fn(VkCommandBuffer, uint32_t, ^mut VkAccelerationStructureKHR, VkQueryType, VkQueryPool, uint32_t) -> void
PFN_vkCompileDeferredNV :: fn(VkDevice, VkPipeline, uint32_t) -> VkResult
PFN_vkGetMemoryHostPointerPropertiesEXT :: fn(VkDevice, VkExternalMemoryHandleTypeFlagBits, ^mut void, ^mut VkMemoryHostPointerPropertiesEXT) -> VkResult
PFN_vkCmdWriteBufferMarkerAMD :: fn(VkCommandBuffer, VkPipelineStageFlagBits, VkBuffer, VkDeviceSize, uint32_t) -> void
VkPipelineCompilerControlFlagsAMD :: VkFlags
PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkTimeDomainEXT) -> VkResult
PFN_vkGetCalibratedTimestampsEXT :: fn(VkDevice, uint32_t, ^mut VkCalibratedTimestampInfoEXT, ^mut uint64_t, ^mut uint64_t) -> VkResult
VkPipelineCreationFeedbackFlagsEXT :: VkFlags
PFN_vkCmdDrawMeshTasksNV :: fn(VkCommandBuffer, uint32_t, uint32_t) -> void
PFN_vkCmdDrawMeshTasksIndirectNV :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdDrawMeshTasksIndirectCountNV :: fn(VkCommandBuffer, VkBuffer, VkDeviceSize, VkBuffer, VkDeviceSize, uint32_t, uint32_t) -> void
PFN_vkCmdSetExclusiveScissorNV :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkRect2D) -> void
PFN_vkCmdSetCheckpointNV :: fn(VkCommandBuffer, ^mut void) -> void
PFN_vkGetQueueCheckpointDataNV :: fn(VkQueue, ^mut uint32_t, ^mut VkCheckpointDataNV) -> void
VkPerformanceConfigurationINTEL_T :: struct #copy {}
VkPerformanceConfigurationINTEL :: ^mut VkPerformanceConfigurationINTEL_T
VkQueryPoolCreateInfoINTEL :: VkQueryPoolPerformanceQueryCreateInfoINTEL
PFN_vkInitializePerformanceApiINTEL :: fn(VkDevice, ^mut VkInitializePerformanceApiInfoINTEL) -> VkResult
PFN_vkUninitializePerformanceApiINTEL :: fn(VkDevice) -> void
PFN_vkCmdSetPerformanceMarkerINTEL :: fn(VkCommandBuffer, ^mut VkPerformanceMarkerInfoINTEL) -> VkResult
PFN_vkCmdSetPerformanceStreamMarkerINTEL :: fn(VkCommandBuffer, ^mut VkPerformanceStreamMarkerInfoINTEL) -> VkResult
PFN_vkCmdSetPerformanceOverrideINTEL :: fn(VkCommandBuffer, ^mut VkPerformanceOverrideInfoINTEL) -> VkResult
PFN_vkAcquirePerformanceConfigurationINTEL :: fn(VkDevice, ^mut VkPerformanceConfigurationAcquireInfoINTEL, ^mut VkPerformanceConfigurationINTEL) -> VkResult
PFN_vkReleasePerformanceConfigurationINTEL :: fn(VkDevice, VkPerformanceConfigurationINTEL) -> VkResult
PFN_vkQueueSetPerformanceConfigurationINTEL :: fn(VkQueue, VkPerformanceConfigurationINTEL) -> VkResult
PFN_vkGetPerformanceParameterINTEL :: fn(VkDevice, VkPerformanceParameterTypeINTEL, ^mut VkPerformanceValueINTEL) -> VkResult
PFN_vkSetLocalDimmingAMD :: fn(VkDevice, VkSwapchainKHR, VkBool32) -> void
VkPhysicalDeviceScalarBlockLayoutFeaturesEXT :: VkPhysicalDeviceScalarBlockLayoutFeatures
VkShaderCorePropertiesFlagsAMD :: VkFlags
VkPhysicalDeviceBufferAddressFeaturesEXT :: VkPhysicalDeviceBufferDeviceAddressFeaturesEXT
VkBufferDeviceAddressInfoEXT :: VkBufferDeviceAddressInfo
PFN_vkGetBufferDeviceAddressEXT :: fn(VkDevice, ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress
VkToolPurposeFlagsEXT :: VkFlags
PFN_vkGetPhysicalDeviceToolPropertiesEXT :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkPhysicalDeviceToolPropertiesEXT) -> VkResult
VkImageStencilUsageCreateInfoEXT :: VkImageStencilUsageCreateInfo
PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkCooperativeMatrixPropertiesNV) -> VkResult
VkPipelineCoverageReductionStateCreateFlagsNV :: VkFlags
PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: fn(VkPhysicalDevice, ^mut uint32_t, ^mut VkFramebufferMixedSamplesCombinationNV) -> VkResult
VkHeadlessSurfaceCreateFlagsEXT :: VkFlags
PFN_vkCreateHeadlessSurfaceEXT :: fn(VkInstance, ^mut VkHeadlessSurfaceCreateInfoEXT, ^mut VkAllocationCallbacks, ^mut VkSurfaceKHR) -> VkResult
PFN_vkCmdSetLineStippleEXT :: fn(VkCommandBuffer, uint32_t, uint16_t) -> void
VkPhysicalDeviceHostQueryResetFeaturesEXT :: VkPhysicalDeviceHostQueryResetFeatures
PFN_vkResetQueryPoolEXT :: fn(VkDevice, VkQueryPool, uint32_t, uint32_t) -> void
PFN_vkCmdSetCullModeEXT :: fn(VkCommandBuffer, VkCullModeFlags) -> void
PFN_vkCmdSetFrontFaceEXT :: fn(VkCommandBuffer, VkFrontFace) -> void
PFN_vkCmdSetPrimitiveTopologyEXT :: fn(VkCommandBuffer, VkPrimitiveTopology) -> void
PFN_vkCmdSetViewportWithCountEXT :: fn(VkCommandBuffer, uint32_t, ^mut VkViewport) -> void
PFN_vkCmdSetScissorWithCountEXT :: fn(VkCommandBuffer, uint32_t, ^mut VkRect2D) -> void
PFN_vkCmdBindVertexBuffers2EXT :: fn(VkCommandBuffer, uint32_t, uint32_t, ^mut VkBuffer, ^mut VkDeviceSize, ^mut VkDeviceSize, ^mut VkDeviceSize) -> void
PFN_vkCmdSetDepthTestEnableEXT :: fn(VkCommandBuffer, VkBool32) -> void
PFN_vkCmdSetDepthWriteEnableEXT :: fn(VkCommandBuffer, VkBool32) -> void
PFN_vkCmdSetDepthCompareOpEXT :: fn(VkCommandBuffer, VkCompareOp) -> void
PFN_vkCmdSetDepthBoundsTestEnableEXT :: fn(VkCommandBuffer, VkBool32) -> void
PFN_vkCmdSetStencilTestEnableEXT :: fn(VkCommandBuffer, VkBool32) -> void
PFN_vkCmdSetStencilOpEXT :: fn(VkCommandBuffer, VkStencilFaceFlags, VkStencilOp, VkStencilOp, VkStencilOp, VkCompareOp) -> void
VkIndirectCommandsLayoutNV_T :: struct #copy {}
VkIndirectCommandsLayoutNV :: ^mut VkIndirectCommandsLayoutNV_T
VkIndirectStateFlagsNV :: VkFlags
VkIndirectCommandsLayoutUsageFlagsNV :: VkFlags
PFN_vkGetGeneratedCommandsMemoryRequirementsNV :: fn(VkDevice, ^mut VkGeneratedCommandsMemoryRequirementsInfoNV, ^mut VkMemoryRequirements2) -> void
PFN_vkCmdPreprocessGeneratedCommandsNV :: fn(VkCommandBuffer, ^mut VkGeneratedCommandsInfoNV) -> void
PFN_vkCmdExecuteGeneratedCommandsNV :: fn(VkCommandBuffer, VkBool32, ^mut VkGeneratedCommandsInfoNV) -> void
PFN_vkCmdBindPipelineShaderGroupNV :: fn(VkCommandBuffer, VkPipelineBindPoint, VkPipeline, uint32_t) -> void
PFN_vkCreateIndirectCommandsLayoutNV :: fn(VkDevice, ^mut VkIndirectCommandsLayoutCreateInfoNV, ^mut VkAllocationCallbacks, ^mut VkIndirectCommandsLayoutNV) -> VkResult
PFN_vkDestroyIndirectCommandsLayoutNV :: fn(VkDevice, VkIndirectCommandsLayoutNV, ^mut VkAllocationCallbacks) -> void
VkPrivateDataSlotEXT_T :: struct #copy {}
VkPrivateDataSlotEXT :: ^mut VkPrivateDataSlotEXT_T
VkPrivateDataSlotCreateFlagsEXT :: VkFlags
PFN_vkCreatePrivateDataSlotEXT :: fn(VkDevice, ^mut VkPrivateDataSlotCreateInfoEXT, ^mut VkAllocationCallbacks, ^mut VkPrivateDataSlotEXT) -> VkResult
PFN_vkDestroyPrivateDataSlotEXT :: fn(VkDevice, VkPrivateDataSlotEXT, ^mut VkAllocationCallbacks) -> void
PFN_vkSetPrivateDataEXT :: fn(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlotEXT, uint64_t) -> VkResult
PFN_vkGetPrivateDataEXT :: fn(VkDevice, VkObjectType, uint64_t, VkPrivateDataSlotEXT, ^mut uint64_t) -> void
VkDeviceDiagnosticsConfigFlagsNV :: VkFlags
VK_VERSION_1_0 :: 1
VK_API_VERSION_1_0 :: VK_MAKE_VERSION(1,0,0)
VK_HEADER_VERSION :: 148
VK_HEADER_VERSION_COMPLETE :: VK_MAKE_VERSION(1,2,VK_HEADER_VERSION)
VK_NULL_HANDLE :: 0
VK_ATTACHMENT_UNUSED :: u32.max
VK_FALSE :: 0
VK_LOD_CLAMP_NONE :: 1000.0f
VK_QUEUE_FAMILY_IGNORED :: u32.max
VK_REMAINING_ARRAY_LAYERS :: u32.max
VK_REMAINING_MIP_LEVELS :: u32.max
VK_SUBPASS_EXTERNAL :: u32.max
VK_TRUE :: 1
VK_WHOLE_SIZE :: u64.max
VK_MAX_MEMORY_TYPES :: 32
VK_MAX_MEMORY_HEAPS :: 16
VK_MAX_PHYSICAL_DEVICE_NAME_SIZE :: 256
VK_UUID_SIZE :: 16
VK_MAX_EXTENSION_NAME_SIZE :: 256
VK_MAX_DESCRIPTION_SIZE :: 256
VK_VERSION_1_1 :: 1
VK_API_VERSION_1_1 :: VK_MAKE_VERSION(1,1,0)
VK_MAX_DEVICE_GROUP_SIZE :: 32
VK_LUID_SIZE :: 8
VK_QUEUE_FAMILY_EXTERNAL :: u32.max - 1
VK_VERSION_1_2 :: 1
VK_API_VERSION_1_2 :: VK_MAKE_VERSION(1,2,0)
VK_MAX_DRIVER_NAME_SIZE :: 256
VK_MAX_DRIVER_INFO_SIZE :: 256
VK_KHR_surface :: 1
VK_KHR_SURFACE_SPEC_VERSION :: 25
VK_KHR_SURFACE_EXTENSION_NAME :: "VK_KHR_surface"
VK_KHR_swapchain :: 1
VK_KHR_SWAPCHAIN_SPEC_VERSION :: 70
VK_KHR_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_swapchain"
VK_KHR_display :: 1
VK_KHR_DISPLAY_SPEC_VERSION :: 23
VK_KHR_DISPLAY_EXTENSION_NAME :: "VK_KHR_display"
VK_KHR_display_swapchain :: 1
VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION :: 10
VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME :: "VK_KHR_display_swapchain"
VK_KHR_sampler_mirror_clamp_to_edge :: 1
VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION :: 3
VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME :: "VK_KHR_sampler_mirror_clamp_to_edge"
VK_KHR_multiview :: 1
VK_KHR_MULTIVIEW_SPEC_VERSION :: 1
VK_KHR_MULTIVIEW_EXTENSION_NAME :: "VK_KHR_multiview"
VK_KHR_get_physical_device_properties2 :: 1
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION :: 2
VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_physical_device_properties2"
VK_KHR_device_group :: 1
VK_KHR_DEVICE_GROUP_SPEC_VERSION :: 4
VK_KHR_DEVICE_GROUP_EXTENSION_NAME :: "VK_KHR_device_group"
VK_KHR_shader_draw_parameters :: 1
VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION :: 1
VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME :: "VK_KHR_shader_draw_parameters"
VK_KHR_maintenance1 :: 1
VK_KHR_MAINTENANCE1_SPEC_VERSION :: 2
VK_KHR_MAINTENANCE1_EXTENSION_NAME :: "VK_KHR_maintenance1"
VK_KHR_device_group_creation :: 1
VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION :: 1
VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME :: "VK_KHR_device_group_creation"
VK_MAX_DEVICE_GROUP_SIZE_KHR :: VK_MAX_DEVICE_GROUP_SIZE
VK_KHR_external_memory_capabilities :: 1
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_memory_capabilities"
VK_LUID_SIZE_KHR :: VK_LUID_SIZE
VK_KHR_external_memory :: 1
VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_KHR_external_memory"
VK_QUEUE_FAMILY_EXTERNAL_KHR :: VK_QUEUE_FAMILY_EXTERNAL
VK_KHR_external_memory_fd :: 1
VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME :: "VK_KHR_external_memory_fd"
VK_KHR_external_semaphore_capabilities :: 1
VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_semaphore_capabilities"
VK_KHR_external_semaphore :: 1
VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_external_semaphore"
VK_KHR_external_semaphore_fd :: 1
VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME :: "VK_KHR_external_semaphore_fd"
VK_KHR_push_descriptor :: 1
VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION :: 2
VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME :: "VK_KHR_push_descriptor"
VK_KHR_shader_float16_int8 :: 1
VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION :: 1
VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME :: "VK_KHR_shader_float16_int8"
VK_KHR_16bit_storage :: 1
VK_KHR_16BIT_STORAGE_SPEC_VERSION :: 1
VK_KHR_16BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_16bit_storage"
VK_KHR_incremental_present :: 1
VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION :: 1
VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME :: "VK_KHR_incremental_present"
VK_KHR_descriptor_update_template :: 1
VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION :: 1
VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME :: "VK_KHR_descriptor_update_template"
VK_KHR_imageless_framebuffer :: 1
VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION :: 1
VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME :: "VK_KHR_imageless_framebuffer"
VK_KHR_create_renderpass2 :: 1
VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION :: 1
VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME :: "VK_KHR_create_renderpass2"
VK_KHR_shared_presentable_image :: 1
VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION :: 1
VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME :: "VK_KHR_shared_presentable_image"
VK_KHR_external_fence_capabilities :: 1
VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_external_fence_capabilities"
VK_KHR_external_fence :: 1
VK_KHR_EXTERNAL_FENCE_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME :: "VK_KHR_external_fence"
VK_KHR_external_fence_fd :: 1
VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION :: 1
VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME :: "VK_KHR_external_fence_fd"
VK_KHR_performance_query :: 1
VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION :: 1
VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_KHR_performance_query"
VK_KHR_maintenance2 :: 1
VK_KHR_MAINTENANCE2_SPEC_VERSION :: 1
VK_KHR_MAINTENANCE2_EXTENSION_NAME :: "VK_KHR_maintenance2"
VK_KHR_get_surface_capabilities2 :: 1
VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION :: 1
VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME :: "VK_KHR_get_surface_capabilities2"
VK_KHR_variable_pointers :: 1
VK_KHR_VARIABLE_POINTERS_SPEC_VERSION :: 1
VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME :: "VK_KHR_variable_pointers"
VK_KHR_get_display_properties2 :: 1
VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION :: 1
VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME :: "VK_KHR_get_display_properties2"
VK_KHR_dedicated_allocation :: 1
VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION :: 3
VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_KHR_dedicated_allocation"
VK_KHR_storage_buffer_storage_class :: 1
VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION :: 1
VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME :: "VK_KHR_storage_buffer_storage_class"
VK_KHR_relaxed_block_layout :: 1
VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION :: 1
VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_KHR_relaxed_block_layout"
VK_KHR_get_memory_requirements2 :: 1
VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION :: 1
VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME :: "VK_KHR_get_memory_requirements2"
VK_KHR_image_format_list :: 1
VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION :: 1
VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME :: "VK_KHR_image_format_list"
VK_KHR_sampler_ycbcr_conversion :: 1
VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION :: 14
VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME :: "VK_KHR_sampler_ycbcr_conversion"
VK_KHR_bind_memory2 :: 1
VK_KHR_BIND_MEMORY_2_SPEC_VERSION :: 1
VK_KHR_BIND_MEMORY_2_EXTENSION_NAME :: "VK_KHR_bind_memory2"
VK_KHR_maintenance3 :: 1
VK_KHR_MAINTENANCE3_SPEC_VERSION :: 1
VK_KHR_MAINTENANCE3_EXTENSION_NAME :: "VK_KHR_maintenance3"
VK_KHR_draw_indirect_count :: 1
VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 1
VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_KHR_draw_indirect_count"
VK_KHR_shader_subgroup_extended_types :: 1
VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION :: 1
VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME :: "VK_KHR_shader_subgroup_extended_types"
VK_KHR_8bit_storage :: 1
VK_KHR_8BIT_STORAGE_SPEC_VERSION :: 1
VK_KHR_8BIT_STORAGE_EXTENSION_NAME :: "VK_KHR_8bit_storage"
VK_KHR_shader_atomic_int64 :: 1
VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION :: 1
VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME :: "VK_KHR_shader_atomic_int64"
VK_KHR_shader_clock :: 1
VK_KHR_SHADER_CLOCK_SPEC_VERSION :: 1
VK_KHR_SHADER_CLOCK_EXTENSION_NAME :: "VK_KHR_shader_clock"
VK_KHR_driver_properties :: 1
VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION :: 1
VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME :: "VK_KHR_driver_properties"
VK_MAX_DRIVER_NAME_SIZE_KHR :: VK_MAX_DRIVER_NAME_SIZE
VK_MAX_DRIVER_INFO_SIZE_KHR :: VK_MAX_DRIVER_INFO_SIZE
VK_KHR_shader_float_controls :: 1
VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION :: 4
VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME :: "VK_KHR_shader_float_controls"
VK_KHR_depth_stencil_resolve :: 1
VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION :: 1
VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME :: "VK_KHR_depth_stencil_resolve"
VK_KHR_swapchain_mutable_format :: 1
VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION :: 1
VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME :: "VK_KHR_swapchain_mutable_format"
VK_KHR_timeline_semaphore :: 1
VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION :: 2
VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME :: "VK_KHR_timeline_semaphore"
VK_KHR_vulkan_memory_model :: 1
VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION :: 3
VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME :: "VK_KHR_vulkan_memory_model"
VK_KHR_spirv_1_4 :: 1
VK_KHR_SPIRV_1_4_SPEC_VERSION :: 1
VK_KHR_SPIRV_1_4_EXTENSION_NAME :: "VK_KHR_spirv_1_4"
VK_KHR_surface_protected_capabilities :: 1
VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION :: 1
VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME :: "VK_KHR_surface_protected_capabilities"
VK_KHR_separate_depth_stencil_layouts :: 1
VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION :: 1
VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME :: "VK_KHR_separate_depth_stencil_layouts"
VK_KHR_uniform_buffer_standard_layout :: 1
VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION :: 1
VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME :: "VK_KHR_uniform_buffer_standard_layout"
VK_KHR_buffer_device_address :: 1
VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 1
VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_KHR_buffer_device_address"
VK_KHR_pipeline_executable_properties :: 1
VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION :: 1
VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME :: "VK_KHR_pipeline_executable_properties"
VK_KHR_shader_non_semantic_info :: 1
VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION :: 1
VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME :: "VK_KHR_shader_non_semantic_info"
VK_EXT_debug_report :: 1
VK_EXT_DEBUG_REPORT_SPEC_VERSION :: 9
VK_EXT_DEBUG_REPORT_EXTENSION_NAME :: "VK_EXT_debug_report"
VK_NV_glsl_shader :: 1
VK_NV_GLSL_SHADER_SPEC_VERSION :: 1
VK_NV_GLSL_SHADER_EXTENSION_NAME :: "VK_NV_glsl_shader"
VK_EXT_depth_range_unrestricted :: 1
VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION :: 1
VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME :: "VK_EXT_depth_range_unrestricted"
VK_IMG_filter_cubic :: 1
VK_IMG_FILTER_CUBIC_SPEC_VERSION :: 1
VK_IMG_FILTER_CUBIC_EXTENSION_NAME :: "VK_IMG_filter_cubic"
VK_AMD_rasterization_order :: 1
VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION :: 1
VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME :: "VK_AMD_rasterization_order"
VK_AMD_shader_trinary_minmax :: 1
VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION :: 1
VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME :: "VK_AMD_shader_trinary_minmax"
VK_AMD_shader_explicit_vertex_parameter :: 1
VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION :: 1
VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME :: "VK_AMD_shader_explicit_vertex_parameter"
VK_EXT_debug_marker :: 1
VK_EXT_DEBUG_MARKER_SPEC_VERSION :: 4
VK_EXT_DEBUG_MARKER_EXTENSION_NAME :: "VK_EXT_debug_marker"
VK_AMD_gcn_shader :: 1
VK_AMD_GCN_SHADER_SPEC_VERSION :: 1
VK_AMD_GCN_SHADER_EXTENSION_NAME :: "VK_AMD_gcn_shader"
VK_NV_dedicated_allocation :: 1
VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION :: 1
VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME :: "VK_NV_dedicated_allocation"
VK_EXT_transform_feedback :: 1
VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION :: 1
VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME :: "VK_EXT_transform_feedback"
VK_NVX_image_view_handle :: 1
VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION :: 2
VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME :: "VK_NVX_image_view_handle"
VK_AMD_draw_indirect_count :: 1
VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION :: 2
VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME :: "VK_AMD_draw_indirect_count"
VK_AMD_negative_viewport_height :: 1
VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION :: 1
VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME :: "VK_AMD_negative_viewport_height"
VK_AMD_gpu_shader_half_float :: 1
VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION :: 2
VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME :: "VK_AMD_gpu_shader_half_float"
VK_AMD_shader_ballot :: 1
VK_AMD_SHADER_BALLOT_SPEC_VERSION :: 1
VK_AMD_SHADER_BALLOT_EXTENSION_NAME :: "VK_AMD_shader_ballot"
VK_AMD_texture_gather_bias_lod :: 1
VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION :: 1
VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME :: "VK_AMD_texture_gather_bias_lod"
VK_AMD_shader_info :: 1
VK_AMD_SHADER_INFO_SPEC_VERSION :: 1
VK_AMD_SHADER_INFO_EXTENSION_NAME :: "VK_AMD_shader_info"
VK_AMD_shader_image_load_store_lod :: 1
VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION :: 1
VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME :: "VK_AMD_shader_image_load_store_lod"
VK_NV_corner_sampled_image :: 1
VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION :: 2
VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME :: "VK_NV_corner_sampled_image"
VK_IMG_format_pvrtc :: 1
VK_IMG_FORMAT_PVRTC_SPEC_VERSION :: 1
VK_IMG_FORMAT_PVRTC_EXTENSION_NAME :: "VK_IMG_format_pvrtc"
VK_NV_external_memory_capabilities :: 1
VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION :: 1
VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME :: "VK_NV_external_memory_capabilities"
VK_NV_external_memory :: 1
VK_NV_EXTERNAL_MEMORY_SPEC_VERSION :: 1
VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME :: "VK_NV_external_memory"
VK_EXT_validation_flags :: 1
VK_EXT_VALIDATION_FLAGS_SPEC_VERSION :: 2
VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME :: "VK_EXT_validation_flags"
VK_EXT_shader_subgroup_ballot :: 1
VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION :: 1
VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME :: "VK_EXT_shader_subgroup_ballot"
VK_EXT_shader_subgroup_vote :: 1
VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION :: 1
VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME :: "VK_EXT_shader_subgroup_vote"
VK_EXT_texture_compression_astc_hdr :: 1
VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION :: 1
VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME :: "VK_EXT_texture_compression_astc_hdr"
VK_EXT_astc_decode_mode :: 1
VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION :: 1
VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME :: "VK_EXT_astc_decode_mode"
VK_EXT_conditional_rendering :: 1
VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION :: 2
VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME :: "VK_EXT_conditional_rendering"
VK_NV_clip_space_w_scaling :: 1
VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION :: 1
VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME :: "VK_NV_clip_space_w_scaling"
VK_EXT_direct_mode_display :: 1
VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION :: 1
VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME :: "VK_EXT_direct_mode_display"
VK_EXT_display_surface_counter :: 1
VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION :: 1
VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME :: "VK_EXT_display_surface_counter"
VK_EXT_display_control :: 1
VK_EXT_DISPLAY_CONTROL_SPEC_VERSION :: 1
VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME :: "VK_EXT_display_control"
VK_GOOGLE_display_timing :: 1
VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION :: 1
VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME :: "VK_GOOGLE_display_timing"
VK_NV_sample_mask_override_coverage :: 1
VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION :: 1
VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME :: "VK_NV_sample_mask_override_coverage"
VK_NV_geometry_shader_passthrough :: 1
VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION :: 1
VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME :: "VK_NV_geometry_shader_passthrough"
VK_NV_viewport_array2 :: 1
VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION :: 1
VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME :: "VK_NV_viewport_array2"
VK_NVX_multiview_per_view_attributes :: 1
VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION :: 1
VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME :: "VK_NVX_multiview_per_view_attributes"
VK_NV_viewport_swizzle :: 1
VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION :: 1
VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME :: "VK_NV_viewport_swizzle"
VK_EXT_discard_rectangles :: 1
VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION :: 1
VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME :: "VK_EXT_discard_rectangles"
VK_EXT_conservative_rasterization :: 1
VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION :: 1
VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_conservative_rasterization"
VK_EXT_depth_clip_enable :: 1
VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION :: 1
VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME :: "VK_EXT_depth_clip_enable"
VK_EXT_swapchain_colorspace :: 1
VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION :: 4
VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME :: "VK_EXT_swapchain_colorspace"
VK_EXT_hdr_metadata :: 1
VK_EXT_HDR_METADATA_SPEC_VERSION :: 2
VK_EXT_HDR_METADATA_EXTENSION_NAME :: "VK_EXT_hdr_metadata"
VK_EXT_external_memory_dma_buf :: 1
VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION :: 1
VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME :: "VK_EXT_external_memory_dma_buf"
VK_EXT_queue_family_foreign :: 1
VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION :: 1
VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME :: "VK_EXT_queue_family_foreign"
VK_QUEUE_FAMILY_FOREIGN_EXT :: u32.max - 2
VK_EXT_debug_utils :: 1
VK_EXT_DEBUG_UTILS_SPEC_VERSION :: 2
VK_EXT_DEBUG_UTILS_EXTENSION_NAME :: "VK_EXT_debug_utils"
VK_EXT_sampler_filter_minmax :: 1
VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION :: 2
VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME :: "VK_EXT_sampler_filter_minmax"
VK_AMD_gpu_shader_int16 :: 1
VK_AMD_GPU_SHADER_INT16_SPEC_VERSION :: 2
VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME :: "VK_AMD_gpu_shader_int16"
VK_AMD_mixed_attachment_samples :: 1
VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION :: 1
VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME :: "VK_AMD_mixed_attachment_samples"
VK_AMD_shader_fragment_mask :: 1
VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION :: 1
VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME :: "VK_AMD_shader_fragment_mask"
VK_EXT_inline_uniform_block :: 1
VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION :: 1
VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME :: "VK_EXT_inline_uniform_block"
VK_EXT_shader_stencil_export :: 1
VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION :: 1
VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME :: "VK_EXT_shader_stencil_export"
VK_EXT_sample_locations :: 1
VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION :: 1
VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME :: "VK_EXT_sample_locations"
VK_EXT_blend_operation_advanced :: 1
VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION :: 2
VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME :: "VK_EXT_blend_operation_advanced"
VK_NV_fragment_coverage_to_color :: 1
VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION :: 1
VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME :: "VK_NV_fragment_coverage_to_color"
VK_NV_framebuffer_mixed_samples :: 1
VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION :: 1
VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME :: "VK_NV_framebuffer_mixed_samples"
VK_NV_fill_rectangle :: 1
VK_NV_FILL_RECTANGLE_SPEC_VERSION :: 1
VK_NV_FILL_RECTANGLE_EXTENSION_NAME :: "VK_NV_fill_rectangle"
VK_NV_shader_sm_builtins :: 1
VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION :: 1
VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME :: "VK_NV_shader_sm_builtins"
VK_EXT_post_depth_coverage :: 1
VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION :: 1
VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME :: "VK_EXT_post_depth_coverage"
VK_EXT_image_drm_format_modifier :: 1
VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION :: 1
VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME :: "VK_EXT_image_drm_format_modifier"
VK_EXT_validation_cache :: 1
VK_EXT_VALIDATION_CACHE_SPEC_VERSION :: 1
VK_EXT_VALIDATION_CACHE_EXTENSION_NAME :: "VK_EXT_validation_cache"
VK_EXT_descriptor_indexing :: 1
VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION :: 2
VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME :: "VK_EXT_descriptor_indexing"
VK_EXT_shader_viewport_index_layer :: 1
VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION :: 1
VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME :: "VK_EXT_shader_viewport_index_layer"
VK_NV_shading_rate_image :: 1
VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION :: 3
VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME :: "VK_NV_shading_rate_image"
VK_NV_ray_tracing :: 1
VK_NV_RAY_TRACING_SPEC_VERSION :: 3
VK_NV_RAY_TRACING_EXTENSION_NAME :: "VK_NV_ray_tracing"
VK_SHADER_UNUSED_KHR :: u32.max
VK_SHADER_UNUSED_NV :: VK_SHADER_UNUSED_KHR
VK_NV_representative_fragment_test :: 1
VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION :: 2
VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME :: "VK_NV_representative_fragment_test"
VK_EXT_filter_cubic :: 1
VK_EXT_FILTER_CUBIC_SPEC_VERSION :: 3
VK_EXT_FILTER_CUBIC_EXTENSION_NAME :: "VK_EXT_filter_cubic"
VK_QCOM_render_pass_shader_resolve :: 1
VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION :: 4
VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME :: "VK_QCOM_render_pass_shader_resolve"
VK_EXT_global_priority :: 1
VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION :: 2
VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME :: "VK_EXT_global_priority"
VK_EXT_external_memory_host :: 1
VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION :: 1
VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME :: "VK_EXT_external_memory_host"
VK_AMD_buffer_marker :: 1
VK_AMD_BUFFER_MARKER_SPEC_VERSION :: 1
VK_AMD_BUFFER_MARKER_EXTENSION_NAME :: "VK_AMD_buffer_marker"
VK_AMD_pipeline_compiler_control :: 1
VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION :: 1
VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME :: "VK_AMD_pipeline_compiler_control"
VK_EXT_calibrated_timestamps :: 1
VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION :: 1
VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME :: "VK_EXT_calibrated_timestamps"
VK_AMD_shader_core_properties :: 1
VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION :: 2
VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME :: "VK_AMD_shader_core_properties"
VK_AMD_memory_overallocation_behavior :: 1
VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION :: 1
VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME :: "VK_AMD_memory_overallocation_behavior"
VK_EXT_vertex_attribute_divisor :: 1
VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION :: 3
VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME :: "VK_EXT_vertex_attribute_divisor"
VK_EXT_pipeline_creation_feedback :: 1
VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION :: 1
VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME :: "VK_EXT_pipeline_creation_feedback"
VK_NV_shader_subgroup_partitioned :: 1
VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION :: 1
VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME :: "VK_NV_shader_subgroup_partitioned"
VK_NV_compute_shader_derivatives :: 1
VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION :: 1
VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME :: "VK_NV_compute_shader_derivatives"
VK_NV_mesh_shader :: 1
VK_NV_MESH_SHADER_SPEC_VERSION :: 1
VK_NV_MESH_SHADER_EXTENSION_NAME :: "VK_NV_mesh_shader"
VK_NV_fragment_shader_barycentric :: 1
VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION :: 1
VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME :: "VK_NV_fragment_shader_barycentric"
VK_NV_shader_image_footprint :: 1
VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION :: 2
VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME :: "VK_NV_shader_image_footprint"
VK_NV_scissor_exclusive :: 1
VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION :: 1
VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME :: "VK_NV_scissor_exclusive"
VK_NV_device_diagnostic_checkpoints :: 1
VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION :: 2
VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME :: "VK_NV_device_diagnostic_checkpoints"
VK_INTEL_shader_integer_functions2 :: 1
VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION :: 1
VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME :: "VK_INTEL_shader_integer_functions2"
VK_INTEL_performance_query :: 1
VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION :: 2
VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME :: "VK_INTEL_performance_query"
VK_EXT_pci_bus_info :: 1
VK_EXT_PCI_BUS_INFO_SPEC_VERSION :: 2
VK_EXT_PCI_BUS_INFO_EXTENSION_NAME :: "VK_EXT_pci_bus_info"
VK_AMD_display_native_hdr :: 1
VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION :: 1
VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME :: "VK_AMD_display_native_hdr"
VK_EXT_fragment_density_map :: 1
VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION :: 1
VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME :: "VK_EXT_fragment_density_map"
VK_EXT_scalar_block_layout :: 1
VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION :: 1
VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME :: "VK_EXT_scalar_block_layout"
VK_GOOGLE_hlsl_functionality1 :: 1
VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION :: 1
VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME :: "VK_GOOGLE_hlsl_functionality1"
VK_GOOGLE_decorate_string :: 1
VK_GOOGLE_DECORATE_STRING_SPEC_VERSION :: 1
VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME :: "VK_GOOGLE_decorate_string"
VK_EXT_subgroup_size_control :: 1
VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION :: 2
VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME :: "VK_EXT_subgroup_size_control"
VK_AMD_shader_core_properties2 :: 1
VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION :: 1
VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME :: "VK_AMD_shader_core_properties2"
VK_AMD_device_coherent_memory :: 1
VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION :: 1
VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME :: "VK_AMD_device_coherent_memory"
VK_EXT_memory_budget :: 1
VK_EXT_MEMORY_BUDGET_SPEC_VERSION :: 1
VK_EXT_MEMORY_BUDGET_EXTENSION_NAME :: "VK_EXT_memory_budget"
VK_EXT_memory_priority :: 1
VK_EXT_MEMORY_PRIORITY_SPEC_VERSION :: 1
VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME :: "VK_EXT_memory_priority"
VK_NV_dedicated_allocation_image_aliasing :: 1
VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION :: 1
VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME :: "VK_NV_dedicated_allocation_image_aliasing"
VK_EXT_buffer_device_address :: 1
VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION :: 2
VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME :: "VK_EXT_buffer_device_address"
VK_EXT_tooling_info :: 1
VK_EXT_TOOLING_INFO_SPEC_VERSION :: 1
VK_EXT_TOOLING_INFO_EXTENSION_NAME :: "VK_EXT_tooling_info"
VK_EXT_separate_stencil_usage :: 1
VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION :: 1
VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME :: "VK_EXT_separate_stencil_usage"
VK_EXT_validation_features :: 1
VK_EXT_VALIDATION_FEATURES_SPEC_VERSION :: 3
VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME :: "VK_EXT_validation_features"
VK_NV_cooperative_matrix :: 1
VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION :: 1
VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME :: "VK_NV_cooperative_matrix"
VK_NV_coverage_reduction_mode :: 1
VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION :: 1
VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME :: "VK_NV_coverage_reduction_mode"
VK_EXT_fragment_shader_interlock :: 1
VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION :: 1
VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME :: "VK_EXT_fragment_shader_interlock"
VK_EXT_ycbcr_image_arrays :: 1
VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION :: 1
VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME :: "VK_EXT_ycbcr_image_arrays"
VK_EXT_headless_surface :: 1
VK_EXT_HEADLESS_SURFACE_SPEC_VERSION :: 1
VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME :: "VK_EXT_headless_surface"
VK_EXT_line_rasterization :: 1
VK_EXT_LINE_RASTERIZATION_SPEC_VERSION :: 1
VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME :: "VK_EXT_line_rasterization"
VK_EXT_shader_atomic_float :: 1
VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION :: 1
VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME :: "VK_EXT_shader_atomic_float"
VK_EXT_host_query_reset :: 1
VK_EXT_HOST_QUERY_RESET_SPEC_VERSION :: 1
VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME :: "VK_EXT_host_query_reset"
VK_EXT_index_type_uint8 :: 1
VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION :: 1
VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME :: "VK_EXT_index_type_uint8"
VK_EXT_extended_dynamic_state :: 1
VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION :: 1
VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME :: "VK_EXT_extended_dynamic_state"
VK_EXT_shader_demote_to_helper_invocation :: 1
VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION :: 1
VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME :: "VK_EXT_shader_demote_to_helper_invocation"
VK_NV_device_generated_commands :: 1
VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION :: 3
VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME :: "VK_NV_device_generated_commands"
VK_EXT_texel_buffer_alignment :: 1
VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION :: 1
VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME :: "VK_EXT_texel_buffer_alignment"
VK_QCOM_render_pass_transform :: 1
VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION :: 1
VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME :: "VK_QCOM_render_pass_transform"
VK_EXT_robustness2 :: 1
VK_EXT_ROBUSTNESS_2_SPEC_VERSION :: 1
VK_EXT_ROBUSTNESS_2_EXTENSION_NAME :: "VK_EXT_robustness2"
VK_EXT_custom_border_color :: 1
VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION :: 12
VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME :: "VK_EXT_custom_border_color"
VK_GOOGLE_user_type :: 1
VK_GOOGLE_USER_TYPE_SPEC_VERSION :: 1
VK_GOOGLE_USER_TYPE_EXTENSION_NAME :: "VK_GOOGLE_user_type"
VK_EXT_private_data :: 1
VK_EXT_PRIVATE_DATA_SPEC_VERSION :: 1
VK_EXT_PRIVATE_DATA_EXTENSION_NAME :: "VK_EXT_private_data"
VK_EXT_pipeline_creation_cache_control :: 1
VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION :: 3
VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME :: "VK_EXT_pipeline_creation_cache_control"
VK_NV_device_diagnostics_config :: 1
VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION :: 1
VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME :: "VK_NV_device_diagnostics_config"
VK_QCOM_render_pass_store_ops :: 1
VK_QCOM_render_pass_store_ops_SPEC_VERSION :: 2
VK_QCOM_render_pass_store_ops_EXTENSION_NAME :: "VK_QCOM_render_pass_store_ops"
VK_EXT_fragment_density_map2 :: 1
VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION :: 1
VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME :: "VK_EXT_fragment_density_map2"
VK_EXT_image_robustness :: 1
VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION :: 1
VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME :: "VK_EXT_image_robustness"
VkResult :: enum #copy #repr("C") #tag_type(i32) {
    Success                                     = 0x0
    NotReady                                    = 0x1
    Timeout                                     = 0x2
    EventSet                                    = 0x3
    EventReset                                  = 0x4
    Incomplete                                  = 0x5
    ErrorOutOfHostMemory                        = -1
    ErrorOutOfDeviceMemory                      = -2
    ErrorInitializationFailed                   = -3
    ErrorDeviceLost                             = -4
    ErrorMemoryMapFailed                        = -5
    ErrorLayerNotPresent                        = -6
    ErrorExtensionNotPresent                    = -7
    ErrorFeatureNotPresent                      = -8
    ErrorIncompatibleDriver                     = -9
    ErrorTooManyObjects                         = -10
    ErrorFormatNotSupported                     = -11
    ErrorFragmentedPool                         = -12
    ErrorUnknown                                = -13
    ErrorOutOfPoolMemory                        = -1000069000
    ErrorInvalidExternalHandle                  = -1000072003
    ErrorFragmentation                          = -1000161000
    ErrorInvalidOpaqueCaptureAddress            = -1000257000
    ErrorSurfaceLostKhr                         = -1000000000
    ErrorNativeWindowInUseKhr                   = -1000000001
    SuboptimalKhr                               = 0x3b9acdeb
    ErrorOutOfDateKhr                           = -1000001004
    ErrorIncompatibleDisplayKhr                 = -1000003001
    ErrorValidationFailedExt                    = -1000011001
    ErrorInvalidShaderNv                        = -1000012000
    ErrorIncompatibleVersionKhr                 = -1000150000
    ErrorInvalidDrmFormatModifierPlaneLayoutExt = -1000158000
    ErrorNotPermittedExt                        = -1000174001
    ErrorFullScreenExclusiveModeLostExt         = -1000255000
    ThreadIdleKhr                               = 0x3b9ee0e0
    ThreadDoneKhr                               = 0x3b9ee0e1
    OperationDeferredKhr                        = 0x3b9ee0e2
    OperationNotDeferredKhr                     = 0x3b9ee0e3
    PipelineCompileRequiredExt                  = 0x3b9f5228
    ErrorOutOfPoolMemoryKhr                     = -1000069000
    ErrorInvalidExternalHandleKhr               = -1000072003
    ErrorFragmentationExt                       = -1000161000
    ErrorInvalidDeviceAddressExt                = -1000257000
    ErrorInvalidOpaqueCaptureAddressKhr         = -1000257000
    ErrorPipelineCompileRequiredExt             = 0x3b9f5228
    MaxEnum                                     = 0x7fffffff
}
VkStructureType :: enum #copy #repr("C") #tag_type(i32) {
    ApplicationInfo                                          = 0x0
    InstanceCreateInfo                                       = 0x1
    DeviceQueueCreateInfo                                    = 0x2
    DeviceCreateInfo                                         = 0x3
    SubmitInfo                                               = 0x4
    MemoryAllocateInfo                                       = 0x5
    MappedMemoryRange                                        = 0x6
    BindSparseInfo                                           = 0x7
    FenceCreateInfo                                          = 0x8
    SemaphoreCreateInfo                                      = 0x9
    EventCreateInfo                                          = 0xa
    QueryPoolCreateInfo                                      = 0xb
    BufferCreateInfo                                         = 0xc
    BufferViewCreateInfo                                     = 0xd
    ImageCreateInfo                                          = 0xe
    ImageViewCreateInfo                                      = 0xf
    ShaderModuleCreateInfo                                   = 0x10
    PipelineCacheCreateInfo                                  = 0x11
    PipelineShaderStageCreateInfo                            = 0x12
    PipelineVertexInputStateCreateInfo                       = 0x13
    PipelineInputAssemblyStateCreateInfo                     = 0x14
    PipelineTessellationStateCreateInfo                      = 0x15
    PipelineViewportStateCreateInfo                          = 0x16
    PipelineRasterizationStateCreateInfo                     = 0x17
    PipelineMultisampleStateCreateInfo                       = 0x18
    PipelineDepthStencilStateCreateInfo                      = 0x19
    PipelineColorBlendStateCreateInfo                        = 0x1a
    PipelineDynamicStateCreateInfo                           = 0x1b
    GraphicsPipelineCreateInfo                               = 0x1c
    ComputePipelineCreateInfo                                = 0x1d
    PipelineLayoutCreateInfo                                 = 0x1e
    SamplerCreateInfo                                        = 0x1f
    DescriptorSetLayoutCreateInfo                            = 0x20
    DescriptorPoolCreateInfo                                 = 0x21
    DescriptorSetAllocateInfo                                = 0x22
    WriteDescriptorSet                                       = 0x23
    CopyDescriptorSet                                        = 0x24
    FramebufferCreateInfo                                    = 0x25
    RenderPassCreateInfo                                     = 0x26
    CommandPoolCreateInfo                                    = 0x27
    CommandBufferAllocateInfo                                = 0x28
    CommandBufferInheritanceInfo                             = 0x29
    CommandBufferBeginInfo                                   = 0x2a
    RenderPassBeginInfo                                      = 0x2b
    BufferMemoryBarrier                                      = 0x2c
    ImageMemoryBarrier                                       = 0x2d
    MemoryBarrier                                            = 0x2e
    LoaderInstanceCreateInfo                                 = 0x2f
    LoaderDeviceCreateInfo                                   = 0x30
    PhysicalDeviceSubgroupProperties                         = 0x3b9c3930
    BindBufferMemoryInfo                                     = 0x3b9d2f48
    BindImageMemoryInfo                                      = 0x3b9d2f49
    PhysicalDevice16bitStorageFeatures                       = 0x3b9c0e38
    MemoryDedicatedRequirements                              = 0x3b9cba18
    MemoryDedicatedAllocateInfo                              = 0x3b9cba19
    MemoryAllocateFlagsInfo                                  = 0x3b9bb460
    DeviceGroupRenderPassBeginInfo                           = 0x3b9bb463
    DeviceGroupCommandBufferBeginInfo                        = 0x3b9bb464
    DeviceGroupSubmitInfo                                    = 0x3b9bb465
    DeviceGroupBindSparseInfo                                = 0x3b9bb466
    BindBufferMemoryDeviceGroupInfo                          = 0x3b9bb46d
    BindImageMemoryDeviceGroupInfo                           = 0x3b9bb46e
    PhysicalDeviceGroupProperties                            = 0x3b9bdb70
    DeviceGroupDeviceCreateInfo                              = 0x3b9bdb71
    BufferMemoryRequirementsInfo2                            = 0x3b9d0450
    ImageMemoryRequirementsInfo2                             = 0x3b9d0451
    ImageSparseMemoryRequirementsInfo2                       = 0x3b9d0452
    MemoryRequirements2                                      = 0x3b9d0453
    SparseImageMemoryRequirements2                           = 0x3b9d0454
    PhysicalDeviceFeatures2                                  = 0x3b9bb078
    PhysicalDeviceProperties2                                = 0x3b9bb079
    FormatProperties2                                        = 0x3b9bb07a
    ImageFormatProperties2                                   = 0x3b9bb07b
    PhysicalDeviceImageFormatInfo2                           = 0x3b9bb07c
    QueueFamilyProperties2                                   = 0x3b9bb07d
    PhysicalDeviceMemoryProperties2                          = 0x3b9bb07e
    SparseImageFormatProperties2                             = 0x3b9bb07f
    PhysicalDeviceSparseImageFormatInfo2                     = 0x3b9bb080
    PhysicalDevicePointClippingProperties                    = 0x3b9c9308
    RenderPassInputAttachmentAspectCreateInfo                = 0x3b9c9309
    ImageViewUsageCreateInfo                                 = 0x3b9c930a
    PipelineTessellationDomainOriginStateCreateInfo          = 0x3b9c930b
    RenderPassMultiviewCreateInfo                            = 0x3b9b9908
    PhysicalDeviceMultiviewFeatures                          = 0x3b9b9909
    PhysicalDeviceMultiviewProperties                        = 0x3b9b990a
    PhysicalDeviceVariablePointersFeatures                   = 0x3b9c9ec0
    ProtectedSubmitInfo                                      = 0x3b9d0068
    PhysicalDeviceProtectedMemoryFeatures                    = 0x3b9d0069
    PhysicalDeviceProtectedMemoryProperties                  = 0x3b9d006a
    DeviceQueueInfo2                                         = 0x3b9d006b
    SamplerYcbcrConversionCreateInfo                         = 0x3b9d2b60
    SamplerYcbcrConversionInfo                               = 0x3b9d2b61
    BindImagePlaneMemoryInfo                                 = 0x3b9d2b62
    ImagePlaneMemoryRequirementsInfo                         = 0x3b9d2b63
    PhysicalDeviceSamplerYcbcrConversionFeatures             = 0x3b9d2b64
    SamplerYcbcrConversionImageFormatProperties              = 0x3b9d2b65
    DescriptorUpdateTemplateCreateInfo                       = 0x3b9c1608
    PhysicalDeviceExternalImageFormatInfo                    = 0x3b9bdf58
    ExternalImageFormatProperties                            = 0x3b9bdf59
    PhysicalDeviceExternalBufferInfo                         = 0x3b9bdf5a
    ExternalBufferProperties                                 = 0x3b9bdf5b
    PhysicalDeviceIdProperties                               = 0x3b9bdf5c
    ExternalMemoryBufferCreateInfo                           = 0x3b9be340
    ExternalMemoryImageCreateInfo                            = 0x3b9be341
    ExportMemoryAllocateInfo                                 = 0x3b9be342
    PhysicalDeviceExternalFenceInfo                          = 0x3b9c7f80
    ExternalFenceProperties                                  = 0x3b9c7f81
    ExportFenceCreateInfo                                    = 0x3b9c8368
    ExportSemaphoreCreateInfo                                = 0x3b9bf6c8
    PhysicalDeviceExternalSemaphoreInfo                      = 0x3b9bf2e0
    ExternalSemaphoreProperties                              = 0x3b9bf2e1
    PhysicalDeviceMaintenance3Properties                     = 0x3b9d5a40
    DescriptorSetLayoutSupport                               = 0x3b9d5a41
    PhysicalDeviceShaderDrawParametersFeatures               = 0x3b9bc018
    PhysicalDeviceVulkan11Features                           = 0x31
    PhysicalDeviceVulkan11Properties                         = 0x32
    PhysicalDeviceVulkan12Features                           = 0x33
    PhysicalDeviceVulkan12Properties                         = 0x34
    ImageFormatListCreateInfo                                = 0x3b9d0838
    AttachmentDescription2                                   = 0x3b9c73c8
    AttachmentReference2                                     = 0x3b9c73c9
    SubpassDescription2                                      = 0x3b9c73ca
    SubpassDependency2                                       = 0x3b9c73cb
    RenderPassCreateInfo2                                    = 0x3b9c73cc
    SubpassBeginInfo                                         = 0x3b9c73cd
    SubpassEndInfo                                           = 0x3b9c73ce
    PhysicalDevice8bitStorageFeatures                        = 0x3b9d7d68
    PhysicalDeviceDriverProperties                           = 0x3b9dc7a0
    PhysicalDeviceShaderAtomicInt64Features                  = 0x3b9d8920
    PhysicalDeviceShaderFloat16Int8Features                  = 0x3b9c0a50
    PhysicalDeviceFloatControlsProperties                    = 0x3b9dcb88
    DescriptorSetLayoutBindingFlagsCreateInfo                = 0x3b9d3ee8
    PhysicalDeviceDescriptorIndexingFeatures                 = 0x3b9d3ee9
    PhysicalDeviceDescriptorIndexingProperties               = 0x3b9d3eea
    DescriptorSetVariableDescriptorCountAllocateInfo         = 0x3b9d3eeb
    DescriptorSetVariableDescriptorCountLayoutSupport        = 0x3b9d3eec
    PhysicalDeviceDepthStencilResolveProperties              = 0x3b9dd358
    SubpassDescriptionDepthStencilResolve                    = 0x3b9dd359
    PhysicalDeviceScalarBlockLayoutFeatures                  = 0x3b9e2948
    ImageStencilUsageCreateInfo                              = 0x3b9e8af0
    PhysicalDeviceSamplerFilterMinmaxProperties              = 0x3b9cc5d0
    SamplerReductionModeCreateInfo                           = 0x3b9cc5d1
    PhysicalDeviceVulkanMemoryModelFeatures                  = 0x3b9e0238
    PhysicalDeviceImagelessFramebufferFeatures               = 0x3b9c6fe0
    FramebufferAttachmentsCreateInfo                         = 0x3b9c6fe1
    FramebufferAttachmentImageInfo                           = 0x3b9c6fe2
    RenderPassAttachmentBeginInfo                            = 0x3b9c6fe3
    PhysicalDeviceUniformBufferStandardLayoutFeatures        = 0x3b9ea648
    PhysicalDeviceShaderSubgroupExtendedTypesFeatures        = 0x3b9d7598
    PhysicalDeviceSeparateDepthStencilLayoutsFeatures        = 0x3b9e7768
    AttachmentReferenceStencilLayout                         = 0x3b9e7769
    AttachmentDescriptionStencilLayout                       = 0x3b9e776a
    PhysicalDeviceHostQueryResetFeatures                     = 0x3b9ec588
    PhysicalDeviceTimelineSemaphoreFeatures                  = 0x3b9df298
    PhysicalDeviceTimelineSemaphoreProperties                = 0x3b9df299
    SemaphoreTypeCreateInfo                                  = 0x3b9df29a
    TimelineSemaphoreSubmitInfo                              = 0x3b9df29b
    SemaphoreWaitInfo                                        = 0x3b9df29c
    SemaphoreSignalInfo                                      = 0x3b9df29d
    PhysicalDeviceBufferDeviceAddressFeatures                = 0x3b9eb5e8
    BufferDeviceAddressInfo                                  = 0x3b9e8321
    BufferOpaqueCaptureAddressCreateInfo                     = 0x3b9eb5ea
    MemoryOpaqueCaptureAddressAllocateInfo                   = 0x3b9eb5eb
    DeviceMemoryOpaqueCaptureAddressInfo                     = 0x3b9eb5ec
    SwapchainCreateInfoKhr                                   = 0x3b9acde8
    PresentInfoKhr                                           = 0x3b9acde9
    DeviceGroupPresentCapabilitiesKhr                        = 0x3b9bb467
    ImageSwapchainCreateInfoKhr                              = 0x3b9bb468
    BindImageMemorySwapchainInfoKhr                          = 0x3b9bb469
    AcquireNextImageInfoKhr                                  = 0x3b9bb46a
    DeviceGroupPresentInfoKhr                                = 0x3b9bb46b
    DeviceGroupSwapchainCreateInfoKhr                        = 0x3b9bb46c
    DisplayModeCreateInfoKhr                                 = 0x3b9ad1d0
    DisplaySurfaceCreateInfoKhr                              = 0x3b9ad1d1
    DisplayPresentInfoKhr                                    = 0x3b9ad5b8
    XlibSurfaceCreateInfoKhr                                 = 0x3b9ad9a0
    XcbSurfaceCreateInfoKhr                                  = 0x3b9add88
    WaylandSurfaceCreateInfoKhr                              = 0x3b9ae170
    AndroidSurfaceCreateInfoKhr                              = 0x3b9ae940
    Win32SurfaceCreateInfoKhr                                = 0x3b9aed28
    DebugReportCallbackCreateInfoExt                         = 0x3b9af4f8
    PipelineRasterizationStateRasterizationOrderAmd          = 0x3b9b1050
    DebugMarkerObjectNameInfoExt                             = 0x3b9b1ff0
    DebugMarkerObjectTagInfoExt                              = 0x3b9b1ff1
    DebugMarkerMarkerInfoExt                                 = 0x3b9b1ff2
    DedicatedAllocationImageCreateInfoNv                     = 0x3b9b2f90
    DedicatedAllocationBufferCreateInfoNv                    = 0x3b9b2f91
    DedicatedAllocationMemoryAllocateInfoNv                  = 0x3b9b2f92
    PhysicalDeviceTransformFeedbackFeaturesExt               = 0x3b9b3760
    PhysicalDeviceTransformFeedbackPropertiesExt             = 0x3b9b3761
    PipelineRasterizationStateStreamCreateInfoExt            = 0x3b9b3762
    ImageViewHandleInfoNvx                                   = 0x3b9b3f30
    ImageViewAddressPropertiesNvx                            = 0x3b9b3f31
    TextureLodGatherFormatPropertiesAmd                      = 0x3b9b6a28
    StreamDescriptorSurfaceCreateInfoGgp                     = 0x3b9b8968
    PhysicalDeviceCornerSampledImageFeaturesNv               = 0x3b9b8d50
    ExternalMemoryImageCreateInfoNv                          = 0x3b9ba4c0
    ExportMemoryAllocateInfoNv                               = 0x3b9ba4c1
    ImportMemoryWin32HandleInfoNv                            = 0x3b9ba8a8
    ExportMemoryWin32HandleInfoNv                            = 0x3b9ba8a9
    Win32KeyedMutexAcquireReleaseInfoNv                      = 0x3b9bac90
    ValidationFlagsExt                                       = 0x3b9bb848
    ViSurfaceCreateInfoNn                                    = 0x3b9bbc30
    PhysicalDeviceTextureCompressionAstcHdrFeaturesExt       = 0x3b9bcbd0
    ImageViewAstcDecodeModeExt                               = 0x3b9bcfb8
    PhysicalDeviceAstcDecodeFeaturesExt                      = 0x3b9bcfb9
    ImportMemoryWin32HandleInfoKhr                           = 0x3b9be728
    ExportMemoryWin32HandleInfoKhr                           = 0x3b9be729
    MemoryWin32HandlePropertiesKhr                           = 0x3b9be72a
    MemoryGetWin32HandleInfoKhr                              = 0x3b9be72b
    ImportMemoryFdInfoKhr                                    = 0x3b9beb10
    MemoryFdPropertiesKhr                                    = 0x3b9beb11
    MemoryGetFdInfoKhr                                       = 0x3b9beb12
    Win32KeyedMutexAcquireReleaseInfoKhr                     = 0x3b9beef8
    ImportSemaphoreWin32HandleInfoKhr                        = 0x3b9bfab0
    ExportSemaphoreWin32HandleInfoKhr                        = 0x3b9bfab1
    D3d12FenceSubmitInfoKhr                                  = 0x3b9bfab2
    SemaphoreGetWin32HandleInfoKhr                           = 0x3b9bfab3
    ImportSemaphoreFdInfoKhr                                 = 0x3b9bfe98
    SemaphoreGetFdInfoKhr                                    = 0x3b9bfe99
    PhysicalDevicePushDescriptorPropertiesKhr                = 0x3b9c0280
    CommandBufferInheritanceConditionalRenderingInfoExt      = 0x3b9c0668
    PhysicalDeviceConditionalRenderingFeaturesExt            = 0x3b9c0669
    ConditionalRenderingBeginInfoExt                         = 0x3b9c066a
    PresentRegionsKhr                                        = 0x3b9c1220
    PipelineViewportWScalingStateCreateInfoNv                = 0x3b9c1dd8
    SurfaceCapabilities2Ext                                  = 0x3b9c2990
    DisplayPowerInfoExt                                      = 0x3b9c2d78
    DeviceEventInfoExt                                       = 0x3b9c2d79
    DisplayEventInfoExt                                      = 0x3b9c2d7a
    SwapchainCounterCreateInfoExt                            = 0x3b9c2d7b
    PresentTimesInfoGoogle                                   = 0x3b9c3160
    PhysicalDeviceMultiviewPerViewAttributesPropertiesNvx    = 0x3b9c44e8
    PipelineViewportSwizzleStateCreateInfoNv                 = 0x3b9c48d0
    PhysicalDeviceDiscardRectanglePropertiesExt              = 0x3b9c4cb8
    PipelineDiscardRectangleStateCreateInfoExt               = 0x3b9c4cb9
    PhysicalDeviceConservativeRasterizationPropertiesExt     = 0x3b9c5488
    PipelineRasterizationConservativeStateCreateInfoExt      = 0x3b9c5489
    PhysicalDeviceDepthClipEnableFeaturesExt                 = 0x3b9c5870
    PipelineRasterizationDepthClipStateCreateInfoExt         = 0x3b9c5871
    HdrMetadataExt                                           = 0x3b9c6428
    SharedPresentSurfaceCapabilitiesKhr                      = 0x3b9c7b98
    ImportFenceWin32HandleInfoKhr                            = 0x3b9c8750
    ExportFenceWin32HandleInfoKhr                            = 0x3b9c8751
    FenceGetWin32HandleInfoKhr                               = 0x3b9c8752
    ImportFenceFdInfoKhr                                     = 0x3b9c8b38
    FenceGetFdInfoKhr                                        = 0x3b9c8b39
    PhysicalDevicePerformanceQueryFeaturesKhr                = 0x3b9c8f20
    PhysicalDevicePerformanceQueryPropertiesKhr              = 0x3b9c8f21
    QueryPoolPerformanceCreateInfoKhr                        = 0x3b9c8f22
    PerformanceQuerySubmitInfoKhr                            = 0x3b9c8f23
    AcquireProfilingLockInfoKhr                              = 0x3b9c8f24
    PerformanceCounterKhr                                    = 0x3b9c8f25
    PerformanceCounterDescriptionKhr                         = 0x3b9c8f26
    PhysicalDeviceSurfaceInfo2Khr                            = 0x3b9c9ad8
    SurfaceCapabilities2Khr                                  = 0x3b9c9ad9
    SurfaceFormat2Khr                                        = 0x3b9c9ada
    DisplayProperties2Khr                                    = 0x3b9ca2a8
    DisplayPlaneProperties2Khr                               = 0x3b9ca2a9
    DisplayModeProperties2Khr                                = 0x3b9ca2aa
    DisplayPlaneInfo2Khr                                     = 0x3b9ca2ab
    DisplayPlaneCapabilities2Khr                             = 0x3b9ca2ac
    IosSurfaceCreateInfoMvk                                  = 0x3b9ca690
    MacosSurfaceCreateInfoMvk                                = 0x3b9caa78
    DebugUtilsObjectNameInfoExt                              = 0x3b9cbe00
    DebugUtilsObjectTagInfoExt                               = 0x3b9cbe01
    DebugUtilsLabelExt                                       = 0x3b9cbe02
    DebugUtilsMessengerCallbackDataExt                       = 0x3b9cbe03
    DebugUtilsMessengerCreateInfoExt                         = 0x3b9cbe04
    AndroidHardwareBufferUsageAndroid                        = 0x3b9cc1e8
    AndroidHardwareBufferPropertiesAndroid                   = 0x3b9cc1e9
    AndroidHardwareBufferFormatPropertiesAndroid             = 0x3b9cc1ea
    ImportAndroidHardwareBufferInfoAndroid                   = 0x3b9cc1eb
    MemoryGetAndroidHardwareBufferInfoAndroid                = 0x3b9cc1ec
    ExternalFormatAndroid                                    = 0x3b9cc1ed
    PhysicalDeviceInlineUniformBlockFeaturesExt              = 0x3b9ce510
    PhysicalDeviceInlineUniformBlockPropertiesExt            = 0x3b9ce511
    WriteDescriptorSetInlineUniformBlockExt                  = 0x3b9ce512
    DescriptorPoolInlineUniformBlockCreateInfoExt            = 0x3b9ce513
    SampleLocationsInfoExt                                   = 0x3b9cf898
    RenderPassSampleLocationsBeginInfoExt                    = 0x3b9cf899
    PipelineSampleLocationsStateCreateInfoExt                = 0x3b9cf89a
    PhysicalDeviceSampleLocationsPropertiesExt               = 0x3b9cf89b
    MultisamplePropertiesExt                                 = 0x3b9cf89c
    PhysicalDeviceBlendOperationAdvancedFeaturesExt          = 0x3b9d0c20
    PhysicalDeviceBlendOperationAdvancedPropertiesExt        = 0x3b9d0c21
    PipelineColorBlendAdvancedStateCreateInfoExt             = 0x3b9d0c22
    PipelineCoverageToColorStateCreateInfoNv                 = 0x3b9d1008
    BindAccelerationStructureMemoryInfoKhr                   = 0x3b9d4e8e
    WriteDescriptorSetAccelerationStructureKhr               = 0x3b9d4e8f
    AccelerationStructureBuildGeometryInfoKhr                = 0x3b9d13f0
    AccelerationStructureCreateGeometryTypeInfoKhr           = 0x3b9d13f1
    AccelerationStructureDeviceAddressInfoKhr                = 0x3b9d13f2
    AccelerationStructureGeometryAabbsDataKhr                = 0x3b9d13f3
    AccelerationStructureGeometryInstancesDataKhr            = 0x3b9d13f4
    AccelerationStructureGeometryTrianglesDataKhr            = 0x3b9d13f5
    AccelerationStructureGeometryKhr                         = 0x3b9d13f6
    AccelerationStructureMemoryRequirementsInfoKhr           = 0x3b9d13f8
    AccelerationStructureVersionKhr                          = 0x3b9d13f9
    CopyAccelerationStructureInfoKhr                         = 0x3b9d13fa
    CopyAccelerationStructureToMemoryInfoKhr                 = 0x3b9d13fb
    CopyMemoryToAccelerationStructureInfoKhr                 = 0x3b9d13fc
    PhysicalDeviceRayTracingFeaturesKhr                      = 0x3b9d13fd
    PhysicalDeviceRayTracingPropertiesKhr                    = 0x3b9d13fe
    RayTracingPipelineCreateInfoKhr                          = 0x3b9d13ff
    RayTracingShaderGroupCreateInfoKhr                       = 0x3b9d1400
    AccelerationStructureCreateInfoKhr                       = 0x3b9d1401
    RayTracingPipelineInterfaceCreateInfoKhr                 = 0x3b9d1402
    PipelineCoverageModulationStateCreateInfoNv              = 0x3b9d1bc0
    PhysicalDeviceShaderSmBuiltinsFeaturesNv                 = 0x3b9d2390
    PhysicalDeviceShaderSmBuiltinsPropertiesNv               = 0x3b9d2391
    DrmFormatModifierPropertiesListExt                       = 0x3b9d3330
    DrmFormatModifierPropertiesExt                           = 0x3b9d3331
    PhysicalDeviceImageDrmFormatModifierInfoExt              = 0x3b9d3332
    ImageDrmFormatModifierListCreateInfoExt                  = 0x3b9d3333
    ImageDrmFormatModifierExplicitCreateInfoExt              = 0x3b9d3334
    ImageDrmFormatModifierPropertiesExt                      = 0x3b9d3335
    ValidationCacheCreateInfoExt                             = 0x3b9d3b00
    ShaderModuleValidationCacheCreateInfoExt                 = 0x3b9d3b01
    PipelineViewportShadingRateImageStateCreateInfoNv        = 0x3b9d4aa0
    PhysicalDeviceShadingRateImageFeaturesNv                 = 0x3b9d4aa1
    PhysicalDeviceShadingRateImagePropertiesNv               = 0x3b9d4aa2
    PipelineViewportCoarseSampleOrderStateCreateInfoNv       = 0x3b9d4aa5
    RayTracingPipelineCreateInfoNv                           = 0x3b9d4e88
    AccelerationStructureCreateInfoNv                        = 0x3b9d4e89
    GeometryNv                                               = 0x3b9d4e8b
    GeometryTrianglesNv                                      = 0x3b9d4e8c
    GeometryAabbNv                                           = 0x3b9d4e8d
    AccelerationStructureMemoryRequirementsInfoNv            = 0x3b9d4e90
    PhysicalDeviceRayTracingPropertiesNv                     = 0x3b9d4e91
    RayTracingShaderGroupCreateInfoNv                        = 0x3b9d4e93
    AccelerationStructureInfoNv                              = 0x3b9d4e94
    PhysicalDeviceRepresentativeFragmentTestFeaturesNv       = 0x3b9d5270
    PipelineRepresentativeFragmentTestStateCreateInfoNv      = 0x3b9d5271
    PhysicalDeviceImageViewImageFormatInfoExt                = 0x3b9d6210
    FilterCubicImageViewImageFormatPropertiesExt             = 0x3b9d6211
    DeviceQueueGlobalPriorityCreateInfoExt                   = 0x3b9d71b0
    ImportMemoryHostPointerInfoExt                           = 0x3b9d8150
    MemoryHostPointerPropertiesExt                           = 0x3b9d8151
    PhysicalDeviceExternalMemoryHostPropertiesExt            = 0x3b9d8152
    PhysicalDeviceShaderClockFeaturesKhr                     = 0x3b9d8d08
    PipelineCompilerControlCreateInfoAmd                     = 0x3b9d94d8
    CalibratedTimestampInfoExt                               = 0x3b9d98c0
    PhysicalDeviceShaderCorePropertiesAmd                    = 0x3b9d9ca8
    DeviceMemoryOverallocationCreateInfoAmd                  = 0x3b9dac48
    PhysicalDeviceVertexAttributeDivisorPropertiesExt        = 0x3b9db030
    PipelineVertexInputDivisorStateCreateInfoExt             = 0x3b9db031
    PhysicalDeviceVertexAttributeDivisorFeaturesExt          = 0x3b9db032
    PresentFrameTokenGgp                                     = 0x3b9db418
    PipelineCreationFeedbackCreateInfoExt                    = 0x3b9db800
    PhysicalDeviceComputeShaderDerivativesFeaturesNv         = 0x3b9ddb28
    PhysicalDeviceMeshShaderFeaturesNv                       = 0x3b9ddf10
    PhysicalDeviceMeshShaderPropertiesNv                     = 0x3b9ddf11
    PhysicalDeviceFragmentShaderBarycentricFeaturesNv        = 0x3b9de2f8
    PhysicalDeviceShaderImageFootprintFeaturesNv             = 0x3b9de6e0
    PipelineViewportExclusiveScissorStateCreateInfoNv        = 0x3b9deac8
    PhysicalDeviceExclusiveScissorFeaturesNv                 = 0x3b9deaca
    CheckpointDataNv                                         = 0x3b9deeb0
    QueueFamilyCheckpointPropertiesNv                        = 0x3b9deeb1
    PhysicalDeviceShaderIntegerFunctions2FeaturesIntel       = 0x3b9dfa68
    QueryPoolPerformanceQueryCreateInfoIntel                 = 0x3b9dfe50
    InitializePerformanceApiInfoIntel                        = 0x3b9dfe51
    PerformanceMarkerInfoIntel                               = 0x3b9dfe52
    PerformanceStreamMarkerInfoIntel                         = 0x3b9dfe53
    PerformanceOverrideInfoIntel                             = 0x3b9dfe54
    PerformanceConfigurationAcquireInfoIntel                 = 0x3b9dfe55
    PhysicalDevicePciBusInfoPropertiesExt                    = 0x3b9e0620
    DisplayNativeHdrSurfaceCapabilitiesAmd                   = 0x3b9e0a08
    SwapchainDisplayNativeHdrCreateInfoAmd                   = 0x3b9e0a09
    ImagepipeSurfaceCreateInfoFuchsia                        = 0x3b9e0df0
    MetalSurfaceCreateInfoExt                                = 0x3b9e19a8
    PhysicalDeviceFragmentDensityMapFeaturesExt              = 0x3b9e1d90
    PhysicalDeviceFragmentDensityMapPropertiesExt            = 0x3b9e1d91
    RenderPassFragmentDensityMapCreateInfoExt                = 0x3b9e1d92
    PhysicalDeviceSubgroupSizeControlPropertiesExt           = 0x3b9e38e8
    PipelineShaderStageRequiredSubgroupSizeCreateInfoExt     = 0x3b9e38e9
    PhysicalDeviceSubgroupSizeControlFeaturesExt             = 0x3b9e38ea
    PhysicalDeviceShaderCoreProperties2Amd                   = 0x3b9e40b8
    PhysicalDeviceCoherentMemoryFeaturesAmd                  = 0x3b9e4888
    PhysicalDeviceMemoryBudgetPropertiesExt                  = 0x3b9e67c8
    PhysicalDeviceMemoryPriorityFeaturesExt                  = 0x3b9e6bb0
    MemoryPriorityAllocateInfoExt                            = 0x3b9e6bb1
    SurfaceProtectedCapabilitiesKhr                          = 0x3b9e6f98
    PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNv = 0x3b9e7380
    PhysicalDeviceBufferDeviceAddressFeaturesExt             = 0x3b9e8320
    BufferDeviceAddressCreateInfoExt                         = 0x3b9e8322
    PhysicalDeviceToolPropertiesExt                          = 0x3b9e8708
    ValidationFeaturesExt                                    = 0x3b9e8ed8
    PhysicalDeviceCooperativeMatrixFeaturesNv                = 0x3b9e96a8
    CooperativeMatrixPropertiesNv                            = 0x3b9e96a9
    PhysicalDeviceCooperativeMatrixPropertiesNv              = 0x3b9e96aa
    PhysicalDeviceCoverageReductionModeFeaturesNv            = 0x3b9e9a90
    PipelineCoverageReductionStateCreateInfoNv               = 0x3b9e9a91
    FramebufferMixedSamplesCombinationNv                     = 0x3b9e9a92
    PhysicalDeviceFragmentShaderInterlockFeaturesExt         = 0x3b9e9e78
    PhysicalDeviceYcbcrImageArraysFeaturesExt                = 0x3b9ea260
    SurfaceFullScreenExclusiveInfoExt                        = 0x3b9eae18
    SurfaceCapabilitiesFullScreenExclusiveExt                = 0x3b9eae1a
    SurfaceFullScreenExclusiveWin32InfoExt                   = 0x3b9eae19
    HeadlessSurfaceCreateInfoExt                             = 0x3b9eb200
    PhysicalDeviceLineRasterizationFeaturesExt               = 0x3b9ebdb8
    PipelineRasterizationLineStateCreateInfoExt              = 0x3b9ebdb9
    PhysicalDeviceLineRasterizationPropertiesExt             = 0x3b9ebdba
    PhysicalDeviceShaderAtomicFloatFeaturesExt               = 0x3b9ec1a0
    PhysicalDeviceIndexTypeUint8FeaturesExt                  = 0x3b9ed528
    PhysicalDeviceExtendedDynamicStateFeaturesExt            = 0x3b9edcf8
    DeferredOperationInfoKhr                                 = 0x3b9ee0e0
    PhysicalDevicePipelineExecutablePropertiesFeaturesKhr    = 0x3b9ee4c8
    PipelineInfoKhr                                          = 0x3b9ee4c9
    PipelineExecutablePropertiesKhr                          = 0x3b9ee4ca
    PipelineExecutableInfoKhr                                = 0x3b9ee4cb
    PipelineExecutableStatisticKhr                           = 0x3b9ee4cc
    PipelineExecutableInternalRepresentationKhr              = 0x3b9ee4cd
    PhysicalDeviceShaderDemoteToHelperInvocationFeaturesExt  = 0x3b9f0020
    PhysicalDeviceDeviceGeneratedCommandsPropertiesNv        = 0x3b9f0408
    GraphicsShaderGroupCreateInfoNv                          = 0x3b9f0409
    GraphicsPipelineShaderGroupsCreateInfoNv                 = 0x3b9f040a
    IndirectCommandsLayoutTokenNv                            = 0x3b9f040b
    IndirectCommandsLayoutCreateInfoNv                       = 0x3b9f040c
    GeneratedCommandsInfoNv                                  = 0x3b9f040d
    GeneratedCommandsMemoryRequirementsInfoNv                = 0x3b9f040e
    PhysicalDeviceDeviceGeneratedCommandsFeaturesNv          = 0x3b9f040f
    PhysicalDeviceTexelBufferAlignmentFeaturesExt            = 0x3b9f13a8
    PhysicalDeviceTexelBufferAlignmentPropertiesExt          = 0x3b9f13a9
    CommandBufferInheritanceRenderPassTransformInfoQcom      = 0x3b9f1790
    RenderPassTransformBeginInfoQcom                         = 0x3b9f1791
    PhysicalDeviceRobustness2FeaturesExt                     = 0x3b9f2730
    PhysicalDeviceRobustness2PropertiesExt                   = 0x3b9f2731
    SamplerCustomBorderColorCreateInfoExt                    = 0x3b9f2b18
    PhysicalDeviceCustomBorderColorPropertiesExt             = 0x3b9f2b19
    PhysicalDeviceCustomBorderColorFeaturesExt               = 0x3b9f2b1a
    PipelineLibraryCreateInfoKhr                             = 0x3b9f36d0
    PhysicalDevicePrivateDataFeaturesExt                     = 0x3b9f4a58
    DevicePrivateDataCreateInfoExt                           = 0x3b9f4a59
    PrivateDataSlotCreateInfoExt                             = 0x3b9f4a5a
    PhysicalDevicePipelineCreationCacheControlFeaturesExt    = 0x3b9f5228
    PhysicalDeviceDiagnosticsConfigFeaturesNv                = 0x3b9f5de0
    DeviceDiagnosticsConfigCreateInfoNv                      = 0x3b9f5de1
    PhysicalDeviceFragmentDensityMap2FeaturesExt             = 0x3b9fdae0
    PhysicalDeviceFragmentDensityMap2PropertiesExt           = 0x3b9fdae1
    PhysicalDeviceImageRobustnessFeaturesExt                 = 0x3b9fe698
    DirectfbSurfaceCreateInfoExt                             = 0x3ba01190
    PhysicalDeviceVariablePointerFeatures                    = 0x3b9c9ec0
    PhysicalDeviceShaderDrawParameterFeatures                = 0x3b9bc018
    DebugReportCreateInfoExt                                 = 0x3b9af4f8
    RenderPassMultiviewCreateInfoKhr                         = 0x3b9b9908
    PhysicalDeviceMultiviewFeaturesKhr                       = 0x3b9b9909
    PhysicalDeviceMultiviewPropertiesKhr                     = 0x3b9b990a
    PhysicalDeviceFeatures2Khr                               = 0x3b9bb078
    PhysicalDeviceProperties2Khr                             = 0x3b9bb079
    FormatProperties2Khr                                     = 0x3b9bb07a
    ImageFormatProperties2Khr                                = 0x3b9bb07b
    PhysicalDeviceImageFormatInfo2Khr                        = 0x3b9bb07c
    QueueFamilyProperties2Khr                                = 0x3b9bb07d
    PhysicalDeviceMemoryProperties2Khr                       = 0x3b9bb07e
    SparseImageFormatProperties2Khr                          = 0x3b9bb07f
    PhysicalDeviceSparseImageFormatInfo2Khr                  = 0x3b9bb080
    MemoryAllocateFlagsInfoKhr                               = 0x3b9bb460
    DeviceGroupRenderPassBeginInfoKhr                        = 0x3b9bb463
    DeviceGroupCommandBufferBeginInfoKhr                     = 0x3b9bb464
    DeviceGroupSubmitInfoKhr                                 = 0x3b9bb465
    DeviceGroupBindSparseInfoKhr                             = 0x3b9bb466
    BindBufferMemoryDeviceGroupInfoKhr                       = 0x3b9bb46d
    BindImageMemoryDeviceGroupInfoKhr                        = 0x3b9bb46e
    PhysicalDeviceGroupPropertiesKhr                         = 0x3b9bdb70
    DeviceGroupDeviceCreateInfoKhr                           = 0x3b9bdb71
    PhysicalDeviceExternalImageFormatInfoKhr                 = 0x3b9bdf58
    ExternalImageFormatPropertiesKhr                         = 0x3b9bdf59
    PhysicalDeviceExternalBufferInfoKhr                      = 0x3b9bdf5a
    ExternalBufferPropertiesKhr                              = 0x3b9bdf5b
    PhysicalDeviceIdPropertiesKhr                            = 0x3b9bdf5c
    ExternalMemoryBufferCreateInfoKhr                        = 0x3b9be340
    ExternalMemoryImageCreateInfoKhr                         = 0x3b9be341
    ExportMemoryAllocateInfoKhr                              = 0x3b9be342
    PhysicalDeviceExternalSemaphoreInfoKhr                   = 0x3b9bf2e0
    ExternalSemaphorePropertiesKhr                           = 0x3b9bf2e1
    ExportSemaphoreCreateInfoKhr                             = 0x3b9bf6c8
    PhysicalDeviceShaderFloat16Int8FeaturesKhr               = 0x3b9c0a50
    PhysicalDeviceFloat16Int8FeaturesKhr                     = 0x3b9c0a50
    PhysicalDevice16bitStorageFeaturesKhr                    = 0x3b9c0e38
    DescriptorUpdateTemplateCreateInfoKhr                    = 0x3b9c1608
    SurfaceCapabilities2Ext                                  = 0x3b9c2990
    PhysicalDeviceImagelessFramebufferFeaturesKhr            = 0x3b9c6fe0
    FramebufferAttachmentsCreateInfoKhr                      = 0x3b9c6fe1
    FramebufferAttachmentImageInfoKhr                        = 0x3b9c6fe2
    RenderPassAttachmentBeginInfoKhr                         = 0x3b9c6fe3
    AttachmentDescription2Khr                                = 0x3b9c73c8
    AttachmentReference2Khr                                  = 0x3b9c73c9
    SubpassDescription2Khr                                   = 0x3b9c73ca
    SubpassDependency2Khr                                    = 0x3b9c73cb
    RenderPassCreateInfo2Khr                                 = 0x3b9c73cc
    SubpassBeginInfoKhr                                      = 0x3b9c73cd
    SubpassEndInfoKhr                                        = 0x3b9c73ce
    PhysicalDeviceExternalFenceInfoKhr                       = 0x3b9c7f80
    ExternalFencePropertiesKhr                               = 0x3b9c7f81
    ExportFenceCreateInfoKhr                                 = 0x3b9c8368
    PhysicalDevicePointClippingPropertiesKhr                 = 0x3b9c9308
    RenderPassInputAttachmentAspectCreateInfoKhr             = 0x3b9c9309
    ImageViewUsageCreateInfoKhr                              = 0x3b9c930a
    PipelineTessellationDomainOriginStateCreateInfoKhr       = 0x3b9c930b
    PhysicalDeviceVariablePointersFeaturesKhr                = 0x3b9c9ec0
    PhysicalDeviceVariablePointerFeaturesKhr                 = 0x3b9c9ec0
    MemoryDedicatedRequirementsKhr                           = 0x3b9cba18
    MemoryDedicatedAllocateInfoKhr                           = 0x3b9cba19
    PhysicalDeviceSamplerFilterMinmaxPropertiesExt           = 0x3b9cc5d0
    SamplerReductionModeCreateInfoExt                        = 0x3b9cc5d1
    BufferMemoryRequirementsInfo2Khr                         = 0x3b9d0450
    ImageMemoryRequirementsInfo2Khr                          = 0x3b9d0451
    ImageSparseMemoryRequirementsInfo2Khr                    = 0x3b9d0452
    MemoryRequirements2Khr                                   = 0x3b9d0453
    SparseImageMemoryRequirements2Khr                        = 0x3b9d0454
    ImageFormatListCreateInfoKhr                             = 0x3b9d0838
    SamplerYcbcrConversionCreateInfoKhr                      = 0x3b9d2b60
    SamplerYcbcrConversionInfoKhr                            = 0x3b9d2b61
    BindImagePlaneMemoryInfoKhr                              = 0x3b9d2b62
    ImagePlaneMemoryRequirementsInfoKhr                      = 0x3b9d2b63
    PhysicalDeviceSamplerYcbcrConversionFeaturesKhr          = 0x3b9d2b64
    SamplerYcbcrConversionImageFormatPropertiesKhr           = 0x3b9d2b65
    BindBufferMemoryInfoKhr                                  = 0x3b9d2f48
    BindImageMemoryInfoKhr                                   = 0x3b9d2f49
    DescriptorSetLayoutBindingFlagsCreateInfoExt             = 0x3b9d3ee8
    PhysicalDeviceDescriptorIndexingFeaturesExt              = 0x3b9d3ee9
    PhysicalDeviceDescriptorIndexingPropertiesExt            = 0x3b9d3eea
    DescriptorSetVariableDescriptorCountAllocateInfoExt      = 0x3b9d3eeb
    DescriptorSetVariableDescriptorCountLayoutSupportExt     = 0x3b9d3eec
    BindAccelerationStructureMemoryInfoNv                    = 0x3b9d4e8e
    WriteDescriptorSetAccelerationStructureNv                = 0x3b9d4e8f
    PhysicalDeviceMaintenance3PropertiesKhr                  = 0x3b9d5a40
    DescriptorSetLayoutSupportKhr                            = 0x3b9d5a41
    PhysicalDeviceShaderSubgroupExtendedTypesFeaturesKhr     = 0x3b9d7598
    PhysicalDevice8bitStorageFeaturesKhr                     = 0x3b9d7d68
    PhysicalDeviceShaderAtomicInt64FeaturesKhr               = 0x3b9d8920
    PhysicalDeviceDriverPropertiesKhr                        = 0x3b9dc7a0
    PhysicalDeviceFloatControlsPropertiesKhr                 = 0x3b9dcb88
    PhysicalDeviceDepthStencilResolvePropertiesKhr           = 0x3b9dd358
    SubpassDescriptionDepthStencilResolveKhr                 = 0x3b9dd359
    PhysicalDeviceTimelineSemaphoreFeaturesKhr               = 0x3b9df298
    PhysicalDeviceTimelineSemaphorePropertiesKhr             = 0x3b9df299
    SemaphoreTypeCreateInfoKhr                               = 0x3b9df29a
    TimelineSemaphoreSubmitInfoKhr                           = 0x3b9df29b
    SemaphoreWaitInfoKhr                                     = 0x3b9df29c
    SemaphoreSignalInfoKhr                                   = 0x3b9df29d
    QueryPoolCreateInfoIntel                                 = 0x3b9dfe50
    PhysicalDeviceVulkanMemoryModelFeaturesKhr               = 0x3b9e0238
    PhysicalDeviceScalarBlockLayoutFeaturesExt               = 0x3b9e2948
    PhysicalDeviceSeparateDepthStencilLayoutsFeaturesKhr     = 0x3b9e7768
    AttachmentReferenceStencilLayoutKhr                      = 0x3b9e7769
    AttachmentDescriptionStencilLayoutKhr                    = 0x3b9e776a
    PhysicalDeviceBufferAddressFeaturesExt                   = 0x3b9e8320
    BufferDeviceAddressInfoExt                               = 0x3b9e8321
    ImageStencilUsageCreateInfoExt                           = 0x3b9e8af0
    PhysicalDeviceUniformBufferStandardLayoutFeaturesKhr     = 0x3b9ea648
    PhysicalDeviceBufferDeviceAddressFeaturesKhr             = 0x3b9eb5e8
    BufferDeviceAddressInfoKhr                               = 0x3b9e8321
    BufferOpaqueCaptureAddressCreateInfoKhr                  = 0x3b9eb5ea
    MemoryOpaqueCaptureAddressAllocateInfoKhr                = 0x3b9eb5eb
    DeviceMemoryOpaqueCaptureAddressInfoKhr                  = 0x3b9eb5ec
    PhysicalDeviceHostQueryResetFeaturesExt                  = 0x3b9ec588
    MaxEnum                                                  = 0x7fffffff
}
VkImageLayout :: enum #copy #repr("C") #tag_type(i32) {
    Undefined                                = 0x0
    General                                  = 0x1
    ColorAttachmentOptimal                   = 0x2
    DepthStencilAttachmentOptimal            = 0x3
    DepthStencilReadOnlyOptimal              = 0x4
    ShaderReadOnlyOptimal                    = 0x5
    TransferSrcOptimal                       = 0x6
    TransferDstOptimal                       = 0x7
    Preinitialized                           = 0x8
    DepthReadOnlyStencilAttachmentOptimal    = 0x3b9c9308
    DepthAttachmentStencilReadOnlyOptimal    = 0x3b9c9309
    DepthAttachmentOptimal                   = 0x3b9e7768
    DepthReadOnlyOptimal                     = 0x3b9e7769
    StencilAttachmentOptimal                 = 0x3b9e776a
    StencilReadOnlyOptimal                   = 0x3b9e776b
    PresentSrcKhr                            = 0x3b9acdea
    SharedPresentKhr                         = 0x3b9c7b98
    ShadingRateOptimalNv                     = 0x3b9d4aa3
    FragmentDensityMapOptimalExt             = 0x3b9e1d90
    DepthReadOnlyStencilAttachmentOptimalKhr = 0x3b9c9308
    DepthAttachmentStencilReadOnlyOptimalKhr = 0x3b9c9309
    DepthAttachmentOptimalKhr                = 0x3b9e7768
    DepthReadOnlyOptimalKhr                  = 0x3b9e7769
    StencilAttachmentOptimalKhr              = 0x3b9e776a
    StencilReadOnlyOptimalKhr                = 0x3b9e776b
    MaxEnum                                  = 0x7fffffff
}
VkObjectType :: enum #copy #repr("C") #tag_type(i32) {
    Unknown                       = 0x0
    Instance                      = 0x1
    PhysicalDevice                = 0x2
    Device                        = 0x3
    Queue                         = 0x4
    Semaphore                     = 0x5
    CommandBuffer                 = 0x6
    Fence                         = 0x7
    DeviceMemory                  = 0x8
    Buffer                        = 0x9
    Image                         = 0xa
    Event                         = 0xb
    QueryPool                     = 0xc
    BufferView                    = 0xd
    ImageView                     = 0xe
    ShaderModule                  = 0xf
    PipelineCache                 = 0x10
    PipelineLayout                = 0x11
    RenderPass                    = 0x12
    Pipeline                      = 0x13
    DescriptorSetLayout           = 0x14
    Sampler                       = 0x15
    DescriptorPool                = 0x16
    DescriptorSet                 = 0x17
    Framebuffer                   = 0x18
    CommandPool                   = 0x19
    SamplerYcbcrConversion        = 0x3b9d2b60
    DescriptorUpdateTemplate      = 0x3b9c1608
    SurfaceKhr                    = 0x3b9aca00
    SwapchainKhr                  = 0x3b9acde8
    DisplayKhr                    = 0x3b9ad1d0
    DisplayModeKhr                = 0x3b9ad1d1
    DebugReportCallbackExt        = 0x3b9af4f8
    DebugUtilsMessengerExt        = 0x3b9cbe00
    AccelerationStructureKhr      = 0x3b9d4e88
    ValidationCacheExt            = 0x3b9d3b00
    PerformanceConfigurationIntel = 0x3b9dfe50
    DeferredOperationKhr          = 0x3b9ee0e0
    IndirectCommandsLayoutNv      = 0x3b9f0408
    PrivateDataSlotExt            = 0x3b9f4a58
    DescriptorUpdateTemplateKhr   = 0x3b9c1608
    SamplerYcbcrConversionKhr     = 0x3b9d2b60
    AccelerationStructureNv       = 0x3b9d4e88
    MaxEnum                       = 0x7fffffff
}
VkVendorId :: enum #copy #repr("C") #tag_type(i32) {
    Viv      = 0x10001
    Vsi      = 0x10002
    Kazan    = 0x10003
    Codeplay = 0x10004
    Mesa     = 0x10005
    MaxEnum  = 0x7fffffff
}
VkPipelineCacheHeaderVersion :: enum #copy #repr("C") #tag_type(i32) {
    One     = 0x1
    MaxEnum = 0x7fffffff
}
VkSystemAllocationScope :: enum #copy #repr("C") #tag_type(i32) {
    Command  = 0x0
    Object   = 0x1
    Cache    = 0x2
    Device   = 0x3
    Instance = 0x4
    MaxEnum  = 0x7fffffff
}
VkInternalAllocationType :: enum #copy #repr("C") #tag_type(i32) {
    Executable = 0x0
    MaxEnum    = 0x7fffffff
}
VkFormat :: enum #copy #repr("C") #tag_type(i32) {
    Undefined                               = 0x0
    R4g4UnormPack8                          = 0x1
    R4g4b4a4UnormPack16                     = 0x2
    B4g4r4a4UnormPack16                     = 0x3
    R5g6b5UnormPack16                       = 0x4
    B5g6r5UnormPack16                       = 0x5
    R5g5b5a1UnormPack16                     = 0x6
    B5g5r5a1UnormPack16                     = 0x7
    A1r5g5b5UnormPack16                     = 0x8
    R8Unorm                                 = 0x9
    R8Snorm                                 = 0xa
    R8Uscaled                               = 0xb
    R8Sscaled                               = 0xc
    R8Uint                                  = 0xd
    R8Sint                                  = 0xe
    R8Srgb                                  = 0xf
    R8g8Unorm                               = 0x10
    R8g8Snorm                               = 0x11
    R8g8Uscaled                             = 0x12
    R8g8Sscaled                             = 0x13
    R8g8Uint                                = 0x14
    R8g8Sint                                = 0x15
    R8g8Srgb                                = 0x16
    R8g8b8Unorm                             = 0x17
    R8g8b8Snorm                             = 0x18
    R8g8b8Uscaled                           = 0x19
    R8g8b8Sscaled                           = 0x1a
    R8g8b8Uint                              = 0x1b
    R8g8b8Sint                              = 0x1c
    R8g8b8Srgb                              = 0x1d
    B8g8r8Unorm                             = 0x1e
    B8g8r8Snorm                             = 0x1f
    B8g8r8Uscaled                           = 0x20
    B8g8r8Sscaled                           = 0x21
    B8g8r8Uint                              = 0x22
    B8g8r8Sint                              = 0x23
    B8g8r8Srgb                              = 0x24
    R8g8b8a8Unorm                           = 0x25
    R8g8b8a8Snorm                           = 0x26
    R8g8b8a8Uscaled                         = 0x27
    R8g8b8a8Sscaled                         = 0x28
    R8g8b8a8Uint                            = 0x29
    R8g8b8a8Sint                            = 0x2a
    R8g8b8a8Srgb                            = 0x2b
    B8g8r8a8Unorm                           = 0x2c
    B8g8r8a8Snorm                           = 0x2d
    B8g8r8a8Uscaled                         = 0x2e
    B8g8r8a8Sscaled                         = 0x2f
    B8g8r8a8Uint                            = 0x30
    B8g8r8a8Sint                            = 0x31
    B8g8r8a8Srgb                            = 0x32
    A8b8g8r8UnormPack32                     = 0x33
    A8b8g8r8SnormPack32                     = 0x34
    A8b8g8r8UscaledPack32                   = 0x35
    A8b8g8r8SscaledPack32                   = 0x36
    A8b8g8r8UintPack32                      = 0x37
    A8b8g8r8SintPack32                      = 0x38
    A8b8g8r8SrgbPack32                      = 0x39
    A2r10g10b10UnormPack32                  = 0x3a
    A2r10g10b10SnormPack32                  = 0x3b
    A2r10g10b10UscaledPack32                = 0x3c
    A2r10g10b10SscaledPack32                = 0x3d
    A2r10g10b10UintPack32                   = 0x3e
    A2r10g10b10SintPack32                   = 0x3f
    A2b10g10r10UnormPack32                  = 0x40
    A2b10g10r10SnormPack32                  = 0x41
    A2b10g10r10UscaledPack32                = 0x42
    A2b10g10r10SscaledPack32                = 0x43
    A2b10g10r10UintPack32                   = 0x44
    A2b10g10r10SintPack32                   = 0x45
    R16Unorm                                = 0x46
    R16Snorm                                = 0x47
    R16Uscaled                              = 0x48
    R16Sscaled                              = 0x49
    R16Uint                                 = 0x4a
    R16Sint                                 = 0x4b
    R16Sfloat                               = 0x4c
    R16g16Unorm                             = 0x4d
    R16g16Snorm                             = 0x4e
    R16g16Uscaled                           = 0x4f
    R16g16Sscaled                           = 0x50
    R16g16Uint                              = 0x51
    R16g16Sint                              = 0x52
    R16g16Sfloat                            = 0x53
    R16g16b16Unorm                          = 0x54
    R16g16b16Snorm                          = 0x55
    R16g16b16Uscaled                        = 0x56
    R16g16b16Sscaled                        = 0x57
    R16g16b16Uint                           = 0x58
    R16g16b16Sint                           = 0x59
    R16g16b16Sfloat                         = 0x5a
    R16g16b16a16Unorm                       = 0x5b
    R16g16b16a16Snorm                       = 0x5c
    R16g16b16a16Uscaled                     = 0x5d
    R16g16b16a16Sscaled                     = 0x5e
    R16g16b16a16Uint                        = 0x5f
    R16g16b16a16Sint                        = 0x60
    R16g16b16a16Sfloat                      = 0x61
    R32Uint                                 = 0x62
    R32Sint                                 = 0x63
    R32Sfloat                               = 0x64
    R32g32Uint                              = 0x65
    R32g32Sint                              = 0x66
    R32g32Sfloat                            = 0x67
    R32g32b32Uint                           = 0x68
    R32g32b32Sint                           = 0x69
    R32g32b32Sfloat                         = 0x6a
    R32g32b32a32Uint                        = 0x6b
    R32g32b32a32Sint                        = 0x6c
    R32g32b32a32Sfloat                      = 0x6d
    R64Uint                                 = 0x6e
    R64Sint                                 = 0x6f
    R64Sfloat                               = 0x70
    R64g64Uint                              = 0x71
    R64g64Sint                              = 0x72
    R64g64Sfloat                            = 0x73
    R64g64b64Uint                           = 0x74
    R64g64b64Sint                           = 0x75
    R64g64b64Sfloat                         = 0x76
    R64g64b64a64Uint                        = 0x77
    R64g64b64a64Sint                        = 0x78
    R64g64b64a64Sfloat                      = 0x79
    B10g11r11UfloatPack32                   = 0x7a
    E5b9g9r9UfloatPack32                    = 0x7b
    D16Unorm                                = 0x7c
    X8D24UnormPack32                        = 0x7d
    D32Sfloat                               = 0x7e
    S8Uint                                  = 0x7f
    D16UnormS8Uint                          = 0x80
    D24UnormS8Uint                          = 0x81
    D32SfloatS8Uint                         = 0x82
    Bc1RgbUnormBlock                        = 0x83
    Bc1RgbSrgbBlock                         = 0x84
    Bc1RgbaUnormBlock                       = 0x85
    Bc1RgbaSrgbBlock                        = 0x86
    Bc2UnormBlock                           = 0x87
    Bc2SrgbBlock                            = 0x88
    Bc3UnormBlock                           = 0x89
    Bc3SrgbBlock                            = 0x8a
    Bc4UnormBlock                           = 0x8b
    Bc4SnormBlock                           = 0x8c
    Bc5UnormBlock                           = 0x8d
    Bc5SnormBlock                           = 0x8e
    Bc6hUfloatBlock                         = 0x8f
    Bc6hSfloatBlock                         = 0x90
    Bc7UnormBlock                           = 0x91
    Bc7SrgbBlock                            = 0x92
    Etc2R8g8b8UnormBlock                    = 0x93
    Etc2R8g8b8SrgbBlock                     = 0x94
    Etc2R8g8b8a1UnormBlock                  = 0x95
    Etc2R8g8b8a1SrgbBlock                   = 0x96
    Etc2R8g8b8a8UnormBlock                  = 0x97
    Etc2R8g8b8a8SrgbBlock                   = 0x98
    EacR11UnormBlock                        = 0x99
    EacR11SnormBlock                        = 0x9a
    EacR11g11UnormBlock                     = 0x9b
    EacR11g11SnormBlock                     = 0x9c
    Astc4x4UnormBlock                       = 0x9d
    Astc4x4SrgbBlock                        = 0x9e
    Astc5x4UnormBlock                       = 0x9f
    Astc5x4SrgbBlock                        = 0xa0
    Astc5x5UnormBlock                       = 0xa1
    Astc5x5SrgbBlock                        = 0xa2
    Astc6x5UnormBlock                       = 0xa3
    Astc6x5SrgbBlock                        = 0xa4
    Astc6x6UnormBlock                       = 0xa5
    Astc6x6SrgbBlock                        = 0xa6
    Astc8x5UnormBlock                       = 0xa7
    Astc8x5SrgbBlock                        = 0xa8
    Astc8x6UnormBlock                       = 0xa9
    Astc8x6SrgbBlock                        = 0xaa
    Astc8x8UnormBlock                       = 0xab
    Astc8x8SrgbBlock                        = 0xac
    Astc10x5UnormBlock                      = 0xad
    Astc10x5SrgbBlock                       = 0xae
    Astc10x6UnormBlock                      = 0xaf
    Astc10x6SrgbBlock                       = 0xb0
    Astc10x8UnormBlock                      = 0xb1
    Astc10x8SrgbBlock                       = 0xb2
    Astc10x10UnormBlock                     = 0xb3
    Astc10x10SrgbBlock                      = 0xb4
    Astc12x10UnormBlock                     = 0xb5
    Astc12x10SrgbBlock                      = 0xb6
    Astc12x12UnormBlock                     = 0xb7
    Astc12x12SrgbBlock                      = 0xb8
    G8b8g8r8422Unorm                        = 0x3b9d2b60
    B8g8r8g8422Unorm                        = 0x3b9d2b61
    G8B8R83plane420Unorm                    = 0x3b9d2b62
    G8B8r82plane420Unorm                    = 0x3b9d2b63
    G8B8R83plane422Unorm                    = 0x3b9d2b64
    G8B8r82plane422Unorm                    = 0x3b9d2b65
    G8B8R83plane444Unorm                    = 0x3b9d2b66
    R10x6UnormPack16                        = 0x3b9d2b67
    R10x6g10x6Unorm2pack16                  = 0x3b9d2b68
    R10x6g10x6b10x6a10x6Unorm4pack16        = 0x3b9d2b69
    G10x6b10x6g10x6r10x6422Unorm4pack16     = 0x3b9d2b6a
    B10x6g10x6r10x6g10x6422Unorm4pack16     = 0x3b9d2b6b
    G10x6B10x6R10x63plane420Unorm3pack16    = 0x3b9d2b6c
    G10x6B10x6r10x62plane420Unorm3pack16    = 0x3b9d2b6d
    G10x6B10x6R10x63plane422Unorm3pack16    = 0x3b9d2b6e
    G10x6B10x6r10x62plane422Unorm3pack16    = 0x3b9d2b6f
    G10x6B10x6R10x63plane444Unorm3pack16    = 0x3b9d2b70
    R12x4UnormPack16                        = 0x3b9d2b71
    R12x4g12x4Unorm2pack16                  = 0x3b9d2b72
    R12x4g12x4b12x4a12x4Unorm4pack16        = 0x3b9d2b73
    G12x4b12x4g12x4r12x4422Unorm4pack16     = 0x3b9d2b74
    B12x4g12x4r12x4g12x4422Unorm4pack16     = 0x3b9d2b75
    G12x4B12x4R12x43plane420Unorm3pack16    = 0x3b9d2b76
    G12x4B12x4r12x42plane420Unorm3pack16    = 0x3b9d2b77
    G12x4B12x4R12x43plane422Unorm3pack16    = 0x3b9d2b78
    G12x4B12x4r12x42plane422Unorm3pack16    = 0x3b9d2b79
    G12x4B12x4R12x43plane444Unorm3pack16    = 0x3b9d2b7a
    G16b16g16r16422Unorm                    = 0x3b9d2b7b
    B16g16r16g16422Unorm                    = 0x3b9d2b7c
    G16B16R163plane420Unorm                 = 0x3b9d2b7d
    G16B16r162plane420Unorm                 = 0x3b9d2b7e
    G16B16R163plane422Unorm                 = 0x3b9d2b7f
    G16B16r162plane422Unorm                 = 0x3b9d2b80
    G16B16R163plane444Unorm                 = 0x3b9d2b81
    Pvrtc12bppUnormBlockImg                 = 0x3b9b9cf0
    Pvrtc14bppUnormBlockImg                 = 0x3b9b9cf1
    Pvrtc22bppUnormBlockImg                 = 0x3b9b9cf2
    Pvrtc24bppUnormBlockImg                 = 0x3b9b9cf3
    Pvrtc12bppSrgbBlockImg                  = 0x3b9b9cf4
    Pvrtc14bppSrgbBlockImg                  = 0x3b9b9cf5
    Pvrtc22bppSrgbBlockImg                  = 0x3b9b9cf6
    Pvrtc24bppSrgbBlockImg                  = 0x3b9b9cf7
    Astc4x4SfloatBlockExt                   = 0x3b9bcbd0
    Astc5x4SfloatBlockExt                   = 0x3b9bcbd1
    Astc5x5SfloatBlockExt                   = 0x3b9bcbd2
    Astc6x5SfloatBlockExt                   = 0x3b9bcbd3
    Astc6x6SfloatBlockExt                   = 0x3b9bcbd4
    Astc8x5SfloatBlockExt                   = 0x3b9bcbd5
    Astc8x6SfloatBlockExt                   = 0x3b9bcbd6
    Astc8x8SfloatBlockExt                   = 0x3b9bcbd7
    Astc10x5SfloatBlockExt                  = 0x3b9bcbd8
    Astc10x6SfloatBlockExt                  = 0x3b9bcbd9
    Astc10x8SfloatBlockExt                  = 0x3b9bcbda
    Astc10x10SfloatBlockExt                 = 0x3b9bcbdb
    Astc12x10SfloatBlockExt                 = 0x3b9bcbdc
    Astc12x12SfloatBlockExt                 = 0x3b9bcbdd
    G8b8g8r8422UnormKhr                     = 0x3b9d2b60
    B8g8r8g8422UnormKhr                     = 0x3b9d2b61
    G8B8R83plane420UnormKhr                 = 0x3b9d2b62
    G8B8r82plane420UnormKhr                 = 0x3b9d2b63
    G8B8R83plane422UnormKhr                 = 0x3b9d2b64
    G8B8r82plane422UnormKhr                 = 0x3b9d2b65
    G8B8R83plane444UnormKhr                 = 0x3b9d2b66
    R10x6UnormPack16Khr                     = 0x3b9d2b67
    R10x6g10x6Unorm2pack16Khr               = 0x3b9d2b68
    R10x6g10x6b10x6a10x6Unorm4pack16Khr     = 0x3b9d2b69
    G10x6b10x6g10x6r10x6422Unorm4pack16Khr  = 0x3b9d2b6a
    B10x6g10x6r10x6g10x6422Unorm4pack16Khr  = 0x3b9d2b6b
    G10x6B10x6R10x63plane420Unorm3pack16Khr = 0x3b9d2b6c
    G10x6B10x6r10x62plane420Unorm3pack16Khr = 0x3b9d2b6d
    G10x6B10x6R10x63plane422Unorm3pack16Khr = 0x3b9d2b6e
    G10x6B10x6r10x62plane422Unorm3pack16Khr = 0x3b9d2b6f
    G10x6B10x6R10x63plane444Unorm3pack16Khr = 0x3b9d2b70
    R12x4UnormPack16Khr                     = 0x3b9d2b71
    R12x4g12x4Unorm2pack16Khr               = 0x3b9d2b72
    R12x4g12x4b12x4a12x4Unorm4pack16Khr     = 0x3b9d2b73
    G12x4b12x4g12x4r12x4422Unorm4pack16Khr  = 0x3b9d2b74
    B12x4g12x4r12x4g12x4422Unorm4pack16Khr  = 0x3b9d2b75
    G12x4B12x4R12x43plane420Unorm3pack16Khr = 0x3b9d2b76
    G12x4B12x4r12x42plane420Unorm3pack16Khr = 0x3b9d2b77
    G12x4B12x4R12x43plane422Unorm3pack16Khr = 0x3b9d2b78
    G12x4B12x4r12x42plane422Unorm3pack16Khr = 0x3b9d2b79
    G12x4B12x4R12x43plane444Unorm3pack16Khr = 0x3b9d2b7a
    G16b16g16r16422UnormKhr                 = 0x3b9d2b7b
    B16g16r16g16422UnormKhr                 = 0x3b9d2b7c
    G16B16R163plane420UnormKhr              = 0x3b9d2b7d
    G16B16r162plane420UnormKhr              = 0x3b9d2b7e
    G16B16R163plane422UnormKhr              = 0x3b9d2b7f
    G16B16r162plane422UnormKhr              = 0x3b9d2b80
    G16B16R163plane444UnormKhr              = 0x3b9d2b81
    MaxEnum                                 = 0x7fffffff
}
VkImageTiling :: enum #copy #repr("C") #tag_type(i32) {
    Optimal              = 0x0
    Linear               = 0x1
    DrmFormatModifierExt = 0x3b9d3330
    MaxEnum              = 0x7fffffff
}
VkImageType :: enum #copy #repr("C") #tag_type(i32) {
    _1d     = 0x0
    _2d     = 0x1
    _3d     = 0x2
    MaxEnum = 0x7fffffff
}
VkPhysicalDeviceType :: enum #copy #repr("C") #tag_type(i32) {
    Other         = 0x0
    IntegratedGpu = 0x1
    DiscreteGpu   = 0x2
    VirtualGpu    = 0x3
    Cpu           = 0x4
    MaxEnum       = 0x7fffffff
}
VkQueryType :: enum #copy #repr("C") #tag_type(i32) {
    Occlusion                                 = 0x0
    PipelineStatistics                        = 0x1
    Timestamp                                 = 0x2
    TransformFeedbackStreamExt                = 0x3b9b3764
    PerformanceQueryKhr                       = 0x3b9c8f20
    AccelerationStructureCompactedSizeKhr     = 0x3b9d4e88
    AccelerationStructureSerializationSizeKhr = 0x3b9d13f0
    PerformanceQueryIntel                     = 0x3b9dfe50
    AccelerationStructureCompactedSizeNv      = 0x3b9d4e88
    MaxEnum                                   = 0x7fffffff
}
VkSharingMode :: enum #copy #repr("C") #tag_type(i32) {
    Exclusive  = 0x0
    Concurrent = 0x1
    MaxEnum    = 0x7fffffff
}
VkComponentSwizzle :: enum #copy #repr("C") #tag_type(i32) {
    Identity = 0x0
    Zero     = 0x1
    One      = 0x2
    R        = 0x3
    G        = 0x4
    B        = 0x5
    A        = 0x6
    MaxEnum  = 0x7fffffff
}
VkImageViewType :: enum #copy #repr("C") #tag_type(i32) {
    _1d       = 0x0
    _2d       = 0x1
    _3d       = 0x2
    Cube      = 0x3
    _1dArray  = 0x4
    _2dArray  = 0x5
    CubeArray = 0x6
    MaxEnum   = 0x7fffffff
}
VkBlendFactor :: enum #copy #repr("C") #tag_type(i32) {
    Zero                  = 0x0
    One                   = 0x1
    SrcColor              = 0x2
    OneMinusSrcColor      = 0x3
    DstColor              = 0x4
    OneMinusDstColor      = 0x5
    SrcAlpha              = 0x6
    OneMinusSrcAlpha      = 0x7
    DstAlpha              = 0x8
    OneMinusDstAlpha      = 0x9
    ConstantColor         = 0xa
    OneMinusConstantColor = 0xb
    ConstantAlpha         = 0xc
    OneMinusConstantAlpha = 0xd
    SrcAlphaSaturate      = 0xe
    Src1Color             = 0xf
    OneMinusSrc1Color     = 0x10
    Src1Alpha             = 0x11
    OneMinusSrc1Alpha     = 0x12
    MaxEnum               = 0x7fffffff
}
VkBlendOp :: enum #copy #repr("C") #tag_type(i32) {
    Add                 = 0x0
    Subtract            = 0x1
    ReverseSubtract     = 0x2
    Min                 = 0x3
    Max                 = 0x4
    ZeroExt             = 0x3b9d0c20
    SrcExt              = 0x3b9d0c21
    DstExt              = 0x3b9d0c22
    SrcOverExt          = 0x3b9d0c23
    DstOverExt          = 0x3b9d0c24
    SrcInExt            = 0x3b9d0c25
    DstInExt            = 0x3b9d0c26
    SrcOutExt           = 0x3b9d0c27
    DstOutExt           = 0x3b9d0c28
    SrcAtopExt          = 0x3b9d0c29
    DstAtopExt          = 0x3b9d0c2a
    XorExt              = 0x3b9d0c2b
    MultiplyExt         = 0x3b9d0c2c
    ScreenExt           = 0x3b9d0c2d
    OverlayExt          = 0x3b9d0c2e
    DarkenExt           = 0x3b9d0c2f
    LightenExt          = 0x3b9d0c30
    ColordodgeExt       = 0x3b9d0c31
    ColorburnExt        = 0x3b9d0c32
    HardlightExt        = 0x3b9d0c33
    SoftlightExt        = 0x3b9d0c34
    DifferenceExt       = 0x3b9d0c35
    ExclusionExt        = 0x3b9d0c36
    InvertExt           = 0x3b9d0c37
    InvertRgbExt        = 0x3b9d0c38
    LineardodgeExt      = 0x3b9d0c39
    LinearburnExt       = 0x3b9d0c3a
    VividlightExt       = 0x3b9d0c3b
    LinearlightExt      = 0x3b9d0c3c
    PinlightExt         = 0x3b9d0c3d
    HardmixExt          = 0x3b9d0c3e
    HslHueExt           = 0x3b9d0c3f
    HslSaturationExt    = 0x3b9d0c40
    HslColorExt         = 0x3b9d0c41
    HslLuminosityExt    = 0x3b9d0c42
    PlusExt             = 0x3b9d0c43
    PlusClampedExt      = 0x3b9d0c44
    PlusClampedAlphaExt = 0x3b9d0c45
    PlusDarkerExt       = 0x3b9d0c46
    MinusExt            = 0x3b9d0c47
    MinusClampedExt     = 0x3b9d0c48
    ContrastExt         = 0x3b9d0c49
    InvertOvgExt        = 0x3b9d0c4a
    RedExt              = 0x3b9d0c4b
    GreenExt            = 0x3b9d0c4c
    BlueExt             = 0x3b9d0c4d
    MaxEnum             = 0x7fffffff
}
VkCompareOp :: enum #copy #repr("C") #tag_type(i32) {
    Never          = 0x0
    Less           = 0x1
    Equal          = 0x2
    LessOrEqual    = 0x3
    Greater        = 0x4
    NotEqual       = 0x5
    GreaterOrEqual = 0x6
    Always         = 0x7
    MaxEnum        = 0x7fffffff
}
VkDynamicState :: enum #copy #repr("C") #tag_type(i32) {
    Viewport                     = 0x0
    Scissor                      = 0x1
    LineWidth                    = 0x2
    DepthBias                    = 0x3
    BlendConstants               = 0x4
    DepthBounds                  = 0x5
    StencilCompareMask           = 0x6
    StencilWriteMask             = 0x7
    StencilReference             = 0x8
    ViewportWScalingNv           = 0x3b9c1dd8
    DiscardRectangleExt          = 0x3b9c4cb8
    SampleLocationsExt           = 0x3b9cf898
    ViewportShadingRatePaletteNv = 0x3b9d4aa4
    ViewportCoarseSampleOrderNv  = 0x3b9d4aa6
    ExclusiveScissorNv           = 0x3b9deac9
    LineStippleExt               = 0x3b9ebdb8
    CullModeExt                  = 0x3b9edcf8
    FrontFaceExt                 = 0x3b9edcf9
    PrimitiveTopologyExt         = 0x3b9edcfa
    ViewportWithCountExt         = 0x3b9edcfb
    ScissorWithCountExt          = 0x3b9edcfc
    VertexInputBindingStrideExt  = 0x3b9edcfd
    DepthTestEnableExt           = 0x3b9edcfe
    DepthWriteEnableExt          = 0x3b9edcff
    DepthCompareOpExt            = 0x3b9edd00
    DepthBoundsTestEnableExt     = 0x3b9edd01
    StencilTestEnableExt         = 0x3b9edd02
    StencilOpExt                 = 0x3b9edd03
    MaxEnum                      = 0x7fffffff
}
VkFrontFace :: enum #copy #repr("C") #tag_type(i32) {
    CounterClockwise = 0x0
    Clockwise        = 0x1
    MaxEnum          = 0x7fffffff
}
VkVertexInputRate :: enum #copy #repr("C") #tag_type(i32) {
    Vertex   = 0x0
    Instance = 0x1
    MaxEnum  = 0x7fffffff
}
VkPrimitiveTopology :: enum #copy #repr("C") #tag_type(i32) {
    PointList                  = 0x0
    LineList                   = 0x1
    LineStrip                  = 0x2
    TriangleList               = 0x3
    TriangleStrip              = 0x4
    TriangleFan                = 0x5
    LineListWithAdjacency      = 0x6
    LineStripWithAdjacency     = 0x7
    TriangleListWithAdjacency  = 0x8
    TriangleStripWithAdjacency = 0x9
    PatchList                  = 0xa
    MaxEnum                    = 0x7fffffff
}
VkPolygonMode :: enum #copy #repr("C") #tag_type(i32) {
    Fill            = 0x0
    Line            = 0x1
    Point           = 0x2
    FillRectangleNv = 0x3b9d1fa8
    MaxEnum         = 0x7fffffff
}
VkStencilOp :: enum #copy #repr("C") #tag_type(i32) {
    Keep              = 0x0
    Zero              = 0x1
    Replace           = 0x2
    IncrementAndClamp = 0x3
    DecrementAndClamp = 0x4
    Invert            = 0x5
    IncrementAndWrap  = 0x6
    DecrementAndWrap  = 0x7
    MaxEnum           = 0x7fffffff
}
VkLogicOp :: enum #copy #repr("C") #tag_type(i32) {
    Clear        = 0x0
    And          = 0x1
    AndReverse   = 0x2
    Copy         = 0x3
    AndInverted  = 0x4
    NoOp         = 0x5
    Xor          = 0x6
    Or           = 0x7
    Nor          = 0x8
    Equivalent   = 0x9
    Invert       = 0xa
    OrReverse    = 0xb
    CopyInverted = 0xc
    OrInverted   = 0xd
    Nand         = 0xe
    Set          = 0xf
    MaxEnum      = 0x7fffffff
}
VkBorderColor :: enum #copy #repr("C") #tag_type(i32) {
    FloatTransparentBlack = 0x0
    IntTransparentBlack   = 0x1
    FloatOpaqueBlack      = 0x2
    IntOpaqueBlack        = 0x3
    FloatOpaqueWhite      = 0x4
    IntOpaqueWhite        = 0x5
    FloatCustomExt        = 0x3b9f2b1b
    IntCustomExt          = 0x3b9f2b1c
    MaxEnum               = 0x7fffffff
}
VkFilter :: enum #copy #repr("C") #tag_type(i32) {
    Nearest  = 0x0
    Linear   = 0x1
    CubicImg = 0x3b9b0498
    CubicExt = 0x3b9b0498
    MaxEnum  = 0x7fffffff
}
VkSamplerAddressMode :: enum #copy #repr("C") #tag_type(i32) {
    Repeat               = 0x0
    MirroredRepeat       = 0x1
    ClampToEdge          = 0x2
    ClampToBorder        = 0x3
    MirrorClampToEdge    = 0x4
    MirrorClampToEdgeKhr = 0x4
    MaxEnum              = 0x7fffffff
}
VkSamplerMipmapMode :: enum #copy #repr("C") #tag_type(i32) {
    Nearest = 0x0
    Linear  = 0x1
    MaxEnum = 0x7fffffff
}
VkDescriptorType :: enum #copy #repr("C") #tag_type(i32) {
    Sampler                  = 0x0
    CombinedImageSampler     = 0x1
    SampledImage             = 0x2
    StorageImage             = 0x3
    UniformTexelBuffer       = 0x4
    StorageTexelBuffer       = 0x5
    UniformBuffer            = 0x6
    StorageBuffer            = 0x7
    UniformBufferDynamic     = 0x8
    StorageBufferDynamic     = 0x9
    InputAttachment          = 0xa
    InlineUniformBlockExt    = 0x3b9ce510
    AccelerationStructureKhr = 0x3b9d4e88
    AccelerationStructureNv  = 0x3b9d4e88
    MaxEnum                  = 0x7fffffff
}
VkAttachmentLoadOp :: enum #copy #repr("C") #tag_type(i32) {
    Load     = 0x0
    Clear    = 0x1
    DontCare = 0x2
    MaxEnum  = 0x7fffffff
}
VkAttachmentStoreOp :: enum #copy #repr("C") #tag_type(i32) {
    Store    = 0x0
    DontCare = 0x1
    NoneQcom = 0x3b9f61c8
    MaxEnum  = 0x7fffffff
}
VkPipelineBindPoint :: enum #copy #repr("C") #tag_type(i32) {
    Graphics      = 0x0
    Compute       = 0x1
    RayTracingKhr = 0x3b9d4e88
    RayTracingNv  = 0x3b9d4e88
    MaxEnum       = 0x7fffffff
}
VkCommandBufferLevel :: enum #copy #repr("C") #tag_type(i32) {
    Primary   = 0x0
    Secondary = 0x1
    MaxEnum   = 0x7fffffff
}
VkIndexType :: enum #copy #repr("C") #tag_type(i32) {
    Uint16   = 0x0
    Uint32   = 0x1
    NoneKhr  = 0x3b9d4e88
    Uint8Ext = 0x3b9ed528
    NoneNv   = 0x3b9d4e88
    MaxEnum  = 0x7fffffff
}
VkSubpassContents :: enum #copy #repr("C") #tag_type(i32) {
    Inline                  = 0x0
    SecondaryCommandBuffers = 0x1
    MaxEnum                 = 0x7fffffff
}
VkAccessFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    IndirectCommandReadBit               = 0x1
    IndexReadBit                         = 0x2
    VertexAttributeReadBit               = 0x4
    UniformReadBit                       = 0x8
    InputAttachmentReadBit               = 0x10
    ShaderReadBit                        = 0x20
    ShaderWriteBit                       = 0x40
    ColorAttachmentReadBit               = 0x80
    ColorAttachmentWriteBit              = 0x100
    DepthStencilAttachmentReadBit        = 0x200
    DepthStencilAttachmentWriteBit       = 0x400
    TransferReadBit                      = 0x800
    TransferWriteBit                     = 0x1000
    HostReadBit                          = 0x2000
    HostWriteBit                         = 0x4000
    MemoryReadBit                        = 0x8000
    MemoryWriteBit                       = 0x10000
    TransformFeedbackWriteBitExt         = 0x2000000
    TransformFeedbackCounterReadBitExt   = 0x4000000
    TransformFeedbackCounterWriteBitExt  = 0x8000000
    ConditionalRenderingReadBitExt       = 0x100000
    ColorAttachmentReadNoncoherentBitExt = 0x80000
    AccelerationStructureReadBitKhr      = 0x200000
    AccelerationStructureWriteBitKhr     = 0x400000
    ShadingRateImageReadBitNv            = 0x800000
    ragmentDensityMapReadBitExt          = 0x1000000
    CommandPreprocessReadBitNv           = 0x20000
    CommandPreprocessWriteBitNv          = 0x40000
    AccelerationStructureReadBitNv       = 0x200000
    AccelerationStructureWriteBitNv      = 0x400000
    MaxEnum                              = 0x7fffffff
}
VkImageAspectFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ColorBit           = 0x1
    DepthBit           = 0x2
    StencilBit         = 0x4
    MetadataBit        = 0x8
    Plane0Bit          = 0x10
    Plane1Bit          = 0x20
    Plane2Bit          = 0x40
    MemoryPlane0BitExt = 0x80
    MemoryPlane1BitExt = 0x100
    MemoryPlane2BitExt = 0x200
    MemoryPlane3BitExt = 0x400
    Plane0BitKhr       = 0x10
    Plane1BitKhr       = 0x20
    Plane2BitKhr       = 0x40
    MaxEnum            = 0x7fffffff
}
VkFormatFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SampledImageBit                                                        = 0x1
    StorageImageBit                                                        = 0x2
    StorageImageAtomicBit                                                  = 0x4
    UniformTexelBufferBit                                                  = 0x8
    StorageTexelBufferBit                                                  = 0x10
    StorageTexelBufferAtomicBit                                            = 0x20
    VertexBufferBit                                                        = 0x40
    ColorAttachmentBit                                                     = 0x80
    ColorAttachmentBlendBit                                                = 0x100
    DepthStencilAttachmentBit                                              = 0x200
    BlitSrcBit                                                             = 0x400
    BlitDstBit                                                             = 0x800
    SampledImageFilterLinearBit                                            = 0x1000
    TransferSrcBit                                                         = 0x4000
    TransferDstBit                                                         = 0x8000
    MidpointChromaSamplesBit                                               = 0x20000
    SampledImageYcbcrConversionLinearFilterBit                             = 0x40000
    SampledImageYcbcrConversionSeparateReconstructionFilterBit             = 0x80000
    SampledImageYcbcrConversionChromaReconstructionExplicitBit             = 0x100000
    SampledImageYcbcrConversionChromaReconstructionExplicitForceableBit    = 0x200000
    DisjointBit                                                            = 0x400000
    CositedChromaSamplesBit                                                = 0x800000
    SampledImageFilterMinmaxBit                                            = 0x10000
    SampledImageFilterCubicBitImg                                          = 0x2000
    AccelerationStructureVertexBufferBitKhr                                = 0x20000000
    ragmentDensityMapBitExt                                                = 0x1000000
    TransferSrcBitKhr                                                      = 0x4000
    TransferDstBitKhr                                                      = 0x8000
    SampledImageFilterMinmaxBitExt                                         = 0x10000
    MidpointChromaSamplesBitKhr                                            = 0x20000
    SampledImageYcbcrConversionLinearFilterBitKhr                          = 0x40000
    SampledImageYcbcrConversionSeparateReconstructionFilterBitKhr          = 0x80000
    SampledImageYcbcrConversionChromaReconstructionExplicitBitKhr          = 0x100000
    SampledImageYcbcrConversionChromaReconstructionExplicitForceableBitKhr = 0x200000
    DisjointBitKhr                                                         = 0x400000
    CositedChromaSamplesBitKhr                                             = 0x800000
    SampledImageFilterCubicBitExt                                          = 0x2000
    MaxEnum                                                                = 0x7fffffff
}
VkImageCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SparseBindingBit                     = 0x1
    SparseResidencyBit                   = 0x2
    SparseAliasedBit                     = 0x4
    MutableFormatBit                     = 0x8
    CubeCompatibleBit                    = 0x10
    AliasBit                             = 0x400
    SplitInstanceBindRegionsBit          = 0x40
    _2dArrayCompatibleBit                = 0x20
    BlockTexelViewCompatibleBit          = 0x80
    ExtendedUsageBit                     = 0x100
    ProtectedBit                         = 0x800
    DisjointBit                          = 0x200
    CornerSampledBitNv                   = 0x2000
    SampleLocationsCompatibleDepthBitExt = 0x1000
    SubsampledBitExt                     = 0x4000
    SplitInstanceBindRegionsBitKhr       = 0x40
    _2dArrayCompatibleBitKhr             = 0x20
    BlockTexelViewCompatibleBitKhr       = 0x80
    ExtendedUsageBitKhr                  = 0x100
    DisjointBitKhr                       = 0x200
    AliasBitKhr                          = 0x400
    MaxEnum                              = 0x7fffffff
}
VkSampleCountFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    _1Bit   = 0x1
    _2Bit   = 0x2
    _4Bit   = 0x4
    _8Bit   = 0x8
    _16Bit  = 0x10
    _32Bit  = 0x20
    _64Bit  = 0x40
    MaxEnum = 0x7fffffff
}
VkImageUsageFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TransferSrcBit            = 0x1
    TransferDstBit            = 0x2
    SampledBit                = 0x4
    StorageBit                = 0x8
    ColorAttachmentBit        = 0x10
    DepthStencilAttachmentBit = 0x20
    TransientAttachmentBit    = 0x40
    InputAttachmentBit        = 0x80
    ShadingRateImageBitNv     = 0x100
    ragmentDensityMapBitExt   = 0x200
    MaxEnum                   = 0x7fffffff
}
VkMemoryHeapFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    DeviceLocalBit      = 0x1
    MultiInstanceBit    = 0x2
    MultiInstanceBitKhr = 0x2
    MaxEnum             = 0x7fffffff
}
VkMemoryPropertyFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    DeviceLocalBit       = 0x1
    HostVisibleBit       = 0x2
    HostCoherentBit      = 0x4
    HostCachedBit        = 0x8
    LazilyAllocatedBit   = 0x10
    ProtectedBit         = 0x20
    DeviceCoherentBitAmd = 0x40
    DeviceUncachedBitAmd = 0x80
    MaxEnum              = 0x7fffffff
}
VkQueueFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    GraphicsBit      = 0x1
    ComputeBit       = 0x2
    TransferBit      = 0x4
    SparseBindingBit = 0x8
    ProtectedBit     = 0x10
    MaxEnum          = 0x7fffffff
}
VkDeviceQueueCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ProtectedBit = 0x1
    MaxEnum      = 0x7fffffff
}
VkPipelineStageFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TopOfPipeBit                     = 0x1
    DrawIndirectBit                  = 0x2
    VertexInputBit                   = 0x4
    VertexShaderBit                  = 0x8
    TessellationControlShaderBit     = 0x10
    TessellationEvaluationShaderBit  = 0x20
    GeometryShaderBit                = 0x40
    ragmentShaderBit                 = 0x80
    EarlyFragmentTestsBit            = 0x100
    LateFragmentTestsBit             = 0x200
    ColorAttachmentOutputBit         = 0x400
    ComputeShaderBit                 = 0x800
    TransferBit                      = 0x1000
    BottomOfPipeBit                  = 0x2000
    HostBit                          = 0x4000
    AllGraphicsBit                   = 0x8000
    AllCommandsBit                   = 0x10000
    TransformFeedbackBitExt          = 0x1000000
    ConditionalRenderingBitExt       = 0x40000
    RayTracingShaderBitKhr           = 0x200000
    AccelerationStructureBuildBitKhr = 0x2000000
    ShadingRateImageBitNv            = 0x400000
    TaskShaderBitNv                  = 0x80000
    MeshShaderBitNv                  = 0x100000
    ragmentDensityProcessBitExt      = 0x800000
    CommandPreprocessBitNv           = 0x20000
    RayTracingShaderBitNv            = 0x200000
    AccelerationStructureBuildBitNv  = 0x2000000
    MaxEnum                          = 0x7fffffff
}
VkSparseMemoryBindFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    MetadataBit = 0x1
    MaxEnum     = 0x7fffffff
}
VkSparseImageFormatFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SingleMiptailBit        = 0x1
    AlignedMipSizeBit       = 0x2
    NonstandardBlockSizeBit = 0x4
    MaxEnum                 = 0x7fffffff
}
VkFenceCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SignaledBit = 0x1
    MaxEnum     = 0x7fffffff
}
VkQueryPipelineStatisticFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    InputAssemblyVerticesBit                   = 0x1
    InputAssemblyPrimitivesBit                 = 0x2
    VertexShaderInvocationsBit                 = 0x4
    GeometryShaderInvocationsBit               = 0x8
    GeometryShaderPrimitivesBit                = 0x10
    ClippingInvocationsBit                     = 0x20
    ClippingPrimitivesBit                      = 0x40
    ragmentShaderInvocationsBit                = 0x80
    TessellationControlShaderPatchesBit        = 0x100
    TessellationEvaluationShaderInvocationsBit = 0x200
    ComputeShaderInvocationsBit                = 0x400
    MaxEnum                                    = 0x7fffffff
}
VkQueryResultFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    _64Bit              = 0x1
    WaitBit             = 0x2
    WithAvailabilityBit = 0x4
    PartialBit          = 0x8
    MaxEnum             = 0x7fffffff
}
VkBufferCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SparseBindingBit                 = 0x1
    SparseResidencyBit               = 0x2
    SparseAliasedBit                 = 0x4
    ProtectedBit                     = 0x8
    DeviceAddressCaptureReplayBit    = 0x10
    DeviceAddressCaptureReplayBitExt = 0x10
    DeviceAddressCaptureReplayBitKhr = 0x10
    MaxEnum                          = 0x7fffffff
}
VkBufferUsageFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TransferSrcBit                       = 0x1
    TransferDstBit                       = 0x2
    UniformTexelBufferBit                = 0x4
    StorageTexelBufferBit                = 0x8
    UniformBufferBit                     = 0x10
    StorageBufferBit                     = 0x20
    IndexBufferBit                       = 0x40
    VertexBufferBit                      = 0x80
    IndirectBufferBit                    = 0x100
    ShaderDeviceAddressBit               = 0x20000
    TransformFeedbackBufferBitExt        = 0x800
    TransformFeedbackCounterBufferBitExt = 0x1000
    ConditionalRenderingBitExt           = 0x200
    RayTracingBitKhr                     = 0x400
    RayTracingBitNv                      = 0x400
    ShaderDeviceAddressBitExt            = 0x20000
    ShaderDeviceAddressBitKhr            = 0x20000
    MaxEnum                              = 0x7fffffff
}
VkImageViewCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ragmentDensityMapDynamicBitExt  = 0x1
    ragmentDensityMapDeferredBitExt = 0x2
    MaxEnum                         = 0x7fffffff
}
VkShaderModuleCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    MaxEnum = 0x7fffffff
}
VkPipelineCacheCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ExternallySynchronizedBitExt = 0x1
    MaxEnum                      = 0x7fffffff
}
VkColorComponentFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    RBit    = 0x1
    GBit    = 0x2
    BBit    = 0x4
    ABit    = 0x8
    MaxEnum = 0x7fffffff
}
VkPipelineCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    DisableOptimizationBit                    = 0x1
    AllowDerivativesBit                       = 0x2
    DerivativeBit                             = 0x4
    ViewIndexFromDeviceIndexBit               = 0x8
    DispatchBaseBit                           = 0x10
    RayTracingNoNullAnyHitShadersBitKhr       = 0x4000
    RayTracingNoNullClosestHitShadersBitKhr   = 0x8000
    RayTracingNoNullMissShadersBitKhr         = 0x10000
    RayTracingNoNullIntersectionShadersBitKhr = 0x20000
    RayTracingSkipTrianglesBitKhr             = 0x1000
    RayTracingSkipAabbsBitKhr                 = 0x2000
    DeferCompileBitNv                         = 0x20
    CaptureStatisticsBitKhr                   = 0x40
    CaptureInternalRepresentationsBitKhr      = 0x80
    IndirectBindableBitNv                     = 0x40000
    LibraryBitKhr                             = 0x800
    ailOnPipelineCompileRequiredBitExt        = 0x100
    EarlyReturnOnFailureBitExt                = 0x200
    DispatchBase                              = 0x10
    ViewIndexFromDeviceIndexBitKhr            = 0x8
    DispatchBaseKhr                           = 0x10
    MaxEnum                                   = 0x7fffffff
}
VkPipelineShaderStageCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    AllowVaryingSubgroupSizeBitExt = 0x1
    RequireFullSubgroupsBitExt     = 0x2
    MaxEnum                        = 0x7fffffff
}
VkShaderStageFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    VertexBit                 = 0x1
    TessellationControlBit    = 0x2
    TessellationEvaluationBit = 0x4
    GeometryBit               = 0x8
    ragmentBit                = 0x10
    ComputeBit                = 0x20
    AllGraphics               = 0x1f
    All                       = 0x7fffffff
    RaygenBitKhr              = 0x100
    AnyHitBitKhr              = 0x200
    ClosestHitBitKhr          = 0x400
    MissBitKhr                = 0x800
    IntersectionBitKhr        = 0x1000
    CallableBitKhr            = 0x2000
    TaskBitNv                 = 0x40
    MeshBitNv                 = 0x80
    RaygenBitNv               = 0x100
    AnyHitBitNv               = 0x200
    ClosestHitBitNv           = 0x400
    MissBitNv                 = 0x800
    IntersectionBitNv         = 0x1000
    CallableBitNv             = 0x2000
    MaxEnum                   = 0x7fffffff
}
VkCullModeFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    None        = 0x0
    rontBit     = 0x1
    BackBit     = 0x2
    rontAndBack = 0x3
    MaxEnum     = 0x7fffffff
}
VkSamplerCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    SubsampledBitExt                     = 0x1
    SubsampledCoarseReconstructionBitExt = 0x2
    MaxEnum                              = 0x7fffffff
}
VkDescriptorPoolCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    reeDescriptorSetBit   = 0x1
    UpdateAfterBindBit    = 0x2
    UpdateAfterBindBitExt = 0x2
    MaxEnum               = 0x7fffffff
}
VkDescriptorSetLayoutCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    UpdateAfterBindPoolBit    = 0x2
    PushDescriptorBitKhr      = 0x1
    UpdateAfterBindPoolBitExt = 0x2
    MaxEnum                   = 0x7fffffff
}
VkAttachmentDescriptionFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    MayAliasBit = 0x1
    MaxEnum     = 0x7fffffff
}
VkDependencyFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ByRegionBit       = 0x1
    DeviceGroupBit    = 0x4
    ViewLocalBit      = 0x2
    ViewLocalBitKhr   = 0x2
    DeviceGroupBitKhr = 0x4
    MaxEnum           = 0x7fffffff
}
VkFramebufferCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ImagelessBit    = 0x1
    ImagelessBitKhr = 0x1
    MaxEnum         = 0x7fffffff
}
VkRenderPassCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TransformBitQcom = 0x2
    MaxEnum          = 0x7fffffff
}
VkSubpassDescriptionFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    PerViewAttributesBitNvx    = 0x1
    PerViewPositionXOnlyBitNvx = 0x2
    ragmentRegionBitQcom       = 0x4
    ShaderResolveBitQcom       = 0x8
    MaxEnum                    = 0x7fffffff
}
VkCommandPoolCreateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TransientBit          = 0x1
    ResetCommandBufferBit = 0x2
    ProtectedBit          = 0x4
    MaxEnum               = 0x7fffffff
}
VkCommandPoolResetFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ReleaseResourcesBit = 0x1
    MaxEnum             = 0x7fffffff
}
VkCommandBufferUsageFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    OneTimeSubmitBit      = 0x1
    RenderPassContinueBit = 0x2
    SimultaneousUseBit    = 0x4
    MaxEnum               = 0x7fffffff
}
VkQueryControlFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    PreciseBit = 0x1
    MaxEnum    = 0x7fffffff
}
VkCommandBufferResetFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ReleaseResourcesBit = 0x1
    MaxEnum             = 0x7fffffff
}
VkStencilFaceFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    rontBit     = 0x1
    BackBit     = 0x2
    rontAndBack = 0x3
    rontAndBack = 0x3
    MaxEnum     = 0x7fffffff
}
VkPointClippingBehavior :: enum #copy #repr("C") #tag_type(i32) {
    AllClipPlanes         = 0x0
    UserClipPlanesOnly    = 0x1
    AllClipPlanesKhr      = 0x0
    UserClipPlanesOnlyKhr = 0x1
    MaxEnum               = 0x7fffffff
}
VkTessellationDomainOrigin :: enum #copy #repr("C") #tag_type(i32) {
    UpperLeft    = 0x0
    LowerLeft    = 0x1
    UpperLeftKhr = 0x0
    LowerLeftKhr = 0x1
    MaxEnum      = 0x7fffffff
}
VkSamplerYcbcrModelConversion :: enum #copy #repr("C") #tag_type(i32) {
    RgbIdentity      = 0x0
    YcbcrIdentity    = 0x1
    Ycbcr709         = 0x2
    Ycbcr601         = 0x3
    Ycbcr2020        = 0x4
    RgbIdentityKhr   = 0x0
    YcbcrIdentityKhr = 0x1
    Ycbcr709Khr      = 0x2
    Ycbcr601Khr      = 0x3
    Ycbcr2020Khr     = 0x4
    MaxEnum          = 0x7fffffff
}
VkSamplerYcbcrRange :: enum #copy #repr("C") #tag_type(i32) {
    ItuFull      = 0x0
    ItuNarrow    = 0x1
    ItuFullKhr   = 0x0
    ItuNarrowKhr = 0x1
    MaxEnum      = 0x7fffffff
}
VkChromaLocation :: enum #copy #repr("C") #tag_type(i32) {
    CositedEven    = 0x0
    Midpoint       = 0x1
    CositedEvenKhr = 0x0
    MidpointKhr    = 0x1
    MaxEnum        = 0x7fffffff
}
VkDescriptorUpdateTemplateType :: enum #copy #repr("C") #tag_type(i32) {
    DescriptorSet      = 0x0
    PushDescriptorsKhr = 0x1
    DescriptorSetKhr   = 0x0
    MaxEnum            = 0x7fffffff
}
VkSubgroupFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    BasicBit           = 0x1
    VoteBit            = 0x2
    ArithmeticBit      = 0x4
    BallotBit          = 0x8
    ShuffleBit         = 0x10
    ShuffleRelativeBit = 0x20
    ClusteredBit       = 0x40
    QuadBit            = 0x80
    PartitionedBitNv   = 0x100
    MaxEnum            = 0x7fffffff
}
VkPeerMemoryFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    CopySrcBit       = 0x1
    CopyDstBit       = 0x2
    GenericSrcBit    = 0x4
    GenericDstBit    = 0x8
    CopySrcBitKhr    = 0x1
    CopyDstBitKhr    = 0x2
    GenericSrcBitKhr = 0x4
    GenericDstBitKhr = 0x8
    MaxEnum          = 0x7fffffff
}
VkMemoryAllocateFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    DeviceMaskBit                    = 0x1
    DeviceAddressBit                 = 0x2
    DeviceAddressCaptureReplayBit    = 0x4
    DeviceMaskBitKhr                 = 0x1
    DeviceAddressBitKhr              = 0x2
    DeviceAddressCaptureReplayBitKhr = 0x4
    MaxEnum                          = 0x7fffffff
}
VkExternalMemoryHandleTypeFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueFdBit                     = 0x1
    OpaqueWin32Bit                  = 0x2
    OpaqueWin32KmtBit               = 0x4
    D3d11TextureBit                 = 0x8
    D3d11TextureKmtBit              = 0x10
    D3d12HeapBit                    = 0x20
    D3d12ResourceBit                = 0x40
    DmaBufBitExt                    = 0x200
    AndroidHardwareBufferBitAndroid = 0x400
    HostAllocationBitExt            = 0x80
    HostMappedForeignMemoryBitExt   = 0x100
    OpaqueFdBitKhr                  = 0x1
    OpaqueWin32BitKhr               = 0x2
    OpaqueWin32KmtBitKhr            = 0x4
    D3d11TextureBitKhr              = 0x8
    D3d11TextureKmtBitKhr           = 0x10
    D3d12HeapBitKhr                 = 0x20
    D3d12ResourceBitKhr             = 0x40
    MaxEnum                         = 0x7fffffff
}
VkExternalMemoryFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    DedicatedOnlyBit    = 0x1
    ExportableBit       = 0x2
    ImportableBit       = 0x4
    DedicatedOnlyBitKhr = 0x1
    ExportableBitKhr    = 0x2
    ImportableBitKhr    = 0x4
    MaxEnum             = 0x7fffffff
}
VkExternalFenceHandleTypeFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueFdBit          = 0x1
    OpaqueWin32Bit       = 0x2
    OpaqueWin32KmtBit    = 0x4
    SyncFdBit            = 0x8
    OpaqueFdBitKhr       = 0x1
    OpaqueWin32BitKhr    = 0x2
    OpaqueWin32KmtBitKhr = 0x4
    SyncFdBitKhr         = 0x8
    MaxEnum              = 0x7fffffff
}
VkExternalFenceFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ExportableBit    = 0x1
    ImportableBit    = 0x2
    ExportableBitKhr = 0x1
    ImportableBitKhr = 0x2
    MaxEnum          = 0x7fffffff
}
VkFenceImportFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TemporaryBit    = 0x1
    TemporaryBitKhr = 0x1
    MaxEnum         = 0x7fffffff
}
VkSemaphoreImportFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    TemporaryBit    = 0x1
    TemporaryBitKhr = 0x1
    MaxEnum         = 0x7fffffff
}
VkExternalSemaphoreHandleTypeFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueFdBit          = 0x1
    OpaqueWin32Bit       = 0x2
    OpaqueWin32KmtBit    = 0x4
    D3d12FenceBit        = 0x8
    SyncFdBit            = 0x10
    D3d11FenceBit        = 0x8
    OpaqueFdBitKhr       = 0x1
    OpaqueWin32BitKhr    = 0x2
    OpaqueWin32KmtBitKhr = 0x4
    D3d12FenceBitKhr     = 0x8
    SyncFdBitKhr         = 0x10
    MaxEnum              = 0x7fffffff
}
VkExternalSemaphoreFeatureFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    ExportableBit    = 0x1
    ImportableBit    = 0x2
    ExportableBitKhr = 0x1
    ImportableBitKhr = 0x2
    MaxEnum          = 0x7fffffff
}
VkDriverId :: enum #copy #repr("C") #tag_type(i32) {
    AmdProprietary             = 0x1
    AmdOpenSource              = 0x2
    MesaRadv                   = 0x3
    NvidiaProprietary          = 0x4
    IntelProprietaryWindows    = 0x5
    IntelOpenSourceMesa        = 0x6
    ImaginationProprietary     = 0x7
    QualcommProprietary        = 0x8
    ArmProprietary             = 0x9
    GoogleSwiftshader          = 0xa
    GgpProprietary             = 0xb
    BroadcomProprietary        = 0xc
    MesaLlvmpipe               = 0xd
    Moltenvk                   = 0xe
    AmdProprietaryKhr          = 0x1
    AmdOpenSourceKhr           = 0x2
    MesaRadvKhr                = 0x3
    NvidiaProprietaryKhr       = 0x4
    IntelProprietaryWindowsKhr = 0x5
    IntelOpenSourceMesaKhr     = 0x6
    ImaginationProprietaryKhr  = 0x7
    QualcommProprietaryKhr     = 0x8
    ArmProprietaryKhr          = 0x9
    GoogleSwiftshaderKhr       = 0xa
    GgpProprietaryKhr          = 0xb
    BroadcomProprietaryKhr     = 0xc
    MaxEnum                    = 0x7fffffff
}
VkShaderFloatControlsIndependence :: enum #copy #repr("C") #tag_type(i32) {
    _32BitOnly    = 0x0
    All           = 0x1
    None          = 0x2
    _32BitOnlyKhr = 0x0
    AllKhr        = 0x1
    NoneKhr       = 0x2
    MaxEnum       = 0x7fffffff
}
VkSamplerReductionMode :: enum #copy #repr("C") #tag_type(i32) {
    WeightedAverage    = 0x0
    Min                = 0x1
    Max                = 0x2
    WeightedAverageExt = 0x0
    MinExt             = 0x1
    MaxExt             = 0x2
    MaxEnum            = 0x7fffffff
}
VkSemaphoreType :: enum #copy #repr("C") #tag_type(i32) {
    Binary      = 0x0
    Timeline    = 0x1
    BinaryKhr   = 0x0
    TimelineKhr = 0x1
    MaxEnum     = 0x7fffffff
}
VkResolveModeFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    None             = 0x0
    SampleZeroBit    = 0x1
    AverageBit       = 0x2
    MinBit           = 0x4
    MaxBit           = 0x8
    NoneKhr          = 0x0
    SampleZeroBitKhr = 0x1
    AverageBitKhr    = 0x2
    MinBitKhr        = 0x4
    MaxBitKhr        = 0x8
    MaxEnum          = 0x7fffffff
}
VkDescriptorBindingFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    UpdateAfterBindBit             = 0x1
    UpdateUnusedWhilePendingBit    = 0x2
    PartiallyBoundBit              = 0x4
    VariableDescriptorCountBit     = 0x8
    UpdateAfterBindBitExt          = 0x1
    UpdateUnusedWhilePendingBitExt = 0x2
    PartiallyBoundBitExt           = 0x4
    VariableDescriptorCountBitExt  = 0x8
    MaxEnum                        = 0x7fffffff
}
VkSemaphoreWaitFlagBits :: enum #copy #repr("C") #tag_type(i32) {
    AnyBit    = 0x1
    AnyBitKhr = 0x1
    MaxEnum   = 0x7fffffff
}
VkPresentModeKHR :: enum #copy #repr("C") #tag_type(i32) {
    ImmediateKhr               = 0x0
    MailboxKhr                 = 0x1
    FifoKhr                    = 0x2
    FifoRelaxedKhr             = 0x3
    SharedDemandRefreshKhr     = 0x3b9c7b98
    SharedContinuousRefreshKhr = 0x3b9c7b99
    MaxEnumKhr                 = 0x7fffffff
}
VkColorSpaceKHR :: enum #copy #repr("C") #tag_type(i32) {
    SrgbNonlinearKhr         = 0x0
    DisplayP3NonlinearExt    = 0x3b9c6041
    ExtendedSrgbLinearExt    = 0x3b9c6042
    DisplayP3LinearExt       = 0x3b9c6043
    DciP3NonlinearExt        = 0x3b9c6044
    Bt709LinearExt           = 0x3b9c6045
    Bt709NonlinearExt        = 0x3b9c6046
    Bt2020LinearExt          = 0x3b9c6047
    Hdr10St2084Ext           = 0x3b9c6048
    DolbyvisionExt           = 0x3b9c6049
    Hdr10HlgExt              = 0x3b9c604a
    AdobergbLinearExt        = 0x3b9c604b
    AdobergbNonlinearExt     = 0x3b9c604c
    PassThroughExt           = 0x3b9c604d
    ExtendedSrgbNonlinearExt = 0x3b9c604e
    DisplayNativeAmd         = 0x3b9e0a08
    spaceSrgbNonlinearKhr    = 0x0
    DciP3LinearExt           = 0x3b9c6043
    MaxEnumKhr               = 0x7fffffff
}
VkSurfaceTransformFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    IdentityBitKhr                  = 0x1
    Rotate90BitKhr                  = 0x2
    Rotate180BitKhr                 = 0x4
    Rotate270BitKhr                 = 0x8
    HorizontalMirrorBitKhr          = 0x10
    HorizontalMirrorRotate90BitKhr  = 0x20
    HorizontalMirrorRotate180BitKhr = 0x40
    HorizontalMirrorRotate270BitKhr = 0x80
    InheritBitKhr                   = 0x100
    MaxEnumKhr                      = 0x7fffffff
}
VkCompositeAlphaFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueBitKhr         = 0x1
    PreMultipliedBitKhr  = 0x2
    PostMultipliedBitKhr = 0x4
    InheritBitKhr        = 0x8
    MaxEnumKhr           = 0x7fffffff
}
VkSwapchainCreateFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    SplitInstanceBindRegionsBitKhr = 0x1
    ProtectedBitKhr                = 0x2
    MutableFormatBitKhr            = 0x4
    MaxEnumKhr                     = 0x7fffffff
}
VkDeviceGroupPresentModeFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    LocalBitKhr            = 0x1
    RemoteBitKhr           = 0x2
    SumBitKhr              = 0x4
    LocalMultiDeviceBitKhr = 0x8
    MaxEnumKhr             = 0x7fffffff
}
VkDisplayPlaneAlphaFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueBitKhr                = 0x1
    GlobalBitKhr                = 0x2
    PerPixelBitKhr              = 0x4
    PerPixelPremultipliedBitKhr = 0x8
    MaxEnumKhr                  = 0x7fffffff
}
VkPerformanceCounterUnitKHR :: enum #copy #repr("C") #tag_type(i32) {
    GenericKhr        = 0x0
    PercentageKhr     = 0x1
    NanosecondsKhr    = 0x2
    BytesKhr          = 0x3
    BytesPerSecondKhr = 0x4
    elvinKhr          = 0x5
    WattsKhr          = 0x6
    VoltsKhr          = 0x7
    AmpsKhr           = 0x8
    HertzKhr          = 0x9
    CyclesKhr         = 0xa
    MaxEnumKhr        = 0x7fffffff
}
VkPerformanceCounterScopeKHR :: enum #copy #repr("C") #tag_type(i32) {
    CommandBufferKhr           = 0x0
    RenderPassKhr              = 0x1
    CommandKhr                 = 0x2
    QueryScopeCommandBufferKhr = 0x0
    QueryScopeRenderPassKhr    = 0x1
    QueryScopeCommandKhr       = 0x2
    MaxEnumKhr                 = 0x7fffffff
}
VkPerformanceCounterStorageKHR :: enum #copy #repr("C") #tag_type(i32) {
    Int32Khr   = 0x0
    Int64Khr   = 0x1
    Uint32Khr  = 0x2
    Uint64Khr  = 0x3
    Float32Khr = 0x4
    Float64Khr = 0x5
    MaxEnumKhr = 0x7fffffff
}
VkPerformanceCounterDescriptionFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    PerformanceImpactingKhr = 0x1
    ConcurrentlyImpactedKhr = 0x2
    MaxEnumKhr              = 0x7fffffff
}
VkAcquireProfilingLockFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    MaxEnumKhr = 0x7fffffff
}
VkPipelineExecutableStatisticFormatKHR :: enum #copy #repr("C") #tag_type(i32) {
    Bool32Khr  = 0x0
    Int64Khr   = 0x1
    Uint64Khr  = 0x2
    Float64Khr = 0x3
    MaxEnumKhr = 0x7fffffff
}
VkDebugReportObjectTypeEXT :: enum #copy #repr("C") #tag_type(i32) {
    UnknownExt                     = 0x0
    InstanceExt                    = 0x1
    PhysicalDeviceExt              = 0x2
    DeviceExt                      = 0x3
    QueueExt                       = 0x4
    SemaphoreExt                   = 0x5
    CommandBufferExt               = 0x6
    FenceExt                       = 0x7
    DeviceMemoryExt                = 0x8
    BufferExt                      = 0x9
    ImageExt                       = 0xa
    ventExt                        = 0xb
    QueryPoolExt                   = 0xc
    BufferViewExt                  = 0xd
    ImageViewExt                   = 0xe
    ShaderModuleExt                = 0xf
    PipelineCacheExt               = 0x10
    PipelineLayoutExt              = 0x11
    RenderPassExt                  = 0x12
    PipelineExt                    = 0x13
    DescriptorSetLayoutExt         = 0x14
    SamplerExt                     = 0x15
    DescriptorPoolExt              = 0x16
    DescriptorSetExt               = 0x17
    FramebufferExt                 = 0x18
    CommandPoolExt                 = 0x19
    SurfaceKhrExt                  = 0x1a
    SwapchainKhrExt                = 0x1b
    DebugReportCallbackExtExt      = 0x1c
    DisplayKhrExt                  = 0x1d
    DisplayModeKhrExt              = 0x1e
    ValidationCacheExtExt          = 0x21
    SamplerYcbcrConversionExt      = 0x3b9d2b60
    DescriptorUpdateTemplateExt    = 0x3b9c1608
    AccelerationStructureKhrExt    = 0x3b9d4e88
    DebugReportExt                 = 0x1c
    ValidationCacheExt             = 0x21
    DescriptorUpdateTemplateKhrExt = 0x3b9c1608
    SamplerYcbcrConversionKhrExt   = 0x3b9d2b60
    AccelerationStructureNvExt     = 0x3b9d4e88
    MaxEnumExt                     = 0x7fffffff
}
VkDebugReportFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    InformationBitExt        = 0x1
    WarningBitExt            = 0x2
    PerformanceWarningBitExt = 0x4
    ErrorBitExt              = 0x8
    DebugBitExt              = 0x10
    MaxEnumExt               = 0x7fffffff
}
VkRasterizationOrderAMD :: enum #copy #repr("C") #tag_type(i32) {
    StrictAmd  = 0x0
    RelaxedAmd = 0x1
    MaxEnumAmd = 0x7fffffff
}
VkShaderInfoTypeAMD :: enum #copy #repr("C") #tag_type(i32) {
    StatisticsAmd  = 0x0
    BinaryAmd      = 0x1
    DisassemblyAmd = 0x2
    MaxEnumAmd     = 0x7fffffff
}
VkExternalMemoryHandleTypeFlagBitsNV :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueWin32BitNv    = 0x1
    OpaqueWin32KmtBitNv = 0x2
    D3d11ImageBitNv     = 0x4
    D3d11ImageKmtBitNv  = 0x8
    MaxEnumNv           = 0x7fffffff
}
VkExternalMemoryFeatureFlagBitsNV :: enum #copy #repr("C") #tag_type(i32) {
    DedicatedOnlyBitNv = 0x1
    ExportableBitNv    = 0x2
    ImportableBitNv    = 0x4
    MaxEnumNv          = 0x7fffffff
}
VkValidationCheckEXT :: enum #copy #repr("C") #tag_type(i32) {
    AllExt     = 0x0
    ShadersExt = 0x1
    MaxEnumExt = 0x7fffffff
}
VkConditionalRenderingFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    InvertedBitExt = 0x1
    MaxEnumExt     = 0x7fffffff
}
VkSurfaceCounterFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    VblankExt  = 0x1
    MaxEnumExt = 0x7fffffff
}
VkDisplayPowerStateEXT :: enum #copy #repr("C") #tag_type(i32) {
    OffExt     = 0x0
    SuspendExt = 0x1
    OnExt      = 0x2
    MaxEnumExt = 0x7fffffff
}
VkDeviceEventTypeEXT :: enum #copy #repr("C") #tag_type(i32) {
    DisplayHotplugExt = 0x0
    MaxEnumExt        = 0x7fffffff
}
VkDisplayEventTypeEXT :: enum #copy #repr("C") #tag_type(i32) {
    FirstPixelOutExt = 0x0
    MaxEnumExt       = 0x7fffffff
}
VkViewportCoordinateSwizzleNV :: enum #copy #repr("C") #tag_type(i32) {
    PositiveXNv = 0x0
    egativeXNv  = 0x1
    PositiveYNv = 0x2
    egativeYNv  = 0x3
    PositiveZNv = 0x4
    egativeZNv  = 0x5
    PositiveWNv = 0x6
    egativeWNv  = 0x7
    MaxEnumNv   = 0x7fffffff
}
VkDiscardRectangleModeEXT :: enum #copy #repr("C") #tag_type(i32) {
    InclusiveExt = 0x0
    xclusiveExt  = 0x1
    MaxEnumExt   = 0x7fffffff
}
VkConservativeRasterizationModeEXT :: enum #copy #repr("C") #tag_type(i32) {
    DisabledExt      = 0x0
    OverestimateExt  = 0x1
    UnderestimateExt = 0x2
    MaxEnumExt       = 0x7fffffff
}
VkDebugUtilsMessageSeverityFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    VerboseBitExt = 0x1
    InfoBitExt    = 0x10
    WarningBitExt = 0x100
    ErrorBitExt   = 0x1000
    MaxEnumExt    = 0x7fffffff
}
VkDebugUtilsMessageTypeFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    GeneralBitExt     = 0x1
    ValidationBitExt  = 0x2
    PerformanceBitExt = 0x4
    MaxEnumExt        = 0x7fffffff
}
VkBlendOverlapEXT :: enum #copy #repr("C") #tag_type(i32) {
    UncorrelatedExt = 0x0
    DisjointExt     = 0x1
    ConjointExt     = 0x2
    MaxEnumExt      = 0x7fffffff
}
VkCoverageModulationModeNV :: enum #copy #repr("C") #tag_type(i32) {
    oneNv     = 0x0
    RgbNv     = 0x1
    AlphaNv   = 0x2
    RgbaNv    = 0x3
    MaxEnumNv = 0x7fffffff
}
VkValidationCacheHeaderVersionEXT :: enum #copy #repr("C") #tag_type(i32) {
    OneExt     = 0x1
    MaxEnumExt = 0x7fffffff
}
VkShadingRatePaletteEntryNV :: enum #copy #repr("C") #tag_type(i32) {
    oInvocationsNv             = 0x0
    _16InvocationsPerPixelNv   = 0x1
    _8InvocationsPerPixelNv    = 0x2
    _4InvocationsPerPixelNv    = 0x3
    _2InvocationsPerPixelNv    = 0x4
    _1InvocationPerPixelNv     = 0x5
    _1InvocationPer2x1PixelsNv = 0x6
    _1InvocationPer1x2PixelsNv = 0x7
    _1InvocationPer2x2PixelsNv = 0x8
    _1InvocationPer4x2PixelsNv = 0x9
    _1InvocationPer2x4PixelsNv = 0xa
    _1InvocationPer4x4PixelsNv = 0xb
    MaxEnumNv                  = 0x7fffffff
}
VkCoarseSampleOrderTypeNV :: enum #copy #repr("C") #tag_type(i32) {
    DefaultNv     = 0x0
    CustomNv      = 0x1
    PixelMajorNv  = 0x2
    SampleMajorNv = 0x3
    MaxEnumNv     = 0x7fffffff
}
VkRayTracingShaderGroupTypeKHR :: enum #copy #repr("C") #tag_type(i32) {
    GeneralKhr            = 0x0
    TrianglesHitGroupKhr  = 0x1
    ProceduralHitGroupKhr = 0x2
    GeneralNv             = 0x0
    TrianglesHitGroupNv   = 0x1
    ProceduralHitGroupNv  = 0x2
    MaxEnumKhr            = 0x7fffffff
}
VkGeometryTypeKHR :: enum #copy #repr("C") #tag_type(i32) {
    TrianglesKhr = 0x0
    AabbsKhr     = 0x1
    InstancesKhr = 0x3b9d13f0
    TrianglesNv  = 0x0
    AabbsNv      = 0x1
    MaxEnumKhr   = 0x7fffffff
}
VkAccelerationStructureTypeKHR :: enum #copy #repr("C") #tag_type(i32) {
    TopLevelKhr    = 0x0
    BottomLevelKhr = 0x1
    TopLevelNv     = 0x0
    BottomLevelNv  = 0x1
    MaxEnumKhr     = 0x7fffffff
}
VkCopyAccelerationStructureModeKHR :: enum #copy #repr("C") #tag_type(i32) {
    CloneKhr       = 0x0
    CompactKhr     = 0x1
    SerializeKhr   = 0x2
    DeserializeKhr = 0x3
    CloneNv        = 0x0
    CompactNv      = 0x1
    MaxEnumKhr     = 0x7fffffff
}
VkAccelerationStructureMemoryRequirementsTypeKHR :: enum #copy #repr("C") #tag_type(i32) {
    ObjectKhr        = 0x0
    BuildScratchKhr  = 0x1
    UpdateScratchKhr = 0x2
    ObjectNv         = 0x0
    BuildScratchNv   = 0x1
    UpdateScratchNv  = 0x2
    MaxEnumKhr       = 0x7fffffff
}
VkGeometryFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    OpaqueBitKhr                      = 0x1
    NoDuplicateAnyHitInvocationBitKhr = 0x2
    OpaqueBitNv                       = 0x1
    NoDuplicateAnyHitInvocationBitNv  = 0x2
    MaxEnumKhr                        = 0x7fffffff
}
VkGeometryInstanceFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    TriangleFacingCullDisableBitKhr     = 0x1
    TriangleFrontCounterclockwiseBitKhr = 0x2
    orceOpaqueBitKhr                    = 0x4
    orceNoOpaqueBitKhr                  = 0x8
    TriangleCullDisableBitNv            = 0x1
    TriangleFrontCounterclockwiseBitNv  = 0x2
    orceOpaqueBitNv                     = 0x4
    orceNoOpaqueBitNv                   = 0x8
    MaxEnumKhr                          = 0x7fffffff
}
VkBuildAccelerationStructureFlagBitsKHR :: enum #copy #repr("C") #tag_type(i32) {
    AllowUpdateBitKhr     = 0x1
    AllowCompactionBitKhr = 0x2
    PreferFastTraceBitKhr = 0x4
    PreferFastBuildBitKhr = 0x8
    LowMemoryBitKhr       = 0x10
    AllowUpdateBitNv      = 0x1
    AllowCompactionBitNv  = 0x2
    PreferFastTraceBitNv  = 0x4
    PreferFastBuildBitNv  = 0x8
    LowMemoryBitNv        = 0x10
    MaxEnumKhr            = 0x7fffffff
}
VkQueueGlobalPriorityEXT :: enum #copy #repr("C") #tag_type(i32) {
    LowExt      = 0x80
    MediumExt   = 0x100
    HighExt     = 0x200
    RealtimeExt = 0x400
    MaxEnumExt  = 0x7fffffff
}
VkPipelineCompilerControlFlagBitsAMD :: enum #copy #repr("C") #tag_type(i32) {
    MaxEnumAmd = 0x7fffffff
}
VkTimeDomainEXT :: enum #copy #repr("C") #tag_type(i32) {
    DeviceExt                  = 0x0
    ClockMonotonicExt          = 0x1
    ClockMonotonicRawExt       = 0x2
    QueryPerformanceCounterExt = 0x3
    MaxEnumExt                 = 0x7fffffff
}
VkMemoryOverallocationBehaviorAMD :: enum #copy #repr("C") #tag_type(i32) {
    DefaultAmd    = 0x0
    llowedAmd     = 0x1
    DisallowedAmd = 0x2
    MaxEnumAmd    = 0x7fffffff
}
VkPipelineCreationFeedbackFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    ValidBitExt                       = 0x1
    ApplicationPipelineCacheHitBitExt = 0x2
    BasePipelineAccelerationBitExt    = 0x4
    MaxEnumExt                        = 0x7fffffff
}
VkPerformanceConfigurationTypeINTEL :: enum #copy #repr("C") #tag_type(i32) {
    CommandQueueMetricsDiscoveryActivatedIntel = 0x0
    MaxEnumIntel                               = 0x7fffffff
}
VkQueryPoolSamplingModeINTEL :: enum #copy #repr("C") #tag_type(i32) {
    ManualIntel  = 0x0
    MaxEnumIntel = 0x7fffffff
}
VkPerformanceOverrideTypeINTEL :: enum #copy #repr("C") #tag_type(i32) {
    NullHardwareIntel   = 0x0
    FlushGpuCachesIntel = 0x1
    MaxEnumIntel        = 0x7fffffff
}
VkPerformanceParameterTypeINTEL :: enum #copy #repr("C") #tag_type(i32) {
    HwCountersSupportedIntel   = 0x0
    StreamMarkerValidBitsIntel = 0x1
    MaxEnumIntel               = 0x7fffffff
}
VkPerformanceValueTypeINTEL :: enum #copy #repr("C") #tag_type(i32) {
    Uint32Intel  = 0x0
    Uint64Intel  = 0x1
    FloatIntel   = 0x2
    BoolIntel    = 0x3
    StringIntel  = 0x4
    MaxEnumIntel = 0x7fffffff
}
VkShaderCorePropertiesFlagBitsAMD :: enum #copy #repr("C") #tag_type(i32) {
    MaxEnumAmd = 0x7fffffff
}
VkToolPurposeFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    ValidationBitExt         = 0x1
    ProfilingBitExt          = 0x2
    TracingBitExt            = 0x4
    AdditionalFeaturesBitExt = 0x8
    ModifyingFeaturesBitExt  = 0x10
    DebugReportingBitExt     = 0x20
    DebugMarkersBitExt       = 0x40
    MaxEnumExt               = 0x7fffffff
}
VkValidationFeatureEnableEXT :: enum #copy #repr("C") #tag_type(i32) {
    GpuAssistedExt                   = 0x0
    GpuAssistedReserveBindingSlotExt = 0x1
    BestPracticesExt                 = 0x2
    DebugPrintfExt                   = 0x3
    MaxEnumExt                       = 0x7fffffff
}
VkValidationFeatureDisableEXT :: enum #copy #repr("C") #tag_type(i32) {
    AllExt             = 0x0
    ShadersExt         = 0x1
    ThreadSafetyExt    = 0x2
    ApiParametersExt   = 0x3
    ObjectLifetimesExt = 0x4
    CoreChecksExt      = 0x5
    UniqueHandlesExt   = 0x6
    MaxEnumExt         = 0x7fffffff
}
VkComponentTypeNV :: enum #copy #repr("C") #tag_type(i32) {
    Float16Nv = 0x0
    Float32Nv = 0x1
    Float64Nv = 0x2
    Sint8Nv   = 0x3
    Sint16Nv  = 0x4
    Sint32Nv  = 0x5
    Sint64Nv  = 0x6
    Uint8Nv   = 0x7
    Uint16Nv  = 0x8
    Uint32Nv  = 0x9
    Uint64Nv  = 0xa
    MaxEnumNv = 0x7fffffff
}
VkScopeNV :: enum #copy #repr("C") #tag_type(i32) {
    DeviceNv      = 0x1
    WorkgroupNv   = 0x2
    SubgroupNv    = 0x3
    QueueFamilyNv = 0x5
    MaxEnumNv     = 0x7fffffff
}
VkCoverageReductionModeNV :: enum #copy #repr("C") #tag_type(i32) {
    MergeNv    = 0x0
    TruncateNv = 0x1
    MaxEnumNv  = 0x7fffffff
}
VkLineRasterizationModeEXT :: enum #copy #repr("C") #tag_type(i32) {
    DefaultExt           = 0x0
    RectangularExt       = 0x1
    BresenhamExt         = 0x2
    RectangularSmoothExt = 0x3
    MaxEnumExt           = 0x7fffffff
}
VkIndirectCommandsTokenTypeNV :: enum #copy #repr("C") #tag_type(i32) {
    ShaderGroupNv  = 0x0
    StateFlagsNv   = 0x1
    IndexBufferNv  = 0x2
    VertexBufferNv = 0x3
    PushConstantNv = 0x4
    DrawIndexedNv  = 0x5
    DrawNv         = 0x6
    DrawTasksNv    = 0x7
    MaxEnumNv      = 0x7fffffff
}
VkIndirectStateFlagBitsNV :: enum #copy #repr("C") #tag_type(i32) {
    FrontfaceBitNv = 0x1
    MaxEnumNv      = 0x7fffffff
}
VkIndirectCommandsLayoutUsageFlagBitsNV :: enum #copy #repr("C") #tag_type(i32) {
    ExplicitPreprocessBitNv = 0x1
    IndexedSequencesBitNv   = 0x2
    UnorderedSequencesBitNv = 0x4
    MaxEnumNv               = 0x7fffffff
}
VkPrivateDataSlotCreateFlagBitsEXT :: enum #copy #repr("C") #tag_type(i32) {
    MaxEnumExt = 0x7fffffff
}
VkDeviceDiagnosticsConfigFlagBitsNV :: enum #copy #repr("C") #tag_type(i32) {
    EnableShaderDebugInfoBitNv      = 0x1
    EnableResourceTrackingBitNv     = 0x2
    EnableAutomaticCheckpointsBitNv = 0x4
    MaxEnumNv                       = 0x7fffffff
}
VkExtent2D :: struct #copy {
    width : uint32_t = default
    height : uint32_t = default
}
VkExtent3D :: struct #copy {
    width : uint32_t = default
    height : uint32_t = default
    depth : uint32_t = default
}
VkOffset2D :: struct #copy {
    x : int32_t = default
    y : int32_t = default
}
VkOffset3D :: struct #copy {
    x : int32_t = default
    y : int32_t = default
    z : int32_t = default
}
VkRect2D :: struct #copy {
    offset : VkOffset2D = default
    extent : VkExtent2D = default
}
VkBaseInStructure :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut VkBaseInStructure = default
}
VkBaseOutStructure :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut VkBaseOutStructure = default
}
VkBufferMemoryBarrier :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcAccessMask : VkAccessFlags = default
    dstAccessMask : VkAccessFlags = default
    srcQueueFamilyIndex : uint32_t = default
    dstQueueFamilyIndex : uint32_t = default
    buffer : VkBuffer = default
    offset : VkDeviceSize = default
    size : VkDeviceSize = default
}
VkDispatchIndirectCommand :: struct #copy {
    x : uint32_t = default
    y : uint32_t = default
    z : uint32_t = default
}
VkDrawIndexedIndirectCommand :: struct #copy {
    indexCount : uint32_t = default
    instanceCount : uint32_t = default
    firstIndex : uint32_t = default
    vertexOffset : int32_t = default
    firstInstance : uint32_t = default
}
VkDrawIndirectCommand :: struct #copy {
    vertexCount : uint32_t = default
    instanceCount : uint32_t = default
    firstVertex : uint32_t = default
    firstInstance : uint32_t = default
}
VkImageSubresourceRange :: struct #copy {
    aspectMask : VkImageAspectFlags = default
    baseMipLevel : uint32_t = default
    levelCount : uint32_t = default
    baseArrayLayer : uint32_t = default
    layerCount : uint32_t = default
}
VkImageMemoryBarrier :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcAccessMask : VkAccessFlags = default
    dstAccessMask : VkAccessFlags = default
    oldLayout : VkImageLayout = default
    newLayout : VkImageLayout = default
    srcQueueFamilyIndex : uint32_t = default
    dstQueueFamilyIndex : uint32_t = default
    image : VkImage = default
    subresourceRange : VkImageSubresourceRange = default
}
VkMemoryBarrier :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcAccessMask : VkAccessFlags = default
    dstAccessMask : VkAccessFlags = default
}
VkAllocationCallbacks :: struct #copy {
    pUserData : ^mut void = default
    pfnAllocation : PFN_vkAllocationFunction = default
    pfnReallocation : PFN_vkReallocationFunction = default
    pfnFree : PFN_vkFreeFunction = default
    pfnInternalAllocation : PFN_vkInternalAllocationNotification = default
    pfnInternalFree : PFN_vkInternalFreeNotification = default
}
VkApplicationInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pApplicationName : ^mut char8 = default
    applicationVersion : uint32_t = default
    pEngineName : ^mut char8 = default
    engineVersion : uint32_t = default
    apiVersion : uint32_t = default
}
VkFormatProperties :: struct #copy {
    linearTilingFeatures : VkFormatFeatureFlags = default
    optimalTilingFeatures : VkFormatFeatureFlags = default
    bufferFeatures : VkFormatFeatureFlags = default
}
VkImageFormatProperties :: struct #copy {
    maxExtent : VkExtent3D = default
    maxMipLevels : uint32_t = default
    maxArrayLayers : uint32_t = default
    sampleCounts : VkSampleCountFlags = default
    maxResourceSize : VkDeviceSize = default
}
VkInstanceCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkInstanceCreateFlags = default
    pApplicationInfo : ^mut VkApplicationInfo = default
    enabledLayerCount : uint32_t = default
    ppEnabledLayerNames : ^mut ^mut char8 = default
    enabledExtensionCount : uint32_t = default
    ppEnabledExtensionNames : ^mut ^mut char8 = default
}
VkMemoryHeap :: struct #copy {
    size : VkDeviceSize = default
    flags : VkMemoryHeapFlags = default
}
VkMemoryType :: struct #copy {
    propertyFlags : VkMemoryPropertyFlags = default
    heapIndex : uint32_t = default
}
VkPhysicalDeviceFeatures :: struct #copy {
    robustBufferAccess : VkBool32 = default
    fullDrawIndexUint32 : VkBool32 = default
    imageCubeArray : VkBool32 = default
    independentBlend : VkBool32 = default
    geometryShader : VkBool32 = default
    tessellationShader : VkBool32 = default
    sampleRateShading : VkBool32 = default
    dualSrcBlend : VkBool32 = default
    logicOp : VkBool32 = default
    multiDrawIndirect : VkBool32 = default
    drawIndirectFirstInstance : VkBool32 = default
    depthClamp : VkBool32 = default
    depthBiasClamp : VkBool32 = default
    fillModeNonSolid : VkBool32 = default
    depthBounds : VkBool32 = default
    wideLines : VkBool32 = default
    largePoints : VkBool32 = default
    alphaToOne : VkBool32 = default
    multiViewport : VkBool32 = default
    samplerAnisotropy : VkBool32 = default
    textureCompressionETC2 : VkBool32 = default
    textureCompressionASTC_LDR : VkBool32 = default
    textureCompressionBC : VkBool32 = default
    occlusionQueryPrecise : VkBool32 = default
    pipelineStatisticsQuery : VkBool32 = default
    vertexPipelineStoresAndAtomics : VkBool32 = default
    fragmentStoresAndAtomics : VkBool32 = default
    shaderTessellationAndGeometryPointSize : VkBool32 = default
    shaderImageGatherExtended : VkBool32 = default
    shaderStorageImageExtendedFormats : VkBool32 = default
    shaderStorageImageMultisample : VkBool32 = default
    shaderStorageImageReadWithoutFormat : VkBool32 = default
    shaderStorageImageWriteWithoutFormat : VkBool32 = default
    shaderUniformBufferArrayDynamicIndexing : VkBool32 = default
    shaderSampledImageArrayDynamicIndexing : VkBool32 = default
    shaderStorageBufferArrayDynamicIndexing : VkBool32 = default
    shaderStorageImageArrayDynamicIndexing : VkBool32 = default
    shaderClipDistance : VkBool32 = default
    shaderCullDistance : VkBool32 = default
    shaderFloat64 : VkBool32 = default
    shaderInt64 : VkBool32 = default
    shaderInt16 : VkBool32 = default
    shaderResourceResidency : VkBool32 = default
    shaderResourceMinLod : VkBool32 = default
    sparseBinding : VkBool32 = default
    sparseResidencyBuffer : VkBool32 = default
    sparseResidencyImage2D : VkBool32 = default
    sparseResidencyImage3D : VkBool32 = default
    sparseResidency2Samples : VkBool32 = default
    sparseResidency4Samples : VkBool32 = default
    sparseResidency8Samples : VkBool32 = default
    sparseResidency16Samples : VkBool32 = default
    sparseResidencyAliased : VkBool32 = default
    variableMultisampleRate : VkBool32 = default
    inheritedQueries : VkBool32 = default
}
VkPhysicalDeviceLimits :: struct #copy {
    maxImageDimension1D : uint32_t = default
    maxImageDimension2D : uint32_t = default
    maxImageDimension3D : uint32_t = default
    maxImageDimensionCube : uint32_t = default
    maxImageArrayLayers : uint32_t = default
    maxTexelBufferElements : uint32_t = default
    maxUniformBufferRange : uint32_t = default
    maxStorageBufferRange : uint32_t = default
    maxPushConstantsSize : uint32_t = default
    maxMemoryAllocationCount : uint32_t = default
    maxSamplerAllocationCount : uint32_t = default
    bufferImageGranularity : VkDeviceSize = default
    sparseAddressSpaceSize : VkDeviceSize = default
    maxBoundDescriptorSets : uint32_t = default
    maxPerStageDescriptorSamplers : uint32_t = default
    maxPerStageDescriptorUniformBuffers : uint32_t = default
    maxPerStageDescriptorStorageBuffers : uint32_t = default
    maxPerStageDescriptorSampledImages : uint32_t = default
    maxPerStageDescriptorStorageImages : uint32_t = default
    maxPerStageDescriptorInputAttachments : uint32_t = default
    maxPerStageResources : uint32_t = default
    maxDescriptorSetSamplers : uint32_t = default
    maxDescriptorSetUniformBuffers : uint32_t = default
    maxDescriptorSetUniformBuffersDynamic : uint32_t = default
    maxDescriptorSetStorageBuffers : uint32_t = default
    maxDescriptorSetStorageBuffersDynamic : uint32_t = default
    maxDescriptorSetSampledImages : uint32_t = default
    maxDescriptorSetStorageImages : uint32_t = default
    maxDescriptorSetInputAttachments : uint32_t = default
    maxVertexInputAttributes : uint32_t = default
    maxVertexInputBindings : uint32_t = default
    maxVertexInputAttributeOffset : uint32_t = default
    maxVertexInputBindingStride : uint32_t = default
    maxVertexOutputComponents : uint32_t = default
    maxTessellationGenerationLevel : uint32_t = default
    maxTessellationPatchSize : uint32_t = default
    maxTessellationControlPerVertexInputComponents : uint32_t = default
    maxTessellationControlPerVertexOutputComponents : uint32_t = default
    maxTessellationControlPerPatchOutputComponents : uint32_t = default
    maxTessellationControlTotalOutputComponents : uint32_t = default
    maxTessellationEvaluationInputComponents : uint32_t = default
    maxTessellationEvaluationOutputComponents : uint32_t = default
    maxGeometryShaderInvocations : uint32_t = default
    maxGeometryInputComponents : uint32_t = default
    maxGeometryOutputComponents : uint32_t = default
    maxGeometryOutputVertices : uint32_t = default
    maxGeometryTotalOutputComponents : uint32_t = default
    maxFragmentInputComponents : uint32_t = default
    maxFragmentOutputAttachments : uint32_t = default
    maxFragmentDualSrcAttachments : uint32_t = default
    maxFragmentCombinedOutputResources : uint32_t = default
    maxComputeSharedMemorySize : uint32_t = default
    maxComputeWorkGroupCount : [3]uint32_t = default
    maxComputeWorkGroupInvocations : uint32_t = default
    maxComputeWorkGroupSize : [3]uint32_t = default
    subPixelPrecisionBits : uint32_t = default
    subTexelPrecisionBits : uint32_t = default
    mipmapPrecisionBits : uint32_t = default
    maxDrawIndexedIndexValue : uint32_t = default
    maxDrawIndirectCount : uint32_t = default
    maxSamplerLodBias : f32 = default
    maxSamplerAnisotropy : f32 = default
    maxViewports : uint32_t = default
    maxViewportDimensions : [2]uint32_t = default
    viewportBoundsRange : [2]f32 = default
    viewportSubPixelBits : uint32_t = default
    minMemoryMapAlignment : size_t = default
    minTexelBufferOffsetAlignment : VkDeviceSize = default
    minUniformBufferOffsetAlignment : VkDeviceSize = default
    minStorageBufferOffsetAlignment : VkDeviceSize = default
    minTexelOffset : int32_t = default
    maxTexelOffset : uint32_t = default
    minTexelGatherOffset : int32_t = default
    maxTexelGatherOffset : uint32_t = default
    minInterpolationOffset : f32 = default
    maxInterpolationOffset : f32 = default
    subPixelInterpolationOffsetBits : uint32_t = default
    maxFramebufferWidth : uint32_t = default
    maxFramebufferHeight : uint32_t = default
    maxFramebufferLayers : uint32_t = default
    framebufferColorSampleCounts : VkSampleCountFlags = default
    framebufferDepthSampleCounts : VkSampleCountFlags = default
    framebufferStencilSampleCounts : VkSampleCountFlags = default
    framebufferNoAttachmentsSampleCounts : VkSampleCountFlags = default
    maxColorAttachments : uint32_t = default
    sampledImageColorSampleCounts : VkSampleCountFlags = default
    sampledImageIntegerSampleCounts : VkSampleCountFlags = default
    sampledImageDepthSampleCounts : VkSampleCountFlags = default
    sampledImageStencilSampleCounts : VkSampleCountFlags = default
    storageImageSampleCounts : VkSampleCountFlags = default
    maxSampleMaskWords : uint32_t = default
    timestampComputeAndGraphics : VkBool32 = default
    timestampPeriod : f32 = default
    maxClipDistances : uint32_t = default
    maxCullDistances : uint32_t = default
    maxCombinedClipAndCullDistances : uint32_t = default
    discreteQueuePriorities : uint32_t = default
    pointSizeRange : [2]f32 = default
    lineWidthRange : [2]f32 = default
    pointSizeGranularity : f32 = default
    lineWidthGranularity : f32 = default
    strictLines : VkBool32 = default
    standardSampleLocations : VkBool32 = default
    optimalBufferCopyOffsetAlignment : VkDeviceSize = default
    optimalBufferCopyRowPitchAlignment : VkDeviceSize = default
    nonCoherentAtomSize : VkDeviceSize = default
}
VkPhysicalDeviceMemoryProperties :: struct #copy {
    memoryTypeCount : uint32_t = default
    memoryTypes : [32]VkMemoryType = default
    memoryHeapCount : uint32_t = default
    memoryHeaps : [16]VkMemoryHeap = default
}
VkPhysicalDeviceSparseProperties :: struct #copy {
    residencyStandard2DBlockShape : VkBool32 = default
    residencyStandard2DMultisampleBlockShape : VkBool32 = default
    residencyStandard3DBlockShape : VkBool32 = default
    residencyAlignedMipSize : VkBool32 = default
    residencyNonResidentStrict : VkBool32 = default
}
VkPhysicalDeviceProperties :: struct #copy {
    apiVersion : uint32_t = default
    driverVersion : uint32_t = default
    vendorID : uint32_t = default
    deviceID : uint32_t = default
    deviceType : VkPhysicalDeviceType = default
    deviceName : [256]char8 = default
    pipelineCacheUUID : [16]uint8_t = default
    limits : VkPhysicalDeviceLimits = default
    sparseProperties : VkPhysicalDeviceSparseProperties = default
}
VkQueueFamilyProperties :: struct #copy {
    queueFlags : VkQueueFlags = default
    queueCount : uint32_t = default
    timestampValidBits : uint32_t = default
    minImageTransferGranularity : VkExtent3D = default
}
VkDeviceQueueCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDeviceQueueCreateFlags = default
    queueFamilyIndex : uint32_t = default
    queueCount : uint32_t = default
    pQueuePriorities : ^mut f32 = default
}
VkDeviceCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDeviceCreateFlags = default
    queueCreateInfoCount : uint32_t = default
    pQueueCreateInfos : ^mut VkDeviceQueueCreateInfo = default
    enabledLayerCount : uint32_t = default
    ppEnabledLayerNames : ^mut ^mut char8 = default
    enabledExtensionCount : uint32_t = default
    ppEnabledExtensionNames : ^mut ^mut char8 = default
    pEnabledFeatures : ^mut VkPhysicalDeviceFeatures = default
}
VkExtensionProperties :: struct #copy {
    extensionName : [256]char8 = default
    specVersion : uint32_t = default
}
VkLayerProperties :: struct #copy {
    layerName : [256]char8 = default
    specVersion : uint32_t = default
    implementationVersion : uint32_t = default
    description : [256]char8 = default
}
VkSubmitInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    waitSemaphoreCount : uint32_t = default
    pWaitSemaphores : ^mut VkSemaphore = default
    pWaitDstStageMask : ^mut VkPipelineStageFlags = default
    commandBufferCount : uint32_t = default
    pCommandBuffers : ^mut VkCommandBuffer = default
    signalSemaphoreCount : uint32_t = default
    pSignalSemaphores : ^mut VkSemaphore = default
}
VkMappedMemoryRange :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memory : VkDeviceMemory = default
    offset : VkDeviceSize = default
    size : VkDeviceSize = default
}
VkMemoryAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    allocationSize : VkDeviceSize = default
    memoryTypeIndex : uint32_t = default
}
VkMemoryRequirements :: struct #copy {
    size : VkDeviceSize = default
    alignment : VkDeviceSize = default
    memoryTypeBits : uint32_t = default
}
VkSparseMemoryBind :: struct #copy {
    resourceOffset : VkDeviceSize = default
    size : VkDeviceSize = default
    memory : VkDeviceMemory = default
    memoryOffset : VkDeviceSize = default
    flags : VkSparseMemoryBindFlags = default
}
VkSparseBufferMemoryBindInfo :: struct #copy {
    buffer : VkBuffer = default
    bindCount : uint32_t = default
    pBinds : ^mut VkSparseMemoryBind = default
}
VkSparseImageOpaqueMemoryBindInfo :: struct #copy {
    image : VkImage = default
    bindCount : uint32_t = default
    pBinds : ^mut VkSparseMemoryBind = default
}
VkImageSubresource :: struct #copy {
    aspectMask : VkImageAspectFlags = default
    mipLevel : uint32_t = default
    arrayLayer : uint32_t = default
}
VkSparseImageMemoryBind :: struct #copy {
    subresource : VkImageSubresource = default
    offset : VkOffset3D = default
    extent : VkExtent3D = default
    memory : VkDeviceMemory = default
    memoryOffset : VkDeviceSize = default
    flags : VkSparseMemoryBindFlags = default
}
VkSparseImageMemoryBindInfo :: struct #copy {
    image : VkImage = default
    bindCount : uint32_t = default
    pBinds : ^mut VkSparseImageMemoryBind = default
}
VkBindSparseInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    waitSemaphoreCount : uint32_t = default
    pWaitSemaphores : ^mut VkSemaphore = default
    bufferBindCount : uint32_t = default
    pBufferBinds : ^mut VkSparseBufferMemoryBindInfo = default
    imageOpaqueBindCount : uint32_t = default
    pImageOpaqueBinds : ^mut VkSparseImageOpaqueMemoryBindInfo = default
    imageBindCount : uint32_t = default
    pImageBinds : ^mut VkSparseImageMemoryBindInfo = default
    signalSemaphoreCount : uint32_t = default
    pSignalSemaphores : ^mut VkSemaphore = default
}
VkSparseImageFormatProperties :: struct #copy {
    aspectMask : VkImageAspectFlags = default
    imageGranularity : VkExtent3D = default
    flags : VkSparseImageFormatFlags = default
}
VkSparseImageMemoryRequirements :: struct #copy {
    formatProperties : VkSparseImageFormatProperties = default
    imageMipTailFirstLod : uint32_t = default
    imageMipTailSize : VkDeviceSize = default
    imageMipTailOffset : VkDeviceSize = default
    imageMipTailStride : VkDeviceSize = default
}
VkFenceCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkFenceCreateFlags = default
}
VkSemaphoreCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkSemaphoreCreateFlags = default
}
VkEventCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkEventCreateFlags = default
}
VkQueryPoolCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkQueryPoolCreateFlags = default
    queryType : VkQueryType = default
    queryCount : uint32_t = default
    pipelineStatistics : VkQueryPipelineStatisticFlags = default
}
VkBufferCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkBufferCreateFlags = default
    size : VkDeviceSize = default
    usage : VkBufferUsageFlags = default
    sharingMode : VkSharingMode = default
    queueFamilyIndexCount : uint32_t = default
    pQueueFamilyIndices : ^mut uint32_t = default
}
VkBufferViewCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkBufferViewCreateFlags = default
    buffer : VkBuffer = default
    format : VkFormat = default
    offset : VkDeviceSize = default
    range : VkDeviceSize = default
}
VkImageCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkImageCreateFlags = default
    imageType : VkImageType = default
    format : VkFormat = default
    extent : VkExtent3D = default
    mipLevels : uint32_t = default
    arrayLayers : uint32_t = default
    samples : VkSampleCountFlagBits = default
    tiling : VkImageTiling = default
    usage : VkImageUsageFlags = default
    sharingMode : VkSharingMode = default
    queueFamilyIndexCount : uint32_t = default
    pQueueFamilyIndices : ^mut uint32_t = default
    initialLayout : VkImageLayout = default
}
VkSubresourceLayout :: struct #copy {
    offset : VkDeviceSize = default
    size : VkDeviceSize = default
    rowPitch : VkDeviceSize = default
    arrayPitch : VkDeviceSize = default
    depthPitch : VkDeviceSize = default
}
VkComponentMapping :: struct #copy {
    r : VkComponentSwizzle = default
    g : VkComponentSwizzle = default
    b : VkComponentSwizzle = default
    a : VkComponentSwizzle = default
}
VkImageViewCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkImageViewCreateFlags = default
    image : VkImage = default
    viewType : VkImageViewType = default
    format : VkFormat = default
    components : VkComponentMapping = default
    subresourceRange : VkImageSubresourceRange = default
}
VkShaderModuleCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkShaderModuleCreateFlags = default
    codeSize : size_t = default
    pCode : ^mut uint32_t = default
}
VkPipelineCacheCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCacheCreateFlags = default
    initialDataSize : size_t = default
    pInitialData : ^mut void = default
}
VkSpecializationMapEntry :: struct #copy {
    constantID : uint32_t = default
    offset : uint32_t = default
    size : size_t = default
}
VkSpecializationInfo :: struct #copy {
    mapEntryCount : uint32_t = default
    pMapEntries : ^mut VkSpecializationMapEntry = default
    dataSize : size_t = default
    pData : ^mut void = default
}
VkPipelineShaderStageCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineShaderStageCreateFlags = default
    stage : VkShaderStageFlagBits = default
    module : VkShaderModule = default
    pName : ^mut char8 = default
    pSpecializationInfo : ^mut VkSpecializationInfo = default
}
VkComputePipelineCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCreateFlags = default
    stage : VkPipelineShaderStageCreateInfo = default
    layout : VkPipelineLayout = default
    basePipelineHandle : VkPipeline = default
    basePipelineIndex : int32_t = default
}
VkVertexInputBindingDescription :: struct #copy {
    binding : uint32_t = default
    stride : uint32_t = default
    inputRate : VkVertexInputRate = default
}
VkVertexInputAttributeDescription :: struct #copy {
    location : uint32_t = default
    binding : uint32_t = default
    format : VkFormat = default
    offset : uint32_t = default
}
VkPipelineVertexInputStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineVertexInputStateCreateFlags = default
    vertexBindingDescriptionCount : uint32_t = default
    pVertexBindingDescriptions : ^mut VkVertexInputBindingDescription = default
    vertexAttributeDescriptionCount : uint32_t = default
    pVertexAttributeDescriptions : ^mut VkVertexInputAttributeDescription = default
}
VkPipelineInputAssemblyStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineInputAssemblyStateCreateFlags = default
    topology : VkPrimitiveTopology = default
    primitiveRestartEnable : VkBool32 = default
}
VkPipelineTessellationStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineTessellationStateCreateFlags = default
    patchControlPoints : uint32_t = default
}
VkViewport :: struct #copy {
    x : f32 = default
    y : f32 = default
    width : f32 = default
    height : f32 = default
    minDepth : f32 = default
    maxDepth : f32 = default
}
VkPipelineViewportStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineViewportStateCreateFlags = default
    viewportCount : uint32_t = default
    pViewports : ^mut VkViewport = default
    scissorCount : uint32_t = default
    pScissors : ^mut VkRect2D = default
}
VkPipelineRasterizationStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineRasterizationStateCreateFlags = default
    depthClampEnable : VkBool32 = default
    rasterizerDiscardEnable : VkBool32 = default
    polygonMode : VkPolygonMode = default
    cullMode : VkCullModeFlags = default
    frontFace : VkFrontFace = default
    depthBiasEnable : VkBool32 = default
    depthBiasConstantFactor : f32 = default
    depthBiasClamp : f32 = default
    depthBiasSlopeFactor : f32 = default
    lineWidth : f32 = default
}
VkPipelineMultisampleStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineMultisampleStateCreateFlags = default
    rasterizationSamples : VkSampleCountFlagBits = default
    sampleShadingEnable : VkBool32 = default
    minSampleShading : f32 = default
    pSampleMask : ^mut VkSampleMask = default
    alphaToCoverageEnable : VkBool32 = default
    alphaToOneEnable : VkBool32 = default
}
VkStencilOpState :: struct #copy {
    failOp : VkStencilOp = default
    passOp : VkStencilOp = default
    depthFailOp : VkStencilOp = default
    compareOp : VkCompareOp = default
    compareMask : uint32_t = default
    writeMask : uint32_t = default
    reference : uint32_t = default
}
VkPipelineDepthStencilStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineDepthStencilStateCreateFlags = default
    depthTestEnable : VkBool32 = default
    depthWriteEnable : VkBool32 = default
    depthCompareOp : VkCompareOp = default
    depthBoundsTestEnable : VkBool32 = default
    stencilTestEnable : VkBool32 = default
    front : VkStencilOpState = default
    back : VkStencilOpState = default
    minDepthBounds : f32 = default
    maxDepthBounds : f32 = default
}
VkPipelineColorBlendAttachmentState :: struct #copy {
    blendEnable : VkBool32 = default
    srcColorBlendFactor : VkBlendFactor = default
    dstColorBlendFactor : VkBlendFactor = default
    colorBlendOp : VkBlendOp = default
    srcAlphaBlendFactor : VkBlendFactor = default
    dstAlphaBlendFactor : VkBlendFactor = default
    alphaBlendOp : VkBlendOp = default
    colorWriteMask : VkColorComponentFlags = default
}
VkPipelineColorBlendStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineColorBlendStateCreateFlags = default
    logicOpEnable : VkBool32 = default
    logicOp : VkLogicOp = default
    attachmentCount : uint32_t = default
    pAttachments : ^mut VkPipelineColorBlendAttachmentState = default
    blendConstants : [4]f32 = default
}
VkPipelineDynamicStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineDynamicStateCreateFlags = default
    dynamicStateCount : uint32_t = default
    pDynamicStates : ^mut VkDynamicState = default
}
VkGraphicsPipelineCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCreateFlags = default
    stageCount : uint32_t = default
    pStages : ^mut VkPipelineShaderStageCreateInfo = default
    pVertexInputState : ^mut VkPipelineVertexInputStateCreateInfo = default
    pInputAssemblyState : ^mut VkPipelineInputAssemblyStateCreateInfo = default
    pTessellationState : ^mut VkPipelineTessellationStateCreateInfo = default
    pViewportState : ^mut VkPipelineViewportStateCreateInfo = default
    pRasterizationState : ^mut VkPipelineRasterizationStateCreateInfo = default
    pMultisampleState : ^mut VkPipelineMultisampleStateCreateInfo = default
    pDepthStencilState : ^mut VkPipelineDepthStencilStateCreateInfo = default
    pColorBlendState : ^mut VkPipelineColorBlendStateCreateInfo = default
    pDynamicState : ^mut VkPipelineDynamicStateCreateInfo = default
    layout : VkPipelineLayout = default
    renderPass : VkRenderPass = default
    subpass : uint32_t = default
    basePipelineHandle : VkPipeline = default
    basePipelineIndex : int32_t = default
}
VkPushConstantRange :: struct #copy {
    stageFlags : VkShaderStageFlags = default
    offset : uint32_t = default
    size : uint32_t = default
}
VkPipelineLayoutCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineLayoutCreateFlags = default
    setLayoutCount : uint32_t = default
    pSetLayouts : ^mut VkDescriptorSetLayout = default
    pushConstantRangeCount : uint32_t = default
    pPushConstantRanges : ^mut VkPushConstantRange = default
}
VkSamplerCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkSamplerCreateFlags = default
    magFilter : VkFilter = default
    minFilter : VkFilter = default
    mipmapMode : VkSamplerMipmapMode = default
    addressModeU : VkSamplerAddressMode = default
    addressModeV : VkSamplerAddressMode = default
    addressModeW : VkSamplerAddressMode = default
    mipLodBias : f32 = default
    anisotropyEnable : VkBool32 = default
    maxAnisotropy : f32 = default
    compareEnable : VkBool32 = default
    compareOp : VkCompareOp = default
    minLod : f32 = default
    maxLod : f32 = default
    borderColor : VkBorderColor = default
    unnormalizedCoordinates : VkBool32 = default
}
VkCopyDescriptorSet :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcSet : VkDescriptorSet = default
    srcBinding : uint32_t = default
    srcArrayElement : uint32_t = default
    dstSet : VkDescriptorSet = default
    dstBinding : uint32_t = default
    dstArrayElement : uint32_t = default
    descriptorCount : uint32_t = default
}
VkDescriptorBufferInfo :: struct #copy {
    buffer : VkBuffer = default
    offset : VkDeviceSize = default
    range : VkDeviceSize = default
}
VkDescriptorImageInfo :: struct #copy {
    sampler : VkSampler = default
    imageView : VkImageView = default
    imageLayout : VkImageLayout = default
}
VkDescriptorPoolSize :: struct #copy {
    type : VkDescriptorType = default
    descriptorCount : uint32_t = default
}
VkDescriptorPoolCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDescriptorPoolCreateFlags = default
    maxSets : uint32_t = default
    poolSizeCount : uint32_t = default
    pPoolSizes : ^mut VkDescriptorPoolSize = default
}
VkDescriptorSetAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    descriptorPool : VkDescriptorPool = default
    descriptorSetCount : uint32_t = default
    pSetLayouts : ^mut VkDescriptorSetLayout = default
}
VkDescriptorSetLayoutBinding :: struct #copy {
    binding : uint32_t = default
    descriptorType : VkDescriptorType = default
    descriptorCount : uint32_t = default
    stageFlags : VkShaderStageFlags = default
    pImmutableSamplers : ^mut VkSampler = default
}
VkDescriptorSetLayoutCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDescriptorSetLayoutCreateFlags = default
    bindingCount : uint32_t = default
    pBindings : ^mut VkDescriptorSetLayoutBinding = default
}
VkWriteDescriptorSet :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    dstSet : VkDescriptorSet = default
    dstBinding : uint32_t = default
    dstArrayElement : uint32_t = default
    descriptorCount : uint32_t = default
    descriptorType : VkDescriptorType = default
    pImageInfo : ^mut VkDescriptorImageInfo = default
    pBufferInfo : ^mut VkDescriptorBufferInfo = default
    pTexelBufferView : ^mut VkBufferView = default
}
VkAttachmentDescription :: struct #copy {
    flags : VkAttachmentDescriptionFlags = default
    format : VkFormat = default
    samples : VkSampleCountFlagBits = default
    loadOp : VkAttachmentLoadOp = default
    storeOp : VkAttachmentStoreOp = default
    stencilLoadOp : VkAttachmentLoadOp = default
    stencilStoreOp : VkAttachmentStoreOp = default
    initialLayout : VkImageLayout = default
    finalLayout : VkImageLayout = default
}
VkAttachmentReference :: struct #copy {
    attachment : uint32_t = default
    layout : VkImageLayout = default
}
VkFramebufferCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkFramebufferCreateFlags = default
    renderPass : VkRenderPass = default
    attachmentCount : uint32_t = default
    pAttachments : ^mut VkImageView = default
    width : uint32_t = default
    height : uint32_t = default
    layers : uint32_t = default
}
VkSubpassDescription :: struct #copy {
    flags : VkSubpassDescriptionFlags = default
    pipelineBindPoint : VkPipelineBindPoint = default
    inputAttachmentCount : uint32_t = default
    pInputAttachments : ^mut VkAttachmentReference = default
    colorAttachmentCount : uint32_t = default
    pColorAttachments : ^mut VkAttachmentReference = default
    pResolveAttachments : ^mut VkAttachmentReference = default
    pDepthStencilAttachment : ^mut VkAttachmentReference = default
    preserveAttachmentCount : uint32_t = default
    pPreserveAttachments : ^mut uint32_t = default
}
VkSubpassDependency :: struct #copy {
    srcSubpass : uint32_t = default
    dstSubpass : uint32_t = default
    srcStageMask : VkPipelineStageFlags = default
    dstStageMask : VkPipelineStageFlags = default
    srcAccessMask : VkAccessFlags = default
    dstAccessMask : VkAccessFlags = default
    dependencyFlags : VkDependencyFlags = default
}
VkRenderPassCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkRenderPassCreateFlags = default
    attachmentCount : uint32_t = default
    pAttachments : ^mut VkAttachmentDescription = default
    subpassCount : uint32_t = default
    pSubpasses : ^mut VkSubpassDescription = default
    dependencyCount : uint32_t = default
    pDependencies : ^mut VkSubpassDependency = default
}
VkCommandPoolCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkCommandPoolCreateFlags = default
    queueFamilyIndex : uint32_t = default
}
VkCommandBufferAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    commandPool : VkCommandPool = default
    level : VkCommandBufferLevel = default
    commandBufferCount : uint32_t = default
}
VkCommandBufferInheritanceInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    renderPass : VkRenderPass = default
    subpass : uint32_t = default
    framebuffer : VkFramebuffer = default
    occlusionQueryEnable : VkBool32 = default
    queryFlags : VkQueryControlFlags = default
    pipelineStatistics : VkQueryPipelineStatisticFlags = default
}
VkCommandBufferBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkCommandBufferUsageFlags = default
    pInheritanceInfo : ^mut VkCommandBufferInheritanceInfo = default
}
VkBufferCopy :: struct #copy {
    srcOffset : VkDeviceSize = default
    dstOffset : VkDeviceSize = default
    size : VkDeviceSize = default
}
VkImageSubresourceLayers :: struct #copy {
    aspectMask : VkImageAspectFlags = default
    mipLevel : uint32_t = default
    baseArrayLayer : uint32_t = default
    layerCount : uint32_t = default
}
VkBufferImageCopy :: struct #copy {
    bufferOffset : VkDeviceSize = default
    bufferRowLength : uint32_t = default
    bufferImageHeight : uint32_t = default
    imageSubresource : VkImageSubresourceLayers = default
    imageOffset : VkOffset3D = default
    imageExtent : VkExtent3D = default
}
VkClearDepthStencilValue :: struct #copy {
    depth : f32 = default
    stencil : uint32_t = default
}
VkClearAttachment :: struct #copy {
    aspectMask : VkImageAspectFlags = default
    colorAttachment : uint32_t = default
    clearValue : VkClearValue = default
}
VkClearRect :: struct #copy {
    rect : VkRect2D = default
    baseArrayLayer : uint32_t = default
    layerCount : uint32_t = default
}
VkImageBlit :: struct #copy {
    srcSubresource : VkImageSubresourceLayers = default
    srcOffsets : [2]VkOffset3D = default
    dstSubresource : VkImageSubresourceLayers = default
    dstOffsets : [2]VkOffset3D = default
}
VkImageCopy :: struct #copy {
    srcSubresource : VkImageSubresourceLayers = default
    srcOffset : VkOffset3D = default
    dstSubresource : VkImageSubresourceLayers = default
    dstOffset : VkOffset3D = default
    extent : VkExtent3D = default
}
VkImageResolve :: struct #copy {
    srcSubresource : VkImageSubresourceLayers = default
    srcOffset : VkOffset3D = default
    dstSubresource : VkImageSubresourceLayers = default
    dstOffset : VkOffset3D = default
    extent : VkExtent3D = default
}
VkRenderPassBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    renderPass : VkRenderPass = default
    framebuffer : VkFramebuffer = default
    renderArea : VkRect2D = default
    clearValueCount : uint32_t = default
    pClearValues : ^mut VkClearValue = default
}
VkPhysicalDeviceSubgroupProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    subgroupSize : uint32_t = default
    supportedStages : VkShaderStageFlags = default
    supportedOperations : VkSubgroupFeatureFlags = default
    quadOperationsInAllStages : VkBool32 = default
}
VkBindBufferMemoryInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    buffer : VkBuffer = default
    memory : VkDeviceMemory = default
    memoryOffset : VkDeviceSize = default
}
VkBindImageMemoryInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    image : VkImage = default
    memory : VkDeviceMemory = default
    memoryOffset : VkDeviceSize = default
}
VkPhysicalDevice16BitStorageFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    storageBuffer16BitAccess : VkBool32 = default
    uniformAndStorageBuffer16BitAccess : VkBool32 = default
    storagePushConstant16 : VkBool32 = default
    storageInputOutput16 : VkBool32 = default
}
VkMemoryDedicatedRequirements :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    prefersDedicatedAllocation : VkBool32 = default
    requiresDedicatedAllocation : VkBool32 = default
}
VkMemoryDedicatedAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    image : VkImage = default
    buffer : VkBuffer = default
}
VkMemoryAllocateFlagsInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkMemoryAllocateFlags = default
    deviceMask : uint32_t = default
}
VkDeviceGroupRenderPassBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceMask : uint32_t = default
    deviceRenderAreaCount : uint32_t = default
    pDeviceRenderAreas : ^mut VkRect2D = default
}
VkDeviceGroupCommandBufferBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceMask : uint32_t = default
}
VkDeviceGroupSubmitInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    waitSemaphoreCount : uint32_t = default
    pWaitSemaphoreDeviceIndices : ^mut uint32_t = default
    commandBufferCount : uint32_t = default
    pCommandBufferDeviceMasks : ^mut uint32_t = default
    signalSemaphoreCount : uint32_t = default
    pSignalSemaphoreDeviceIndices : ^mut uint32_t = default
}
VkDeviceGroupBindSparseInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    resourceDeviceIndex : uint32_t = default
    memoryDeviceIndex : uint32_t = default
}
VkBindBufferMemoryDeviceGroupInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceIndexCount : uint32_t = default
    pDeviceIndices : ^mut uint32_t = default
}
VkBindImageMemoryDeviceGroupInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceIndexCount : uint32_t = default
    pDeviceIndices : ^mut uint32_t = default
    splitInstanceBindRegionCount : uint32_t = default
    pSplitInstanceBindRegions : ^mut VkRect2D = default
}
VkPhysicalDeviceGroupProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    physicalDeviceCount : uint32_t = default
    physicalDevices : [32]VkPhysicalDevice = default
    subsetAllocation : VkBool32 = default
}
VkDeviceGroupDeviceCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    physicalDeviceCount : uint32_t = default
    pPhysicalDevices : ^mut VkPhysicalDevice = default
}
VkBufferMemoryRequirementsInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    buffer : VkBuffer = default
}
VkImageMemoryRequirementsInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    image : VkImage = default
}
VkImageSparseMemoryRequirementsInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    image : VkImage = default
}
VkMemoryRequirements2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryRequirements : VkMemoryRequirements = default
}
VkSparseImageMemoryRequirements2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryRequirements : VkSparseImageMemoryRequirements = default
}
VkPhysicalDeviceFeatures2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    features : VkPhysicalDeviceFeatures = default
}
VkPhysicalDeviceProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    properties : VkPhysicalDeviceProperties = default
}
VkFormatProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    formatProperties : VkFormatProperties = default
}
VkImageFormatProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    imageFormatProperties : VkImageFormatProperties = default
}
VkPhysicalDeviceImageFormatInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    format : VkFormat = default
    type : VkImageType = default
    tiling : VkImageTiling = default
    usage : VkImageUsageFlags = default
    flags : VkImageCreateFlags = default
}
VkQueueFamilyProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    queueFamilyProperties : VkQueueFamilyProperties = default
}
VkPhysicalDeviceMemoryProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryProperties : VkPhysicalDeviceMemoryProperties = default
}
VkSparseImageFormatProperties2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    properties : VkSparseImageFormatProperties = default
}
VkPhysicalDeviceSparseImageFormatInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    format : VkFormat = default
    type : VkImageType = default
    samples : VkSampleCountFlagBits = default
    usage : VkImageUsageFlags = default
    tiling : VkImageTiling = default
}
VkPhysicalDevicePointClippingProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pointClippingBehavior : VkPointClippingBehavior = default
}
VkInputAttachmentAspectReference :: struct #copy {
    subpass : uint32_t = default
    inputAttachmentIndex : uint32_t = default
    aspectMask : VkImageAspectFlags = default
}
VkRenderPassInputAttachmentAspectCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    aspectReferenceCount : uint32_t = default
    pAspectReferences : ^mut VkInputAttachmentAspectReference = default
}
VkImageViewUsageCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    usage : VkImageUsageFlags = default
}
VkPipelineTessellationDomainOriginStateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    domainOrigin : VkTessellationDomainOrigin = default
}
VkRenderPassMultiviewCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    subpassCount : uint32_t = default
    pViewMasks : ^mut uint32_t = default
    dependencyCount : uint32_t = default
    pViewOffsets : ^mut int32_t = default
    correlationMaskCount : uint32_t = default
    pCorrelationMasks : ^mut uint32_t = default
}
VkPhysicalDeviceMultiviewFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    multiview : VkBool32 = default
    multiviewGeometryShader : VkBool32 = default
    multiviewTessellationShader : VkBool32 = default
}
VkPhysicalDeviceMultiviewProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxMultiviewViewCount : uint32_t = default
    maxMultiviewInstanceIndex : uint32_t = default
}
VkPhysicalDeviceVariablePointersFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    variablePointersStorageBuffer : VkBool32 = default
    variablePointers : VkBool32 = default
}
VkPhysicalDeviceProtectedMemoryFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    protectedMemory : VkBool32 = default
}
VkPhysicalDeviceProtectedMemoryProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    protectedNoFault : VkBool32 = default
}
VkDeviceQueueInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDeviceQueueCreateFlags = default
    queueFamilyIndex : uint32_t = default
    queueIndex : uint32_t = default
}
VkProtectedSubmitInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    protectedSubmit : VkBool32 = default
}
VkSamplerYcbcrConversionCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    format : VkFormat = default
    ycbcrModel : VkSamplerYcbcrModelConversion = default
    ycbcrRange : VkSamplerYcbcrRange = default
    components : VkComponentMapping = default
    xChromaOffset : VkChromaLocation = default
    yChromaOffset : VkChromaLocation = default
    chromaFilter : VkFilter = default
    forceExplicitReconstruction : VkBool32 = default
}
VkSamplerYcbcrConversionInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    conversion : VkSamplerYcbcrConversion = default
}
VkBindImagePlaneMemoryInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    planeAspect : VkImageAspectFlagBits = default
}
VkImagePlaneMemoryRequirementsInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    planeAspect : VkImageAspectFlagBits = default
}
VkPhysicalDeviceSamplerYcbcrConversionFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    samplerYcbcrConversion : VkBool32 = default
}
VkSamplerYcbcrConversionImageFormatProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    combinedImageSamplerDescriptorCount : uint32_t = default
}
VkDescriptorUpdateTemplateEntry :: struct #copy {
    dstBinding : uint32_t = default
    dstArrayElement : uint32_t = default
    descriptorCount : uint32_t = default
    descriptorType : VkDescriptorType = default
    offset : size_t = default
    stride : size_t = default
}
VkDescriptorUpdateTemplateCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDescriptorUpdateTemplateCreateFlags = default
    descriptorUpdateEntryCount : uint32_t = default
    pDescriptorUpdateEntries : ^mut VkDescriptorUpdateTemplateEntry = default
    templateType : VkDescriptorUpdateTemplateType = default
    descriptorSetLayout : VkDescriptorSetLayout = default
    pipelineBindPoint : VkPipelineBindPoint = default
    pipelineLayout : VkPipelineLayout = default
    set : uint32_t = default
}
VkExternalMemoryProperties :: struct #copy {
    externalMemoryFeatures : VkExternalMemoryFeatureFlags = default
    exportFromImportedHandleTypes : VkExternalMemoryHandleTypeFlags = default
    compatibleHandleTypes : VkExternalMemoryHandleTypeFlags = default
}
VkPhysicalDeviceExternalImageFormatInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleType : VkExternalMemoryHandleTypeFlagBits = default
}
VkExternalImageFormatProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    externalMemoryProperties : VkExternalMemoryProperties = default
}
VkPhysicalDeviceExternalBufferInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkBufferCreateFlags = default
    usage : VkBufferUsageFlags = default
    handleType : VkExternalMemoryHandleTypeFlagBits = default
}
VkExternalBufferProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    externalMemoryProperties : VkExternalMemoryProperties = default
}
VkPhysicalDeviceIDProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceUUID : [16]uint8_t = default
    driverUUID : [16]uint8_t = default
    deviceLUID : [8]uint8_t = default
    deviceNodeMask : uint32_t = default
    deviceLUIDValid : VkBool32 = default
}
VkExternalMemoryImageCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalMemoryHandleTypeFlags = default
}
VkExternalMemoryBufferCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalMemoryHandleTypeFlags = default
}
VkExportMemoryAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalMemoryHandleTypeFlags = default
}
VkPhysicalDeviceExternalFenceInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleType : VkExternalFenceHandleTypeFlagBits = default
}
VkExternalFenceProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    exportFromImportedHandleTypes : VkExternalFenceHandleTypeFlags = default
    compatibleHandleTypes : VkExternalFenceHandleTypeFlags = default
    externalFenceFeatures : VkExternalFenceFeatureFlags = default
}
VkExportFenceCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalFenceHandleTypeFlags = default
}
VkExportSemaphoreCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalSemaphoreHandleTypeFlags = default
}
VkPhysicalDeviceExternalSemaphoreInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleType : VkExternalSemaphoreHandleTypeFlagBits = default
}
VkExternalSemaphoreProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    exportFromImportedHandleTypes : VkExternalSemaphoreHandleTypeFlags = default
    compatibleHandleTypes : VkExternalSemaphoreHandleTypeFlags = default
    externalSemaphoreFeatures : VkExternalSemaphoreFeatureFlags = default
}
VkPhysicalDeviceMaintenance3Properties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxPerSetDescriptors : uint32_t = default
    maxMemoryAllocationSize : VkDeviceSize = default
}
VkDescriptorSetLayoutSupport :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    supported : VkBool32 = default
}
VkPhysicalDeviceShaderDrawParametersFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderDrawParameters : VkBool32 = default
}
VkPhysicalDeviceVulkan11Features :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    storageBuffer16BitAccess : VkBool32 = default
    uniformAndStorageBuffer16BitAccess : VkBool32 = default
    storagePushConstant16 : VkBool32 = default
    storageInputOutput16 : VkBool32 = default
    multiview : VkBool32 = default
    multiviewGeometryShader : VkBool32 = default
    multiviewTessellationShader : VkBool32 = default
    variablePointersStorageBuffer : VkBool32 = default
    variablePointers : VkBool32 = default
    protectedMemory : VkBool32 = default
    samplerYcbcrConversion : VkBool32 = default
    shaderDrawParameters : VkBool32 = default
}
VkPhysicalDeviceVulkan11Properties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceUUID : [16]uint8_t = default
    driverUUID : [16]uint8_t = default
    deviceLUID : [8]uint8_t = default
    deviceNodeMask : uint32_t = default
    deviceLUIDValid : VkBool32 = default
    subgroupSize : uint32_t = default
    subgroupSupportedStages : VkShaderStageFlags = default
    subgroupSupportedOperations : VkSubgroupFeatureFlags = default
    subgroupQuadOperationsInAllStages : VkBool32 = default
    pointClippingBehavior : VkPointClippingBehavior = default
    maxMultiviewViewCount : uint32_t = default
    maxMultiviewInstanceIndex : uint32_t = default
    protectedNoFault : VkBool32 = default
    maxPerSetDescriptors : uint32_t = default
    maxMemoryAllocationSize : VkDeviceSize = default
}
VkPhysicalDeviceVulkan12Features :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    samplerMirrorClampToEdge : VkBool32 = default
    drawIndirectCount : VkBool32 = default
    storageBuffer8BitAccess : VkBool32 = default
    uniformAndStorageBuffer8BitAccess : VkBool32 = default
    storagePushConstant8 : VkBool32 = default
    shaderBufferInt64Atomics : VkBool32 = default
    shaderSharedInt64Atomics : VkBool32 = default
    shaderFloat16 : VkBool32 = default
    shaderInt8 : VkBool32 = default
    descriptorIndexing : VkBool32 = default
    shaderInputAttachmentArrayDynamicIndexing : VkBool32 = default
    shaderUniformTexelBufferArrayDynamicIndexing : VkBool32 = default
    shaderStorageTexelBufferArrayDynamicIndexing : VkBool32 = default
    shaderUniformBufferArrayNonUniformIndexing : VkBool32 = default
    shaderSampledImageArrayNonUniformIndexing : VkBool32 = default
    shaderStorageBufferArrayNonUniformIndexing : VkBool32 = default
    shaderStorageImageArrayNonUniformIndexing : VkBool32 = default
    shaderInputAttachmentArrayNonUniformIndexing : VkBool32 = default
    shaderUniformTexelBufferArrayNonUniformIndexing : VkBool32 = default
    shaderStorageTexelBufferArrayNonUniformIndexing : VkBool32 = default
    descriptorBindingUniformBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingSampledImageUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageImageUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingUniformTexelBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageTexelBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingUpdateUnusedWhilePending : VkBool32 = default
    descriptorBindingPartiallyBound : VkBool32 = default
    descriptorBindingVariableDescriptorCount : VkBool32 = default
    runtimeDescriptorArray : VkBool32 = default
    samplerFilterMinmax : VkBool32 = default
    scalarBlockLayout : VkBool32 = default
    imagelessFramebuffer : VkBool32 = default
    uniformBufferStandardLayout : VkBool32 = default
    shaderSubgroupExtendedTypes : VkBool32 = default
    separateDepthStencilLayouts : VkBool32 = default
    hostQueryReset : VkBool32 = default
    timelineSemaphore : VkBool32 = default
    bufferDeviceAddress : VkBool32 = default
    bufferDeviceAddressCaptureReplay : VkBool32 = default
    bufferDeviceAddressMultiDevice : VkBool32 = default
    vulkanMemoryModel : VkBool32 = default
    vulkanMemoryModelDeviceScope : VkBool32 = default
    vulkanMemoryModelAvailabilityVisibilityChains : VkBool32 = default
    shaderOutputViewportIndex : VkBool32 = default
    shaderOutputLayer : VkBool32 = default
    subgroupBroadcastDynamicId : VkBool32 = default
}
VkConformanceVersion :: struct #copy {
    major : uint8_t = default
    minor : uint8_t = default
    subminor : uint8_t = default
    patch : uint8_t = default
}
VkPhysicalDeviceVulkan12Properties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    driverID : VkDriverId = default
    driverName : [256]char8 = default
    driverInfo : [256]char8 = default
    conformanceVersion : VkConformanceVersion = default
    denormBehaviorIndependence : VkShaderFloatControlsIndependence = default
    roundingModeIndependence : VkShaderFloatControlsIndependence = default
    shaderSignedZeroInfNanPreserveFloat16 : VkBool32 = default
    shaderSignedZeroInfNanPreserveFloat32 : VkBool32 = default
    shaderSignedZeroInfNanPreserveFloat64 : VkBool32 = default
    shaderDenormPreserveFloat16 : VkBool32 = default
    shaderDenormPreserveFloat32 : VkBool32 = default
    shaderDenormPreserveFloat64 : VkBool32 = default
    shaderDenormFlushToZeroFloat16 : VkBool32 = default
    shaderDenormFlushToZeroFloat32 : VkBool32 = default
    shaderDenormFlushToZeroFloat64 : VkBool32 = default
    shaderRoundingModeRTEFloat16 : VkBool32 = default
    shaderRoundingModeRTEFloat32 : VkBool32 = default
    shaderRoundingModeRTEFloat64 : VkBool32 = default
    shaderRoundingModeRTZFloat16 : VkBool32 = default
    shaderRoundingModeRTZFloat32 : VkBool32 = default
    shaderRoundingModeRTZFloat64 : VkBool32 = default
    maxUpdateAfterBindDescriptorsInAllPools : uint32_t = default
    shaderUniformBufferArrayNonUniformIndexingNative : VkBool32 = default
    shaderSampledImageArrayNonUniformIndexingNative : VkBool32 = default
    shaderStorageBufferArrayNonUniformIndexingNative : VkBool32 = default
    shaderStorageImageArrayNonUniformIndexingNative : VkBool32 = default
    shaderInputAttachmentArrayNonUniformIndexingNative : VkBool32 = default
    robustBufferAccessUpdateAfterBind : VkBool32 = default
    quadDivergentImplicitLod : VkBool32 = default
    maxPerStageDescriptorUpdateAfterBindSamplers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindUniformBuffers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindStorageBuffers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindSampledImages : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindStorageImages : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindInputAttachments : uint32_t = default
    maxPerStageUpdateAfterBindResources : uint32_t = default
    maxDescriptorSetUpdateAfterBindSamplers : uint32_t = default
    maxDescriptorSetUpdateAfterBindUniformBuffers : uint32_t = default
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageBuffers : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic : uint32_t = default
    maxDescriptorSetUpdateAfterBindSampledImages : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageImages : uint32_t = default
    maxDescriptorSetUpdateAfterBindInputAttachments : uint32_t = default
    supportedDepthResolveModes : VkResolveModeFlags = default
    supportedStencilResolveModes : VkResolveModeFlags = default
    independentResolveNone : VkBool32 = default
    independentResolve : VkBool32 = default
    filterMinmaxSingleComponentFormats : VkBool32 = default
    filterMinmaxImageComponentMapping : VkBool32 = default
    maxTimelineSemaphoreValueDifference : uint64_t = default
    framebufferIntegerColorSampleCounts : VkSampleCountFlags = default
}
VkImageFormatListCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    viewFormatCount : uint32_t = default
    pViewFormats : ^mut VkFormat = default
}
VkAttachmentDescription2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkAttachmentDescriptionFlags = default
    format : VkFormat = default
    samples : VkSampleCountFlagBits = default
    loadOp : VkAttachmentLoadOp = default
    storeOp : VkAttachmentStoreOp = default
    stencilLoadOp : VkAttachmentLoadOp = default
    stencilStoreOp : VkAttachmentStoreOp = default
    initialLayout : VkImageLayout = default
    finalLayout : VkImageLayout = default
}
VkAttachmentReference2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    attachment : uint32_t = default
    layout : VkImageLayout = default
    aspectMask : VkImageAspectFlags = default
}
VkSubpassDescription2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkSubpassDescriptionFlags = default
    pipelineBindPoint : VkPipelineBindPoint = default
    viewMask : uint32_t = default
    inputAttachmentCount : uint32_t = default
    pInputAttachments : ^mut VkAttachmentReference2 = default
    colorAttachmentCount : uint32_t = default
    pColorAttachments : ^mut VkAttachmentReference2 = default
    pResolveAttachments : ^mut VkAttachmentReference2 = default
    pDepthStencilAttachment : ^mut VkAttachmentReference2 = default
    preserveAttachmentCount : uint32_t = default
    pPreserveAttachments : ^mut uint32_t = default
}
VkSubpassDependency2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcSubpass : uint32_t = default
    dstSubpass : uint32_t = default
    srcStageMask : VkPipelineStageFlags = default
    dstStageMask : VkPipelineStageFlags = default
    srcAccessMask : VkAccessFlags = default
    dstAccessMask : VkAccessFlags = default
    dependencyFlags : VkDependencyFlags = default
    viewOffset : int32_t = default
}
VkRenderPassCreateInfo2 :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkRenderPassCreateFlags = default
    attachmentCount : uint32_t = default
    pAttachments : ^mut VkAttachmentDescription2 = default
    subpassCount : uint32_t = default
    pSubpasses : ^mut VkSubpassDescription2 = default
    dependencyCount : uint32_t = default
    pDependencies : ^mut VkSubpassDependency2 = default
    correlatedViewMaskCount : uint32_t = default
    pCorrelatedViewMasks : ^mut uint32_t = default
}
VkSubpassBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    contents : VkSubpassContents = default
}
VkSubpassEndInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
}
VkPhysicalDevice8BitStorageFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    storageBuffer8BitAccess : VkBool32 = default
    uniformAndStorageBuffer8BitAccess : VkBool32 = default
    storagePushConstant8 : VkBool32 = default
}
VkPhysicalDeviceDriverProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    driverID : VkDriverId = default
    driverName : [256]char8 = default
    driverInfo : [256]char8 = default
    conformanceVersion : VkConformanceVersion = default
}
VkPhysicalDeviceShaderAtomicInt64Features :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderBufferInt64Atomics : VkBool32 = default
    shaderSharedInt64Atomics : VkBool32 = default
}
VkPhysicalDeviceShaderFloat16Int8Features :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderFloat16 : VkBool32 = default
    shaderInt8 : VkBool32 = default
}
VkPhysicalDeviceFloatControlsProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    denormBehaviorIndependence : VkShaderFloatControlsIndependence = default
    roundingModeIndependence : VkShaderFloatControlsIndependence = default
    shaderSignedZeroInfNanPreserveFloat16 : VkBool32 = default
    shaderSignedZeroInfNanPreserveFloat32 : VkBool32 = default
    shaderSignedZeroInfNanPreserveFloat64 : VkBool32 = default
    shaderDenormPreserveFloat16 : VkBool32 = default
    shaderDenormPreserveFloat32 : VkBool32 = default
    shaderDenormPreserveFloat64 : VkBool32 = default
    shaderDenormFlushToZeroFloat16 : VkBool32 = default
    shaderDenormFlushToZeroFloat32 : VkBool32 = default
    shaderDenormFlushToZeroFloat64 : VkBool32 = default
    shaderRoundingModeRTEFloat16 : VkBool32 = default
    shaderRoundingModeRTEFloat32 : VkBool32 = default
    shaderRoundingModeRTEFloat64 : VkBool32 = default
    shaderRoundingModeRTZFloat16 : VkBool32 = default
    shaderRoundingModeRTZFloat32 : VkBool32 = default
    shaderRoundingModeRTZFloat64 : VkBool32 = default
}
VkDescriptorSetLayoutBindingFlagsCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    bindingCount : uint32_t = default
    pBindingFlags : ^mut VkDescriptorBindingFlags = default
}
VkPhysicalDeviceDescriptorIndexingFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderInputAttachmentArrayDynamicIndexing : VkBool32 = default
    shaderUniformTexelBufferArrayDynamicIndexing : VkBool32 = default
    shaderStorageTexelBufferArrayDynamicIndexing : VkBool32 = default
    shaderUniformBufferArrayNonUniformIndexing : VkBool32 = default
    shaderSampledImageArrayNonUniformIndexing : VkBool32 = default
    shaderStorageBufferArrayNonUniformIndexing : VkBool32 = default
    shaderStorageImageArrayNonUniformIndexing : VkBool32 = default
    shaderInputAttachmentArrayNonUniformIndexing : VkBool32 = default
    shaderUniformTexelBufferArrayNonUniformIndexing : VkBool32 = default
    shaderStorageTexelBufferArrayNonUniformIndexing : VkBool32 = default
    descriptorBindingUniformBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingSampledImageUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageImageUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingUniformTexelBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingStorageTexelBufferUpdateAfterBind : VkBool32 = default
    descriptorBindingUpdateUnusedWhilePending : VkBool32 = default
    descriptorBindingPartiallyBound : VkBool32 = default
    descriptorBindingVariableDescriptorCount : VkBool32 = default
    runtimeDescriptorArray : VkBool32 = default
}
VkPhysicalDeviceDescriptorIndexingProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxUpdateAfterBindDescriptorsInAllPools : uint32_t = default
    shaderUniformBufferArrayNonUniformIndexingNative : VkBool32 = default
    shaderSampledImageArrayNonUniformIndexingNative : VkBool32 = default
    shaderStorageBufferArrayNonUniformIndexingNative : VkBool32 = default
    shaderStorageImageArrayNonUniformIndexingNative : VkBool32 = default
    shaderInputAttachmentArrayNonUniformIndexingNative : VkBool32 = default
    robustBufferAccessUpdateAfterBind : VkBool32 = default
    quadDivergentImplicitLod : VkBool32 = default
    maxPerStageDescriptorUpdateAfterBindSamplers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindUniformBuffers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindStorageBuffers : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindSampledImages : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindStorageImages : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindInputAttachments : uint32_t = default
    maxPerStageUpdateAfterBindResources : uint32_t = default
    maxDescriptorSetUpdateAfterBindSamplers : uint32_t = default
    maxDescriptorSetUpdateAfterBindUniformBuffers : uint32_t = default
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageBuffers : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic : uint32_t = default
    maxDescriptorSetUpdateAfterBindSampledImages : uint32_t = default
    maxDescriptorSetUpdateAfterBindStorageImages : uint32_t = default
    maxDescriptorSetUpdateAfterBindInputAttachments : uint32_t = default
}
VkDescriptorSetVariableDescriptorCountAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    descriptorSetCount : uint32_t = default
    pDescriptorCounts : ^mut uint32_t = default
}
VkDescriptorSetVariableDescriptorCountLayoutSupport :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxVariableDescriptorCount : uint32_t = default
}
VkSubpassDescriptionDepthStencilResolve :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    depthResolveMode : VkResolveModeFlagBits = default
    stencilResolveMode : VkResolveModeFlagBits = default
    pDepthStencilResolveAttachment : ^mut VkAttachmentReference2 = default
}
VkPhysicalDeviceDepthStencilResolveProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    supportedDepthResolveModes : VkResolveModeFlags = default
    supportedStencilResolveModes : VkResolveModeFlags = default
    independentResolveNone : VkBool32 = default
    independentResolve : VkBool32 = default
}
VkPhysicalDeviceScalarBlockLayoutFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    scalarBlockLayout : VkBool32 = default
}
VkImageStencilUsageCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stencilUsage : VkImageUsageFlags = default
}
VkSamplerReductionModeCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    reductionMode : VkSamplerReductionMode = default
}
VkPhysicalDeviceSamplerFilterMinmaxProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    filterMinmaxSingleComponentFormats : VkBool32 = default
    filterMinmaxImageComponentMapping : VkBool32 = default
}
VkPhysicalDeviceVulkanMemoryModelFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    vulkanMemoryModel : VkBool32 = default
    vulkanMemoryModelDeviceScope : VkBool32 = default
    vulkanMemoryModelAvailabilityVisibilityChains : VkBool32 = default
}
VkPhysicalDeviceImagelessFramebufferFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    imagelessFramebuffer : VkBool32 = default
}
VkFramebufferAttachmentImageInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkImageCreateFlags = default
    usage : VkImageUsageFlags = default
    width : uint32_t = default
    height : uint32_t = default
    layerCount : uint32_t = default
    viewFormatCount : uint32_t = default
    pViewFormats : ^mut VkFormat = default
}
VkFramebufferAttachmentsCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    attachmentImageInfoCount : uint32_t = default
    pAttachmentImageInfos : ^mut VkFramebufferAttachmentImageInfo = default
}
VkRenderPassAttachmentBeginInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    attachmentCount : uint32_t = default
    pAttachments : ^mut VkImageView = default
}
VkPhysicalDeviceUniformBufferStandardLayoutFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    uniformBufferStandardLayout : VkBool32 = default
}
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderSubgroupExtendedTypes : VkBool32 = default
}
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    separateDepthStencilLayouts : VkBool32 = default
}
VkAttachmentReferenceStencilLayout :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stencilLayout : VkImageLayout = default
}
VkAttachmentDescriptionStencilLayout :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stencilInitialLayout : VkImageLayout = default
    stencilFinalLayout : VkImageLayout = default
}
VkPhysicalDeviceHostQueryResetFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    hostQueryReset : VkBool32 = default
}
VkPhysicalDeviceTimelineSemaphoreFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    timelineSemaphore : VkBool32 = default
}
VkPhysicalDeviceTimelineSemaphoreProperties :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxTimelineSemaphoreValueDifference : uint64_t = default
}
VkSemaphoreTypeCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    semaphoreType : VkSemaphoreType = default
    initialValue : uint64_t = default
}
VkTimelineSemaphoreSubmitInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    waitSemaphoreValueCount : uint32_t = default
    pWaitSemaphoreValues : ^mut uint64_t = default
    signalSemaphoreValueCount : uint32_t = default
    pSignalSemaphoreValues : ^mut uint64_t = default
}
VkSemaphoreWaitInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkSemaphoreWaitFlags = default
    semaphoreCount : uint32_t = default
    pSemaphores : ^mut VkSemaphore = default
    pValues : ^mut uint64_t = default
}
VkSemaphoreSignalInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    semaphore : VkSemaphore = default
    value : uint64_t = default
}
VkPhysicalDeviceBufferDeviceAddressFeatures :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    bufferDeviceAddress : VkBool32 = default
    bufferDeviceAddressCaptureReplay : VkBool32 = default
    bufferDeviceAddressMultiDevice : VkBool32 = default
}
VkBufferDeviceAddressInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    buffer : VkBuffer = default
}
VkBufferOpaqueCaptureAddressCreateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    opaqueCaptureAddress : uint64_t = default
}
VkMemoryOpaqueCaptureAddressAllocateInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    opaqueCaptureAddress : uint64_t = default
}
VkDeviceMemoryOpaqueCaptureAddressInfo :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memory : VkDeviceMemory = default
}
VkSurfaceCapabilitiesKHR :: struct #copy {
    minImageCount : uint32_t = default
    maxImageCount : uint32_t = default
    currentExtent : VkExtent2D = default
    minImageExtent : VkExtent2D = default
    maxImageExtent : VkExtent2D = default
    maxImageArrayLayers : uint32_t = default
    supportedTransforms : VkSurfaceTransformFlagsKHR = default
    currentTransform : VkSurfaceTransformFlagBitsKHR = default
    supportedCompositeAlpha : VkCompositeAlphaFlagsKHR = default
    supportedUsageFlags : VkImageUsageFlags = default
}
VkSurfaceFormatKHR :: struct #copy {
    format : VkFormat = default
    colorSpace : VkColorSpaceKHR = default
}
VkSwapchainCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkSwapchainCreateFlagsKHR = default
    surface : VkSurfaceKHR = default
    minImageCount : uint32_t = default
    imageFormat : VkFormat = default
    imageColorSpace : VkColorSpaceKHR = default
    imageExtent : VkExtent2D = default
    imageArrayLayers : uint32_t = default
    imageUsage : VkImageUsageFlags = default
    imageSharingMode : VkSharingMode = default
    queueFamilyIndexCount : uint32_t = default
    pQueueFamilyIndices : ^mut uint32_t = default
    preTransform : VkSurfaceTransformFlagBitsKHR = default
    compositeAlpha : VkCompositeAlphaFlagBitsKHR = default
    presentMode : VkPresentModeKHR = default
    clipped : VkBool32 = default
    oldSwapchain : VkSwapchainKHR = default
}
VkPresentInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    waitSemaphoreCount : uint32_t = default
    pWaitSemaphores : ^mut VkSemaphore = default
    swapchainCount : uint32_t = default
    pSwapchains : ^mut VkSwapchainKHR = default
    pImageIndices : ^mut uint32_t = default
    pResults : ^mut VkResult = default
}
VkImageSwapchainCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchain : VkSwapchainKHR = default
}
VkBindImageMemorySwapchainInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchain : VkSwapchainKHR = default
    imageIndex : uint32_t = default
}
VkAcquireNextImageInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchain : VkSwapchainKHR = default
    timeout : uint64_t = default
    semaphore : VkSemaphore = default
    fence : VkFence = default
    deviceMask : uint32_t = default
}
VkDeviceGroupPresentCapabilitiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    presentMask : [32]uint32_t = default
    modes : VkDeviceGroupPresentModeFlagsKHR = default
}
VkDeviceGroupPresentInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchainCount : uint32_t = default
    pDeviceMasks : ^mut uint32_t = default
    mode : VkDeviceGroupPresentModeFlagBitsKHR = default
}
VkDeviceGroupSwapchainCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    modes : VkDeviceGroupPresentModeFlagsKHR = default
}
VkDisplayModeParametersKHR :: struct #copy {
    visibleRegion : VkExtent2D = default
    refreshRate : uint32_t = default
}
VkDisplayModeCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDisplayModeCreateFlagsKHR = default
    parameters : VkDisplayModeParametersKHR = default
}
VkDisplayModePropertiesKHR :: struct #copy {
    displayMode : VkDisplayModeKHR = default
    parameters : VkDisplayModeParametersKHR = default
}
VkDisplayPlaneCapabilitiesKHR :: struct #copy {
    supportedAlpha : VkDisplayPlaneAlphaFlagsKHR = default
    minSrcPosition : VkOffset2D = default
    maxSrcPosition : VkOffset2D = default
    minSrcExtent : VkExtent2D = default
    maxSrcExtent : VkExtent2D = default
    minDstPosition : VkOffset2D = default
    maxDstPosition : VkOffset2D = default
    minDstExtent : VkExtent2D = default
    maxDstExtent : VkExtent2D = default
}
VkDisplayPlanePropertiesKHR :: struct #copy {
    currentDisplay : VkDisplayKHR = default
    currentStackIndex : uint32_t = default
}
VkDisplayPropertiesKHR :: struct #copy {
    display : VkDisplayKHR = default
    displayName : ^mut char8 = default
    physicalDimensions : VkExtent2D = default
    physicalResolution : VkExtent2D = default
    supportedTransforms : VkSurfaceTransformFlagsKHR = default
    planeReorderPossible : VkBool32 = default
    persistentContent : VkBool32 = default
}
VkDisplaySurfaceCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDisplaySurfaceCreateFlagsKHR = default
    displayMode : VkDisplayModeKHR = default
    planeIndex : uint32_t = default
    planeStackIndex : uint32_t = default
    transform : VkSurfaceTransformFlagBitsKHR = default
    globalAlpha : f32 = default
    alphaMode : VkDisplayPlaneAlphaFlagBitsKHR = default
    imageExtent : VkExtent2D = default
}
VkDisplayPresentInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcRect : VkRect2D = default
    dstRect : VkRect2D = default
    persistent : VkBool32 = default
}
VkImportMemoryFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleType : VkExternalMemoryHandleTypeFlagBits = default
    fd : i32 = default
}
VkMemoryFdPropertiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryTypeBits : uint32_t = default
}
VkMemoryGetFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memory : VkDeviceMemory = default
    handleType : VkExternalMemoryHandleTypeFlagBits = default
}
VkImportSemaphoreFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    semaphore : VkSemaphore = default
    flags : VkSemaphoreImportFlags = default
    handleType : VkExternalSemaphoreHandleTypeFlagBits = default
    fd : i32 = default
}
VkSemaphoreGetFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    semaphore : VkSemaphore = default
    handleType : VkExternalSemaphoreHandleTypeFlagBits = default
}
VkPhysicalDevicePushDescriptorPropertiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxPushDescriptors : uint32_t = default
}
VkRectLayerKHR :: struct #copy {
    offset : VkOffset2D = default
    extent : VkExtent2D = default
    layer : uint32_t = default
}
VkPresentRegionKHR :: struct #copy {
    rectangleCount : uint32_t = default
    pRectangles : ^mut VkRectLayerKHR = default
}
VkPresentRegionsKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchainCount : uint32_t = default
    pRegions : ^mut VkPresentRegionKHR = default
}
VkSharedPresentSurfaceCapabilitiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    sharedPresentSupportedUsageFlags : VkImageUsageFlags = default
}
VkImportFenceFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fence : VkFence = default
    flags : VkFenceImportFlags = default
    handleType : VkExternalFenceHandleTypeFlagBits = default
    fd : i32 = default
}
VkFenceGetFdInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fence : VkFence = default
    handleType : VkExternalFenceHandleTypeFlagBits = default
}
VkPhysicalDevicePerformanceQueryFeaturesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    performanceCounterQueryPools : VkBool32 = default
    performanceCounterMultipleQueryPools : VkBool32 = default
}
VkPhysicalDevicePerformanceQueryPropertiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    allowCommandBufferQueryCopies : VkBool32 = default
}
VkPerformanceCounterKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    unit : VkPerformanceCounterUnitKHR = default
    scope : VkPerformanceCounterScopeKHR = default
    storage : VkPerformanceCounterStorageKHR = default
    uuid : [16]uint8_t = default
}
VkPerformanceCounterDescriptionKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPerformanceCounterDescriptionFlagsKHR = default
    name : [256]char8 = default
    category : [256]char8 = default
    description : [256]char8 = default
}
VkQueryPoolPerformanceCreateInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    queueFamilyIndex : uint32_t = default
    counterIndexCount : uint32_t = default
    pCounterIndices : ^mut uint32_t = default
}
VkAcquireProfilingLockInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkAcquireProfilingLockFlagsKHR = default
    timeout : uint64_t = default
}
VkPerformanceQuerySubmitInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    counterPassIndex : uint32_t = default
}
VkPhysicalDeviceSurfaceInfo2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    surface : VkSurfaceKHR = default
}
VkSurfaceCapabilities2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    surfaceCapabilities : VkSurfaceCapabilitiesKHR = default
}
VkSurfaceFormat2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    surfaceFormat : VkSurfaceFormatKHR = default
}
VkDisplayProperties2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    displayProperties : VkDisplayPropertiesKHR = default
}
VkDisplayPlaneProperties2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    displayPlaneProperties : VkDisplayPlanePropertiesKHR = default
}
VkDisplayModeProperties2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    displayModeProperties : VkDisplayModePropertiesKHR = default
}
VkDisplayPlaneInfo2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    mode : VkDisplayModeKHR = default
    planeIndex : uint32_t = default
}
VkDisplayPlaneCapabilities2KHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    capabilities : VkDisplayPlaneCapabilitiesKHR = default
}
VkPhysicalDeviceShaderClockFeaturesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderSubgroupClock : VkBool32 = default
    shaderDeviceClock : VkBool32 = default
}
VkSurfaceProtectedCapabilitiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    supportsProtected : VkBool32 = default
}
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipelineExecutableInfo : VkBool32 = default
}
VkPipelineInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipeline : VkPipeline = default
}
VkPipelineExecutablePropertiesKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stages : VkShaderStageFlags = default
    name : [256]char8 = default
    description : [256]char8 = default
    subgroupSize : uint32_t = default
}
VkPipelineExecutableInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipeline : VkPipeline = default
    executableIndex : uint32_t = default
}
VkPipelineExecutableStatisticKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    name : [256]char8 = default
    description : [256]char8 = default
    format : VkPipelineExecutableStatisticFormatKHR = default
    value : VkPipelineExecutableStatisticValueKHR = default
}
VkPipelineExecutableInternalRepresentationKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    name : [256]char8 = default
    description : [256]char8 = default
    isText : VkBool32 = default
    dataSize : size_t = default
    pData : ^mut void = default
}
VkDebugReportCallbackCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDebugReportFlagsEXT = default
    pfnCallback : PFN_vkDebugReportCallbackEXT = default
    pUserData : ^mut void = default
}
VkPipelineRasterizationStateRasterizationOrderAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    rasterizationOrder : VkRasterizationOrderAMD = default
}
VkDebugMarkerObjectNameInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    objectType : VkDebugReportObjectTypeEXT = default
    object : uint64_t = default
    pObjectName : ^mut char8 = default
}
VkDebugMarkerObjectTagInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    objectType : VkDebugReportObjectTypeEXT = default
    object : uint64_t = default
    tagName : uint64_t = default
    tagSize : size_t = default
    pTag : ^mut void = default
}
VkDebugMarkerMarkerInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pMarkerName : ^mut char8 = default
    color : [4]f32 = default
}
VkDedicatedAllocationImageCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    dedicatedAllocation : VkBool32 = default
}
VkDedicatedAllocationBufferCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    dedicatedAllocation : VkBool32 = default
}
VkDedicatedAllocationMemoryAllocateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    image : VkImage = default
    buffer : VkBuffer = default
}
VkPhysicalDeviceTransformFeedbackFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    transformFeedback : VkBool32 = default
    geometryStreams : VkBool32 = default
}
VkPhysicalDeviceTransformFeedbackPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxTransformFeedbackStreams : uint32_t = default
    maxTransformFeedbackBuffers : uint32_t = default
    maxTransformFeedbackBufferSize : VkDeviceSize = default
    maxTransformFeedbackStreamDataSize : uint32_t = default
    maxTransformFeedbackBufferDataSize : uint32_t = default
    maxTransformFeedbackBufferDataStride : uint32_t = default
    transformFeedbackQueries : VkBool32 = default
    transformFeedbackStreamsLinesTriangles : VkBool32 = default
    transformFeedbackRasterizationStreamSelect : VkBool32 = default
    transformFeedbackDraw : VkBool32 = default
}
VkPipelineRasterizationStateStreamCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineRasterizationStateStreamCreateFlagsEXT = default
    rasterizationStream : uint32_t = default
}
VkImageViewHandleInfoNVX :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    imageView : VkImageView = default
    descriptorType : VkDescriptorType = default
    sampler : VkSampler = default
}
VkImageViewAddressPropertiesNVX :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceAddress : VkDeviceAddress = default
    size : VkDeviceSize = default
}
VkTextureLODGatherFormatPropertiesAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    supportsTextureGatherLODBiasAMD : VkBool32 = default
}
VkShaderResourceUsageAMD :: struct #copy {
    numUsedVgprs : uint32_t = default
    numUsedSgprs : uint32_t = default
    ldsSizePerLocalWorkGroup : uint32_t = default
    ldsUsageSizeInBytes : size_t = default
    scratchMemUsageInBytes : size_t = default
}
VkShaderStatisticsInfoAMD :: struct #copy {
    shaderStageMask : VkShaderStageFlags = default
    resourceUsage : VkShaderResourceUsageAMD = default
    numPhysicalVgprs : uint32_t = default
    numPhysicalSgprs : uint32_t = default
    numAvailableVgprs : uint32_t = default
    numAvailableSgprs : uint32_t = default
    computeWorkGroupSize : [3]uint32_t = default
}
VkPhysicalDeviceCornerSampledImageFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    cornerSampledImage : VkBool32 = default
}
VkExternalImageFormatPropertiesNV :: struct #copy {
    imageFormatProperties : VkImageFormatProperties = default
    externalMemoryFeatures : VkExternalMemoryFeatureFlagsNV = default
    exportFromImportedHandleTypes : VkExternalMemoryHandleTypeFlagsNV = default
    compatibleHandleTypes : VkExternalMemoryHandleTypeFlagsNV = default
}
VkExternalMemoryImageCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalMemoryHandleTypeFlagsNV = default
}
VkExportMemoryAllocateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleTypes : VkExternalMemoryHandleTypeFlagsNV = default
}
VkValidationFlagsEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    disabledValidationCheckCount : uint32_t = default
    pDisabledValidationChecks : ^mut VkValidationCheckEXT = default
}
VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    textureCompressionASTC_HDR : VkBool32 = default
}
VkImageViewASTCDecodeModeEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    decodeMode : VkFormat = default
}
VkPhysicalDeviceASTCDecodeFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    decodeModeSharedExponent : VkBool32 = default
}
VkConditionalRenderingBeginInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    buffer : VkBuffer = default
    offset : VkDeviceSize = default
    flags : VkConditionalRenderingFlagsEXT = default
}
VkPhysicalDeviceConditionalRenderingFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    conditionalRendering : VkBool32 = default
    inheritedConditionalRendering : VkBool32 = default
}
VkCommandBufferInheritanceConditionalRenderingInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    conditionalRenderingEnable : VkBool32 = default
}
VkViewportWScalingNV :: struct #copy {
    xcoeff : f32 = default
    ycoeff : f32 = default
}
VkPipelineViewportWScalingStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    viewportWScalingEnable : VkBool32 = default
    viewportCount : uint32_t = default
    pViewportWScalings : ^mut VkViewportWScalingNV = default
}
VkSurfaceCapabilities2EXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    minImageCount : uint32_t = default
    maxImageCount : uint32_t = default
    currentExtent : VkExtent2D = default
    minImageExtent : VkExtent2D = default
    maxImageExtent : VkExtent2D = default
    maxImageArrayLayers : uint32_t = default
    supportedTransforms : VkSurfaceTransformFlagsKHR = default
    currentTransform : VkSurfaceTransformFlagBitsKHR = default
    supportedCompositeAlpha : VkCompositeAlphaFlagsKHR = default
    supportedUsageFlags : VkImageUsageFlags = default
    supportedSurfaceCounters : VkSurfaceCounterFlagsEXT = default
}
VkDisplayPowerInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    powerState : VkDisplayPowerStateEXT = default
}
VkDeviceEventInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceEvent : VkDeviceEventTypeEXT = default
}
VkDisplayEventInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    displayEvent : VkDisplayEventTypeEXT = default
}
VkSwapchainCounterCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    surfaceCounters : VkSurfaceCounterFlagsEXT = default
}
VkRefreshCycleDurationGOOGLE :: struct #copy {
    refreshDuration : uint64_t = default
}
VkPastPresentationTimingGOOGLE :: struct #copy {
    presentID : uint32_t = default
    desiredPresentTime : uint64_t = default
    actualPresentTime : uint64_t = default
    earliestPresentTime : uint64_t = default
    presentMargin : uint64_t = default
}
VkPresentTimeGOOGLE :: struct #copy {
    presentID : uint32_t = default
    desiredPresentTime : uint64_t = default
}
VkPresentTimesInfoGOOGLE :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    swapchainCount : uint32_t = default
    pTimes : ^mut VkPresentTimeGOOGLE = default
}
VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    perViewPositionAllComponents : VkBool32 = default
}
VkViewportSwizzleNV :: struct #copy {
    x : VkViewportCoordinateSwizzleNV = default
    y : VkViewportCoordinateSwizzleNV = default
    z : VkViewportCoordinateSwizzleNV = default
    w : VkViewportCoordinateSwizzleNV = default
}
VkPipelineViewportSwizzleStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineViewportSwizzleStateCreateFlagsNV = default
    viewportCount : uint32_t = default
    pViewportSwizzles : ^mut VkViewportSwizzleNV = default
}
VkPhysicalDeviceDiscardRectanglePropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxDiscardRectangles : uint32_t = default
}
VkPipelineDiscardRectangleStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineDiscardRectangleStateCreateFlagsEXT = default
    discardRectangleMode : VkDiscardRectangleModeEXT = default
    discardRectangleCount : uint32_t = default
    pDiscardRectangles : ^mut VkRect2D = default
}
VkPhysicalDeviceConservativeRasterizationPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    primitiveOverestimationSize : f32 = default
    maxExtraPrimitiveOverestimationSize : f32 = default
    extraPrimitiveOverestimationSizeGranularity : f32 = default
    primitiveUnderestimation : VkBool32 = default
    conservativePointAndLineRasterization : VkBool32 = default
    degenerateTrianglesRasterized : VkBool32 = default
    degenerateLinesRasterized : VkBool32 = default
    fullyCoveredFragmentShaderInputVariable : VkBool32 = default
    conservativeRasterizationPostDepthCoverage : VkBool32 = default
}
VkPipelineRasterizationConservativeStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineRasterizationConservativeStateCreateFlagsEXT = default
    conservativeRasterizationMode : VkConservativeRasterizationModeEXT = default
    extraPrimitiveOverestimationSize : f32 = default
}
VkPhysicalDeviceDepthClipEnableFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    depthClipEnable : VkBool32 = default
}
VkPipelineRasterizationDepthClipStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineRasterizationDepthClipStateCreateFlagsEXT = default
    depthClipEnable : VkBool32 = default
}
VkXYColorEXT :: struct #copy {
    x : f32 = default
    y : f32 = default
}
VkHdrMetadataEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    displayPrimaryRed : VkXYColorEXT = default
    displayPrimaryGreen : VkXYColorEXT = default
    displayPrimaryBlue : VkXYColorEXT = default
    whitePoint : VkXYColorEXT = default
    maxLuminance : f32 = default
    minLuminance : f32 = default
    maxContentLightLevel : f32 = default
    maxFrameAverageLightLevel : f32 = default
}
VkDebugUtilsLabelEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pLabelName : ^mut char8 = default
    color : [4]f32 = default
}
VkDebugUtilsObjectNameInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    objectType : VkObjectType = default
    objectHandle : uint64_t = default
    pObjectName : ^mut char8 = default
}
VkDebugUtilsMessengerCallbackDataEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDebugUtilsMessengerCallbackDataFlagsEXT = default
    pMessageIdName : ^mut char8 = default
    messageIdNumber : int32_t = default
    pMessage : ^mut char8 = default
    queueLabelCount : uint32_t = default
    pQueueLabels : ^mut VkDebugUtilsLabelEXT = default
    cmdBufLabelCount : uint32_t = default
    pCmdBufLabels : ^mut VkDebugUtilsLabelEXT = default
    objectCount : uint32_t = default
    pObjects : ^mut VkDebugUtilsObjectNameInfoEXT = default
}
VkDebugUtilsMessengerCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDebugUtilsMessengerCreateFlagsEXT = default
    messageSeverity : VkDebugUtilsMessageSeverityFlagsEXT = default
    messageType : VkDebugUtilsMessageTypeFlagsEXT = default
    pfnUserCallback : PFN_vkDebugUtilsMessengerCallbackEXT = default
    pUserData : ^mut void = default
}
VkDebugUtilsObjectTagInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    objectType : VkObjectType = default
    objectHandle : uint64_t = default
    tagName : uint64_t = default
    tagSize : size_t = default
    pTag : ^mut void = default
}
VkPhysicalDeviceInlineUniformBlockFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    inlineUniformBlock : VkBool32 = default
    descriptorBindingInlineUniformBlockUpdateAfterBind : VkBool32 = default
}
VkPhysicalDeviceInlineUniformBlockPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxInlineUniformBlockSize : uint32_t = default
    maxPerStageDescriptorInlineUniformBlocks : uint32_t = default
    maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks : uint32_t = default
    maxDescriptorSetInlineUniformBlocks : uint32_t = default
    maxDescriptorSetUpdateAfterBindInlineUniformBlocks : uint32_t = default
}
VkWriteDescriptorSetInlineUniformBlockEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    dataSize : uint32_t = default
    pData : ^mut void = default
}
VkDescriptorPoolInlineUniformBlockCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxInlineUniformBlockBindings : uint32_t = default
}
VkSampleLocationEXT :: struct #copy {
    x : f32 = default
    y : f32 = default
}
VkSampleLocationsInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    sampleLocationsPerPixel : VkSampleCountFlagBits = default
    sampleLocationGridSize : VkExtent2D = default
    sampleLocationsCount : uint32_t = default
    pSampleLocations : ^mut VkSampleLocationEXT = default
}
VkAttachmentSampleLocationsEXT :: struct #copy {
    attachmentIndex : uint32_t = default
    sampleLocationsInfo : VkSampleLocationsInfoEXT = default
}
VkSubpassSampleLocationsEXT :: struct #copy {
    subpassIndex : uint32_t = default
    sampleLocationsInfo : VkSampleLocationsInfoEXT = default
}
VkRenderPassSampleLocationsBeginInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    attachmentInitialSampleLocationsCount : uint32_t = default
    pAttachmentInitialSampleLocations : ^mut VkAttachmentSampleLocationsEXT = default
    postSubpassSampleLocationsCount : uint32_t = default
    pPostSubpassSampleLocations : ^mut VkSubpassSampleLocationsEXT = default
}
VkPipelineSampleLocationsStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    sampleLocationsEnable : VkBool32 = default
    sampleLocationsInfo : VkSampleLocationsInfoEXT = default
}
VkPhysicalDeviceSampleLocationsPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    sampleLocationSampleCounts : VkSampleCountFlags = default
    maxSampleLocationGridSize : VkExtent2D = default
    sampleLocationCoordinateRange : [2]f32 = default
    sampleLocationSubPixelBits : uint32_t = default
    variableSampleLocations : VkBool32 = default
}
VkMultisamplePropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxSampleLocationGridSize : VkExtent2D = default
}
VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    advancedBlendCoherentOperations : VkBool32 = default
}
VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    advancedBlendMaxColorAttachments : uint32_t = default
    advancedBlendIndependentBlend : VkBool32 = default
    advancedBlendNonPremultipliedSrcColor : VkBool32 = default
    advancedBlendNonPremultipliedDstColor : VkBool32 = default
    advancedBlendCorrelatedOverlap : VkBool32 = default
    advancedBlendAllOperations : VkBool32 = default
}
VkPipelineColorBlendAdvancedStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    srcPremultiplied : VkBool32 = default
    dstPremultiplied : VkBool32 = default
    blendOverlap : VkBlendOverlapEXT = default
}
VkPipelineCoverageToColorStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCoverageToColorStateCreateFlagsNV = default
    coverageToColorEnable : VkBool32 = default
    coverageToColorLocation : uint32_t = default
}
VkPipelineCoverageModulationStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCoverageModulationStateCreateFlagsNV = default
    coverageModulationMode : VkCoverageModulationModeNV = default
    coverageModulationTableEnable : VkBool32 = default
    coverageModulationTableCount : uint32_t = default
    pCoverageModulationTable : ^mut f32 = default
}
VkPhysicalDeviceShaderSMBuiltinsPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderSMCount : uint32_t = default
    shaderWarpsPerSM : uint32_t = default
}
VkPhysicalDeviceShaderSMBuiltinsFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderSMBuiltins : VkBool32 = default
}
VkDrmFormatModifierPropertiesEXT :: struct #copy {
    drmFormatModifier : uint64_t = default
    drmFormatModifierPlaneCount : uint32_t = default
    drmFormatModifierTilingFeatures : VkFormatFeatureFlags = default
}
VkDrmFormatModifierPropertiesListEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    drmFormatModifierCount : uint32_t = default
    pDrmFormatModifierProperties : ^mut VkDrmFormatModifierPropertiesEXT = default
}
VkPhysicalDeviceImageDrmFormatModifierInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    drmFormatModifier : uint64_t = default
    sharingMode : VkSharingMode = default
    queueFamilyIndexCount : uint32_t = default
    pQueueFamilyIndices : ^mut uint32_t = default
}
VkImageDrmFormatModifierListCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    drmFormatModifierCount : uint32_t = default
    pDrmFormatModifiers : ^mut uint64_t = default
}
VkImageDrmFormatModifierExplicitCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    drmFormatModifier : uint64_t = default
    drmFormatModifierPlaneCount : uint32_t = default
    pPlaneLayouts : ^mut VkSubresourceLayout = default
}
VkImageDrmFormatModifierPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    drmFormatModifier : uint64_t = default
}
VkValidationCacheCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkValidationCacheCreateFlagsEXT = default
    initialDataSize : size_t = default
    pInitialData : ^mut void = default
}
VkShaderModuleValidationCacheCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    validationCache : VkValidationCacheEXT = default
}
VkShadingRatePaletteNV :: struct #copy {
    shadingRatePaletteEntryCount : uint32_t = default
    pShadingRatePaletteEntries : ^mut VkShadingRatePaletteEntryNV = default
}
VkPipelineViewportShadingRateImageStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shadingRateImageEnable : VkBool32 = default
    viewportCount : uint32_t = default
    pShadingRatePalettes : ^mut VkShadingRatePaletteNV = default
}
VkPhysicalDeviceShadingRateImageFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shadingRateImage : VkBool32 = default
    shadingRateCoarseSampleOrder : VkBool32 = default
}
VkPhysicalDeviceShadingRateImagePropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shadingRateTexelSize : VkExtent2D = default
    shadingRatePaletteSize : uint32_t = default
    shadingRateMaxCoarseSamples : uint32_t = default
}
VkCoarseSampleLocationNV :: struct #copy {
    pixelX : uint32_t = default
    pixelY : uint32_t = default
    sample : uint32_t = default
}
VkCoarseSampleOrderCustomNV :: struct #copy {
    shadingRate : VkShadingRatePaletteEntryNV = default
    sampleCount : uint32_t = default
    sampleLocationCount : uint32_t = default
    pSampleLocations : ^mut VkCoarseSampleLocationNV = default
}
VkPipelineViewportCoarseSampleOrderStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    sampleOrderType : VkCoarseSampleOrderTypeNV = default
    customSampleOrderCount : uint32_t = default
    pCustomSampleOrders : ^mut VkCoarseSampleOrderCustomNV = default
}
VkRayTracingShaderGroupCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    type : VkRayTracingShaderGroupTypeKHR = default
    generalShader : uint32_t = default
    closestHitShader : uint32_t = default
    anyHitShader : uint32_t = default
    intersectionShader : uint32_t = default
}
VkRayTracingPipelineCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCreateFlags = default
    stageCount : uint32_t = default
    pStages : ^mut VkPipelineShaderStageCreateInfo = default
    groupCount : uint32_t = default
    pGroups : ^mut VkRayTracingShaderGroupCreateInfoNV = default
    maxRecursionDepth : uint32_t = default
    layout : VkPipelineLayout = default
    basePipelineHandle : VkPipeline = default
    basePipelineIndex : int32_t = default
}
VkGeometryTrianglesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    vertexData : VkBuffer = default
    vertexOffset : VkDeviceSize = default
    vertexCount : uint32_t = default
    vertexStride : VkDeviceSize = default
    vertexFormat : VkFormat = default
    indexData : VkBuffer = default
    indexOffset : VkDeviceSize = default
    indexCount : uint32_t = default
    indexType : VkIndexType = default
    transformData : VkBuffer = default
    transformOffset : VkDeviceSize = default
}
VkGeometryAABBNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    aabbData : VkBuffer = default
    numAABBs : uint32_t = default
    stride : uint32_t = default
    offset : VkDeviceSize = default
}
VkGeometryDataNV :: struct #copy {
    triangles : VkGeometryTrianglesNV = default
    aabbs : VkGeometryAABBNV = default
}
VkGeometryNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    geometryType : VkGeometryTypeKHR = default
    geometry : VkGeometryDataNV = default
    flags : VkGeometryFlagsKHR = default
}
VkAccelerationStructureInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    type : VkAccelerationStructureTypeNV = default
    flags : VkBuildAccelerationStructureFlagsNV = default
    instanceCount : uint32_t = default
    geometryCount : uint32_t = default
    pGeometries : ^mut VkGeometryNV = default
}
VkAccelerationStructureCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    compactedSize : VkDeviceSize = default
    info : VkAccelerationStructureInfoNV = default
}
VkBindAccelerationStructureMemoryInfoKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    accelerationStructure : VkAccelerationStructureKHR = default
    memory : VkDeviceMemory = default
    memoryOffset : VkDeviceSize = default
    deviceIndexCount : uint32_t = default
    pDeviceIndices : ^mut uint32_t = default
}
VkWriteDescriptorSetAccelerationStructureKHR :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    accelerationStructureCount : uint32_t = default
    pAccelerationStructures : ^mut VkAccelerationStructureKHR = default
}
VkAccelerationStructureMemoryRequirementsInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    type : VkAccelerationStructureMemoryRequirementsTypeNV = default
    accelerationStructure : VkAccelerationStructureNV = default
}
VkPhysicalDeviceRayTracingPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderGroupHandleSize : uint32_t = default
    maxRecursionDepth : uint32_t = default
    maxShaderGroupStride : uint32_t = default
    shaderGroupBaseAlignment : uint32_t = default
    maxGeometryCount : uint64_t = default
    maxInstanceCount : uint64_t = default
    maxTriangleCount : uint64_t = default
    maxDescriptorSetAccelerationStructures : uint32_t = default
}
VkTransformMatrixKHR :: struct #copy {
    matrix : [3][4]f32 = default
}
VkAabbPositionsKHR :: struct #copy {
    minX : f32 = default
    minY : f32 = default
    minZ : f32 = default
    maxX : f32 = default
    maxY : f32 = default
    maxZ : f32 = default
}
VkAccelerationStructureInstanceKHR :: struct #copy {
    transform : VkTransformMatrixKHR = default
    instanceCustomIndex : uint32_t = default
    mask : uint32_t = default
    instanceShaderBindingTableRecordOffset : uint32_t = default
    flags : VkGeometryInstanceFlagsKHR = default
    accelerationStructureReference : uint64_t = default
}
VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    representativeFragmentTest : VkBool32 = default
}
VkPipelineRepresentativeFragmentTestStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    representativeFragmentTestEnable : VkBool32 = default
}
VkPhysicalDeviceImageViewImageFormatInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    imageViewType : VkImageViewType = default
}
VkFilterCubicImageViewImageFormatPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    filterCubic : VkBool32 = default
    filterCubicMinmax : VkBool32 = default
}
VkDeviceQueueGlobalPriorityCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    globalPriority : VkQueueGlobalPriorityEXT = default
}
VkImportMemoryHostPointerInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    handleType : VkExternalMemoryHandleTypeFlagBits = default
    pHostPointer : ^mut void = default
}
VkMemoryHostPointerPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryTypeBits : uint32_t = default
}
VkPhysicalDeviceExternalMemoryHostPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    minImportedHostPointerAlignment : VkDeviceSize = default
}
VkPipelineCompilerControlCreateInfoAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    compilerControlFlags : VkPipelineCompilerControlFlagsAMD = default
}
VkCalibratedTimestampInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    timeDomain : VkTimeDomainEXT = default
}
VkPhysicalDeviceShaderCorePropertiesAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderEngineCount : uint32_t = default
    shaderArraysPerEngineCount : uint32_t = default
    computeUnitsPerShaderArray : uint32_t = default
    simdPerComputeUnit : uint32_t = default
    wavefrontsPerSimd : uint32_t = default
    wavefrontSize : uint32_t = default
    sgprsPerSimd : uint32_t = default
    minSgprAllocation : uint32_t = default
    maxSgprAllocation : uint32_t = default
    sgprAllocationGranularity : uint32_t = default
    vgprsPerSimd : uint32_t = default
    minVgprAllocation : uint32_t = default
    maxVgprAllocation : uint32_t = default
    vgprAllocationGranularity : uint32_t = default
}
VkDeviceMemoryOverallocationCreateInfoAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    overallocationBehavior : VkMemoryOverallocationBehaviorAMD = default
}
VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxVertexAttribDivisor : uint32_t = default
}
VkVertexInputBindingDivisorDescriptionEXT :: struct #copy {
    binding : uint32_t = default
    divisor : uint32_t = default
}
VkPipelineVertexInputDivisorStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    vertexBindingDivisorCount : uint32_t = default
    pVertexBindingDivisors : ^mut VkVertexInputBindingDivisorDescriptionEXT = default
}
VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    vertexAttributeInstanceRateDivisor : VkBool32 = default
    vertexAttributeInstanceRateZeroDivisor : VkBool32 = default
}
VkPipelineCreationFeedbackEXT :: struct #copy {
    flags : VkPipelineCreationFeedbackFlagsEXT = default
    duration : uint64_t = default
}
VkPipelineCreationFeedbackCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pPipelineCreationFeedback : ^mut VkPipelineCreationFeedbackEXT = default
    pipelineStageCreationFeedbackCount : uint32_t = default
    pPipelineStageCreationFeedbacks : ^mut VkPipelineCreationFeedbackEXT = default
}
VkPhysicalDeviceComputeShaderDerivativesFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    computeDerivativeGroupQuads : VkBool32 = default
    computeDerivativeGroupLinear : VkBool32 = default
}
VkPhysicalDeviceMeshShaderFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    taskShader : VkBool32 = default
    meshShader : VkBool32 = default
}
VkPhysicalDeviceMeshShaderPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxDrawMeshTasksCount : uint32_t = default
    maxTaskWorkGroupInvocations : uint32_t = default
    maxTaskWorkGroupSize : [3]uint32_t = default
    maxTaskTotalMemorySize : uint32_t = default
    maxTaskOutputCount : uint32_t = default
    maxMeshWorkGroupInvocations : uint32_t = default
    maxMeshWorkGroupSize : [3]uint32_t = default
    maxMeshTotalMemorySize : uint32_t = default
    maxMeshOutputVertices : uint32_t = default
    maxMeshOutputPrimitives : uint32_t = default
    maxMeshMultiviewViewCount : uint32_t = default
    meshOutputPerVertexGranularity : uint32_t = default
    meshOutputPerPrimitiveGranularity : uint32_t = default
}
VkDrawMeshTasksIndirectCommandNV :: struct #copy {
    taskCount : uint32_t = default
    firstTask : uint32_t = default
}
VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fragmentShaderBarycentric : VkBool32 = default
}
VkPhysicalDeviceShaderImageFootprintFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    imageFootprint : VkBool32 = default
}
VkPipelineViewportExclusiveScissorStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    exclusiveScissorCount : uint32_t = default
    pExclusiveScissors : ^mut VkRect2D = default
}
VkPhysicalDeviceExclusiveScissorFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    exclusiveScissor : VkBool32 = default
}
VkQueueFamilyCheckpointPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    checkpointExecutionStageMask : VkPipelineStageFlags = default
}
VkCheckpointDataNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stage : VkPipelineStageFlagBits = default
    pCheckpointMarker : ^mut void = default
}
VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderIntegerFunctions2 : VkBool32 = default
}
VkPerformanceValueINTEL :: struct #copy {
    type : VkPerformanceValueTypeINTEL = default
    data : VkPerformanceValueDataINTEL = default
}
VkInitializePerformanceApiInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pUserData : ^mut void = default
}
VkQueryPoolPerformanceQueryCreateInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    performanceCountersSampling : VkQueryPoolSamplingModeINTEL = default
}
VkPerformanceMarkerInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    marker : uint64_t = default
}
VkPerformanceStreamMarkerInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    marker : uint32_t = default
}
VkPerformanceOverrideInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    type : VkPerformanceOverrideTypeINTEL = default
    enable : VkBool32 = default
    parameter : uint64_t = default
}
VkPerformanceConfigurationAcquireInfoINTEL :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    type : VkPerformanceConfigurationTypeINTEL = default
}
VkPhysicalDevicePCIBusInfoPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pciDomain : uint32_t = default
    pciBus : uint32_t = default
    pciDevice : uint32_t = default
    pciFunction : uint32_t = default
}
VkDisplayNativeHdrSurfaceCapabilitiesAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    localDimmingSupport : VkBool32 = default
}
VkSwapchainDisplayNativeHdrCreateInfoAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    localDimmingEnable : VkBool32 = default
}
VkPhysicalDeviceFragmentDensityMapFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fragmentDensityMap : VkBool32 = default
    fragmentDensityMapDynamic : VkBool32 = default
    fragmentDensityMapNonSubsampledImages : VkBool32 = default
}
VkPhysicalDeviceFragmentDensityMapPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    minFragmentDensityTexelSize : VkExtent2D = default
    maxFragmentDensityTexelSize : VkExtent2D = default
    fragmentDensityInvocations : VkBool32 = default
}
VkRenderPassFragmentDensityMapCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fragmentDensityMapAttachment : VkAttachmentReference = default
}
VkPhysicalDeviceSubgroupSizeControlFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    subgroupSizeControl : VkBool32 = default
    computeFullSubgroups : VkBool32 = default
}
VkPhysicalDeviceSubgroupSizeControlPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    minSubgroupSize : uint32_t = default
    maxSubgroupSize : uint32_t = default
    maxComputeWorkgroupSubgroups : uint32_t = default
    requiredSubgroupSizeStages : VkShaderStageFlags = default
}
VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    requiredSubgroupSize : uint32_t = default
}
VkPhysicalDeviceShaderCoreProperties2AMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderCoreFeatures : VkShaderCorePropertiesFlagsAMD = default
    activeComputeUnitCount : uint32_t = default
}
VkPhysicalDeviceCoherentMemoryFeaturesAMD :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceCoherentMemory : VkBool32 = default
}
VkPhysicalDeviceMemoryBudgetPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    heapBudget : [16]VkDeviceSize = default
    heapUsage : [16]VkDeviceSize = default
}
VkPhysicalDeviceMemoryPriorityFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    memoryPriority : VkBool32 = default
}
VkMemoryPriorityAllocateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    priority : f32 = default
}
VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    dedicatedAllocationImageAliasing : VkBool32 = default
}
VkPhysicalDeviceBufferDeviceAddressFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    bufferDeviceAddress : VkBool32 = default
    bufferDeviceAddressCaptureReplay : VkBool32 = default
    bufferDeviceAddressMultiDevice : VkBool32 = default
}
VkBufferDeviceAddressCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceAddress : VkDeviceAddress = default
}
VkPhysicalDeviceToolPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    name : [256]char8 = default
    version : [256]char8 = default
    purposes : VkToolPurposeFlagsEXT = default
    description : [256]char8 = default
    layer : [256]char8 = default
}
VkValidationFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    enabledValidationFeatureCount : uint32_t = default
    pEnabledValidationFeatures : ^mut VkValidationFeatureEnableEXT = default
    disabledValidationFeatureCount : uint32_t = default
    pDisabledValidationFeatures : ^mut VkValidationFeatureDisableEXT = default
}
VkCooperativeMatrixPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    MSize : uint32_t = default
    NSize : uint32_t = default
    KSize : uint32_t = default
    AType : VkComponentTypeNV = default
    BType : VkComponentTypeNV = default
    CType : VkComponentTypeNV = default
    DType : VkComponentTypeNV = default
    scope : VkScopeNV = default
}
VkPhysicalDeviceCooperativeMatrixFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    cooperativeMatrix : VkBool32 = default
    cooperativeMatrixRobustBufferAccess : VkBool32 = default
}
VkPhysicalDeviceCooperativeMatrixPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    cooperativeMatrixSupportedStages : VkShaderStageFlags = default
}
VkPhysicalDeviceCoverageReductionModeFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    coverageReductionMode : VkBool32 = default
}
VkPipelineCoverageReductionStateCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPipelineCoverageReductionStateCreateFlagsNV = default
    coverageReductionMode : VkCoverageReductionModeNV = default
}
VkFramebufferMixedSamplesCombinationNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    coverageReductionMode : VkCoverageReductionModeNV = default
    rasterizationSamples : VkSampleCountFlagBits = default
    depthStencilSamples : VkSampleCountFlags = default
    colorSamples : VkSampleCountFlags = default
}
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fragmentShaderSampleInterlock : VkBool32 = default
    fragmentShaderPixelInterlock : VkBool32 = default
    fragmentShaderShadingRateInterlock : VkBool32 = default
}
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    ycbcrImageArrays : VkBool32 = default
}
VkHeadlessSurfaceCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkHeadlessSurfaceCreateFlagsEXT = default
}
VkPhysicalDeviceLineRasterizationFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    rectangularLines : VkBool32 = default
    bresenhamLines : VkBool32 = default
    smoothLines : VkBool32 = default
    stippledRectangularLines : VkBool32 = default
    stippledBresenhamLines : VkBool32 = default
    stippledSmoothLines : VkBool32 = default
}
VkPhysicalDeviceLineRasterizationPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    lineSubPixelPrecisionBits : uint32_t = default
}
VkPipelineRasterizationLineStateCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    lineRasterizationMode : VkLineRasterizationModeEXT = default
    stippledLineEnable : VkBool32 = default
    lineStippleFactor : uint32_t = default
    lineStipplePattern : uint16_t = default
}
VkPhysicalDeviceShaderAtomicFloatFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderBufferFloat32Atomics : VkBool32 = default
    shaderBufferFloat32AtomicAdd : VkBool32 = default
    shaderBufferFloat64Atomics : VkBool32 = default
    shaderBufferFloat64AtomicAdd : VkBool32 = default
    shaderSharedFloat32Atomics : VkBool32 = default
    shaderSharedFloat32AtomicAdd : VkBool32 = default
    shaderSharedFloat64Atomics : VkBool32 = default
    shaderSharedFloat64AtomicAdd : VkBool32 = default
    shaderImageFloat32Atomics : VkBool32 = default
    shaderImageFloat32AtomicAdd : VkBool32 = default
    sparseImageFloat32Atomics : VkBool32 = default
    sparseImageFloat32AtomicAdd : VkBool32 = default
}
VkPhysicalDeviceIndexTypeUint8FeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    indexTypeUint8 : VkBool32 = default
}
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    extendedDynamicState : VkBool32 = default
}
VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    shaderDemoteToHelperInvocation : VkBool32 = default
}
VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxGraphicsShaderGroupCount : uint32_t = default
    maxIndirectSequenceCount : uint32_t = default
    maxIndirectCommandsTokenCount : uint32_t = default
    maxIndirectCommandsStreamCount : uint32_t = default
    maxIndirectCommandsTokenOffset : uint32_t = default
    maxIndirectCommandsStreamStride : uint32_t = default
    minSequencesCountBufferOffsetAlignment : uint32_t = default
    minSequencesIndexBufferOffsetAlignment : uint32_t = default
    minIndirectCommandsBufferOffsetAlignment : uint32_t = default
}
VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    deviceGeneratedCommands : VkBool32 = default
}
VkGraphicsShaderGroupCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    stageCount : uint32_t = default
    pStages : ^mut VkPipelineShaderStageCreateInfo = default
    pVertexInputState : ^mut VkPipelineVertexInputStateCreateInfo = default
    pTessellationState : ^mut VkPipelineTessellationStateCreateInfo = default
}
VkGraphicsPipelineShaderGroupsCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    groupCount : uint32_t = default
    pGroups : ^mut VkGraphicsShaderGroupCreateInfoNV = default
    pipelineCount : uint32_t = default
    pPipelines : ^mut VkPipeline = default
}
VkBindShaderGroupIndirectCommandNV :: struct #copy {
    groupIndex : uint32_t = default
}
VkBindIndexBufferIndirectCommandNV :: struct #copy {
    bufferAddress : VkDeviceAddress = default
    size : uint32_t = default
    indexType : VkIndexType = default
}
VkBindVertexBufferIndirectCommandNV :: struct #copy {
    bufferAddress : VkDeviceAddress = default
    size : uint32_t = default
    stride : uint32_t = default
}
VkSetStateFlagsIndirectCommandNV :: struct #copy {
    data : uint32_t = default
}
VkIndirectCommandsStreamNV :: struct #copy {
    buffer : VkBuffer = default
    offset : VkDeviceSize = default
}
VkIndirectCommandsLayoutTokenNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    tokenType : VkIndirectCommandsTokenTypeNV = default
    stream : uint32_t = default
    offset : uint32_t = default
    vertexBindingUnit : uint32_t = default
    vertexDynamicStride : VkBool32 = default
    pushconstantPipelineLayout : VkPipelineLayout = default
    pushconstantShaderStageFlags : VkShaderStageFlags = default
    pushconstantOffset : uint32_t = default
    pushconstantSize : uint32_t = default
    indirectStateFlags : VkIndirectStateFlagsNV = default
    indexTypeCount : uint32_t = default
    pIndexTypes : ^mut VkIndexType = default
    pIndexTypeValues : ^mut uint32_t = default
}
VkIndirectCommandsLayoutCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkIndirectCommandsLayoutUsageFlagsNV = default
    pipelineBindPoint : VkPipelineBindPoint = default
    tokenCount : uint32_t = default
    pTokens : ^mut VkIndirectCommandsLayoutTokenNV = default
    streamCount : uint32_t = default
    pStreamStrides : ^mut uint32_t = default
}
VkGeneratedCommandsInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipelineBindPoint : VkPipelineBindPoint = default
    pipeline : VkPipeline = default
    indirectCommandsLayout : VkIndirectCommandsLayoutNV = default
    streamCount : uint32_t = default
    pStreams : ^mut VkIndirectCommandsStreamNV = default
    sequencesCount : uint32_t = default
    preprocessBuffer : VkBuffer = default
    preprocessOffset : VkDeviceSize = default
    preprocessSize : VkDeviceSize = default
    sequencesCountBuffer : VkBuffer = default
    sequencesCountOffset : VkDeviceSize = default
    sequencesIndexBuffer : VkBuffer = default
    sequencesIndexOffset : VkDeviceSize = default
}
VkGeneratedCommandsMemoryRequirementsInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipelineBindPoint : VkPipelineBindPoint = default
    pipeline : VkPipeline = default
    indirectCommandsLayout : VkIndirectCommandsLayoutNV = default
    maxSequencesCount : uint32_t = default
}
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    texelBufferAlignment : VkBool32 = default
}
VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    storageTexelBufferOffsetAlignmentBytes : VkDeviceSize = default
    storageTexelBufferOffsetSingleTexelAlignment : VkBool32 = default
    uniformTexelBufferOffsetAlignmentBytes : VkDeviceSize = default
    uniformTexelBufferOffsetSingleTexelAlignment : VkBool32 = default
}
VkRenderPassTransformBeginInfoQCOM :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    transform : VkSurfaceTransformFlagBitsKHR = default
}
VkCommandBufferInheritanceRenderPassTransformInfoQCOM :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    transform : VkSurfaceTransformFlagBitsKHR = default
    renderArea : VkRect2D = default
}
VkPhysicalDeviceRobustness2FeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    robustBufferAccess2 : VkBool32 = default
    robustImageAccess2 : VkBool32 = default
    nullDescriptor : VkBool32 = default
}
VkPhysicalDeviceRobustness2PropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    robustStorageBufferAccessSizeAlignment : VkDeviceSize = default
    robustUniformBufferAccessSizeAlignment : VkDeviceSize = default
}
VkSamplerCustomBorderColorCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    customBorderColor : VkClearColorValue = default
    format : VkFormat = default
}
VkPhysicalDeviceCustomBorderColorPropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    maxCustomBorderColorSamplers : uint32_t = default
}
VkPhysicalDeviceCustomBorderColorFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    customBorderColors : VkBool32 = default
    customBorderColorWithoutFormat : VkBool32 = default
}
VkPhysicalDevicePrivateDataFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    privateData : VkBool32 = default
}
VkDevicePrivateDataCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    privateDataSlotRequestCount : uint32_t = default
}
VkPrivateDataSlotCreateInfoEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkPrivateDataSlotCreateFlagsEXT = default
}
VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    pipelineCreationCacheControl : VkBool32 = default
}
VkPhysicalDeviceDiagnosticsConfigFeaturesNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    diagnosticsConfig : VkBool32 = default
}
VkDeviceDiagnosticsConfigCreateInfoNV :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    flags : VkDeviceDiagnosticsConfigFlagsNV = default
}
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    fragmentDensityMapDeferred : VkBool32 = default
}
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    subsampledLoads : VkBool32 = default
    subsampledCoarseReconstructionEarlyAccess : VkBool32 = default
    maxSubsampledArrayLayers : uint32_t = default
    maxDescriptorSetSubsampledSamplers : uint32_t = default
}
VkPhysicalDeviceImageRobustnessFeaturesEXT :: struct #copy {
    sType : VkStructureType = default
    pNext : ^mut void = default
    robustImageAccess : VkBool32 = default
}
VkClearColorValue :: enum #copy #untagged {
    float32 : [4]f32
    int32   : [4]int32_t
    uint32  : [4]uint32_t
}
VkClearValue :: enum #copy #untagged {
    color        : VkClearColorValue
    depthStencil : VkClearDepthStencilValue
}
VkPerformanceCounterResultKHR :: enum #copy #untagged {
    int32   : int32_t
    int64   : int64_t
    uint32  : uint32_t
    uint64  : uint64_t
    float32 : f32
    float64 : f64
}
VkPipelineExecutableStatisticValueKHR :: enum #copy #untagged {
    b32  : VkBool32
    _i64 : int64_t
    _u64 : uint64_t
    _f64 : f64
}
VkPerformanceValueDataINTEL :: enum #copy #untagged {
    value32     : uint32_t
    value64     : uint64_t
    valueFloat  : f32
    valueBool   : VkBool32
    valueString : ^mut char8
}
vkCreateInstance :: (_pCreateInfo: ^mut VkInstanceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pInstance: ^mut VkInstance) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateInstance(^result, _pCreateInfo, _pAllocator, _pInstance)
    return result
}
vkDestroyInstance :: (_instance: VkInstance, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyInstance(_instance, _pAllocator)
}
vkEnumeratePhysicalDevices :: (_instance: VkInstance, _pPhysicalDeviceCount: ^mut uint32_t, _pPhysicalDevices: ^mut VkPhysicalDevice) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumeratePhysicalDevices(^result, _instance, _pPhysicalDeviceCount, _pPhysicalDevices)
    return result
}
vkGetPhysicalDeviceFeatures :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures) {
    __c__vkGetPhysicalDeviceFeatures(_physicalDevice, _pFeatures)
}
vkGetPhysicalDeviceFormatProperties :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties) {
    __c__vkGetPhysicalDeviceFormatProperties(_physicalDevice, _format, _pFormatProperties)
}
vkGetPhysicalDeviceImageFormatProperties :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _tiling: VkImageTiling, _usage: VkImageUsageFlags, _flags: VkImageCreateFlags, _pImageFormatProperties: ^mut VkImageFormatProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceImageFormatProperties(^result, _physicalDevice, _format, _type, _tiling, _usage, _flags, _pImageFormatProperties)
    return result
}
vkGetPhysicalDeviceProperties :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties) {
    __c__vkGetPhysicalDeviceProperties(_physicalDevice, _pProperties)
}
vkGetPhysicalDeviceQueueFamilyProperties :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties) {
    __c__vkGetPhysicalDeviceQueueFamilyProperties(_physicalDevice, _pQueueFamilyPropertyCount, _pQueueFamilyProperties)
}
vkGetPhysicalDeviceMemoryProperties :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties) {
    __c__vkGetPhysicalDeviceMemoryProperties(_physicalDevice, _pMemoryProperties)
}
vkGetInstanceProcAddr :: (_instance: VkInstance, _pName: ^mut char8) -> PFN_vkVoidFunction {
    mut result : PFN_vkVoidFunction = default
    __c__vkGetInstanceProcAddr(^result, _instance, _pName)
    return result
}
vkGetDeviceProcAddr :: (_device: VkDevice, _pName: ^mut char8) -> PFN_vkVoidFunction {
    mut result : PFN_vkVoidFunction = default
    __c__vkGetDeviceProcAddr(^result, _device, _pName)
    return result
}
vkCreateDevice :: (_physicalDevice: VkPhysicalDevice, _pCreateInfo: ^mut VkDeviceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDevice: ^mut VkDevice) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDevice(^result, _physicalDevice, _pCreateInfo, _pAllocator, _pDevice)
    return result
}
vkDestroyDevice :: (_device: VkDevice, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDevice(_device, _pAllocator)
}
vkEnumerateInstanceExtensionProperties :: (_pLayerName: ^mut char8, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkExtensionProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumerateInstanceExtensionProperties(^result, _pLayerName, _pPropertyCount, _pProperties)
    return result
}
vkEnumerateDeviceExtensionProperties :: (_physicalDevice: VkPhysicalDevice, _pLayerName: ^mut char8, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkExtensionProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumerateDeviceExtensionProperties(^result, _physicalDevice, _pLayerName, _pPropertyCount, _pProperties)
    return result
}
vkEnumerateInstanceLayerProperties :: (_pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkLayerProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumerateInstanceLayerProperties(^result, _pPropertyCount, _pProperties)
    return result
}
vkEnumerateDeviceLayerProperties :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkLayerProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumerateDeviceLayerProperties(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetDeviceQueue :: (_device: VkDevice, _queueFamilyIndex: uint32_t, _queueIndex: uint32_t, _pQueue: ^mut VkQueue) {
    __c__vkGetDeviceQueue(_device, _queueFamilyIndex, _queueIndex, _pQueue)
}
vkQueueSubmit :: (_queue: VkQueue, _submitCount: uint32_t, _pSubmits: ^mut VkSubmitInfo, _fence: VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkQueueSubmit(^result, _queue, _submitCount, _pSubmits, _fence)
    return result
}
vkQueueWaitIdle :: (_queue: VkQueue) -> VkResult {
    mut result : VkResult = default
    __c__vkQueueWaitIdle(^result, _queue)
    return result
}
vkDeviceWaitIdle :: (_device: VkDevice) -> VkResult {
    mut result : VkResult = default
    __c__vkDeviceWaitIdle(^result, _device)
    return result
}
vkAllocateMemory :: (_device: VkDevice, _pAllocateInfo: ^mut VkMemoryAllocateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pMemory: ^mut VkDeviceMemory) -> VkResult {
    mut result : VkResult = default
    __c__vkAllocateMemory(^result, _device, _pAllocateInfo, _pAllocator, _pMemory)
    return result
}
vkFreeMemory :: (_device: VkDevice, _memory: VkDeviceMemory, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkFreeMemory(_device, _memory, _pAllocator)
}
vkMapMemory :: (_device: VkDevice, _memory: VkDeviceMemory, _offset: VkDeviceSize, _size: VkDeviceSize, _flags: VkMemoryMapFlags, _ppData: ^mut ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkMapMemory(^result, _device, _memory, _offset, _size, _flags, _ppData)
    return result
}
vkUnmapMemory :: (_device: VkDevice, _memory: VkDeviceMemory) {
    __c__vkUnmapMemory(_device, _memory)
}
vkFlushMappedMemoryRanges :: (_device: VkDevice, _memoryRangeCount: uint32_t, _pMemoryRanges: ^mut VkMappedMemoryRange) -> VkResult {
    mut result : VkResult = default
    __c__vkFlushMappedMemoryRanges(^result, _device, _memoryRangeCount, _pMemoryRanges)
    return result
}
vkInvalidateMappedMemoryRanges :: (_device: VkDevice, _memoryRangeCount: uint32_t, _pMemoryRanges: ^mut VkMappedMemoryRange) -> VkResult {
    mut result : VkResult = default
    __c__vkInvalidateMappedMemoryRanges(^result, _device, _memoryRangeCount, _pMemoryRanges)
    return result
}
vkGetDeviceMemoryCommitment :: (_device: VkDevice, _memory: VkDeviceMemory, _pCommittedMemoryInBytes: ^mut VkDeviceSize) {
    __c__vkGetDeviceMemoryCommitment(_device, _memory, _pCommittedMemoryInBytes)
}
vkBindBufferMemory :: (_device: VkDevice, _buffer: VkBuffer, _memory: VkDeviceMemory, _memoryOffset: VkDeviceSize) -> VkResult {
    mut result : VkResult = default
    __c__vkBindBufferMemory(^result, _device, _buffer, _memory, _memoryOffset)
    return result
}
vkBindImageMemory :: (_device: VkDevice, _image: VkImage, _memory: VkDeviceMemory, _memoryOffset: VkDeviceSize) -> VkResult {
    mut result : VkResult = default
    __c__vkBindImageMemory(^result, _device, _image, _memory, _memoryOffset)
    return result
}
vkGetBufferMemoryRequirements :: (_device: VkDevice, _buffer: VkBuffer, _pMemoryRequirements: ^mut VkMemoryRequirements) {
    __c__vkGetBufferMemoryRequirements(_device, _buffer, _pMemoryRequirements)
}
vkGetImageMemoryRequirements :: (_device: VkDevice, _image: VkImage, _pMemoryRequirements: ^mut VkMemoryRequirements) {
    __c__vkGetImageMemoryRequirements(_device, _image, _pMemoryRequirements)
}
vkGetImageSparseMemoryRequirements :: (_device: VkDevice, _image: VkImage, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements) {
    __c__vkGetImageSparseMemoryRequirements(_device, _image, _pSparseMemoryRequirementCount, _pSparseMemoryRequirements)
}
vkGetPhysicalDeviceSparseImageFormatProperties :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _samples: VkSampleCountFlagBits, _usage: VkImageUsageFlags, _tiling: VkImageTiling, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties) {
    __c__vkGetPhysicalDeviceSparseImageFormatProperties(_physicalDevice, _format, _type, _samples, _usage, _tiling, _pPropertyCount, _pProperties)
}
vkQueueBindSparse :: (_queue: VkQueue, _bindInfoCount: uint32_t, _pBindInfo: ^mut VkBindSparseInfo, _fence: VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkQueueBindSparse(^result, _queue, _bindInfoCount, _pBindInfo, _fence)
    return result
}
vkCreateFence :: (_device: VkDevice, _pCreateInfo: ^mut VkFenceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateFence(^result, _device, _pCreateInfo, _pAllocator, _pFence)
    return result
}
vkDestroyFence :: (_device: VkDevice, _fence: VkFence, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyFence(_device, _fence, _pAllocator)
}
vkResetFences :: (_device: VkDevice, _fenceCount: uint32_t, _pFences: ^mut VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkResetFences(^result, _device, _fenceCount, _pFences)
    return result
}
vkGetFenceStatus :: (_device: VkDevice, _fence: VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkGetFenceStatus(^result, _device, _fence)
    return result
}
vkWaitForFences :: (_device: VkDevice, _fenceCount: uint32_t, _pFences: ^mut VkFence, _waitAll: VkBool32, _timeout: uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkWaitForFences(^result, _device, _fenceCount, _pFences, _waitAll, _timeout)
    return result
}
vkCreateSemaphore :: (_device: VkDevice, _pCreateInfo: ^mut VkSemaphoreCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSemaphore: ^mut VkSemaphore) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSemaphore(^result, _device, _pCreateInfo, _pAllocator, _pSemaphore)
    return result
}
vkDestroySemaphore :: (_device: VkDevice, _semaphore: VkSemaphore, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySemaphore(_device, _semaphore, _pAllocator)
}
vkCreateEvent :: (_device: VkDevice, _pCreateInfo: ^mut VkEventCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pEvent: ^mut VkEvent) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateEvent(^result, _device, _pCreateInfo, _pAllocator, _pEvent)
    return result
}
vkDestroyEvent :: (_device: VkDevice, _event: VkEvent, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyEvent(_device, _event, _pAllocator)
}
vkGetEventStatus :: (_device: VkDevice, _event: VkEvent) -> VkResult {
    mut result : VkResult = default
    __c__vkGetEventStatus(^result, _device, _event)
    return result
}
vkSetEvent :: (_device: VkDevice, _event: VkEvent) -> VkResult {
    mut result : VkResult = default
    __c__vkSetEvent(^result, _device, _event)
    return result
}
vkResetEvent :: (_device: VkDevice, _event: VkEvent) -> VkResult {
    mut result : VkResult = default
    __c__vkResetEvent(^result, _device, _event)
    return result
}
vkCreateQueryPool :: (_device: VkDevice, _pCreateInfo: ^mut VkQueryPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pQueryPool: ^mut VkQueryPool) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateQueryPool(^result, _device, _pCreateInfo, _pAllocator, _pQueryPool)
    return result
}
vkDestroyQueryPool :: (_device: VkDevice, _queryPool: VkQueryPool, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyQueryPool(_device, _queryPool, _pAllocator)
}
vkGetQueryPoolResults :: (_device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t, _dataSize: size_t, _pData: ^mut void, _stride: VkDeviceSize, _flags: VkQueryResultFlags) -> VkResult {
    mut result : VkResult = default
    __c__vkGetQueryPoolResults(^result, _device, _queryPool, _firstQuery, _queryCount, _dataSize, _pData, _stride, _flags)
    return result
}
vkCreateBuffer :: (_device: VkDevice, _pCreateInfo: ^mut VkBufferCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pBuffer: ^mut VkBuffer) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateBuffer(^result, _device, _pCreateInfo, _pAllocator, _pBuffer)
    return result
}
vkDestroyBuffer :: (_device: VkDevice, _buffer: VkBuffer, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyBuffer(_device, _buffer, _pAllocator)
}
vkCreateBufferView :: (_device: VkDevice, _pCreateInfo: ^mut VkBufferViewCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pView: ^mut VkBufferView) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateBufferView(^result, _device, _pCreateInfo, _pAllocator, _pView)
    return result
}
vkDestroyBufferView :: (_device: VkDevice, _bufferView: VkBufferView, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyBufferView(_device, _bufferView, _pAllocator)
}
vkCreateImage :: (_device: VkDevice, _pCreateInfo: ^mut VkImageCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pImage: ^mut VkImage) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateImage(^result, _device, _pCreateInfo, _pAllocator, _pImage)
    return result
}
vkDestroyImage :: (_device: VkDevice, _image: VkImage, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyImage(_device, _image, _pAllocator)
}
vkGetImageSubresourceLayout :: (_device: VkDevice, _image: VkImage, _pSubresource: ^mut VkImageSubresource, _pLayout: ^mut VkSubresourceLayout) {
    __c__vkGetImageSubresourceLayout(_device, _image, _pSubresource, _pLayout)
}
vkCreateImageView :: (_device: VkDevice, _pCreateInfo: ^mut VkImageViewCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pView: ^mut VkImageView) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateImageView(^result, _device, _pCreateInfo, _pAllocator, _pView)
    return result
}
vkDestroyImageView :: (_device: VkDevice, _imageView: VkImageView, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyImageView(_device, _imageView, _pAllocator)
}
vkCreateShaderModule :: (_device: VkDevice, _pCreateInfo: ^mut VkShaderModuleCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pShaderModule: ^mut VkShaderModule) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateShaderModule(^result, _device, _pCreateInfo, _pAllocator, _pShaderModule)
    return result
}
vkDestroyShaderModule :: (_device: VkDevice, _shaderModule: VkShaderModule, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyShaderModule(_device, _shaderModule, _pAllocator)
}
vkCreatePipelineCache :: (_device: VkDevice, _pCreateInfo: ^mut VkPipelineCacheCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelineCache: ^mut VkPipelineCache) -> VkResult {
    mut result : VkResult = default
    __c__vkCreatePipelineCache(^result, _device, _pCreateInfo, _pAllocator, _pPipelineCache)
    return result
}
vkDestroyPipelineCache :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyPipelineCache(_device, _pipelineCache, _pAllocator)
}
vkGetPipelineCacheData :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _pDataSize: ^mut size_t, _pData: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPipelineCacheData(^result, _device, _pipelineCache, _pDataSize, _pData)
    return result
}
vkMergePipelineCaches :: (_device: VkDevice, _dstCache: VkPipelineCache, _srcCacheCount: uint32_t, _pSrcCaches: ^mut VkPipelineCache) -> VkResult {
    mut result : VkResult = default
    __c__vkMergePipelineCaches(^result, _device, _dstCache, _srcCacheCount, _pSrcCaches)
    return result
}
vkCreateGraphicsPipelines :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkGraphicsPipelineCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateGraphicsPipelines(^result, _device, _pipelineCache, _createInfoCount, _pCreateInfos, _pAllocator, _pPipelines)
    return result
}
vkCreateComputePipelines :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkComputePipelineCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateComputePipelines(^result, _device, _pipelineCache, _createInfoCount, _pCreateInfos, _pAllocator, _pPipelines)
    return result
}
vkDestroyPipeline :: (_device: VkDevice, _pipeline: VkPipeline, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyPipeline(_device, _pipeline, _pAllocator)
}
vkCreatePipelineLayout :: (_device: VkDevice, _pCreateInfo: ^mut VkPipelineLayoutCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelineLayout: ^mut VkPipelineLayout) -> VkResult {
    mut result : VkResult = default
    __c__vkCreatePipelineLayout(^result, _device, _pCreateInfo, _pAllocator, _pPipelineLayout)
    return result
}
vkDestroyPipelineLayout :: (_device: VkDevice, _pipelineLayout: VkPipelineLayout, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyPipelineLayout(_device, _pipelineLayout, _pAllocator)
}
vkCreateSampler :: (_device: VkDevice, _pCreateInfo: ^mut VkSamplerCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSampler: ^mut VkSampler) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSampler(^result, _device, _pCreateInfo, _pAllocator, _pSampler)
    return result
}
vkDestroySampler :: (_device: VkDevice, _sampler: VkSampler, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySampler(_device, _sampler, _pAllocator)
}
vkCreateDescriptorSetLayout :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSetLayout: ^mut VkDescriptorSetLayout) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDescriptorSetLayout(^result, _device, _pCreateInfo, _pAllocator, _pSetLayout)
    return result
}
vkDestroyDescriptorSetLayout :: (_device: VkDevice, _descriptorSetLayout: VkDescriptorSetLayout, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDescriptorSetLayout(_device, _descriptorSetLayout, _pAllocator)
}
vkCreateDescriptorPool :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorPool: ^mut VkDescriptorPool) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDescriptorPool(^result, _device, _pCreateInfo, _pAllocator, _pDescriptorPool)
    return result
}
vkDestroyDescriptorPool :: (_device: VkDevice, _descriptorPool: VkDescriptorPool, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDescriptorPool(_device, _descriptorPool, _pAllocator)
}
vkResetDescriptorPool :: (_device: VkDevice, _descriptorPool: VkDescriptorPool, _flags: VkDescriptorPoolResetFlags) -> VkResult {
    mut result : VkResult = default
    __c__vkResetDescriptorPool(^result, _device, _descriptorPool, _flags)
    return result
}
vkAllocateDescriptorSets :: (_device: VkDevice, _pAllocateInfo: ^mut VkDescriptorSetAllocateInfo, _pDescriptorSets: ^mut VkDescriptorSet) -> VkResult {
    mut result : VkResult = default
    __c__vkAllocateDescriptorSets(^result, _device, _pAllocateInfo, _pDescriptorSets)
    return result
}
vkFreeDescriptorSets :: (_device: VkDevice, _descriptorPool: VkDescriptorPool, _descriptorSetCount: uint32_t, _pDescriptorSets: ^mut VkDescriptorSet) -> VkResult {
    mut result : VkResult = default
    __c__vkFreeDescriptorSets(^result, _device, _descriptorPool, _descriptorSetCount, _pDescriptorSets)
    return result
}
vkUpdateDescriptorSets :: (_device: VkDevice, _descriptorWriteCount: uint32_t, _pDescriptorWrites: ^mut VkWriteDescriptorSet, _descriptorCopyCount: uint32_t, _pDescriptorCopies: ^mut VkCopyDescriptorSet) {
    __c__vkUpdateDescriptorSets(_device, _descriptorWriteCount, _pDescriptorWrites, _descriptorCopyCount, _pDescriptorCopies)
}
vkCreateFramebuffer :: (_device: VkDevice, _pCreateInfo: ^mut VkFramebufferCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pFramebuffer: ^mut VkFramebuffer) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateFramebuffer(^result, _device, _pCreateInfo, _pAllocator, _pFramebuffer)
    return result
}
vkDestroyFramebuffer :: (_device: VkDevice, _framebuffer: VkFramebuffer, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyFramebuffer(_device, _framebuffer, _pAllocator)
}
vkCreateRenderPass :: (_device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateRenderPass(^result, _device, _pCreateInfo, _pAllocator, _pRenderPass)
    return result
}
vkDestroyRenderPass :: (_device: VkDevice, _renderPass: VkRenderPass, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyRenderPass(_device, _renderPass, _pAllocator)
}
vkGetRenderAreaGranularity :: (_device: VkDevice, _renderPass: VkRenderPass, _pGranularity: ^mut VkExtent2D) {
    __c__vkGetRenderAreaGranularity(_device, _renderPass, _pGranularity)
}
vkCreateCommandPool :: (_device: VkDevice, _pCreateInfo: ^mut VkCommandPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pCommandPool: ^mut VkCommandPool) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateCommandPool(^result, _device, _pCreateInfo, _pAllocator, _pCommandPool)
    return result
}
vkDestroyCommandPool :: (_device: VkDevice, _commandPool: VkCommandPool, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyCommandPool(_device, _commandPool, _pAllocator)
}
vkResetCommandPool :: (_device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolResetFlags) -> VkResult {
    mut result : VkResult = default
    __c__vkResetCommandPool(^result, _device, _commandPool, _flags)
    return result
}
vkAllocateCommandBuffers :: (_device: VkDevice, _pAllocateInfo: ^mut VkCommandBufferAllocateInfo, _pCommandBuffers: ^mut VkCommandBuffer) -> VkResult {
    mut result : VkResult = default
    __c__vkAllocateCommandBuffers(^result, _device, _pAllocateInfo, _pCommandBuffers)
    return result
}
vkFreeCommandBuffers :: (_device: VkDevice, _commandPool: VkCommandPool, _commandBufferCount: uint32_t, _pCommandBuffers: ^mut VkCommandBuffer) {
    __c__vkFreeCommandBuffers(_device, _commandPool, _commandBufferCount, _pCommandBuffers)
}
vkBeginCommandBuffer :: (_commandBuffer: VkCommandBuffer, _pBeginInfo: ^mut VkCommandBufferBeginInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkBeginCommandBuffer(^result, _commandBuffer, _pBeginInfo)
    return result
}
vkEndCommandBuffer :: (_commandBuffer: VkCommandBuffer) -> VkResult {
    mut result : VkResult = default
    __c__vkEndCommandBuffer(^result, _commandBuffer)
    return result
}
vkResetCommandBuffer :: (_commandBuffer: VkCommandBuffer, _flags: VkCommandBufferResetFlags) -> VkResult {
    mut result : VkResult = default
    __c__vkResetCommandBuffer(^result, _commandBuffer, _flags)
    return result
}
vkCmdBindPipeline :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _pipeline: VkPipeline) {
    __c__vkCmdBindPipeline(_commandBuffer, _pipelineBindPoint, _pipeline)
}
vkCmdSetViewport :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pViewports: ^mut VkViewport) {
    __c__vkCmdSetViewport(_commandBuffer, _firstViewport, _viewportCount, _pViewports)
}
vkCmdSetScissor :: (_commandBuffer: VkCommandBuffer, _firstScissor: uint32_t, _scissorCount: uint32_t, _pScissors: ^mut VkRect2D) {
    __c__vkCmdSetScissor(_commandBuffer, _firstScissor, _scissorCount, _pScissors)
}
vkCmdSetLineWidth :: (_commandBuffer: VkCommandBuffer, _lineWidth: f32) {
    __c__vkCmdSetLineWidth(_commandBuffer, _lineWidth)
}
vkCmdSetDepthBias :: (_commandBuffer: VkCommandBuffer, _depthBiasConstantFactor: f32, _depthBiasClamp: f32, _depthBiasSlopeFactor: f32) {
    __c__vkCmdSetDepthBias(_commandBuffer, _depthBiasConstantFactor, _depthBiasClamp, _depthBiasSlopeFactor)
}
vkCmdSetBlendConstants :: (_commandBuffer: VkCommandBuffer, _blendConstants: ^mut f32) {
    __c__vkCmdSetBlendConstants(_commandBuffer, _blendConstants)
}
vkCmdSetDepthBounds :: (_commandBuffer: VkCommandBuffer, _minDepthBounds: f32, _maxDepthBounds: f32) {
    __c__vkCmdSetDepthBounds(_commandBuffer, _minDepthBounds, _maxDepthBounds)
}
vkCmdSetStencilCompareMask :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _compareMask: uint32_t) {
    __c__vkCmdSetStencilCompareMask(_commandBuffer, _faceMask, _compareMask)
}
vkCmdSetStencilWriteMask :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _writeMask: uint32_t) {
    __c__vkCmdSetStencilWriteMask(_commandBuffer, _faceMask, _writeMask)
}
vkCmdSetStencilReference :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _reference: uint32_t) {
    __c__vkCmdSetStencilReference(_commandBuffer, _faceMask, _reference)
}
vkCmdBindDescriptorSets :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _layout: VkPipelineLayout, _firstSet: uint32_t, _descriptorSetCount: uint32_t, _pDescriptorSets: ^mut VkDescriptorSet, _dynamicOffsetCount: uint32_t, _pDynamicOffsets: ^mut uint32_t) {
    __c__vkCmdBindDescriptorSets(_commandBuffer, _pipelineBindPoint, _layout, _firstSet, _descriptorSetCount, _pDescriptorSets, _dynamicOffsetCount, _pDynamicOffsets)
}
vkCmdBindIndexBuffer :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _indexType: VkIndexType) {
    __c__vkCmdBindIndexBuffer(_commandBuffer, _buffer, _offset, _indexType)
}
vkCmdBindVertexBuffers :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize) {
    __c__vkCmdBindVertexBuffers(_commandBuffer, _firstBinding, _bindingCount, _pBuffers, _pOffsets)
}
vkCmdDraw :: (_commandBuffer: VkCommandBuffer, _vertexCount: uint32_t, _instanceCount: uint32_t, _firstVertex: uint32_t, _firstInstance: uint32_t) {
    __c__vkCmdDraw(_commandBuffer, _vertexCount, _instanceCount, _firstVertex, _firstInstance)
}
vkCmdDrawIndexed :: (_commandBuffer: VkCommandBuffer, _indexCount: uint32_t, _instanceCount: uint32_t, _firstIndex: uint32_t, _vertexOffset: int32_t, _firstInstance: uint32_t) {
    __c__vkCmdDrawIndexed(_commandBuffer, _indexCount, _instanceCount, _firstIndex, _vertexOffset, _firstInstance)
}
vkCmdDrawIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndirect(_commandBuffer, _buffer, _offset, _drawCount, _stride)
}
vkCmdDrawIndexedIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndexedIndirect(_commandBuffer, _buffer, _offset, _drawCount, _stride)
}
vkCmdDispatch :: (_commandBuffer: VkCommandBuffer, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t) {
    __c__vkCmdDispatch(_commandBuffer, _groupCountX, _groupCountY, _groupCountZ)
}
vkCmdDispatchIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize) {
    __c__vkCmdDispatchIndirect(_commandBuffer, _buffer, _offset)
}
vkCmdCopyBuffer :: (_commandBuffer: VkCommandBuffer, _srcBuffer: VkBuffer, _dstBuffer: VkBuffer, _regionCount: uint32_t, _pRegions: ^mut VkBufferCopy) {
    __c__vkCmdCopyBuffer(_commandBuffer, _srcBuffer, _dstBuffer, _regionCount, _pRegions)
}
vkCmdCopyImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageCopy) {
    __c__vkCmdCopyImage(_commandBuffer, _srcImage, _srcImageLayout, _dstImage, _dstImageLayout, _regionCount, _pRegions)
}
vkCmdBlitImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageBlit, _filter: VkFilter) {
    __c__vkCmdBlitImage(_commandBuffer, _srcImage, _srcImageLayout, _dstImage, _dstImageLayout, _regionCount, _pRegions, _filter)
}
vkCmdCopyBufferToImage :: (_commandBuffer: VkCommandBuffer, _srcBuffer: VkBuffer, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkBufferImageCopy) {
    __c__vkCmdCopyBufferToImage(_commandBuffer, _srcBuffer, _dstImage, _dstImageLayout, _regionCount, _pRegions)
}
vkCmdCopyImageToBuffer :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstBuffer: VkBuffer, _regionCount: uint32_t, _pRegions: ^mut VkBufferImageCopy) {
    __c__vkCmdCopyImageToBuffer(_commandBuffer, _srcImage, _srcImageLayout, _dstBuffer, _regionCount, _pRegions)
}
vkCmdUpdateBuffer :: (_commandBuffer: VkCommandBuffer, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _dataSize: VkDeviceSize, _pData: ^mut void) {
    __c__vkCmdUpdateBuffer(_commandBuffer, _dstBuffer, _dstOffset, _dataSize, _pData)
}
vkCmdFillBuffer :: (_commandBuffer: VkCommandBuffer, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _size: VkDeviceSize, _data: uint32_t) {
    __c__vkCmdFillBuffer(_commandBuffer, _dstBuffer, _dstOffset, _size, _data)
}
vkCmdClearColorImage :: (_commandBuffer: VkCommandBuffer, _image: VkImage, _imageLayout: VkImageLayout, _pColor: ^mut VkClearColorValue, _rangeCount: uint32_t, _pRanges: ^mut VkImageSubresourceRange) {
    __c__vkCmdClearColorImage(_commandBuffer, _image, _imageLayout, _pColor, _rangeCount, _pRanges)
}
vkCmdClearDepthStencilImage :: (_commandBuffer: VkCommandBuffer, _image: VkImage, _imageLayout: VkImageLayout, _pDepthStencil: ^mut VkClearDepthStencilValue, _rangeCount: uint32_t, _pRanges: ^mut VkImageSubresourceRange) {
    __c__vkCmdClearDepthStencilImage(_commandBuffer, _image, _imageLayout, _pDepthStencil, _rangeCount, _pRanges)
}
vkCmdClearAttachments :: (_commandBuffer: VkCommandBuffer, _attachmentCount: uint32_t, _pAttachments: ^mut VkClearAttachment, _rectCount: uint32_t, _pRects: ^mut VkClearRect) {
    __c__vkCmdClearAttachments(_commandBuffer, _attachmentCount, _pAttachments, _rectCount, _pRects)
}
vkCmdResolveImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageResolve) {
    __c__vkCmdResolveImage(_commandBuffer, _srcImage, _srcImageLayout, _dstImage, _dstImageLayout, _regionCount, _pRegions)
}
vkCmdSetEvent :: (_commandBuffer: VkCommandBuffer, _event: VkEvent, _stageMask: VkPipelineStageFlags) {
    __c__vkCmdSetEvent(_commandBuffer, _event, _stageMask)
}
vkCmdResetEvent :: (_commandBuffer: VkCommandBuffer, _event: VkEvent, _stageMask: VkPipelineStageFlags) {
    __c__vkCmdResetEvent(_commandBuffer, _event, _stageMask)
}
vkCmdWaitEvents :: (_commandBuffer: VkCommandBuffer, _eventCount: uint32_t, _pEvents: ^mut VkEvent, _srcStageMask: VkPipelineStageFlags, _dstStageMask: VkPipelineStageFlags, _memoryBarrierCount: uint32_t, _pMemoryBarriers: ^mut VkMemoryBarrier, _bufferMemoryBarrierCount: uint32_t, _pBufferMemoryBarriers: ^mut VkBufferMemoryBarrier, _imageMemoryBarrierCount: uint32_t, _pImageMemoryBarriers: ^mut VkImageMemoryBarrier) {
    __c__vkCmdWaitEvents(_commandBuffer, _eventCount, _pEvents, _srcStageMask, _dstStageMask, _memoryBarrierCount, _pMemoryBarriers, _bufferMemoryBarrierCount, _pBufferMemoryBarriers, _imageMemoryBarrierCount, _pImageMemoryBarriers)
}
vkCmdPipelineBarrier :: (_commandBuffer: VkCommandBuffer, _srcStageMask: VkPipelineStageFlags, _dstStageMask: VkPipelineStageFlags, _dependencyFlags: VkDependencyFlags, _memoryBarrierCount: uint32_t, _pMemoryBarriers: ^mut VkMemoryBarrier, _bufferMemoryBarrierCount: uint32_t, _pBufferMemoryBarriers: ^mut VkBufferMemoryBarrier, _imageMemoryBarrierCount: uint32_t, _pImageMemoryBarriers: ^mut VkImageMemoryBarrier) {
    __c__vkCmdPipelineBarrier(_commandBuffer, _srcStageMask, _dstStageMask, _dependencyFlags, _memoryBarrierCount, _pMemoryBarriers, _bufferMemoryBarrierCount, _pBufferMemoryBarriers, _imageMemoryBarrierCount, _pImageMemoryBarriers)
}
vkCmdBeginQuery :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _flags: VkQueryControlFlags) {
    __c__vkCmdBeginQuery(_commandBuffer, _queryPool, _query, _flags)
}
vkCmdEndQuery :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t) {
    __c__vkCmdEndQuery(_commandBuffer, _queryPool, _query)
}
vkCmdResetQueryPool :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t) {
    __c__vkCmdResetQueryPool(_commandBuffer, _queryPool, _firstQuery, _queryCount)
}
vkCmdWriteTimestamp :: (_commandBuffer: VkCommandBuffer, _pipelineStage: VkPipelineStageFlagBits, _queryPool: VkQueryPool, _query: uint32_t) {
    __c__vkCmdWriteTimestamp(_commandBuffer, _pipelineStage, _queryPool, _query)
}
vkCmdCopyQueryPoolResults :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _stride: VkDeviceSize, _flags: VkQueryResultFlags) {
    __c__vkCmdCopyQueryPoolResults(_commandBuffer, _queryPool, _firstQuery, _queryCount, _dstBuffer, _dstOffset, _stride, _flags)
}
vkCmdPushConstants :: (_commandBuffer: VkCommandBuffer, _layout: VkPipelineLayout, _stageFlags: VkShaderStageFlags, _offset: uint32_t, _size: uint32_t, _pValues: ^mut void) {
    __c__vkCmdPushConstants(_commandBuffer, _layout, _stageFlags, _offset, _size, _pValues)
}
vkCmdBeginRenderPass :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _contents: VkSubpassContents) {
    __c__vkCmdBeginRenderPass(_commandBuffer, _pRenderPassBegin, _contents)
}
vkCmdNextSubpass :: (_commandBuffer: VkCommandBuffer, _contents: VkSubpassContents) {
    __c__vkCmdNextSubpass(_commandBuffer, _contents)
}
vkCmdEndRenderPass :: (_commandBuffer: VkCommandBuffer) {
    __c__vkCmdEndRenderPass(_commandBuffer)
}
vkCmdExecuteCommands :: (_commandBuffer: VkCommandBuffer, _commandBufferCount: uint32_t, _pCommandBuffers: ^mut VkCommandBuffer) {
    __c__vkCmdExecuteCommands(_commandBuffer, _commandBufferCount, _pCommandBuffers)
}
vkEnumerateInstanceVersion :: (_pApiVersion: ^mut uint32_t) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumerateInstanceVersion(^result, _pApiVersion)
    return result
}
vkBindBufferMemory2 :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindBufferMemoryInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkBindBufferMemory2(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkBindImageMemory2 :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindImageMemoryInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkBindImageMemory2(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkGetDeviceGroupPeerMemoryFeatures :: (_device: VkDevice, _heapIndex: uint32_t, _localDeviceIndex: uint32_t, _remoteDeviceIndex: uint32_t, _pPeerMemoryFeatures: ^mut VkPeerMemoryFeatureFlags) {
    __c__vkGetDeviceGroupPeerMemoryFeatures(_device, _heapIndex, _localDeviceIndex, _remoteDeviceIndex, _pPeerMemoryFeatures)
}
vkCmdSetDeviceMask :: (_commandBuffer: VkCommandBuffer, _deviceMask: uint32_t) {
    __c__vkCmdSetDeviceMask(_commandBuffer, _deviceMask)
}
vkCmdDispatchBase :: (_commandBuffer: VkCommandBuffer, _baseGroupX: uint32_t, _baseGroupY: uint32_t, _baseGroupZ: uint32_t, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t) {
    __c__vkCmdDispatchBase(_commandBuffer, _baseGroupX, _baseGroupY, _baseGroupZ, _groupCountX, _groupCountY, _groupCountZ)
}
vkEnumeratePhysicalDeviceGroups :: (_instance: VkInstance, _pPhysicalDeviceGroupCount: ^mut uint32_t, _pPhysicalDeviceGroupProperties: ^mut VkPhysicalDeviceGroupProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumeratePhysicalDeviceGroups(^result, _instance, _pPhysicalDeviceGroupCount, _pPhysicalDeviceGroupProperties)
    return result
}
vkGetImageMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkImageMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2) {
    __c__vkGetImageMemoryRequirements2(_device, _pInfo, _pMemoryRequirements)
}
vkGetBufferMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkBufferMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2) {
    __c__vkGetBufferMemoryRequirements2(_device, _pInfo, _pMemoryRequirements)
}
vkGetImageSparseMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkImageSparseMemoryRequirementsInfo2, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements2) {
    __c__vkGetImageSparseMemoryRequirements2(_device, _pInfo, _pSparseMemoryRequirementCount, _pSparseMemoryRequirements)
}
vkGetPhysicalDeviceFeatures2 :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures2) {
    __c__vkGetPhysicalDeviceFeatures2(_physicalDevice, _pFeatures)
}
vkGetPhysicalDeviceProperties2 :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties2) {
    __c__vkGetPhysicalDeviceProperties2(_physicalDevice, _pProperties)
}
vkGetPhysicalDeviceFormatProperties2 :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties2) {
    __c__vkGetPhysicalDeviceFormatProperties2(_physicalDevice, _format, _pFormatProperties)
}
vkGetPhysicalDeviceImageFormatProperties2 :: (_physicalDevice: VkPhysicalDevice, _pImageFormatInfo: ^mut VkPhysicalDeviceImageFormatInfo2, _pImageFormatProperties: ^mut VkImageFormatProperties2) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceImageFormatProperties2(^result, _physicalDevice, _pImageFormatInfo, _pImageFormatProperties)
    return result
}
vkGetPhysicalDeviceQueueFamilyProperties2 :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties2) {
    __c__vkGetPhysicalDeviceQueueFamilyProperties2(_physicalDevice, _pQueueFamilyPropertyCount, _pQueueFamilyProperties)
}
vkGetPhysicalDeviceMemoryProperties2 :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties2) {
    __c__vkGetPhysicalDeviceMemoryProperties2(_physicalDevice, _pMemoryProperties)
}
vkGetPhysicalDeviceSparseImageFormatProperties2 :: (_physicalDevice: VkPhysicalDevice, _pFormatInfo: ^mut VkPhysicalDeviceSparseImageFormatInfo2, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties2) {
    __c__vkGetPhysicalDeviceSparseImageFormatProperties2(_physicalDevice, _pFormatInfo, _pPropertyCount, _pProperties)
}
vkTrimCommandPool :: (_device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolTrimFlags) {
    __c__vkTrimCommandPool(_device, _commandPool, _flags)
}
vkGetDeviceQueue2 :: (_device: VkDevice, _pQueueInfo: ^mut VkDeviceQueueInfo2, _pQueue: ^mut VkQueue) {
    __c__vkGetDeviceQueue2(_device, _pQueueInfo, _pQueue)
}
vkCreateSamplerYcbcrConversion :: (_device: VkDevice, _pCreateInfo: ^mut VkSamplerYcbcrConversionCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pYcbcrConversion: ^mut VkSamplerYcbcrConversion) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSamplerYcbcrConversion(^result, _device, _pCreateInfo, _pAllocator, _pYcbcrConversion)
    return result
}
vkDestroySamplerYcbcrConversion :: (_device: VkDevice, _ycbcrConversion: VkSamplerYcbcrConversion, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySamplerYcbcrConversion(_device, _ycbcrConversion, _pAllocator)
}
vkCreateDescriptorUpdateTemplate :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorUpdateTemplateCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorUpdateTemplate: ^mut VkDescriptorUpdateTemplate) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDescriptorUpdateTemplate(^result, _device, _pCreateInfo, _pAllocator, _pDescriptorUpdateTemplate)
    return result
}
vkDestroyDescriptorUpdateTemplate :: (_device: VkDevice, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDescriptorUpdateTemplate(_device, _descriptorUpdateTemplate, _pAllocator)
}
vkUpdateDescriptorSetWithTemplate :: (_device: VkDevice, _descriptorSet: VkDescriptorSet, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pData: ^mut void) {
    __c__vkUpdateDescriptorSetWithTemplate(_device, _descriptorSet, _descriptorUpdateTemplate, _pData)
}
vkGetPhysicalDeviceExternalBufferProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalBufferInfo: ^mut VkPhysicalDeviceExternalBufferInfo, _pExternalBufferProperties: ^mut VkExternalBufferProperties) {
    __c__vkGetPhysicalDeviceExternalBufferProperties(_physicalDevice, _pExternalBufferInfo, _pExternalBufferProperties)
}
vkGetPhysicalDeviceExternalFenceProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalFenceInfo: ^mut VkPhysicalDeviceExternalFenceInfo, _pExternalFenceProperties: ^mut VkExternalFenceProperties) {
    __c__vkGetPhysicalDeviceExternalFenceProperties(_physicalDevice, _pExternalFenceInfo, _pExternalFenceProperties)
}
vkGetPhysicalDeviceExternalSemaphoreProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalSemaphoreInfo: ^mut VkPhysicalDeviceExternalSemaphoreInfo, _pExternalSemaphoreProperties: ^mut VkExternalSemaphoreProperties) {
    __c__vkGetPhysicalDeviceExternalSemaphoreProperties(_physicalDevice, _pExternalSemaphoreInfo, _pExternalSemaphoreProperties)
}
vkGetDescriptorSetLayoutSupport :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pSupport: ^mut VkDescriptorSetLayoutSupport) {
    __c__vkGetDescriptorSetLayoutSupport(_device, _pCreateInfo, _pSupport)
}
vkCmdDrawIndirectCount :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndirectCount(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkCmdDrawIndexedIndirectCount :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndexedIndirectCount(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkCreateRenderPass2 :: (_device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo2, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateRenderPass2(^result, _device, _pCreateInfo, _pAllocator, _pRenderPass)
    return result
}
vkCmdBeginRenderPass2 :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo) {
    __c__vkCmdBeginRenderPass2(_commandBuffer, _pRenderPassBegin, _pSubpassBeginInfo)
}
vkCmdNextSubpass2 :: (_commandBuffer: VkCommandBuffer, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo, _pSubpassEndInfo: ^mut VkSubpassEndInfo) {
    __c__vkCmdNextSubpass2(_commandBuffer, _pSubpassBeginInfo, _pSubpassEndInfo)
}
vkCmdEndRenderPass2 :: (_commandBuffer: VkCommandBuffer, _pSubpassEndInfo: ^mut VkSubpassEndInfo) {
    __c__vkCmdEndRenderPass2(_commandBuffer, _pSubpassEndInfo)
}
vkResetQueryPool :: (_device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t) {
    __c__vkResetQueryPool(_device, _queryPool, _firstQuery, _queryCount)
}
vkGetSemaphoreCounterValue :: (_device: VkDevice, _semaphore: VkSemaphore, _pValue: ^mut uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSemaphoreCounterValue(^result, _device, _semaphore, _pValue)
    return result
}
vkWaitSemaphores :: (_device: VkDevice, _pWaitInfo: ^mut VkSemaphoreWaitInfo, _timeout: uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkWaitSemaphores(^result, _device, _pWaitInfo, _timeout)
    return result
}
vkSignalSemaphore :: (_device: VkDevice, _pSignalInfo: ^mut VkSemaphoreSignalInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkSignalSemaphore(^result, _device, _pSignalInfo)
    return result
}
vkGetBufferDeviceAddress :: (_device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress {
    mut result : VkDeviceAddress = default
    __c__vkGetBufferDeviceAddress(^result, _device, _pInfo)
    return result
}
vkGetBufferOpaqueCaptureAddress :: (_device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo) -> uint64_t {
    mut result : uint64_t = default
    __c__vkGetBufferOpaqueCaptureAddress(^result, _device, _pInfo)
    return result
}
vkGetDeviceMemoryOpaqueCaptureAddress :: (_device: VkDevice, _pInfo: ^mut VkDeviceMemoryOpaqueCaptureAddressInfo) -> uint64_t {
    mut result : uint64_t = default
    __c__vkGetDeviceMemoryOpaqueCaptureAddress(^result, _device, _pInfo)
    return result
}
vkDestroySurfaceKHR :: (_instance: VkInstance, _surface: VkSurfaceKHR, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySurfaceKHR(_instance, _surface, _pAllocator)
}
vkGetPhysicalDeviceSurfaceSupportKHR :: (_physicalDevice: VkPhysicalDevice, _queueFamilyIndex: uint32_t, _surface: VkSurfaceKHR, _pSupported: ^mut VkBool32) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceSupportKHR(^result, _physicalDevice, _queueFamilyIndex, _surface, _pSupported)
    return result
}
vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: (_physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilitiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceCapabilitiesKHR(^result, _physicalDevice, _surface, _pSurfaceCapabilities)
    return result
}
vkGetPhysicalDeviceSurfaceFormatsKHR :: (_physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceFormatCount: ^mut uint32_t, _pSurfaceFormats: ^mut VkSurfaceFormatKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceFormatsKHR(^result, _physicalDevice, _surface, _pSurfaceFormatCount, _pSurfaceFormats)
    return result
}
vkGetPhysicalDeviceSurfacePresentModesKHR :: (_physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pPresentModeCount: ^mut uint32_t, _pPresentModes: ^mut VkPresentModeKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfacePresentModesKHR(^result, _physicalDevice, _surface, _pPresentModeCount, _pPresentModes)
    return result
}
vkCreateSwapchainKHR :: (_device: VkDevice, _pCreateInfo: ^mut VkSwapchainCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSwapchain: ^mut VkSwapchainKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSwapchainKHR(^result, _device, _pCreateInfo, _pAllocator, _pSwapchain)
    return result
}
vkDestroySwapchainKHR :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySwapchainKHR(_device, _swapchain, _pAllocator)
}
vkGetSwapchainImagesKHR :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _pSwapchainImageCount: ^mut uint32_t, _pSwapchainImages: ^mut VkImage) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSwapchainImagesKHR(^result, _device, _swapchain, _pSwapchainImageCount, _pSwapchainImages)
    return result
}
vkAcquireNextImageKHR :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _timeout: uint64_t, _semaphore: VkSemaphore, _fence: VkFence, _pImageIndex: ^mut uint32_t) -> VkResult {
    mut result : VkResult = default
    __c__vkAcquireNextImageKHR(^result, _device, _swapchain, _timeout, _semaphore, _fence, _pImageIndex)
    return result
}
vkQueuePresentKHR :: (_queue: VkQueue, _pPresentInfo: ^mut VkPresentInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkQueuePresentKHR(^result, _queue, _pPresentInfo)
    return result
}
vkGetDeviceGroupPresentCapabilitiesKHR :: (_device: VkDevice, _pDeviceGroupPresentCapabilities: ^mut VkDeviceGroupPresentCapabilitiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDeviceGroupPresentCapabilitiesKHR(^result, _device, _pDeviceGroupPresentCapabilities)
    return result
}
vkGetDeviceGroupSurfacePresentModesKHR :: (_device: VkDevice, _surface: VkSurfaceKHR, _pModes: ^mut VkDeviceGroupPresentModeFlagsKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDeviceGroupSurfacePresentModesKHR(^result, _device, _surface, _pModes)
    return result
}
vkGetPhysicalDevicePresentRectanglesKHR :: (_physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pRectCount: ^mut uint32_t, _pRects: ^mut VkRect2D) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDevicePresentRectanglesKHR(^result, _physicalDevice, _surface, _pRectCount, _pRects)
    return result
}
vkAcquireNextImage2KHR :: (_device: VkDevice, _pAcquireInfo: ^mut VkAcquireNextImageInfoKHR, _pImageIndex: ^mut uint32_t) -> VkResult {
    mut result : VkResult = default
    __c__vkAcquireNextImage2KHR(^result, _device, _pAcquireInfo, _pImageIndex)
    return result
}
vkGetPhysicalDeviceDisplayPropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPropertiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceDisplayPropertiesKHR(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPlanePropertiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceDisplayPlanePropertiesKHR(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetDisplayPlaneSupportedDisplaysKHR :: (_physicalDevice: VkPhysicalDevice, _planeIndex: uint32_t, _pDisplayCount: ^mut uint32_t, _pDisplays: ^mut VkDisplayKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDisplayPlaneSupportedDisplaysKHR(^result, _physicalDevice, _planeIndex, _pDisplayCount, _pDisplays)
    return result
}
vkGetDisplayModePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayModePropertiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDisplayModePropertiesKHR(^result, _physicalDevice, _display, _pPropertyCount, _pProperties)
    return result
}
vkCreateDisplayModeKHR :: (_physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pCreateInfo: ^mut VkDisplayModeCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pMode: ^mut VkDisplayModeKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDisplayModeKHR(^result, _physicalDevice, _display, _pCreateInfo, _pAllocator, _pMode)
    return result
}
vkGetDisplayPlaneCapabilitiesKHR :: (_physicalDevice: VkPhysicalDevice, _mode: VkDisplayModeKHR, _planeIndex: uint32_t, _pCapabilities: ^mut VkDisplayPlaneCapabilitiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDisplayPlaneCapabilitiesKHR(^result, _physicalDevice, _mode, _planeIndex, _pCapabilities)
    return result
}
vkCreateDisplayPlaneSurfaceKHR :: (_instance: VkInstance, _pCreateInfo: ^mut VkDisplaySurfaceCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSurface: ^mut VkSurfaceKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDisplayPlaneSurfaceKHR(^result, _instance, _pCreateInfo, _pAllocator, _pSurface)
    return result
}
vkCreateSharedSwapchainsKHR :: (_device: VkDevice, _swapchainCount: uint32_t, _pCreateInfos: ^mut VkSwapchainCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSwapchains: ^mut VkSwapchainKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSharedSwapchainsKHR(^result, _device, _swapchainCount, _pCreateInfos, _pAllocator, _pSwapchains)
    return result
}
vkGetPhysicalDeviceFeatures2KHR :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures2) {
    __c__vkGetPhysicalDeviceFeatures2KHR(_physicalDevice, _pFeatures)
}
vkGetPhysicalDeviceProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties2) {
    __c__vkGetPhysicalDeviceProperties2KHR(_physicalDevice, _pProperties)
}
vkGetPhysicalDeviceFormatProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties2) {
    __c__vkGetPhysicalDeviceFormatProperties2KHR(_physicalDevice, _format, _pFormatProperties)
}
vkGetPhysicalDeviceImageFormatProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pImageFormatInfo: ^mut VkPhysicalDeviceImageFormatInfo2, _pImageFormatProperties: ^mut VkImageFormatProperties2) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceImageFormatProperties2KHR(^result, _physicalDevice, _pImageFormatInfo, _pImageFormatProperties)
    return result
}
vkGetPhysicalDeviceQueueFamilyProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties2) {
    __c__vkGetPhysicalDeviceQueueFamilyProperties2KHR(_physicalDevice, _pQueueFamilyPropertyCount, _pQueueFamilyProperties)
}
vkGetPhysicalDeviceMemoryProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties2) {
    __c__vkGetPhysicalDeviceMemoryProperties2KHR(_physicalDevice, _pMemoryProperties)
}
vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pFormatInfo: ^mut VkPhysicalDeviceSparseImageFormatInfo2, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties2) {
    __c__vkGetPhysicalDeviceSparseImageFormatProperties2KHR(_physicalDevice, _pFormatInfo, _pPropertyCount, _pProperties)
}
vkGetDeviceGroupPeerMemoryFeaturesKHR :: (_device: VkDevice, _heapIndex: uint32_t, _localDeviceIndex: uint32_t, _remoteDeviceIndex: uint32_t, _pPeerMemoryFeatures: ^mut VkPeerMemoryFeatureFlags) {
    __c__vkGetDeviceGroupPeerMemoryFeaturesKHR(_device, _heapIndex, _localDeviceIndex, _remoteDeviceIndex, _pPeerMemoryFeatures)
}
vkCmdSetDeviceMaskKHR :: (_commandBuffer: VkCommandBuffer, _deviceMask: uint32_t) {
    __c__vkCmdSetDeviceMaskKHR(_commandBuffer, _deviceMask)
}
vkCmdDispatchBaseKHR :: (_commandBuffer: VkCommandBuffer, _baseGroupX: uint32_t, _baseGroupY: uint32_t, _baseGroupZ: uint32_t, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t) {
    __c__vkCmdDispatchBaseKHR(_commandBuffer, _baseGroupX, _baseGroupY, _baseGroupZ, _groupCountX, _groupCountY, _groupCountZ)
}
vkTrimCommandPoolKHR :: (_device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolTrimFlags) {
    __c__vkTrimCommandPoolKHR(_device, _commandPool, _flags)
}
vkEnumeratePhysicalDeviceGroupsKHR :: (_instance: VkInstance, _pPhysicalDeviceGroupCount: ^mut uint32_t, _pPhysicalDeviceGroupProperties: ^mut VkPhysicalDeviceGroupProperties) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumeratePhysicalDeviceGroupsKHR(^result, _instance, _pPhysicalDeviceGroupCount, _pPhysicalDeviceGroupProperties)
    return result
}
vkGetPhysicalDeviceExternalBufferPropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalBufferInfo: ^mut VkPhysicalDeviceExternalBufferInfo, _pExternalBufferProperties: ^mut VkExternalBufferProperties) {
    __c__vkGetPhysicalDeviceExternalBufferPropertiesKHR(_physicalDevice, _pExternalBufferInfo, _pExternalBufferProperties)
}
vkGetMemoryFdKHR :: (_device: VkDevice, _pGetFdInfo: ^mut VkMemoryGetFdInfoKHR, _pFd: ^mut i32) -> VkResult {
    mut result : VkResult = default
    __c__vkGetMemoryFdKHR(^result, _device, _pGetFdInfo, _pFd)
    return result
}
vkGetMemoryFdPropertiesKHR :: (_device: VkDevice, _handleType: VkExternalMemoryHandleTypeFlagBits, _fd: i32, _pMemoryFdProperties: ^mut VkMemoryFdPropertiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetMemoryFdPropertiesKHR(^result, _device, _handleType, _fd, _pMemoryFdProperties)
    return result
}
vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalSemaphoreInfo: ^mut VkPhysicalDeviceExternalSemaphoreInfo, _pExternalSemaphoreProperties: ^mut VkExternalSemaphoreProperties) {
    __c__vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(_physicalDevice, _pExternalSemaphoreInfo, _pExternalSemaphoreProperties)
}
vkImportSemaphoreFdKHR :: (_device: VkDevice, _pImportSemaphoreFdInfo: ^mut VkImportSemaphoreFdInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkImportSemaphoreFdKHR(^result, _device, _pImportSemaphoreFdInfo)
    return result
}
vkGetSemaphoreFdKHR :: (_device: VkDevice, _pGetFdInfo: ^mut VkSemaphoreGetFdInfoKHR, _pFd: ^mut i32) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSemaphoreFdKHR(^result, _device, _pGetFdInfo, _pFd)
    return result
}
vkCmdPushDescriptorSetKHR :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _layout: VkPipelineLayout, _set: uint32_t, _descriptorWriteCount: uint32_t, _pDescriptorWrites: ^mut VkWriteDescriptorSet) {
    __c__vkCmdPushDescriptorSetKHR(_commandBuffer, _pipelineBindPoint, _layout, _set, _descriptorWriteCount, _pDescriptorWrites)
}
vkCmdPushDescriptorSetWithTemplateKHR :: (_commandBuffer: VkCommandBuffer, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _layout: VkPipelineLayout, _set: uint32_t, _pData: ^mut void) {
    __c__vkCmdPushDescriptorSetWithTemplateKHR(_commandBuffer, _descriptorUpdateTemplate, _layout, _set, _pData)
}
vkCreateDescriptorUpdateTemplateKHR :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorUpdateTemplateCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorUpdateTemplate: ^mut VkDescriptorUpdateTemplate) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDescriptorUpdateTemplateKHR(^result, _device, _pCreateInfo, _pAllocator, _pDescriptorUpdateTemplate)
    return result
}
vkDestroyDescriptorUpdateTemplateKHR :: (_device: VkDevice, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDescriptorUpdateTemplateKHR(_device, _descriptorUpdateTemplate, _pAllocator)
}
vkUpdateDescriptorSetWithTemplateKHR :: (_device: VkDevice, _descriptorSet: VkDescriptorSet, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pData: ^mut void) {
    __c__vkUpdateDescriptorSetWithTemplateKHR(_device, _descriptorSet, _descriptorUpdateTemplate, _pData)
}
vkCreateRenderPass2KHR :: (_device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo2, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateRenderPass2KHR(^result, _device, _pCreateInfo, _pAllocator, _pRenderPass)
    return result
}
vkCmdBeginRenderPass2KHR :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo) {
    __c__vkCmdBeginRenderPass2KHR(_commandBuffer, _pRenderPassBegin, _pSubpassBeginInfo)
}
vkCmdNextSubpass2KHR :: (_commandBuffer: VkCommandBuffer, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo, _pSubpassEndInfo: ^mut VkSubpassEndInfo) {
    __c__vkCmdNextSubpass2KHR(_commandBuffer, _pSubpassBeginInfo, _pSubpassEndInfo)
}
vkCmdEndRenderPass2KHR :: (_commandBuffer: VkCommandBuffer, _pSubpassEndInfo: ^mut VkSubpassEndInfo) {
    __c__vkCmdEndRenderPass2KHR(_commandBuffer, _pSubpassEndInfo)
}
vkGetSwapchainStatusKHR :: (_device: VkDevice, _swapchain: VkSwapchainKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSwapchainStatusKHR(^result, _device, _swapchain)
    return result
}
vkGetPhysicalDeviceExternalFencePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalFenceInfo: ^mut VkPhysicalDeviceExternalFenceInfo, _pExternalFenceProperties: ^mut VkExternalFenceProperties) {
    __c__vkGetPhysicalDeviceExternalFencePropertiesKHR(_physicalDevice, _pExternalFenceInfo, _pExternalFenceProperties)
}
vkImportFenceFdKHR :: (_device: VkDevice, _pImportFenceFdInfo: ^mut VkImportFenceFdInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkImportFenceFdKHR(^result, _device, _pImportFenceFdInfo)
    return result
}
vkGetFenceFdKHR :: (_device: VkDevice, _pGetFdInfo: ^mut VkFenceGetFdInfoKHR, _pFd: ^mut i32) -> VkResult {
    mut result : VkResult = default
    __c__vkGetFenceFdKHR(^result, _device, _pGetFdInfo, _pFd)
    return result
}
vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: (_physicalDevice: VkPhysicalDevice, _queueFamilyIndex: uint32_t, _pCounterCount: ^mut uint32_t, _pCounters: ^mut VkPerformanceCounterKHR, _pCounterDescriptions: ^mut VkPerformanceCounterDescriptionKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(^result, _physicalDevice, _queueFamilyIndex, _pCounterCount, _pCounters, _pCounterDescriptions)
    return result
}
vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: (_physicalDevice: VkPhysicalDevice, _pPerformanceQueryCreateInfo: ^mut VkQueryPoolPerformanceCreateInfoKHR, _pNumPasses: ^mut uint32_t) {
    __c__vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(_physicalDevice, _pPerformanceQueryCreateInfo, _pNumPasses)
}
vkAcquireProfilingLockKHR :: (_device: VkDevice, _pInfo: ^mut VkAcquireProfilingLockInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkAcquireProfilingLockKHR(^result, _device, _pInfo)
    return result
}
vkReleaseProfilingLockKHR :: (_device: VkDevice) {
    __c__vkReleaseProfilingLockKHR(_device)
}
vkGetPhysicalDeviceSurfaceCapabilities2KHR :: (_physicalDevice: VkPhysicalDevice, _pSurfaceInfo: ^mut VkPhysicalDeviceSurfaceInfo2KHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilities2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceCapabilities2KHR(^result, _physicalDevice, _pSurfaceInfo, _pSurfaceCapabilities)
    return result
}
vkGetPhysicalDeviceSurfaceFormats2KHR :: (_physicalDevice: VkPhysicalDevice, _pSurfaceInfo: ^mut VkPhysicalDeviceSurfaceInfo2KHR, _pSurfaceFormatCount: ^mut uint32_t, _pSurfaceFormats: ^mut VkSurfaceFormat2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceFormats2KHR(^result, _physicalDevice, _pSurfaceInfo, _pSurfaceFormatCount, _pSurfaceFormats)
    return result
}
vkGetPhysicalDeviceDisplayProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayProperties2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceDisplayProperties2KHR(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPlaneProperties2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceDisplayPlaneProperties2KHR(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetDisplayModeProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayModeProperties2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDisplayModeProperties2KHR(^result, _physicalDevice, _display, _pPropertyCount, _pProperties)
    return result
}
vkGetDisplayPlaneCapabilities2KHR :: (_physicalDevice: VkPhysicalDevice, _pDisplayPlaneInfo: ^mut VkDisplayPlaneInfo2KHR, _pCapabilities: ^mut VkDisplayPlaneCapabilities2KHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetDisplayPlaneCapabilities2KHR(^result, _physicalDevice, _pDisplayPlaneInfo, _pCapabilities)
    return result
}
vkGetImageMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkImageMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2) {
    __c__vkGetImageMemoryRequirements2KHR(_device, _pInfo, _pMemoryRequirements)
}
vkGetBufferMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkBufferMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2) {
    __c__vkGetBufferMemoryRequirements2KHR(_device, _pInfo, _pMemoryRequirements)
}
vkGetImageSparseMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkImageSparseMemoryRequirementsInfo2, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements2) {
    __c__vkGetImageSparseMemoryRequirements2KHR(_device, _pInfo, _pSparseMemoryRequirementCount, _pSparseMemoryRequirements)
}
vkCreateSamplerYcbcrConversionKHR :: (_device: VkDevice, _pCreateInfo: ^mut VkSamplerYcbcrConversionCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pYcbcrConversion: ^mut VkSamplerYcbcrConversion) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateSamplerYcbcrConversionKHR(^result, _device, _pCreateInfo, _pAllocator, _pYcbcrConversion)
    return result
}
vkDestroySamplerYcbcrConversionKHR :: (_device: VkDevice, _ycbcrConversion: VkSamplerYcbcrConversion, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroySamplerYcbcrConversionKHR(_device, _ycbcrConversion, _pAllocator)
}
vkBindBufferMemory2KHR :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindBufferMemoryInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkBindBufferMemory2KHR(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkBindImageMemory2KHR :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindImageMemoryInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkBindImageMemory2KHR(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkGetDescriptorSetLayoutSupportKHR :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pSupport: ^mut VkDescriptorSetLayoutSupport) {
    __c__vkGetDescriptorSetLayoutSupportKHR(_device, _pCreateInfo, _pSupport)
}
vkCmdDrawIndirectCountKHR :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndirectCountKHR(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkCmdDrawIndexedIndirectCountKHR :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndexedIndirectCountKHR(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkGetSemaphoreCounterValueKHR :: (_device: VkDevice, _semaphore: VkSemaphore, _pValue: ^mut uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSemaphoreCounterValueKHR(^result, _device, _semaphore, _pValue)
    return result
}
vkWaitSemaphoresKHR :: (_device: VkDevice, _pWaitInfo: ^mut VkSemaphoreWaitInfo, _timeout: uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkWaitSemaphoresKHR(^result, _device, _pWaitInfo, _timeout)
    return result
}
vkSignalSemaphoreKHR :: (_device: VkDevice, _pSignalInfo: ^mut VkSemaphoreSignalInfo) -> VkResult {
    mut result : VkResult = default
    __c__vkSignalSemaphoreKHR(^result, _device, _pSignalInfo)
    return result
}
vkGetBufferDeviceAddressKHR :: (_device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress {
    mut result : VkDeviceAddress = default
    __c__vkGetBufferDeviceAddressKHR(^result, _device, _pInfo)
    return result
}
vkGetBufferOpaqueCaptureAddressKHR :: (_device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo) -> uint64_t {
    mut result : uint64_t = default
    __c__vkGetBufferOpaqueCaptureAddressKHR(^result, _device, _pInfo)
    return result
}
vkGetDeviceMemoryOpaqueCaptureAddressKHR :: (_device: VkDevice, _pInfo: ^mut VkDeviceMemoryOpaqueCaptureAddressInfo) -> uint64_t {
    mut result : uint64_t = default
    __c__vkGetDeviceMemoryOpaqueCaptureAddressKHR(^result, _device, _pInfo)
    return result
}
vkGetPipelineExecutablePropertiesKHR :: (_device: VkDevice, _pPipelineInfo: ^mut VkPipelineInfoKHR, _pExecutableCount: ^mut uint32_t, _pProperties: ^mut VkPipelineExecutablePropertiesKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPipelineExecutablePropertiesKHR(^result, _device, _pPipelineInfo, _pExecutableCount, _pProperties)
    return result
}
vkGetPipelineExecutableStatisticsKHR :: (_device: VkDevice, _pExecutableInfo: ^mut VkPipelineExecutableInfoKHR, _pStatisticCount: ^mut uint32_t, _pStatistics: ^mut VkPipelineExecutableStatisticKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPipelineExecutableStatisticsKHR(^result, _device, _pExecutableInfo, _pStatisticCount, _pStatistics)
    return result
}
vkGetPipelineExecutableInternalRepresentationsKHR :: (_device: VkDevice, _pExecutableInfo: ^mut VkPipelineExecutableInfoKHR, _pInternalRepresentationCount: ^mut uint32_t, _pInternalRepresentations: ^mut VkPipelineExecutableInternalRepresentationKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPipelineExecutableInternalRepresentationsKHR(^result, _device, _pExecutableInfo, _pInternalRepresentationCount, _pInternalRepresentations)
    return result
}
vkCreateDebugReportCallbackEXT :: (_instance: VkInstance, _pCreateInfo: ^mut VkDebugReportCallbackCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pCallback: ^mut VkDebugReportCallbackEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDebugReportCallbackEXT(^result, _instance, _pCreateInfo, _pAllocator, _pCallback)
    return result
}
vkDestroyDebugReportCallbackEXT :: (_instance: VkInstance, _callback: VkDebugReportCallbackEXT, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDebugReportCallbackEXT(_instance, _callback, _pAllocator)
}
vkDebugReportMessageEXT :: (_instance: VkInstance, _flags: VkDebugReportFlagsEXT, _objectType: VkDebugReportObjectTypeEXT, _object: uint64_t, _location: size_t, _messageCode: int32_t, _pLayerPrefix: ^mut char8, _pMessage: ^mut char8) {
    __c__vkDebugReportMessageEXT(_instance, _flags, _objectType, _object, _location, _messageCode, _pLayerPrefix, _pMessage)
}
vkDebugMarkerSetObjectTagEXT :: (_device: VkDevice, _pTagInfo: ^mut VkDebugMarkerObjectTagInfoEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkDebugMarkerSetObjectTagEXT(^result, _device, _pTagInfo)
    return result
}
vkDebugMarkerSetObjectNameEXT :: (_device: VkDevice, _pNameInfo: ^mut VkDebugMarkerObjectNameInfoEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkDebugMarkerSetObjectNameEXT(^result, _device, _pNameInfo)
    return result
}
vkCmdDebugMarkerBeginEXT :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkDebugMarkerMarkerInfoEXT) {
    __c__vkCmdDebugMarkerBeginEXT(_commandBuffer, _pMarkerInfo)
}
vkCmdDebugMarkerEndEXT :: (_commandBuffer: VkCommandBuffer) {
    __c__vkCmdDebugMarkerEndEXT(_commandBuffer)
}
vkCmdDebugMarkerInsertEXT :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkDebugMarkerMarkerInfoEXT) {
    __c__vkCmdDebugMarkerInsertEXT(_commandBuffer, _pMarkerInfo)
}
vkCmdBindTransformFeedbackBuffersEXT :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize, _pSizes: ^mut VkDeviceSize) {
    __c__vkCmdBindTransformFeedbackBuffersEXT(_commandBuffer, _firstBinding, _bindingCount, _pBuffers, _pOffsets, _pSizes)
}
vkCmdBeginTransformFeedbackEXT :: (_commandBuffer: VkCommandBuffer, _firstCounterBuffer: uint32_t, _counterBufferCount: uint32_t, _pCounterBuffers: ^mut VkBuffer, _pCounterBufferOffsets: ^mut VkDeviceSize) {
    __c__vkCmdBeginTransformFeedbackEXT(_commandBuffer, _firstCounterBuffer, _counterBufferCount, _pCounterBuffers, _pCounterBufferOffsets)
}
vkCmdEndTransformFeedbackEXT :: (_commandBuffer: VkCommandBuffer, _firstCounterBuffer: uint32_t, _counterBufferCount: uint32_t, _pCounterBuffers: ^mut VkBuffer, _pCounterBufferOffsets: ^mut VkDeviceSize) {
    __c__vkCmdEndTransformFeedbackEXT(_commandBuffer, _firstCounterBuffer, _counterBufferCount, _pCounterBuffers, _pCounterBufferOffsets)
}
vkCmdBeginQueryIndexedEXT :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _flags: VkQueryControlFlags, _index: uint32_t) {
    __c__vkCmdBeginQueryIndexedEXT(_commandBuffer, _queryPool, _query, _flags, _index)
}
vkCmdEndQueryIndexedEXT :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _index: uint32_t) {
    __c__vkCmdEndQueryIndexedEXT(_commandBuffer, _queryPool, _query, _index)
}
vkCmdDrawIndirectByteCountEXT :: (_commandBuffer: VkCommandBuffer, _instanceCount: uint32_t, _firstInstance: uint32_t, _counterBuffer: VkBuffer, _counterBufferOffset: VkDeviceSize, _counterOffset: uint32_t, _vertexStride: uint32_t) {
    __c__vkCmdDrawIndirectByteCountEXT(_commandBuffer, _instanceCount, _firstInstance, _counterBuffer, _counterBufferOffset, _counterOffset, _vertexStride)
}
vkGetImageViewHandleNVX :: (_device: VkDevice, _pInfo: ^mut VkImageViewHandleInfoNVX) -> uint32_t {
    mut result : uint32_t = default
    __c__vkGetImageViewHandleNVX(^result, _device, _pInfo)
    return result
}
vkGetImageViewAddressNVX :: (_device: VkDevice, _imageView: VkImageView, _pProperties: ^mut VkImageViewAddressPropertiesNVX) -> VkResult {
    mut result : VkResult = default
    __c__vkGetImageViewAddressNVX(^result, _device, _imageView, _pProperties)
    return result
}
vkCmdDrawIndirectCountAMD :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndirectCountAMD(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkCmdDrawIndexedIndirectCountAMD :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawIndexedIndirectCountAMD(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkGetShaderInfoAMD :: (_device: VkDevice, _pipeline: VkPipeline, _shaderStage: VkShaderStageFlagBits, _infoType: VkShaderInfoTypeAMD, _pInfoSize: ^mut size_t, _pInfo: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetShaderInfoAMD(^result, _device, _pipeline, _shaderStage, _infoType, _pInfoSize, _pInfo)
    return result
}
vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _tiling: VkImageTiling, _usage: VkImageUsageFlags, _flags: VkImageCreateFlags, _externalHandleType: VkExternalMemoryHandleTypeFlagsNV, _pExternalImageFormatProperties: ^mut VkExternalImageFormatPropertiesNV) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceExternalImageFormatPropertiesNV(^result, _physicalDevice, _format, _type, _tiling, _usage, _flags, _externalHandleType, _pExternalImageFormatProperties)
    return result
}
vkCmdBeginConditionalRenderingEXT :: (_commandBuffer: VkCommandBuffer, _pConditionalRenderingBegin: ^mut VkConditionalRenderingBeginInfoEXT) {
    __c__vkCmdBeginConditionalRenderingEXT(_commandBuffer, _pConditionalRenderingBegin)
}
vkCmdEndConditionalRenderingEXT :: (_commandBuffer: VkCommandBuffer) {
    __c__vkCmdEndConditionalRenderingEXT(_commandBuffer)
}
vkCmdSetViewportWScalingNV :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pViewportWScalings: ^mut VkViewportWScalingNV) {
    __c__vkCmdSetViewportWScalingNV(_commandBuffer, _firstViewport, _viewportCount, _pViewportWScalings)
}
vkReleaseDisplayEXT :: (_physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkReleaseDisplayEXT(^result, _physicalDevice, _display)
    return result
}
vkGetPhysicalDeviceSurfaceCapabilities2EXT :: (_physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilities2EXT) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSurfaceCapabilities2EXT(^result, _physicalDevice, _surface, _pSurfaceCapabilities)
    return result
}
vkDisplayPowerControlEXT :: (_device: VkDevice, _display: VkDisplayKHR, _pDisplayPowerInfo: ^mut VkDisplayPowerInfoEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkDisplayPowerControlEXT(^result, _device, _display, _pDisplayPowerInfo)
    return result
}
vkRegisterDeviceEventEXT :: (_device: VkDevice, _pDeviceEventInfo: ^mut VkDeviceEventInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkRegisterDeviceEventEXT(^result, _device, _pDeviceEventInfo, _pAllocator, _pFence)
    return result
}
vkRegisterDisplayEventEXT :: (_device: VkDevice, _display: VkDisplayKHR, _pDisplayEventInfo: ^mut VkDisplayEventInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence) -> VkResult {
    mut result : VkResult = default
    __c__vkRegisterDisplayEventEXT(^result, _device, _display, _pDisplayEventInfo, _pAllocator, _pFence)
    return result
}
vkGetSwapchainCounterEXT :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _counter: VkSurfaceCounterFlagBitsEXT, _pCounterValue: ^mut uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkGetSwapchainCounterEXT(^result, _device, _swapchain, _counter, _pCounterValue)
    return result
}
vkGetRefreshCycleDurationGOOGLE :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _pDisplayTimingProperties: ^mut VkRefreshCycleDurationGOOGLE) -> VkResult {
    mut result : VkResult = default
    __c__vkGetRefreshCycleDurationGOOGLE(^result, _device, _swapchain, _pDisplayTimingProperties)
    return result
}
vkGetPastPresentationTimingGOOGLE :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _pPresentationTimingCount: ^mut uint32_t, _pPresentationTimings: ^mut VkPastPresentationTimingGOOGLE) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPastPresentationTimingGOOGLE(^result, _device, _swapchain, _pPresentationTimingCount, _pPresentationTimings)
    return result
}
vkCmdSetDiscardRectangleEXT :: (_commandBuffer: VkCommandBuffer, _firstDiscardRectangle: uint32_t, _discardRectangleCount: uint32_t, _pDiscardRectangles: ^mut VkRect2D) {
    __c__vkCmdSetDiscardRectangleEXT(_commandBuffer, _firstDiscardRectangle, _discardRectangleCount, _pDiscardRectangles)
}
vkSetHdrMetadataEXT :: (_device: VkDevice, _swapchainCount: uint32_t, _pSwapchains: ^mut VkSwapchainKHR, _pMetadata: ^mut VkHdrMetadataEXT) {
    __c__vkSetHdrMetadataEXT(_device, _swapchainCount, _pSwapchains, _pMetadata)
}
vkSetDebugUtilsObjectNameEXT :: (_device: VkDevice, _pNameInfo: ^mut VkDebugUtilsObjectNameInfoEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkSetDebugUtilsObjectNameEXT(^result, _device, _pNameInfo)
    return result
}
vkSetDebugUtilsObjectTagEXT :: (_device: VkDevice, _pTagInfo: ^mut VkDebugUtilsObjectTagInfoEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkSetDebugUtilsObjectTagEXT(^result, _device, _pTagInfo)
    return result
}
vkQueueBeginDebugUtilsLabelEXT :: (_queue: VkQueue, _pLabelInfo: ^mut VkDebugUtilsLabelEXT) {
    __c__vkQueueBeginDebugUtilsLabelEXT(_queue, _pLabelInfo)
}
vkQueueEndDebugUtilsLabelEXT :: (_queue: VkQueue) {
    __c__vkQueueEndDebugUtilsLabelEXT(_queue)
}
vkQueueInsertDebugUtilsLabelEXT :: (_queue: VkQueue, _pLabelInfo: ^mut VkDebugUtilsLabelEXT) {
    __c__vkQueueInsertDebugUtilsLabelEXT(_queue, _pLabelInfo)
}
vkCmdBeginDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer, _pLabelInfo: ^mut VkDebugUtilsLabelEXT) {
    __c__vkCmdBeginDebugUtilsLabelEXT(_commandBuffer, _pLabelInfo)
}
vkCmdEndDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer) {
    __c__vkCmdEndDebugUtilsLabelEXT(_commandBuffer)
}
vkCmdInsertDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer, _pLabelInfo: ^mut VkDebugUtilsLabelEXT) {
    __c__vkCmdInsertDebugUtilsLabelEXT(_commandBuffer, _pLabelInfo)
}
vkCreateDebugUtilsMessengerEXT :: (_instance: VkInstance, _pCreateInfo: ^mut VkDebugUtilsMessengerCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pMessenger: ^mut VkDebugUtilsMessengerEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateDebugUtilsMessengerEXT(^result, _instance, _pCreateInfo, _pAllocator, _pMessenger)
    return result
}
vkDestroyDebugUtilsMessengerEXT :: (_instance: VkInstance, _messenger: VkDebugUtilsMessengerEXT, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyDebugUtilsMessengerEXT(_instance, _messenger, _pAllocator)
}
vkSubmitDebugUtilsMessageEXT :: (_instance: VkInstance, _messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, _messageTypes: VkDebugUtilsMessageTypeFlagsEXT, _pCallbackData: ^mut VkDebugUtilsMessengerCallbackDataEXT) {
    __c__vkSubmitDebugUtilsMessageEXT(_instance, _messageSeverity, _messageTypes, _pCallbackData)
}
vkCmdSetSampleLocationsEXT :: (_commandBuffer: VkCommandBuffer, _pSampleLocationsInfo: ^mut VkSampleLocationsInfoEXT) {
    __c__vkCmdSetSampleLocationsEXT(_commandBuffer, _pSampleLocationsInfo)
}
vkGetPhysicalDeviceMultisamplePropertiesEXT :: (_physicalDevice: VkPhysicalDevice, _samples: VkSampleCountFlagBits, _pMultisampleProperties: ^mut VkMultisamplePropertiesEXT) {
    __c__vkGetPhysicalDeviceMultisamplePropertiesEXT(_physicalDevice, _samples, _pMultisampleProperties)
}
vkGetImageDrmFormatModifierPropertiesEXT :: (_device: VkDevice, _image: VkImage, _pProperties: ^mut VkImageDrmFormatModifierPropertiesEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkGetImageDrmFormatModifierPropertiesEXT(^result, _device, _image, _pProperties)
    return result
}
vkCreateValidationCacheEXT :: (_device: VkDevice, _pCreateInfo: ^mut VkValidationCacheCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pValidationCache: ^mut VkValidationCacheEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateValidationCacheEXT(^result, _device, _pCreateInfo, _pAllocator, _pValidationCache)
    return result
}
vkDestroyValidationCacheEXT :: (_device: VkDevice, _validationCache: VkValidationCacheEXT, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyValidationCacheEXT(_device, _validationCache, _pAllocator)
}
vkMergeValidationCachesEXT :: (_device: VkDevice, _dstCache: VkValidationCacheEXT, _srcCacheCount: uint32_t, _pSrcCaches: ^mut VkValidationCacheEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkMergeValidationCachesEXT(^result, _device, _dstCache, _srcCacheCount, _pSrcCaches)
    return result
}
vkGetValidationCacheDataEXT :: (_device: VkDevice, _validationCache: VkValidationCacheEXT, _pDataSize: ^mut size_t, _pData: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetValidationCacheDataEXT(^result, _device, _validationCache, _pDataSize, _pData)
    return result
}
vkCmdBindShadingRateImageNV :: (_commandBuffer: VkCommandBuffer, _imageView: VkImageView, _imageLayout: VkImageLayout) {
    __c__vkCmdBindShadingRateImageNV(_commandBuffer, _imageView, _imageLayout)
}
vkCmdSetViewportShadingRatePaletteNV :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pShadingRatePalettes: ^mut VkShadingRatePaletteNV) {
    __c__vkCmdSetViewportShadingRatePaletteNV(_commandBuffer, _firstViewport, _viewportCount, _pShadingRatePalettes)
}
vkCmdSetCoarseSampleOrderNV :: (_commandBuffer: VkCommandBuffer, _sampleOrderType: VkCoarseSampleOrderTypeNV, _customSampleOrderCount: uint32_t, _pCustomSampleOrders: ^mut VkCoarseSampleOrderCustomNV) {
    __c__vkCmdSetCoarseSampleOrderNV(_commandBuffer, _sampleOrderType, _customSampleOrderCount, _pCustomSampleOrders)
}
vkCreateAccelerationStructureNV :: (_device: VkDevice, _pCreateInfo: ^mut VkAccelerationStructureCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pAccelerationStructure: ^mut VkAccelerationStructureNV) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateAccelerationStructureNV(^result, _device, _pCreateInfo, _pAllocator, _pAccelerationStructure)
    return result
}
vkDestroyAccelerationStructureKHR :: (_device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyAccelerationStructureKHR(_device, _accelerationStructure, _pAllocator)
}
vkDestroyAccelerationStructureNV :: (_device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyAccelerationStructureNV(_device, _accelerationStructure, _pAllocator)
}
vkGetAccelerationStructureMemoryRequirementsNV :: (_device: VkDevice, _pInfo: ^mut VkAccelerationStructureMemoryRequirementsInfoNV, _pMemoryRequirements: ^mut VkMemoryRequirements2KHR) {
    __c__vkGetAccelerationStructureMemoryRequirementsNV(_device, _pInfo, _pMemoryRequirements)
}
vkBindAccelerationStructureMemoryKHR :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindAccelerationStructureMemoryInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkBindAccelerationStructureMemoryKHR(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkBindAccelerationStructureMemoryNV :: (_device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindAccelerationStructureMemoryInfoKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkBindAccelerationStructureMemoryNV(^result, _device, _bindInfoCount, _pBindInfos)
    return result
}
vkCmdBuildAccelerationStructureNV :: (_commandBuffer: VkCommandBuffer, _pInfo: ^mut VkAccelerationStructureInfoNV, _instanceData: VkBuffer, _instanceOffset: VkDeviceSize, _update: VkBool32, _dst: VkAccelerationStructureKHR, _src: VkAccelerationStructureKHR, _scratch: VkBuffer, _scratchOffset: VkDeviceSize) {
    __c__vkCmdBuildAccelerationStructureNV(_commandBuffer, _pInfo, _instanceData, _instanceOffset, _update, _dst, _src, _scratch, _scratchOffset)
}
vkCmdCopyAccelerationStructureNV :: (_commandBuffer: VkCommandBuffer, _dst: VkAccelerationStructureKHR, _src: VkAccelerationStructureKHR, _mode: VkCopyAccelerationStructureModeKHR) {
    __c__vkCmdCopyAccelerationStructureNV(_commandBuffer, _dst, _src, _mode)
}
vkCmdTraceRaysNV :: (_commandBuffer: VkCommandBuffer, _raygenShaderBindingTableBuffer: VkBuffer, _raygenShaderBindingOffset: VkDeviceSize, _missShaderBindingTableBuffer: VkBuffer, _missShaderBindingOffset: VkDeviceSize, _missShaderBindingStride: VkDeviceSize, _hitShaderBindingTableBuffer: VkBuffer, _hitShaderBindingOffset: VkDeviceSize, _hitShaderBindingStride: VkDeviceSize, _callableShaderBindingTableBuffer: VkBuffer, _callableShaderBindingOffset: VkDeviceSize, _callableShaderBindingStride: VkDeviceSize, _width: uint32_t, _height: uint32_t, _depth: uint32_t) {
    __c__vkCmdTraceRaysNV(_commandBuffer, _raygenShaderBindingTableBuffer, _raygenShaderBindingOffset, _missShaderBindingTableBuffer, _missShaderBindingOffset, _missShaderBindingStride, _hitShaderBindingTableBuffer, _hitShaderBindingOffset, _hitShaderBindingStride, _callableShaderBindingTableBuffer, _callableShaderBindingOffset, _callableShaderBindingStride, _width, _height, _depth)
}
vkCreateRayTracingPipelinesNV :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkRayTracingPipelineCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateRayTracingPipelinesNV(^result, _device, _pipelineCache, _createInfoCount, _pCreateInfos, _pAllocator, _pPipelines)
    return result
}
vkGetRayTracingShaderGroupHandlesKHR :: (_device: VkDevice, _pipeline: VkPipeline, _firstGroup: uint32_t, _groupCount: uint32_t, _dataSize: size_t, _pData: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetRayTracingShaderGroupHandlesKHR(^result, _device, _pipeline, _firstGroup, _groupCount, _dataSize, _pData)
    return result
}
vkGetRayTracingShaderGroupHandlesNV :: (_device: VkDevice, _pipeline: VkPipeline, _firstGroup: uint32_t, _groupCount: uint32_t, _dataSize: size_t, _pData: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetRayTracingShaderGroupHandlesNV(^result, _device, _pipeline, _firstGroup, _groupCount, _dataSize, _pData)
    return result
}
vkGetAccelerationStructureHandleNV :: (_device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _dataSize: size_t, _pData: ^mut void) -> VkResult {
    mut result : VkResult = default
    __c__vkGetAccelerationStructureHandleNV(^result, _device, _accelerationStructure, _dataSize, _pData)
    return result
}
vkCmdWriteAccelerationStructuresPropertiesKHR :: (_commandBuffer: VkCommandBuffer, _accelerationStructureCount: uint32_t, _pAccelerationStructures: ^mut VkAccelerationStructureKHR, _queryType: VkQueryType, _queryPool: VkQueryPool, _firstQuery: uint32_t) {
    __c__vkCmdWriteAccelerationStructuresPropertiesKHR(_commandBuffer, _accelerationStructureCount, _pAccelerationStructures, _queryType, _queryPool, _firstQuery)
}
vkCmdWriteAccelerationStructuresPropertiesNV :: (_commandBuffer: VkCommandBuffer, _accelerationStructureCount: uint32_t, _pAccelerationStructures: ^mut VkAccelerationStructureKHR, _queryType: VkQueryType, _queryPool: VkQueryPool, _firstQuery: uint32_t) {
    __c__vkCmdWriteAccelerationStructuresPropertiesNV(_commandBuffer, _accelerationStructureCount, _pAccelerationStructures, _queryType, _queryPool, _firstQuery)
}
vkCompileDeferredNV :: (_device: VkDevice, _pipeline: VkPipeline, _shader: uint32_t) -> VkResult {
    mut result : VkResult = default
    __c__vkCompileDeferredNV(^result, _device, _pipeline, _shader)
    return result
}
vkGetMemoryHostPointerPropertiesEXT :: (_device: VkDevice, _handleType: VkExternalMemoryHandleTypeFlagBits, _pHostPointer: ^mut void, _pMemoryHostPointerProperties: ^mut VkMemoryHostPointerPropertiesEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkGetMemoryHostPointerPropertiesEXT(^result, _device, _handleType, _pHostPointer, _pMemoryHostPointerProperties)
    return result
}
vkCmdWriteBufferMarkerAMD :: (_commandBuffer: VkCommandBuffer, _pipelineStage: VkPipelineStageFlagBits, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _marker: uint32_t) {
    __c__vkCmdWriteBufferMarkerAMD(_commandBuffer, _pipelineStage, _dstBuffer, _dstOffset, _marker)
}
vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: (_physicalDevice: VkPhysicalDevice, _pTimeDomainCount: ^mut uint32_t, _pTimeDomains: ^mut VkTimeDomainEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(^result, _physicalDevice, _pTimeDomainCount, _pTimeDomains)
    return result
}
vkGetCalibratedTimestampsEXT :: (_device: VkDevice, _timestampCount: uint32_t, _pTimestampInfos: ^mut VkCalibratedTimestampInfoEXT, _pTimestamps: ^mut uint64_t, _pMaxDeviation: ^mut uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkGetCalibratedTimestampsEXT(^result, _device, _timestampCount, _pTimestampInfos, _pTimestamps, _pMaxDeviation)
    return result
}
vkCmdDrawMeshTasksNV :: (_commandBuffer: VkCommandBuffer, _taskCount: uint32_t, _firstTask: uint32_t) {
    __c__vkCmdDrawMeshTasksNV(_commandBuffer, _taskCount, _firstTask)
}
vkCmdDrawMeshTasksIndirectNV :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawMeshTasksIndirectNV(_commandBuffer, _buffer, _offset, _drawCount, _stride)
}
vkCmdDrawMeshTasksIndirectCountNV :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t) {
    __c__vkCmdDrawMeshTasksIndirectCountNV(_commandBuffer, _buffer, _offset, _countBuffer, _countBufferOffset, _maxDrawCount, _stride)
}
vkCmdSetExclusiveScissorNV :: (_commandBuffer: VkCommandBuffer, _firstExclusiveScissor: uint32_t, _exclusiveScissorCount: uint32_t, _pExclusiveScissors: ^mut VkRect2D) {
    __c__vkCmdSetExclusiveScissorNV(_commandBuffer, _firstExclusiveScissor, _exclusiveScissorCount, _pExclusiveScissors)
}
vkCmdSetCheckpointNV :: (_commandBuffer: VkCommandBuffer, _pCheckpointMarker: ^mut void) {
    __c__vkCmdSetCheckpointNV(_commandBuffer, _pCheckpointMarker)
}
vkGetQueueCheckpointDataNV :: (_queue: VkQueue, _pCheckpointDataCount: ^mut uint32_t, _pCheckpointData: ^mut VkCheckpointDataNV) {
    __c__vkGetQueueCheckpointDataNV(_queue, _pCheckpointDataCount, _pCheckpointData)
}
vkInitializePerformanceApiINTEL :: (_device: VkDevice, _pInitializeInfo: ^mut VkInitializePerformanceApiInfoINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkInitializePerformanceApiINTEL(^result, _device, _pInitializeInfo)
    return result
}
vkUninitializePerformanceApiINTEL :: (_device: VkDevice) {
    __c__vkUninitializePerformanceApiINTEL(_device)
}
vkCmdSetPerformanceMarkerINTEL :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkPerformanceMarkerInfoINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkCmdSetPerformanceMarkerINTEL(^result, _commandBuffer, _pMarkerInfo)
    return result
}
vkCmdSetPerformanceStreamMarkerINTEL :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkPerformanceStreamMarkerInfoINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkCmdSetPerformanceStreamMarkerINTEL(^result, _commandBuffer, _pMarkerInfo)
    return result
}
vkCmdSetPerformanceOverrideINTEL :: (_commandBuffer: VkCommandBuffer, _pOverrideInfo: ^mut VkPerformanceOverrideInfoINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkCmdSetPerformanceOverrideINTEL(^result, _commandBuffer, _pOverrideInfo)
    return result
}
vkAcquirePerformanceConfigurationINTEL :: (_device: VkDevice, _pAcquireInfo: ^mut VkPerformanceConfigurationAcquireInfoINTEL, _pConfiguration: ^mut VkPerformanceConfigurationINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkAcquirePerformanceConfigurationINTEL(^result, _device, _pAcquireInfo, _pConfiguration)
    return result
}
vkReleasePerformanceConfigurationINTEL :: (_device: VkDevice, _configuration: VkPerformanceConfigurationINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkReleasePerformanceConfigurationINTEL(^result, _device, _configuration)
    return result
}
vkQueueSetPerformanceConfigurationINTEL :: (_queue: VkQueue, _configuration: VkPerformanceConfigurationINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkQueueSetPerformanceConfigurationINTEL(^result, _queue, _configuration)
    return result
}
vkGetPerformanceParameterINTEL :: (_device: VkDevice, _parameter: VkPerformanceParameterTypeINTEL, _pValue: ^mut VkPerformanceValueINTEL) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPerformanceParameterINTEL(^result, _device, _parameter, _pValue)
    return result
}
vkSetLocalDimmingAMD :: (_device: VkDevice, _swapChain: VkSwapchainKHR, _localDimmingEnable: VkBool32) {
    __c__vkSetLocalDimmingAMD(_device, _swapChain, _localDimmingEnable)
}
vkGetBufferDeviceAddressEXT :: (_device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo) -> VkDeviceAddress {
    mut result : VkDeviceAddress = default
    __c__vkGetBufferDeviceAddressEXT(^result, _device, _pInfo)
    return result
}
vkGetPhysicalDeviceToolPropertiesEXT :: (_physicalDevice: VkPhysicalDevice, _pToolCount: ^mut uint32_t, _pToolProperties: ^mut VkPhysicalDeviceToolPropertiesEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceToolPropertiesEXT(^result, _physicalDevice, _pToolCount, _pToolProperties)
    return result
}
vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: (_physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkCooperativeMatrixPropertiesNV) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(^result, _physicalDevice, _pPropertyCount, _pProperties)
    return result
}
vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: (_physicalDevice: VkPhysicalDevice, _pCombinationCount: ^mut uint32_t, _pCombinations: ^mut VkFramebufferMixedSamplesCombinationNV) -> VkResult {
    mut result : VkResult = default
    __c__vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(^result, _physicalDevice, _pCombinationCount, _pCombinations)
    return result
}
vkCreateHeadlessSurfaceEXT :: (_instance: VkInstance, _pCreateInfo: ^mut VkHeadlessSurfaceCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pSurface: ^mut VkSurfaceKHR) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateHeadlessSurfaceEXT(^result, _instance, _pCreateInfo, _pAllocator, _pSurface)
    return result
}
vkCmdSetLineStippleEXT :: (_commandBuffer: VkCommandBuffer, _lineStippleFactor: uint32_t, _lineStipplePattern: uint16_t) {
    __c__vkCmdSetLineStippleEXT(_commandBuffer, _lineStippleFactor, _lineStipplePattern)
}
vkResetQueryPoolEXT :: (_device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t) {
    __c__vkResetQueryPoolEXT(_device, _queryPool, _firstQuery, _queryCount)
}
vkCmdSetCullModeEXT :: (_commandBuffer: VkCommandBuffer, _cullMode: VkCullModeFlags) {
    __c__vkCmdSetCullModeEXT(_commandBuffer, _cullMode)
}
vkCmdSetFrontFaceEXT :: (_commandBuffer: VkCommandBuffer, _frontFace: VkFrontFace) {
    __c__vkCmdSetFrontFaceEXT(_commandBuffer, _frontFace)
}
vkCmdSetPrimitiveTopologyEXT :: (_commandBuffer: VkCommandBuffer, _primitiveTopology: VkPrimitiveTopology) {
    __c__vkCmdSetPrimitiveTopologyEXT(_commandBuffer, _primitiveTopology)
}
vkCmdSetViewportWithCountEXT :: (_commandBuffer: VkCommandBuffer, _viewportCount: uint32_t, _pViewports: ^mut VkViewport) {
    __c__vkCmdSetViewportWithCountEXT(_commandBuffer, _viewportCount, _pViewports)
}
vkCmdSetScissorWithCountEXT :: (_commandBuffer: VkCommandBuffer, _scissorCount: uint32_t, _pScissors: ^mut VkRect2D) {
    __c__vkCmdSetScissorWithCountEXT(_commandBuffer, _scissorCount, _pScissors)
}
vkCmdBindVertexBuffers2EXT :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize, _pSizes: ^mut VkDeviceSize, _pStrides: ^mut VkDeviceSize) {
    __c__vkCmdBindVertexBuffers2EXT(_commandBuffer, _firstBinding, _bindingCount, _pBuffers, _pOffsets, _pSizes, _pStrides)
}
vkCmdSetDepthTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthTestEnable: VkBool32) {
    __c__vkCmdSetDepthTestEnableEXT(_commandBuffer, _depthTestEnable)
}
vkCmdSetDepthWriteEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthWriteEnable: VkBool32) {
    __c__vkCmdSetDepthWriteEnableEXT(_commandBuffer, _depthWriteEnable)
}
vkCmdSetDepthCompareOpEXT :: (_commandBuffer: VkCommandBuffer, _depthCompareOp: VkCompareOp) {
    __c__vkCmdSetDepthCompareOpEXT(_commandBuffer, _depthCompareOp)
}
vkCmdSetDepthBoundsTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthBoundsTestEnable: VkBool32) {
    __c__vkCmdSetDepthBoundsTestEnableEXT(_commandBuffer, _depthBoundsTestEnable)
}
vkCmdSetStencilTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _stencilTestEnable: VkBool32) {
    __c__vkCmdSetStencilTestEnableEXT(_commandBuffer, _stencilTestEnable)
}
vkCmdSetStencilOpEXT :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _failOp: VkStencilOp, _passOp: VkStencilOp, _depthFailOp: VkStencilOp, _compareOp: VkCompareOp) {
    __c__vkCmdSetStencilOpEXT(_commandBuffer, _faceMask, _failOp, _passOp, _depthFailOp, _compareOp)
}
vkGetGeneratedCommandsMemoryRequirementsNV :: (_device: VkDevice, _pInfo: ^mut VkGeneratedCommandsMemoryRequirementsInfoNV, _pMemoryRequirements: ^mut VkMemoryRequirements2) {
    __c__vkGetGeneratedCommandsMemoryRequirementsNV(_device, _pInfo, _pMemoryRequirements)
}
vkCmdPreprocessGeneratedCommandsNV :: (_commandBuffer: VkCommandBuffer, _pGeneratedCommandsInfo: ^mut VkGeneratedCommandsInfoNV) {
    __c__vkCmdPreprocessGeneratedCommandsNV(_commandBuffer, _pGeneratedCommandsInfo)
}
vkCmdExecuteGeneratedCommandsNV :: (_commandBuffer: VkCommandBuffer, _isPreprocessed: VkBool32, _pGeneratedCommandsInfo: ^mut VkGeneratedCommandsInfoNV) {
    __c__vkCmdExecuteGeneratedCommandsNV(_commandBuffer, _isPreprocessed, _pGeneratedCommandsInfo)
}
vkCmdBindPipelineShaderGroupNV :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _pipeline: VkPipeline, _groupIndex: uint32_t) {
    __c__vkCmdBindPipelineShaderGroupNV(_commandBuffer, _pipelineBindPoint, _pipeline, _groupIndex)
}
vkCreateIndirectCommandsLayoutNV :: (_device: VkDevice, _pCreateInfo: ^mut VkIndirectCommandsLayoutCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pIndirectCommandsLayout: ^mut VkIndirectCommandsLayoutNV) -> VkResult {
    mut result : VkResult = default
    __c__vkCreateIndirectCommandsLayoutNV(^result, _device, _pCreateInfo, _pAllocator, _pIndirectCommandsLayout)
    return result
}
vkDestroyIndirectCommandsLayoutNV :: (_device: VkDevice, _indirectCommandsLayout: VkIndirectCommandsLayoutNV, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyIndirectCommandsLayoutNV(_device, _indirectCommandsLayout, _pAllocator)
}
vkCreatePrivateDataSlotEXT :: (_device: VkDevice, _pCreateInfo: ^mut VkPrivateDataSlotCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pPrivateDataSlot: ^mut VkPrivateDataSlotEXT) -> VkResult {
    mut result : VkResult = default
    __c__vkCreatePrivateDataSlotEXT(^result, _device, _pCreateInfo, _pAllocator, _pPrivateDataSlot)
    return result
}
vkDestroyPrivateDataSlotEXT :: (_device: VkDevice, _privateDataSlot: VkPrivateDataSlotEXT, _pAllocator: ^mut VkAllocationCallbacks) {
    __c__vkDestroyPrivateDataSlotEXT(_device, _privateDataSlot, _pAllocator)
}
vkSetPrivateDataEXT :: (_device: VkDevice, _objectType: VkObjectType, _objectHandle: uint64_t, _privateDataSlot: VkPrivateDataSlotEXT, _data: uint64_t) -> VkResult {
    mut result : VkResult = default
    __c__vkSetPrivateDataEXT(^result, _device, _objectType, _objectHandle, _privateDataSlot, _data)
    return result
}
vkGetPrivateDataEXT :: (_device: VkDevice, _objectType: VkObjectType, _objectHandle: uint64_t, _privateDataSlot: VkPrivateDataSlotEXT, _pData: ^mut uint64_t) {
    __c__vkGetPrivateDataEXT(_device, _objectType, _objectHandle, _privateDataSlot, _pData)
}

// ==========================================================
// ==========================================================
// ==========================================================

#file_scope

__c__vkCreateInstance :: (ret: ^mut VkResult, _pCreateInfo: ^mut VkInstanceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pInstance: ^mut VkInstance);
__c__vkDestroyInstance :: (_instance: VkInstance, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkEnumeratePhysicalDevices :: (ret: ^mut VkResult, _instance: VkInstance, _pPhysicalDeviceCount: ^mut uint32_t, _pPhysicalDevices: ^mut VkPhysicalDevice);
__c__vkGetPhysicalDeviceFeatures :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures);
__c__vkGetPhysicalDeviceFormatProperties :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties);
__c__vkGetPhysicalDeviceImageFormatProperties :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _tiling: VkImageTiling, _usage: VkImageUsageFlags, _flags: VkImageCreateFlags, _pImageFormatProperties: ^mut VkImageFormatProperties);
__c__vkGetPhysicalDeviceProperties :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties);
__c__vkGetPhysicalDeviceQueueFamilyProperties :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties);
__c__vkGetPhysicalDeviceMemoryProperties :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties);
__c__vkGetInstanceProcAddr :: (ret: ^mut PFN_vkVoidFunction, _instance: VkInstance, _pName: ^mut char8);
__c__vkGetDeviceProcAddr :: (ret: ^mut PFN_vkVoidFunction, _device: VkDevice, _pName: ^mut char8);
__c__vkCreateDevice :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pCreateInfo: ^mut VkDeviceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDevice: ^mut VkDevice);
__c__vkDestroyDevice :: (_device: VkDevice, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkEnumerateInstanceExtensionProperties :: (ret: ^mut VkResult, _pLayerName: ^mut char8, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkExtensionProperties);
__c__vkEnumerateDeviceExtensionProperties :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pLayerName: ^mut char8, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkExtensionProperties);
__c__vkEnumerateInstanceLayerProperties :: (ret: ^mut VkResult, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkLayerProperties);
__c__vkEnumerateDeviceLayerProperties :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkLayerProperties);
__c__vkGetDeviceQueue :: (_device: VkDevice, _queueFamilyIndex: uint32_t, _queueIndex: uint32_t, _pQueue: ^mut VkQueue);
__c__vkQueueSubmit :: (ret: ^mut VkResult, _queue: VkQueue, _submitCount: uint32_t, _pSubmits: ^mut VkSubmitInfo, _fence: VkFence);
__c__vkQueueWaitIdle :: (ret: ^mut VkResult, _queue: VkQueue);
__c__vkDeviceWaitIdle :: (ret: ^mut VkResult, _device: VkDevice);
__c__vkAllocateMemory :: (ret: ^mut VkResult, _device: VkDevice, _pAllocateInfo: ^mut VkMemoryAllocateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pMemory: ^mut VkDeviceMemory);
__c__vkFreeMemory :: (_device: VkDevice, _memory: VkDeviceMemory, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkMapMemory :: (ret: ^mut VkResult, _device: VkDevice, _memory: VkDeviceMemory, _offset: VkDeviceSize, _size: VkDeviceSize, _flags: VkMemoryMapFlags, _ppData: ^mut ^mut void);
__c__vkUnmapMemory :: (_device: VkDevice, _memory: VkDeviceMemory);
__c__vkFlushMappedMemoryRanges :: (ret: ^mut VkResult, _device: VkDevice, _memoryRangeCount: uint32_t, _pMemoryRanges: ^mut VkMappedMemoryRange);
__c__vkInvalidateMappedMemoryRanges :: (ret: ^mut VkResult, _device: VkDevice, _memoryRangeCount: uint32_t, _pMemoryRanges: ^mut VkMappedMemoryRange);
__c__vkGetDeviceMemoryCommitment :: (_device: VkDevice, _memory: VkDeviceMemory, _pCommittedMemoryInBytes: ^mut VkDeviceSize);
__c__vkBindBufferMemory :: (ret: ^mut VkResult, _device: VkDevice, _buffer: VkBuffer, _memory: VkDeviceMemory, _memoryOffset: VkDeviceSize);
__c__vkBindImageMemory :: (ret: ^mut VkResult, _device: VkDevice, _image: VkImage, _memory: VkDeviceMemory, _memoryOffset: VkDeviceSize);
__c__vkGetBufferMemoryRequirements :: (_device: VkDevice, _buffer: VkBuffer, _pMemoryRequirements: ^mut VkMemoryRequirements);
__c__vkGetImageMemoryRequirements :: (_device: VkDevice, _image: VkImage, _pMemoryRequirements: ^mut VkMemoryRequirements);
__c__vkGetImageSparseMemoryRequirements :: (_device: VkDevice, _image: VkImage, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements);
__c__vkGetPhysicalDeviceSparseImageFormatProperties :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _samples: VkSampleCountFlagBits, _usage: VkImageUsageFlags, _tiling: VkImageTiling, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties);
__c__vkQueueBindSparse :: (ret: ^mut VkResult, _queue: VkQueue, _bindInfoCount: uint32_t, _pBindInfo: ^mut VkBindSparseInfo, _fence: VkFence);
__c__vkCreateFence :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkFenceCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence);
__c__vkDestroyFence :: (_device: VkDevice, _fence: VkFence, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkResetFences :: (ret: ^mut VkResult, _device: VkDevice, _fenceCount: uint32_t, _pFences: ^mut VkFence);
__c__vkGetFenceStatus :: (ret: ^mut VkResult, _device: VkDevice, _fence: VkFence);
__c__vkWaitForFences :: (ret: ^mut VkResult, _device: VkDevice, _fenceCount: uint32_t, _pFences: ^mut VkFence, _waitAll: VkBool32, _timeout: uint64_t);
__c__vkCreateSemaphore :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkSemaphoreCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSemaphore: ^mut VkSemaphore);
__c__vkDestroySemaphore :: (_device: VkDevice, _semaphore: VkSemaphore, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateEvent :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkEventCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pEvent: ^mut VkEvent);
__c__vkDestroyEvent :: (_device: VkDevice, _event: VkEvent, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetEventStatus :: (ret: ^mut VkResult, _device: VkDevice, _event: VkEvent);
__c__vkSetEvent :: (ret: ^mut VkResult, _device: VkDevice, _event: VkEvent);
__c__vkResetEvent :: (ret: ^mut VkResult, _device: VkDevice, _event: VkEvent);
__c__vkCreateQueryPool :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkQueryPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pQueryPool: ^mut VkQueryPool);
__c__vkDestroyQueryPool :: (_device: VkDevice, _queryPool: VkQueryPool, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetQueryPoolResults :: (ret: ^mut VkResult, _device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t, _dataSize: size_t, _pData: ^mut void, _stride: VkDeviceSize, _flags: VkQueryResultFlags);
__c__vkCreateBuffer :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkBufferCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pBuffer: ^mut VkBuffer);
__c__vkDestroyBuffer :: (_device: VkDevice, _buffer: VkBuffer, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateBufferView :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkBufferViewCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pView: ^mut VkBufferView);
__c__vkDestroyBufferView :: (_device: VkDevice, _bufferView: VkBufferView, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateImage :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkImageCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pImage: ^mut VkImage);
__c__vkDestroyImage :: (_device: VkDevice, _image: VkImage, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetImageSubresourceLayout :: (_device: VkDevice, _image: VkImage, _pSubresource: ^mut VkImageSubresource, _pLayout: ^mut VkSubresourceLayout);
__c__vkCreateImageView :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkImageViewCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pView: ^mut VkImageView);
__c__vkDestroyImageView :: (_device: VkDevice, _imageView: VkImageView, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateShaderModule :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkShaderModuleCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pShaderModule: ^mut VkShaderModule);
__c__vkDestroyShaderModule :: (_device: VkDevice, _shaderModule: VkShaderModule, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreatePipelineCache :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkPipelineCacheCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelineCache: ^mut VkPipelineCache);
__c__vkDestroyPipelineCache :: (_device: VkDevice, _pipelineCache: VkPipelineCache, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetPipelineCacheData :: (ret: ^mut VkResult, _device: VkDevice, _pipelineCache: VkPipelineCache, _pDataSize: ^mut size_t, _pData: ^mut void);
__c__vkMergePipelineCaches :: (ret: ^mut VkResult, _device: VkDevice, _dstCache: VkPipelineCache, _srcCacheCount: uint32_t, _pSrcCaches: ^mut VkPipelineCache);
__c__vkCreateGraphicsPipelines :: (ret: ^mut VkResult, _device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkGraphicsPipelineCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline);
__c__vkCreateComputePipelines :: (ret: ^mut VkResult, _device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkComputePipelineCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline);
__c__vkDestroyPipeline :: (_device: VkDevice, _pipeline: VkPipeline, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreatePipelineLayout :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkPipelineLayoutCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pPipelineLayout: ^mut VkPipelineLayout);
__c__vkDestroyPipelineLayout :: (_device: VkDevice, _pipelineLayout: VkPipelineLayout, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateSampler :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkSamplerCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSampler: ^mut VkSampler);
__c__vkDestroySampler :: (_device: VkDevice, _sampler: VkSampler, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateDescriptorSetLayout :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pSetLayout: ^mut VkDescriptorSetLayout);
__c__vkDestroyDescriptorSetLayout :: (_device: VkDevice, _descriptorSetLayout: VkDescriptorSetLayout, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateDescriptorPool :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkDescriptorPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorPool: ^mut VkDescriptorPool);
__c__vkDestroyDescriptorPool :: (_device: VkDevice, _descriptorPool: VkDescriptorPool, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkResetDescriptorPool :: (ret: ^mut VkResult, _device: VkDevice, _descriptorPool: VkDescriptorPool, _flags: VkDescriptorPoolResetFlags);
__c__vkAllocateDescriptorSets :: (ret: ^mut VkResult, _device: VkDevice, _pAllocateInfo: ^mut VkDescriptorSetAllocateInfo, _pDescriptorSets: ^mut VkDescriptorSet);
__c__vkFreeDescriptorSets :: (ret: ^mut VkResult, _device: VkDevice, _descriptorPool: VkDescriptorPool, _descriptorSetCount: uint32_t, _pDescriptorSets: ^mut VkDescriptorSet);
__c__vkUpdateDescriptorSets :: (_device: VkDevice, _descriptorWriteCount: uint32_t, _pDescriptorWrites: ^mut VkWriteDescriptorSet, _descriptorCopyCount: uint32_t, _pDescriptorCopies: ^mut VkCopyDescriptorSet);
__c__vkCreateFramebuffer :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkFramebufferCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pFramebuffer: ^mut VkFramebuffer);
__c__vkDestroyFramebuffer :: (_device: VkDevice, _framebuffer: VkFramebuffer, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateRenderPass :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass);
__c__vkDestroyRenderPass :: (_device: VkDevice, _renderPass: VkRenderPass, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetRenderAreaGranularity :: (_device: VkDevice, _renderPass: VkRenderPass, _pGranularity: ^mut VkExtent2D);
__c__vkCreateCommandPool :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkCommandPoolCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pCommandPool: ^mut VkCommandPool);
__c__vkDestroyCommandPool :: (_device: VkDevice, _commandPool: VkCommandPool, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkResetCommandPool :: (ret: ^mut VkResult, _device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolResetFlags);
__c__vkAllocateCommandBuffers :: (ret: ^mut VkResult, _device: VkDevice, _pAllocateInfo: ^mut VkCommandBufferAllocateInfo, _pCommandBuffers: ^mut VkCommandBuffer);
__c__vkFreeCommandBuffers :: (_device: VkDevice, _commandPool: VkCommandPool, _commandBufferCount: uint32_t, _pCommandBuffers: ^mut VkCommandBuffer);
__c__vkBeginCommandBuffer :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer, _pBeginInfo: ^mut VkCommandBufferBeginInfo);
__c__vkEndCommandBuffer :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer);
__c__vkResetCommandBuffer :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer, _flags: VkCommandBufferResetFlags);
__c__vkCmdBindPipeline :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _pipeline: VkPipeline);
__c__vkCmdSetViewport :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pViewports: ^mut VkViewport);
__c__vkCmdSetScissor :: (_commandBuffer: VkCommandBuffer, _firstScissor: uint32_t, _scissorCount: uint32_t, _pScissors: ^mut VkRect2D);
__c__vkCmdSetLineWidth :: (_commandBuffer: VkCommandBuffer, _lineWidth: f32);
__c__vkCmdSetDepthBias :: (_commandBuffer: VkCommandBuffer, _depthBiasConstantFactor: f32, _depthBiasClamp: f32, _depthBiasSlopeFactor: f32);
__c__vkCmdSetBlendConstants :: (_commandBuffer: VkCommandBuffer, _blendConstants: ^mut f32);
__c__vkCmdSetDepthBounds :: (_commandBuffer: VkCommandBuffer, _minDepthBounds: f32, _maxDepthBounds: f32);
__c__vkCmdSetStencilCompareMask :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _compareMask: uint32_t);
__c__vkCmdSetStencilWriteMask :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _writeMask: uint32_t);
__c__vkCmdSetStencilReference :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _reference: uint32_t);
__c__vkCmdBindDescriptorSets :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _layout: VkPipelineLayout, _firstSet: uint32_t, _descriptorSetCount: uint32_t, _pDescriptorSets: ^mut VkDescriptorSet, _dynamicOffsetCount: uint32_t, _pDynamicOffsets: ^mut uint32_t);
__c__vkCmdBindIndexBuffer :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _indexType: VkIndexType);
__c__vkCmdBindVertexBuffers :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize);
__c__vkCmdDraw :: (_commandBuffer: VkCommandBuffer, _vertexCount: uint32_t, _instanceCount: uint32_t, _firstVertex: uint32_t, _firstInstance: uint32_t);
__c__vkCmdDrawIndexed :: (_commandBuffer: VkCommandBuffer, _indexCount: uint32_t, _instanceCount: uint32_t, _firstIndex: uint32_t, _vertexOffset: int32_t, _firstInstance: uint32_t);
__c__vkCmdDrawIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDrawIndexedIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDispatch :: (_commandBuffer: VkCommandBuffer, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t);
__c__vkCmdDispatchIndirect :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize);
__c__vkCmdCopyBuffer :: (_commandBuffer: VkCommandBuffer, _srcBuffer: VkBuffer, _dstBuffer: VkBuffer, _regionCount: uint32_t, _pRegions: ^mut VkBufferCopy);
__c__vkCmdCopyImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageCopy);
__c__vkCmdBlitImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageBlit, _filter: VkFilter);
__c__vkCmdCopyBufferToImage :: (_commandBuffer: VkCommandBuffer, _srcBuffer: VkBuffer, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkBufferImageCopy);
__c__vkCmdCopyImageToBuffer :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstBuffer: VkBuffer, _regionCount: uint32_t, _pRegions: ^mut VkBufferImageCopy);
__c__vkCmdUpdateBuffer :: (_commandBuffer: VkCommandBuffer, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _dataSize: VkDeviceSize, _pData: ^mut void);
__c__vkCmdFillBuffer :: (_commandBuffer: VkCommandBuffer, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _size: VkDeviceSize, _data: uint32_t);
__c__vkCmdClearColorImage :: (_commandBuffer: VkCommandBuffer, _image: VkImage, _imageLayout: VkImageLayout, _pColor: ^mut VkClearColorValue, _rangeCount: uint32_t, _pRanges: ^mut VkImageSubresourceRange);
__c__vkCmdClearDepthStencilImage :: (_commandBuffer: VkCommandBuffer, _image: VkImage, _imageLayout: VkImageLayout, _pDepthStencil: ^mut VkClearDepthStencilValue, _rangeCount: uint32_t, _pRanges: ^mut VkImageSubresourceRange);
__c__vkCmdClearAttachments :: (_commandBuffer: VkCommandBuffer, _attachmentCount: uint32_t, _pAttachments: ^mut VkClearAttachment, _rectCount: uint32_t, _pRects: ^mut VkClearRect);
__c__vkCmdResolveImage :: (_commandBuffer: VkCommandBuffer, _srcImage: VkImage, _srcImageLayout: VkImageLayout, _dstImage: VkImage, _dstImageLayout: VkImageLayout, _regionCount: uint32_t, _pRegions: ^mut VkImageResolve);
__c__vkCmdSetEvent :: (_commandBuffer: VkCommandBuffer, _event: VkEvent, _stageMask: VkPipelineStageFlags);
__c__vkCmdResetEvent :: (_commandBuffer: VkCommandBuffer, _event: VkEvent, _stageMask: VkPipelineStageFlags);
__c__vkCmdWaitEvents :: (_commandBuffer: VkCommandBuffer, _eventCount: uint32_t, _pEvents: ^mut VkEvent, _srcStageMask: VkPipelineStageFlags, _dstStageMask: VkPipelineStageFlags, _memoryBarrierCount: uint32_t, _pMemoryBarriers: ^mut VkMemoryBarrier, _bufferMemoryBarrierCount: uint32_t, _pBufferMemoryBarriers: ^mut VkBufferMemoryBarrier, _imageMemoryBarrierCount: uint32_t, _pImageMemoryBarriers: ^mut VkImageMemoryBarrier);
__c__vkCmdPipelineBarrier :: (_commandBuffer: VkCommandBuffer, _srcStageMask: VkPipelineStageFlags, _dstStageMask: VkPipelineStageFlags, _dependencyFlags: VkDependencyFlags, _memoryBarrierCount: uint32_t, _pMemoryBarriers: ^mut VkMemoryBarrier, _bufferMemoryBarrierCount: uint32_t, _pBufferMemoryBarriers: ^mut VkBufferMemoryBarrier, _imageMemoryBarrierCount: uint32_t, _pImageMemoryBarriers: ^mut VkImageMemoryBarrier);
__c__vkCmdBeginQuery :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _flags: VkQueryControlFlags);
__c__vkCmdEndQuery :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t);
__c__vkCmdResetQueryPool :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t);
__c__vkCmdWriteTimestamp :: (_commandBuffer: VkCommandBuffer, _pipelineStage: VkPipelineStageFlagBits, _queryPool: VkQueryPool, _query: uint32_t);
__c__vkCmdCopyQueryPoolResults :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _stride: VkDeviceSize, _flags: VkQueryResultFlags);
__c__vkCmdPushConstants :: (_commandBuffer: VkCommandBuffer, _layout: VkPipelineLayout, _stageFlags: VkShaderStageFlags, _offset: uint32_t, _size: uint32_t, _pValues: ^mut void);
__c__vkCmdBeginRenderPass :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _contents: VkSubpassContents);
__c__vkCmdNextSubpass :: (_commandBuffer: VkCommandBuffer, _contents: VkSubpassContents);
__c__vkCmdEndRenderPass :: (_commandBuffer: VkCommandBuffer);
__c__vkCmdExecuteCommands :: (_commandBuffer: VkCommandBuffer, _commandBufferCount: uint32_t, _pCommandBuffers: ^mut VkCommandBuffer);
__c__vkEnumerateInstanceVersion :: (ret: ^mut VkResult, _pApiVersion: ^mut uint32_t);
__c__vkBindBufferMemory2 :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindBufferMemoryInfo);
__c__vkBindImageMemory2 :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindImageMemoryInfo);
__c__vkGetDeviceGroupPeerMemoryFeatures :: (_device: VkDevice, _heapIndex: uint32_t, _localDeviceIndex: uint32_t, _remoteDeviceIndex: uint32_t, _pPeerMemoryFeatures: ^mut VkPeerMemoryFeatureFlags);
__c__vkCmdSetDeviceMask :: (_commandBuffer: VkCommandBuffer, _deviceMask: uint32_t);
__c__vkCmdDispatchBase :: (_commandBuffer: VkCommandBuffer, _baseGroupX: uint32_t, _baseGroupY: uint32_t, _baseGroupZ: uint32_t, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t);
__c__vkEnumeratePhysicalDeviceGroups :: (ret: ^mut VkResult, _instance: VkInstance, _pPhysicalDeviceGroupCount: ^mut uint32_t, _pPhysicalDeviceGroupProperties: ^mut VkPhysicalDeviceGroupProperties);
__c__vkGetImageMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkImageMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2);
__c__vkGetBufferMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkBufferMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2);
__c__vkGetImageSparseMemoryRequirements2 :: (_device: VkDevice, _pInfo: ^mut VkImageSparseMemoryRequirementsInfo2, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements2);
__c__vkGetPhysicalDeviceFeatures2 :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures2);
__c__vkGetPhysicalDeviceProperties2 :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties2);
__c__vkGetPhysicalDeviceFormatProperties2 :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties2);
__c__vkGetPhysicalDeviceImageFormatProperties2 :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pImageFormatInfo: ^mut VkPhysicalDeviceImageFormatInfo2, _pImageFormatProperties: ^mut VkImageFormatProperties2);
__c__vkGetPhysicalDeviceQueueFamilyProperties2 :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties2);
__c__vkGetPhysicalDeviceMemoryProperties2 :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties2);
__c__vkGetPhysicalDeviceSparseImageFormatProperties2 :: (_physicalDevice: VkPhysicalDevice, _pFormatInfo: ^mut VkPhysicalDeviceSparseImageFormatInfo2, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties2);
__c__vkTrimCommandPool :: (_device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolTrimFlags);
__c__vkGetDeviceQueue2 :: (_device: VkDevice, _pQueueInfo: ^mut VkDeviceQueueInfo2, _pQueue: ^mut VkQueue);
__c__vkCreateSamplerYcbcrConversion :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkSamplerYcbcrConversionCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pYcbcrConversion: ^mut VkSamplerYcbcrConversion);
__c__vkDestroySamplerYcbcrConversion :: (_device: VkDevice, _ycbcrConversion: VkSamplerYcbcrConversion, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreateDescriptorUpdateTemplate :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkDescriptorUpdateTemplateCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorUpdateTemplate: ^mut VkDescriptorUpdateTemplate);
__c__vkDestroyDescriptorUpdateTemplate :: (_device: VkDevice, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkUpdateDescriptorSetWithTemplate :: (_device: VkDevice, _descriptorSet: VkDescriptorSet, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pData: ^mut void);
__c__vkGetPhysicalDeviceExternalBufferProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalBufferInfo: ^mut VkPhysicalDeviceExternalBufferInfo, _pExternalBufferProperties: ^mut VkExternalBufferProperties);
__c__vkGetPhysicalDeviceExternalFenceProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalFenceInfo: ^mut VkPhysicalDeviceExternalFenceInfo, _pExternalFenceProperties: ^mut VkExternalFenceProperties);
__c__vkGetPhysicalDeviceExternalSemaphoreProperties :: (_physicalDevice: VkPhysicalDevice, _pExternalSemaphoreInfo: ^mut VkPhysicalDeviceExternalSemaphoreInfo, _pExternalSemaphoreProperties: ^mut VkExternalSemaphoreProperties);
__c__vkGetDescriptorSetLayoutSupport :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pSupport: ^mut VkDescriptorSetLayoutSupport);
__c__vkCmdDrawIndirectCount :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDrawIndexedIndirectCount :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkCreateRenderPass2 :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo2, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass);
__c__vkCmdBeginRenderPass2 :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo);
__c__vkCmdNextSubpass2 :: (_commandBuffer: VkCommandBuffer, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo, _pSubpassEndInfo: ^mut VkSubpassEndInfo);
__c__vkCmdEndRenderPass2 :: (_commandBuffer: VkCommandBuffer, _pSubpassEndInfo: ^mut VkSubpassEndInfo);
__c__vkResetQueryPool :: (_device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t);
__c__vkGetSemaphoreCounterValue :: (ret: ^mut VkResult, _device: VkDevice, _semaphore: VkSemaphore, _pValue: ^mut uint64_t);
__c__vkWaitSemaphores :: (ret: ^mut VkResult, _device: VkDevice, _pWaitInfo: ^mut VkSemaphoreWaitInfo, _timeout: uint64_t);
__c__vkSignalSemaphore :: (ret: ^mut VkResult, _device: VkDevice, _pSignalInfo: ^mut VkSemaphoreSignalInfo);
__c__vkGetBufferDeviceAddress :: (ret: ^mut VkDeviceAddress, _device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo);
__c__vkGetBufferOpaqueCaptureAddress :: (ret: ^mut uint64_t, _device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo);
__c__vkGetDeviceMemoryOpaqueCaptureAddress :: (ret: ^mut uint64_t, _device: VkDevice, _pInfo: ^mut VkDeviceMemoryOpaqueCaptureAddressInfo);
__c__vkDestroySurfaceKHR :: (_instance: VkInstance, _surface: VkSurfaceKHR, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetPhysicalDeviceSurfaceSupportKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _queueFamilyIndex: uint32_t, _surface: VkSurfaceKHR, _pSupported: ^mut VkBool32);
__c__vkGetPhysicalDeviceSurfaceCapabilitiesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilitiesKHR);
__c__vkGetPhysicalDeviceSurfaceFormatsKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceFormatCount: ^mut uint32_t, _pSurfaceFormats: ^mut VkSurfaceFormatKHR);
__c__vkGetPhysicalDeviceSurfacePresentModesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pPresentModeCount: ^mut uint32_t, _pPresentModes: ^mut VkPresentModeKHR);
__c__vkCreateSwapchainKHR :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkSwapchainCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSwapchain: ^mut VkSwapchainKHR);
__c__vkDestroySwapchainKHR :: (_device: VkDevice, _swapchain: VkSwapchainKHR, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetSwapchainImagesKHR :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR, _pSwapchainImageCount: ^mut uint32_t, _pSwapchainImages: ^mut VkImage);
__c__vkAcquireNextImageKHR :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR, _timeout: uint64_t, _semaphore: VkSemaphore, _fence: VkFence, _pImageIndex: ^mut uint32_t);
__c__vkQueuePresentKHR :: (ret: ^mut VkResult, _queue: VkQueue, _pPresentInfo: ^mut VkPresentInfoKHR);
__c__vkGetDeviceGroupPresentCapabilitiesKHR :: (ret: ^mut VkResult, _device: VkDevice, _pDeviceGroupPresentCapabilities: ^mut VkDeviceGroupPresentCapabilitiesKHR);
__c__vkGetDeviceGroupSurfacePresentModesKHR :: (ret: ^mut VkResult, _device: VkDevice, _surface: VkSurfaceKHR, _pModes: ^mut VkDeviceGroupPresentModeFlagsKHR);
__c__vkGetPhysicalDevicePresentRectanglesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pRectCount: ^mut uint32_t, _pRects: ^mut VkRect2D);
__c__vkAcquireNextImage2KHR :: (ret: ^mut VkResult, _device: VkDevice, _pAcquireInfo: ^mut VkAcquireNextImageInfoKHR, _pImageIndex: ^mut uint32_t);
__c__vkGetPhysicalDeviceDisplayPropertiesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPropertiesKHR);
__c__vkGetPhysicalDeviceDisplayPlanePropertiesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPlanePropertiesKHR);
__c__vkGetDisplayPlaneSupportedDisplaysKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _planeIndex: uint32_t, _pDisplayCount: ^mut uint32_t, _pDisplays: ^mut VkDisplayKHR);
__c__vkGetDisplayModePropertiesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayModePropertiesKHR);
__c__vkCreateDisplayModeKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pCreateInfo: ^mut VkDisplayModeCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pMode: ^mut VkDisplayModeKHR);
__c__vkGetDisplayPlaneCapabilitiesKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _mode: VkDisplayModeKHR, _planeIndex: uint32_t, _pCapabilities: ^mut VkDisplayPlaneCapabilitiesKHR);
__c__vkCreateDisplayPlaneSurfaceKHR :: (ret: ^mut VkResult, _instance: VkInstance, _pCreateInfo: ^mut VkDisplaySurfaceCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSurface: ^mut VkSurfaceKHR);
__c__vkCreateSharedSwapchainsKHR :: (ret: ^mut VkResult, _device: VkDevice, _swapchainCount: uint32_t, _pCreateInfos: ^mut VkSwapchainCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSwapchains: ^mut VkSwapchainKHR);
__c__vkGetPhysicalDeviceFeatures2KHR :: (_physicalDevice: VkPhysicalDevice, _pFeatures: ^mut VkPhysicalDeviceFeatures2);
__c__vkGetPhysicalDeviceProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pProperties: ^mut VkPhysicalDeviceProperties2);
__c__vkGetPhysicalDeviceFormatProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _format: VkFormat, _pFormatProperties: ^mut VkFormatProperties2);
__c__vkGetPhysicalDeviceImageFormatProperties2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pImageFormatInfo: ^mut VkPhysicalDeviceImageFormatInfo2, _pImageFormatProperties: ^mut VkImageFormatProperties2);
__c__vkGetPhysicalDeviceQueueFamilyProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pQueueFamilyPropertyCount: ^mut uint32_t, _pQueueFamilyProperties: ^mut VkQueueFamilyProperties2);
__c__vkGetPhysicalDeviceMemoryProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pMemoryProperties: ^mut VkPhysicalDeviceMemoryProperties2);
__c__vkGetPhysicalDeviceSparseImageFormatProperties2KHR :: (_physicalDevice: VkPhysicalDevice, _pFormatInfo: ^mut VkPhysicalDeviceSparseImageFormatInfo2, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkSparseImageFormatProperties2);
__c__vkGetDeviceGroupPeerMemoryFeaturesKHR :: (_device: VkDevice, _heapIndex: uint32_t, _localDeviceIndex: uint32_t, _remoteDeviceIndex: uint32_t, _pPeerMemoryFeatures: ^mut VkPeerMemoryFeatureFlags);
__c__vkCmdSetDeviceMaskKHR :: (_commandBuffer: VkCommandBuffer, _deviceMask: uint32_t);
__c__vkCmdDispatchBaseKHR :: (_commandBuffer: VkCommandBuffer, _baseGroupX: uint32_t, _baseGroupY: uint32_t, _baseGroupZ: uint32_t, _groupCountX: uint32_t, _groupCountY: uint32_t, _groupCountZ: uint32_t);
__c__vkTrimCommandPoolKHR :: (_device: VkDevice, _commandPool: VkCommandPool, _flags: VkCommandPoolTrimFlags);
__c__vkEnumeratePhysicalDeviceGroupsKHR :: (ret: ^mut VkResult, _instance: VkInstance, _pPhysicalDeviceGroupCount: ^mut uint32_t, _pPhysicalDeviceGroupProperties: ^mut VkPhysicalDeviceGroupProperties);
__c__vkGetPhysicalDeviceExternalBufferPropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalBufferInfo: ^mut VkPhysicalDeviceExternalBufferInfo, _pExternalBufferProperties: ^mut VkExternalBufferProperties);
__c__vkGetMemoryFdKHR :: (ret: ^mut VkResult, _device: VkDevice, _pGetFdInfo: ^mut VkMemoryGetFdInfoKHR, _pFd: ^mut i32);
__c__vkGetMemoryFdPropertiesKHR :: (ret: ^mut VkResult, _device: VkDevice, _handleType: VkExternalMemoryHandleTypeFlagBits, _fd: i32, _pMemoryFdProperties: ^mut VkMemoryFdPropertiesKHR);
__c__vkGetPhysicalDeviceExternalSemaphorePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalSemaphoreInfo: ^mut VkPhysicalDeviceExternalSemaphoreInfo, _pExternalSemaphoreProperties: ^mut VkExternalSemaphoreProperties);
__c__vkImportSemaphoreFdKHR :: (ret: ^mut VkResult, _device: VkDevice, _pImportSemaphoreFdInfo: ^mut VkImportSemaphoreFdInfoKHR);
__c__vkGetSemaphoreFdKHR :: (ret: ^mut VkResult, _device: VkDevice, _pGetFdInfo: ^mut VkSemaphoreGetFdInfoKHR, _pFd: ^mut i32);
__c__vkCmdPushDescriptorSetKHR :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _layout: VkPipelineLayout, _set: uint32_t, _descriptorWriteCount: uint32_t, _pDescriptorWrites: ^mut VkWriteDescriptorSet);
__c__vkCmdPushDescriptorSetWithTemplateKHR :: (_commandBuffer: VkCommandBuffer, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _layout: VkPipelineLayout, _set: uint32_t, _pData: ^mut void);
__c__vkCreateDescriptorUpdateTemplateKHR :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkDescriptorUpdateTemplateCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pDescriptorUpdateTemplate: ^mut VkDescriptorUpdateTemplate);
__c__vkDestroyDescriptorUpdateTemplateKHR :: (_device: VkDevice, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkUpdateDescriptorSetWithTemplateKHR :: (_device: VkDevice, _descriptorSet: VkDescriptorSet, _descriptorUpdateTemplate: VkDescriptorUpdateTemplate, _pData: ^mut void);
__c__vkCreateRenderPass2KHR :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkRenderPassCreateInfo2, _pAllocator: ^mut VkAllocationCallbacks, _pRenderPass: ^mut VkRenderPass);
__c__vkCmdBeginRenderPass2KHR :: (_commandBuffer: VkCommandBuffer, _pRenderPassBegin: ^mut VkRenderPassBeginInfo, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo);
__c__vkCmdNextSubpass2KHR :: (_commandBuffer: VkCommandBuffer, _pSubpassBeginInfo: ^mut VkSubpassBeginInfo, _pSubpassEndInfo: ^mut VkSubpassEndInfo);
__c__vkCmdEndRenderPass2KHR :: (_commandBuffer: VkCommandBuffer, _pSubpassEndInfo: ^mut VkSubpassEndInfo);
__c__vkGetSwapchainStatusKHR :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR);
__c__vkGetPhysicalDeviceExternalFencePropertiesKHR :: (_physicalDevice: VkPhysicalDevice, _pExternalFenceInfo: ^mut VkPhysicalDeviceExternalFenceInfo, _pExternalFenceProperties: ^mut VkExternalFenceProperties);
__c__vkImportFenceFdKHR :: (ret: ^mut VkResult, _device: VkDevice, _pImportFenceFdInfo: ^mut VkImportFenceFdInfoKHR);
__c__vkGetFenceFdKHR :: (ret: ^mut VkResult, _device: VkDevice, _pGetFdInfo: ^mut VkFenceGetFdInfoKHR, _pFd: ^mut i32);
__c__vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _queueFamilyIndex: uint32_t, _pCounterCount: ^mut uint32_t, _pCounters: ^mut VkPerformanceCounterKHR, _pCounterDescriptions: ^mut VkPerformanceCounterDescriptionKHR);
__c__vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR :: (_physicalDevice: VkPhysicalDevice, _pPerformanceQueryCreateInfo: ^mut VkQueryPoolPerformanceCreateInfoKHR, _pNumPasses: ^mut uint32_t);
__c__vkAcquireProfilingLockKHR :: (ret: ^mut VkResult, _device: VkDevice, _pInfo: ^mut VkAcquireProfilingLockInfoKHR);
__c__vkReleaseProfilingLockKHR :: (_device: VkDevice);
__c__vkGetPhysicalDeviceSurfaceCapabilities2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pSurfaceInfo: ^mut VkPhysicalDeviceSurfaceInfo2KHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilities2KHR);
__c__vkGetPhysicalDeviceSurfaceFormats2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pSurfaceInfo: ^mut VkPhysicalDeviceSurfaceInfo2KHR, _pSurfaceFormatCount: ^mut uint32_t, _pSurfaceFormats: ^mut VkSurfaceFormat2KHR);
__c__vkGetPhysicalDeviceDisplayProperties2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayProperties2KHR);
__c__vkGetPhysicalDeviceDisplayPlaneProperties2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayPlaneProperties2KHR);
__c__vkGetDisplayModeProperties2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkDisplayModeProperties2KHR);
__c__vkGetDisplayPlaneCapabilities2KHR :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pDisplayPlaneInfo: ^mut VkDisplayPlaneInfo2KHR, _pCapabilities: ^mut VkDisplayPlaneCapabilities2KHR);
__c__vkGetImageMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkImageMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2);
__c__vkGetBufferMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkBufferMemoryRequirementsInfo2, _pMemoryRequirements: ^mut VkMemoryRequirements2);
__c__vkGetImageSparseMemoryRequirements2KHR :: (_device: VkDevice, _pInfo: ^mut VkImageSparseMemoryRequirementsInfo2, _pSparseMemoryRequirementCount: ^mut uint32_t, _pSparseMemoryRequirements: ^mut VkSparseImageMemoryRequirements2);
__c__vkCreateSamplerYcbcrConversionKHR :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkSamplerYcbcrConversionCreateInfo, _pAllocator: ^mut VkAllocationCallbacks, _pYcbcrConversion: ^mut VkSamplerYcbcrConversion);
__c__vkDestroySamplerYcbcrConversionKHR :: (_device: VkDevice, _ycbcrConversion: VkSamplerYcbcrConversion, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkBindBufferMemory2KHR :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindBufferMemoryInfo);
__c__vkBindImageMemory2KHR :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindImageMemoryInfo);
__c__vkGetDescriptorSetLayoutSupportKHR :: (_device: VkDevice, _pCreateInfo: ^mut VkDescriptorSetLayoutCreateInfo, _pSupport: ^mut VkDescriptorSetLayoutSupport);
__c__vkCmdDrawIndirectCountKHR :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDrawIndexedIndirectCountKHR :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkGetSemaphoreCounterValueKHR :: (ret: ^mut VkResult, _device: VkDevice, _semaphore: VkSemaphore, _pValue: ^mut uint64_t);
__c__vkWaitSemaphoresKHR :: (ret: ^mut VkResult, _device: VkDevice, _pWaitInfo: ^mut VkSemaphoreWaitInfo, _timeout: uint64_t);
__c__vkSignalSemaphoreKHR :: (ret: ^mut VkResult, _device: VkDevice, _pSignalInfo: ^mut VkSemaphoreSignalInfo);
__c__vkGetBufferDeviceAddressKHR :: (ret: ^mut VkDeviceAddress, _device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo);
__c__vkGetBufferOpaqueCaptureAddressKHR :: (ret: ^mut uint64_t, _device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo);
__c__vkGetDeviceMemoryOpaqueCaptureAddressKHR :: (ret: ^mut uint64_t, _device: VkDevice, _pInfo: ^mut VkDeviceMemoryOpaqueCaptureAddressInfo);
__c__vkGetPipelineExecutablePropertiesKHR :: (ret: ^mut VkResult, _device: VkDevice, _pPipelineInfo: ^mut VkPipelineInfoKHR, _pExecutableCount: ^mut uint32_t, _pProperties: ^mut VkPipelineExecutablePropertiesKHR);
__c__vkGetPipelineExecutableStatisticsKHR :: (ret: ^mut VkResult, _device: VkDevice, _pExecutableInfo: ^mut VkPipelineExecutableInfoKHR, _pStatisticCount: ^mut uint32_t, _pStatistics: ^mut VkPipelineExecutableStatisticKHR);
__c__vkGetPipelineExecutableInternalRepresentationsKHR :: (ret: ^mut VkResult, _device: VkDevice, _pExecutableInfo: ^mut VkPipelineExecutableInfoKHR, _pInternalRepresentationCount: ^mut uint32_t, _pInternalRepresentations: ^mut VkPipelineExecutableInternalRepresentationKHR);
__c__vkCreateDebugReportCallbackEXT :: (ret: ^mut VkResult, _instance: VkInstance, _pCreateInfo: ^mut VkDebugReportCallbackCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pCallback: ^mut VkDebugReportCallbackEXT);
__c__vkDestroyDebugReportCallbackEXT :: (_instance: VkInstance, _callback: VkDebugReportCallbackEXT, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkDebugReportMessageEXT :: (_instance: VkInstance, _flags: VkDebugReportFlagsEXT, _objectType: VkDebugReportObjectTypeEXT, _object: uint64_t, _location: size_t, _messageCode: int32_t, _pLayerPrefix: ^mut char8, _pMessage: ^mut char8);
__c__vkDebugMarkerSetObjectTagEXT :: (ret: ^mut VkResult, _device: VkDevice, _pTagInfo: ^mut VkDebugMarkerObjectTagInfoEXT);
__c__vkDebugMarkerSetObjectNameEXT :: (ret: ^mut VkResult, _device: VkDevice, _pNameInfo: ^mut VkDebugMarkerObjectNameInfoEXT);
__c__vkCmdDebugMarkerBeginEXT :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkDebugMarkerMarkerInfoEXT);
__c__vkCmdDebugMarkerEndEXT :: (_commandBuffer: VkCommandBuffer);
__c__vkCmdDebugMarkerInsertEXT :: (_commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkDebugMarkerMarkerInfoEXT);
__c__vkCmdBindTransformFeedbackBuffersEXT :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize, _pSizes: ^mut VkDeviceSize);
__c__vkCmdBeginTransformFeedbackEXT :: (_commandBuffer: VkCommandBuffer, _firstCounterBuffer: uint32_t, _counterBufferCount: uint32_t, _pCounterBuffers: ^mut VkBuffer, _pCounterBufferOffsets: ^mut VkDeviceSize);
__c__vkCmdEndTransformFeedbackEXT :: (_commandBuffer: VkCommandBuffer, _firstCounterBuffer: uint32_t, _counterBufferCount: uint32_t, _pCounterBuffers: ^mut VkBuffer, _pCounterBufferOffsets: ^mut VkDeviceSize);
__c__vkCmdBeginQueryIndexedEXT :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _flags: VkQueryControlFlags, _index: uint32_t);
__c__vkCmdEndQueryIndexedEXT :: (_commandBuffer: VkCommandBuffer, _queryPool: VkQueryPool, _query: uint32_t, _index: uint32_t);
__c__vkCmdDrawIndirectByteCountEXT :: (_commandBuffer: VkCommandBuffer, _instanceCount: uint32_t, _firstInstance: uint32_t, _counterBuffer: VkBuffer, _counterBufferOffset: VkDeviceSize, _counterOffset: uint32_t, _vertexStride: uint32_t);
__c__vkGetImageViewHandleNVX :: (ret: ^mut uint32_t, _device: VkDevice, _pInfo: ^mut VkImageViewHandleInfoNVX);
__c__vkGetImageViewAddressNVX :: (ret: ^mut VkResult, _device: VkDevice, _imageView: VkImageView, _pProperties: ^mut VkImageViewAddressPropertiesNVX);
__c__vkCmdDrawIndirectCountAMD :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDrawIndexedIndirectCountAMD :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkGetShaderInfoAMD :: (ret: ^mut VkResult, _device: VkDevice, _pipeline: VkPipeline, _shaderStage: VkShaderStageFlagBits, _infoType: VkShaderInfoTypeAMD, _pInfoSize: ^mut size_t, _pInfo: ^mut void);
__c__vkGetPhysicalDeviceExternalImageFormatPropertiesNV :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _format: VkFormat, _type: VkImageType, _tiling: VkImageTiling, _usage: VkImageUsageFlags, _flags: VkImageCreateFlags, _externalHandleType: VkExternalMemoryHandleTypeFlagsNV, _pExternalImageFormatProperties: ^mut VkExternalImageFormatPropertiesNV);
__c__vkCmdBeginConditionalRenderingEXT :: (_commandBuffer: VkCommandBuffer, _pConditionalRenderingBegin: ^mut VkConditionalRenderingBeginInfoEXT);
__c__vkCmdEndConditionalRenderingEXT :: (_commandBuffer: VkCommandBuffer);
__c__vkCmdSetViewportWScalingNV :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pViewportWScalings: ^mut VkViewportWScalingNV);
__c__vkReleaseDisplayEXT :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _display: VkDisplayKHR);
__c__vkGetPhysicalDeviceSurfaceCapabilities2EXT :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _surface: VkSurfaceKHR, _pSurfaceCapabilities: ^mut VkSurfaceCapabilities2EXT);
__c__vkDisplayPowerControlEXT :: (ret: ^mut VkResult, _device: VkDevice, _display: VkDisplayKHR, _pDisplayPowerInfo: ^mut VkDisplayPowerInfoEXT);
__c__vkRegisterDeviceEventEXT :: (ret: ^mut VkResult, _device: VkDevice, _pDeviceEventInfo: ^mut VkDeviceEventInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence);
__c__vkRegisterDisplayEventEXT :: (ret: ^mut VkResult, _device: VkDevice, _display: VkDisplayKHR, _pDisplayEventInfo: ^mut VkDisplayEventInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pFence: ^mut VkFence);
__c__vkGetSwapchainCounterEXT :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR, _counter: VkSurfaceCounterFlagBitsEXT, _pCounterValue: ^mut uint64_t);
__c__vkGetRefreshCycleDurationGOOGLE :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR, _pDisplayTimingProperties: ^mut VkRefreshCycleDurationGOOGLE);
__c__vkGetPastPresentationTimingGOOGLE :: (ret: ^mut VkResult, _device: VkDevice, _swapchain: VkSwapchainKHR, _pPresentationTimingCount: ^mut uint32_t, _pPresentationTimings: ^mut VkPastPresentationTimingGOOGLE);
__c__vkCmdSetDiscardRectangleEXT :: (_commandBuffer: VkCommandBuffer, _firstDiscardRectangle: uint32_t, _discardRectangleCount: uint32_t, _pDiscardRectangles: ^mut VkRect2D);
__c__vkSetHdrMetadataEXT :: (_device: VkDevice, _swapchainCount: uint32_t, _pSwapchains: ^mut VkSwapchainKHR, _pMetadata: ^mut VkHdrMetadataEXT);
__c__vkSetDebugUtilsObjectNameEXT :: (ret: ^mut VkResult, _device: VkDevice, _pNameInfo: ^mut VkDebugUtilsObjectNameInfoEXT);
__c__vkSetDebugUtilsObjectTagEXT :: (ret: ^mut VkResult, _device: VkDevice, _pTagInfo: ^mut VkDebugUtilsObjectTagInfoEXT);
__c__vkQueueBeginDebugUtilsLabelEXT :: (_queue: VkQueue, _pLabelInfo: ^mut VkDebugUtilsLabelEXT);
__c__vkQueueEndDebugUtilsLabelEXT :: (_queue: VkQueue);
__c__vkQueueInsertDebugUtilsLabelEXT :: (_queue: VkQueue, _pLabelInfo: ^mut VkDebugUtilsLabelEXT);
__c__vkCmdBeginDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer, _pLabelInfo: ^mut VkDebugUtilsLabelEXT);
__c__vkCmdEndDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer);
__c__vkCmdInsertDebugUtilsLabelEXT :: (_commandBuffer: VkCommandBuffer, _pLabelInfo: ^mut VkDebugUtilsLabelEXT);
__c__vkCreateDebugUtilsMessengerEXT :: (ret: ^mut VkResult, _instance: VkInstance, _pCreateInfo: ^mut VkDebugUtilsMessengerCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pMessenger: ^mut VkDebugUtilsMessengerEXT);
__c__vkDestroyDebugUtilsMessengerEXT :: (_instance: VkInstance, _messenger: VkDebugUtilsMessengerEXT, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkSubmitDebugUtilsMessageEXT :: (_instance: VkInstance, _messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT, _messageTypes: VkDebugUtilsMessageTypeFlagsEXT, _pCallbackData: ^mut VkDebugUtilsMessengerCallbackDataEXT);
__c__vkCmdSetSampleLocationsEXT :: (_commandBuffer: VkCommandBuffer, _pSampleLocationsInfo: ^mut VkSampleLocationsInfoEXT);
__c__vkGetPhysicalDeviceMultisamplePropertiesEXT :: (_physicalDevice: VkPhysicalDevice, _samples: VkSampleCountFlagBits, _pMultisampleProperties: ^mut VkMultisamplePropertiesEXT);
__c__vkGetImageDrmFormatModifierPropertiesEXT :: (ret: ^mut VkResult, _device: VkDevice, _image: VkImage, _pProperties: ^mut VkImageDrmFormatModifierPropertiesEXT);
__c__vkCreateValidationCacheEXT :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkValidationCacheCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pValidationCache: ^mut VkValidationCacheEXT);
__c__vkDestroyValidationCacheEXT :: (_device: VkDevice, _validationCache: VkValidationCacheEXT, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkMergeValidationCachesEXT :: (ret: ^mut VkResult, _device: VkDevice, _dstCache: VkValidationCacheEXT, _srcCacheCount: uint32_t, _pSrcCaches: ^mut VkValidationCacheEXT);
__c__vkGetValidationCacheDataEXT :: (ret: ^mut VkResult, _device: VkDevice, _validationCache: VkValidationCacheEXT, _pDataSize: ^mut size_t, _pData: ^mut void);
__c__vkCmdBindShadingRateImageNV :: (_commandBuffer: VkCommandBuffer, _imageView: VkImageView, _imageLayout: VkImageLayout);
__c__vkCmdSetViewportShadingRatePaletteNV :: (_commandBuffer: VkCommandBuffer, _firstViewport: uint32_t, _viewportCount: uint32_t, _pShadingRatePalettes: ^mut VkShadingRatePaletteNV);
__c__vkCmdSetCoarseSampleOrderNV :: (_commandBuffer: VkCommandBuffer, _sampleOrderType: VkCoarseSampleOrderTypeNV, _customSampleOrderCount: uint32_t, _pCustomSampleOrders: ^mut VkCoarseSampleOrderCustomNV);
__c__vkCreateAccelerationStructureNV :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkAccelerationStructureCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pAccelerationStructure: ^mut VkAccelerationStructureNV);
__c__vkDestroyAccelerationStructureKHR :: (_device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkDestroyAccelerationStructureNV :: (_device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkGetAccelerationStructureMemoryRequirementsNV :: (_device: VkDevice, _pInfo: ^mut VkAccelerationStructureMemoryRequirementsInfoNV, _pMemoryRequirements: ^mut VkMemoryRequirements2KHR);
__c__vkBindAccelerationStructureMemoryKHR :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindAccelerationStructureMemoryInfoKHR);
__c__vkBindAccelerationStructureMemoryNV :: (ret: ^mut VkResult, _device: VkDevice, _bindInfoCount: uint32_t, _pBindInfos: ^mut VkBindAccelerationStructureMemoryInfoKHR);
__c__vkCmdBuildAccelerationStructureNV :: (_commandBuffer: VkCommandBuffer, _pInfo: ^mut VkAccelerationStructureInfoNV, _instanceData: VkBuffer, _instanceOffset: VkDeviceSize, _update: VkBool32, _dst: VkAccelerationStructureKHR, _src: VkAccelerationStructureKHR, _scratch: VkBuffer, _scratchOffset: VkDeviceSize);
__c__vkCmdCopyAccelerationStructureNV :: (_commandBuffer: VkCommandBuffer, _dst: VkAccelerationStructureKHR, _src: VkAccelerationStructureKHR, _mode: VkCopyAccelerationStructureModeKHR);
__c__vkCmdTraceRaysNV :: (_commandBuffer: VkCommandBuffer, _raygenShaderBindingTableBuffer: VkBuffer, _raygenShaderBindingOffset: VkDeviceSize, _missShaderBindingTableBuffer: VkBuffer, _missShaderBindingOffset: VkDeviceSize, _missShaderBindingStride: VkDeviceSize, _hitShaderBindingTableBuffer: VkBuffer, _hitShaderBindingOffset: VkDeviceSize, _hitShaderBindingStride: VkDeviceSize, _callableShaderBindingTableBuffer: VkBuffer, _callableShaderBindingOffset: VkDeviceSize, _callableShaderBindingStride: VkDeviceSize, _width: uint32_t, _height: uint32_t, _depth: uint32_t);
__c__vkCreateRayTracingPipelinesNV :: (ret: ^mut VkResult, _device: VkDevice, _pipelineCache: VkPipelineCache, _createInfoCount: uint32_t, _pCreateInfos: ^mut VkRayTracingPipelineCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pPipelines: ^mut VkPipeline);
__c__vkGetRayTracingShaderGroupHandlesKHR :: (ret: ^mut VkResult, _device: VkDevice, _pipeline: VkPipeline, _firstGroup: uint32_t, _groupCount: uint32_t, _dataSize: size_t, _pData: ^mut void);
__c__vkGetRayTracingShaderGroupHandlesNV :: (ret: ^mut VkResult, _device: VkDevice, _pipeline: VkPipeline, _firstGroup: uint32_t, _groupCount: uint32_t, _dataSize: size_t, _pData: ^mut void);
__c__vkGetAccelerationStructureHandleNV :: (ret: ^mut VkResult, _device: VkDevice, _accelerationStructure: VkAccelerationStructureKHR, _dataSize: size_t, _pData: ^mut void);
__c__vkCmdWriteAccelerationStructuresPropertiesKHR :: (_commandBuffer: VkCommandBuffer, _accelerationStructureCount: uint32_t, _pAccelerationStructures: ^mut VkAccelerationStructureKHR, _queryType: VkQueryType, _queryPool: VkQueryPool, _firstQuery: uint32_t);
__c__vkCmdWriteAccelerationStructuresPropertiesNV :: (_commandBuffer: VkCommandBuffer, _accelerationStructureCount: uint32_t, _pAccelerationStructures: ^mut VkAccelerationStructureKHR, _queryType: VkQueryType, _queryPool: VkQueryPool, _firstQuery: uint32_t);
__c__vkCompileDeferredNV :: (ret: ^mut VkResult, _device: VkDevice, _pipeline: VkPipeline, _shader: uint32_t);
__c__vkGetMemoryHostPointerPropertiesEXT :: (ret: ^mut VkResult, _device: VkDevice, _handleType: VkExternalMemoryHandleTypeFlagBits, _pHostPointer: ^mut void, _pMemoryHostPointerProperties: ^mut VkMemoryHostPointerPropertiesEXT);
__c__vkCmdWriteBufferMarkerAMD :: (_commandBuffer: VkCommandBuffer, _pipelineStage: VkPipelineStageFlagBits, _dstBuffer: VkBuffer, _dstOffset: VkDeviceSize, _marker: uint32_t);
__c__vkGetPhysicalDeviceCalibrateableTimeDomainsEXT :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pTimeDomainCount: ^mut uint32_t, _pTimeDomains: ^mut VkTimeDomainEXT);
__c__vkGetCalibratedTimestampsEXT :: (ret: ^mut VkResult, _device: VkDevice, _timestampCount: uint32_t, _pTimestampInfos: ^mut VkCalibratedTimestampInfoEXT, _pTimestamps: ^mut uint64_t, _pMaxDeviation: ^mut uint64_t);
__c__vkCmdDrawMeshTasksNV :: (_commandBuffer: VkCommandBuffer, _taskCount: uint32_t, _firstTask: uint32_t);
__c__vkCmdDrawMeshTasksIndirectNV :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _drawCount: uint32_t, _stride: uint32_t);
__c__vkCmdDrawMeshTasksIndirectCountNV :: (_commandBuffer: VkCommandBuffer, _buffer: VkBuffer, _offset: VkDeviceSize, _countBuffer: VkBuffer, _countBufferOffset: VkDeviceSize, _maxDrawCount: uint32_t, _stride: uint32_t);
__c__vkCmdSetExclusiveScissorNV :: (_commandBuffer: VkCommandBuffer, _firstExclusiveScissor: uint32_t, _exclusiveScissorCount: uint32_t, _pExclusiveScissors: ^mut VkRect2D);
__c__vkCmdSetCheckpointNV :: (_commandBuffer: VkCommandBuffer, _pCheckpointMarker: ^mut void);
__c__vkGetQueueCheckpointDataNV :: (_queue: VkQueue, _pCheckpointDataCount: ^mut uint32_t, _pCheckpointData: ^mut VkCheckpointDataNV);
__c__vkInitializePerformanceApiINTEL :: (ret: ^mut VkResult, _device: VkDevice, _pInitializeInfo: ^mut VkInitializePerformanceApiInfoINTEL);
__c__vkUninitializePerformanceApiINTEL :: (_device: VkDevice);
__c__vkCmdSetPerformanceMarkerINTEL :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkPerformanceMarkerInfoINTEL);
__c__vkCmdSetPerformanceStreamMarkerINTEL :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer, _pMarkerInfo: ^mut VkPerformanceStreamMarkerInfoINTEL);
__c__vkCmdSetPerformanceOverrideINTEL :: (ret: ^mut VkResult, _commandBuffer: VkCommandBuffer, _pOverrideInfo: ^mut VkPerformanceOverrideInfoINTEL);
__c__vkAcquirePerformanceConfigurationINTEL :: (ret: ^mut VkResult, _device: VkDevice, _pAcquireInfo: ^mut VkPerformanceConfigurationAcquireInfoINTEL, _pConfiguration: ^mut VkPerformanceConfigurationINTEL);
__c__vkReleasePerformanceConfigurationINTEL :: (ret: ^mut VkResult, _device: VkDevice, _configuration: VkPerformanceConfigurationINTEL);
__c__vkQueueSetPerformanceConfigurationINTEL :: (ret: ^mut VkResult, _queue: VkQueue, _configuration: VkPerformanceConfigurationINTEL);
__c__vkGetPerformanceParameterINTEL :: (ret: ^mut VkResult, _device: VkDevice, _parameter: VkPerformanceParameterTypeINTEL, _pValue: ^mut VkPerformanceValueINTEL);
__c__vkSetLocalDimmingAMD :: (_device: VkDevice, _swapChain: VkSwapchainKHR, _localDimmingEnable: VkBool32);
__c__vkGetBufferDeviceAddressEXT :: (ret: ^mut VkDeviceAddress, _device: VkDevice, _pInfo: ^mut VkBufferDeviceAddressInfo);
__c__vkGetPhysicalDeviceToolPropertiesEXT :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pToolCount: ^mut uint32_t, _pToolProperties: ^mut VkPhysicalDeviceToolPropertiesEXT);
__c__vkGetPhysicalDeviceCooperativeMatrixPropertiesNV :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pPropertyCount: ^mut uint32_t, _pProperties: ^mut VkCooperativeMatrixPropertiesNV);
__c__vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV :: (ret: ^mut VkResult, _physicalDevice: VkPhysicalDevice, _pCombinationCount: ^mut uint32_t, _pCombinations: ^mut VkFramebufferMixedSamplesCombinationNV);
__c__vkCreateHeadlessSurfaceEXT :: (ret: ^mut VkResult, _instance: VkInstance, _pCreateInfo: ^mut VkHeadlessSurfaceCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pSurface: ^mut VkSurfaceKHR);
__c__vkCmdSetLineStippleEXT :: (_commandBuffer: VkCommandBuffer, _lineStippleFactor: uint32_t, _lineStipplePattern: uint16_t);
__c__vkResetQueryPoolEXT :: (_device: VkDevice, _queryPool: VkQueryPool, _firstQuery: uint32_t, _queryCount: uint32_t);
__c__vkCmdSetCullModeEXT :: (_commandBuffer: VkCommandBuffer, _cullMode: VkCullModeFlags);
__c__vkCmdSetFrontFaceEXT :: (_commandBuffer: VkCommandBuffer, _frontFace: VkFrontFace);
__c__vkCmdSetPrimitiveTopologyEXT :: (_commandBuffer: VkCommandBuffer, _primitiveTopology: VkPrimitiveTopology);
__c__vkCmdSetViewportWithCountEXT :: (_commandBuffer: VkCommandBuffer, _viewportCount: uint32_t, _pViewports: ^mut VkViewport);
__c__vkCmdSetScissorWithCountEXT :: (_commandBuffer: VkCommandBuffer, _scissorCount: uint32_t, _pScissors: ^mut VkRect2D);
__c__vkCmdBindVertexBuffers2EXT :: (_commandBuffer: VkCommandBuffer, _firstBinding: uint32_t, _bindingCount: uint32_t, _pBuffers: ^mut VkBuffer, _pOffsets: ^mut VkDeviceSize, _pSizes: ^mut VkDeviceSize, _pStrides: ^mut VkDeviceSize);
__c__vkCmdSetDepthTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthTestEnable: VkBool32);
__c__vkCmdSetDepthWriteEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthWriteEnable: VkBool32);
__c__vkCmdSetDepthCompareOpEXT :: (_commandBuffer: VkCommandBuffer, _depthCompareOp: VkCompareOp);
__c__vkCmdSetDepthBoundsTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _depthBoundsTestEnable: VkBool32);
__c__vkCmdSetStencilTestEnableEXT :: (_commandBuffer: VkCommandBuffer, _stencilTestEnable: VkBool32);
__c__vkCmdSetStencilOpEXT :: (_commandBuffer: VkCommandBuffer, _faceMask: VkStencilFaceFlags, _failOp: VkStencilOp, _passOp: VkStencilOp, _depthFailOp: VkStencilOp, _compareOp: VkCompareOp);
__c__vkGetGeneratedCommandsMemoryRequirementsNV :: (_device: VkDevice, _pInfo: ^mut VkGeneratedCommandsMemoryRequirementsInfoNV, _pMemoryRequirements: ^mut VkMemoryRequirements2);
__c__vkCmdPreprocessGeneratedCommandsNV :: (_commandBuffer: VkCommandBuffer, _pGeneratedCommandsInfo: ^mut VkGeneratedCommandsInfoNV);
__c__vkCmdExecuteGeneratedCommandsNV :: (_commandBuffer: VkCommandBuffer, _isPreprocessed: VkBool32, _pGeneratedCommandsInfo: ^mut VkGeneratedCommandsInfoNV);
__c__vkCmdBindPipelineShaderGroupNV :: (_commandBuffer: VkCommandBuffer, _pipelineBindPoint: VkPipelineBindPoint, _pipeline: VkPipeline, _groupIndex: uint32_t);
__c__vkCreateIndirectCommandsLayoutNV :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkIndirectCommandsLayoutCreateInfoNV, _pAllocator: ^mut VkAllocationCallbacks, _pIndirectCommandsLayout: ^mut VkIndirectCommandsLayoutNV);
__c__vkDestroyIndirectCommandsLayoutNV :: (_device: VkDevice, _indirectCommandsLayout: VkIndirectCommandsLayoutNV, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkCreatePrivateDataSlotEXT :: (ret: ^mut VkResult, _device: VkDevice, _pCreateInfo: ^mut VkPrivateDataSlotCreateInfoEXT, _pAllocator: ^mut VkAllocationCallbacks, _pPrivateDataSlot: ^mut VkPrivateDataSlotEXT);
__c__vkDestroyPrivateDataSlotEXT :: (_device: VkDevice, _privateDataSlot: VkPrivateDataSlotEXT, _pAllocator: ^mut VkAllocationCallbacks);
__c__vkSetPrivateDataEXT :: (ret: ^mut VkResult, _device: VkDevice, _objectType: VkObjectType, _objectHandle: uint64_t, _privateDataSlot: VkPrivateDataSlotEXT, _data: uint64_t);
__c__vkGetPrivateDataEXT :: (_device: VkDevice, _objectType: VkObjectType, _objectHandle: uint64_t, _privateDataSlot: VkPrivateDataSlotEXT, _pData: ^mut uint64_t);
