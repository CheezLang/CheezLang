__UNKNOWN_8 :: struct #copy { _: [8]u8 = default }
__UNKNOWN_16 :: struct #copy { _: [16]u8 = default }

#lib("./lib/stb_binding.lib")
#export_scope

size_t :: u32
__u_char :: u8
__u_short :: u16
__u_int :: u32
__u_long :: u32
__int8_t :: i8
__uint8_t :: u8
__int16_t :: i16
__uint16_t :: u16
__int32_t :: i32
__uint32_t :: u32
__int64_t :: i32
__uint64_t :: u32
__quad_t :: i32
__u_quad_t :: u32
__intmax_t :: i32
__uintmax_t :: u32
__dev_t :: u32
__uid_t :: u32
__gid_t :: u32
__ino_t :: u32
__ino64_t :: u32
__mode_t :: u32
__nlink_t :: u32
__off_t :: i32
__off64_t :: i32
__pid_t :: i32
__fsid_t :: struct #copy {}
__clock_t :: i32
__rlim_t :: u32
__rlim64_t :: u32
__id_t :: u32
__time_t :: i32
__useconds_t :: u32
__suseconds_t :: i32
__daddr_t :: i32
__key_t :: i32
__clockid_t :: i32
__timer_t :: &void
__blksize_t :: i32
__blkcnt_t :: i32
__blkcnt64_t :: i32
__fsblkcnt_t :: u32
__fsblkcnt64_t :: u32
__fsfilcnt_t :: u32
__fsfilcnt64_t :: u32
__fsword_t :: i32
__ssize_t :: i32
__syscall_slong_t :: i32
__syscall_ulong_t :: u32
__loff_t :: __off64_t
__caddr_t :: &char8
__intptr_t :: i32
__socklen_t :: u32
__sig_atomic_t :: i32
__FILE :: struct #copy {}
FILE :: struct #copy {}
__mbstate_t :: struct #copy {}
_G_fpos_t :: struct #copy {}
_G_fpos64_t :: struct #copy {}
va_list :: __builtin_va_list
__gnuc_va_list :: __builtin_va_list
_IO_lock_t :: void
_IO_FILE :: struct #copy {}
__io_read_fn :: fn(&void, &char8, size_t) -> __ssize_t
__io_write_fn :: fn(&void, &char8, size_t) -> __ssize_t
__io_seek_fn :: fn(&void, &__off64_t, i32) -> i32
__io_close_fn :: fn(&void) -> i32
va_list :: __gnuc_va_list
off_t :: __off_t
ssize_t :: __ssize_t
fpos_t :: _G_fpos_t
_Float32 :: f32
_Float64 :: f64
_Float32x :: f64
_Float64x :: __UNKNOWN_8
div_t :: struct #copy {}
ldiv_t :: struct #copy {}
lldiv_t :: struct #copy {}
u_char :: __u_char
u_short :: __u_short
u_int :: __u_int
u_long :: __u_long
quad_t :: __quad_t
u_quad_t :: __u_quad_t
fsid_t :: __fsid_t
loff_t :: __loff_t
ino_t :: __ino_t
dev_t :: __dev_t
gid_t :: __gid_t
mode_t :: __mode_t
nlink_t :: __nlink_t
uid_t :: __uid_t
pid_t :: __pid_t
id_t :: __id_t
daddr_t :: __daddr_t
caddr_t :: __caddr_t
key_t :: __key_t
clock_t :: __clock_t
clockid_t :: __clockid_t
time_t :: __time_t
timer_t :: __timer_t
ulong :: u32
ushort :: u16
uint :: u32
int8_t :: __int8_t
int16_t :: __int16_t
int32_t :: __int32_t
int64_t :: __int64_t
u_int8_t :: u8
u_int16_t :: u16
u_int32_t :: u32
u_int64_t :: u64
register_t :: i64
__sigset_t :: struct #copy {}
sigset_t :: __sigset_t
suseconds_t :: __suseconds_t
__fd_mask :: i32
fd_set :: struct #copy {}
fd_mask :: __fd_mask
blksize_t :: __blksize_t
blkcnt_t :: __blkcnt_t
fsblkcnt_t :: __fsblkcnt_t
fsfilcnt_t :: __fsfilcnt_t
__pthread_list_t :: struct #copy {}
pthread_t :: u32
pthread_mutexattr_t :: 
pthread_condattr_t :: 
pthread_key_t :: u32
pthread_once_t :: i32
pthread_attr_t :: pthread_attr_t
pthread_mutex_t :: 
pthread_cond_t :: 
pthread_rwlock_t :: 
pthread_rwlockattr_t :: 
pthread_spinlock_t :: i32
pthread_barrier_t :: 
pthread_barrierattr_t :: 
__compar_fn_t :: fn(&void, &void) -> i32
stbi_uc :: u8
stbi_us :: u16
stbi_io_callbacks :: struct #copy {}
ptrdiff_t :: i32
max_align_t :: struct #copy {}
__locale_t :: &__locale_struct
locale_t :: __locale_t
float_t :: f32
double_t :: f64
uint8_t :: __uint8_t
uint16_t :: __uint16_t
uint32_t :: __uint32_t
uint64_t :: __uint64_t
int_least8_t :: i8
int_least16_t :: i16
int_least32_t :: i32
int_least64_t :: i32
uint_least8_t :: u8
uint_least16_t :: u16
uint_least32_t :: u32
uint_least64_t :: u32
int_fast8_t :: i8
int_fast16_t :: i32
int_fast32_t :: i32
int_fast64_t :: i32
uint_fast8_t :: u8
uint_fast16_t :: u32
uint_fast32_t :: u32
uint_fast64_t :: u32
intptr_t :: i32
uintptr_t :: u32
intmax_t :: __intmax_t
uintmax_t :: __uintmax_t
stbi__uint16 :: uint16_t
stbi__int16 :: int16_t
stbi__uint32 :: uint32_t
stbi__int32 :: int32_t
validate_uint32 :: [1]u8
__m64 :: __UNKNOWN_8
__v1di :: __UNKNOWN_8
__v2si :: __UNKNOWN_8
__v4hi :: __UNKNOWN_8
__v8qi :: __UNKNOWN_8
__v4si :: __UNKNOWN_16
__v4sf :: __UNKNOWN_16
__m128 :: __UNKNOWN_16
__m128_u :: __UNKNOWN_16
__v4su :: __UNKNOWN_16
__m128d :: __UNKNOWN_16
__m128i :: __UNKNOWN_16
__m128d_u :: __UNKNOWN_16
__m128i_u :: __UNKNOWN_16
__v2df :: __UNKNOWN_16
__v2di :: __UNKNOWN_16
__v8hi :: __UNKNOWN_16
__v16qi :: __UNKNOWN_16
__v2du :: __UNKNOWN_16
__v8hu :: __UNKNOWN_16
__v16qu :: __UNKNOWN_16
__v16qs :: __UNKNOWN_16
stbi__context :: struct #copy {}
stbi__result_info :: struct #copy {}
stbi__huffman :: struct #copy {}
stbi__jpeg :: struct #copy {}
resample_row_func :: fn(&stbi_uc, &stbi_uc, &stbi_uc, i32, i32) -> &stbi_uc
stbi__resample :: struct #copy {}
stbi__zhuffman :: struct #copy {}
stbi__zbuf :: struct #copy {}
stbi__pngchunk :: struct #copy {}
stbi__png :: struct #copy {}
stbi__bmp_data :: struct #copy {}
stbi__pic_packet :: struct #copy {}
stbi__gif_lzw :: struct #copy {}
stbi__gif :: struct #copy {}
__codecvt_result :: enum #copy #repr("C") #tag_type(i32) {
    _codecvt_ok      = 0x0
    _codecvt_partial = 0x1
    _codecvt_error   = 0x2
    _codecvt_noconv  = 0x3
}
_IO_marker :: struct #copy {
    _next : &_IO_marker = default
    _sbuf : &_IO_FILE = default
    _pos : i32 = default
}
_IO_FILE :: struct #copy {
    _flags : i32 = default
    _IO_read_ptr : &char8 = default
    _IO_read_end : &char8 = default
    _IO_read_base : &char8 = default
    _IO_write_base : &char8 = default
    _IO_write_ptr : &char8 = default
    _IO_write_end : &char8 = default
    _IO_buf_base : &char8 = default
    _IO_buf_end : &char8 = default
    _IO_save_base : &char8 = default
    _IO_backup_base : &char8 = default
    _IO_save_end : &char8 = default
    _markers : &_IO_marker = default
    _chain : &_IO_FILE = default
    _fileno : i32 = default
    _flags2 : i32 = default
    _old_offset : __off_t = default
    _cur_column : u16 = default
    _vtable_offset : i8 = default
    _shortbuf : [1]char8 = default
    _lock : &_IO_lock_t = default
    _offset : __off64_t = default
    __pad1 : &void = default
    __pad2 : &void = default
    __pad3 : &void = default
    __pad4 : &void = default
    __pad5 : size_t = default
    _mode : i32 = default
    _unused2 : [20]char8 = default
}
timeval :: struct #copy {
    tv_sec : __time_t = default
    tv_usec : __suseconds_t = default
}
timespec :: struct #copy {
    tv_sec : __time_t = default
    tv_nsec : __syscall_slong_t = default
}
__pthread_rwlock_arch_t :: struct #copy {
    __readers : u32 = default
    __writers : u32 = default
    __wrphase_futex : u32 = default
    __writers_futex : u32 = default
    __pad3 : u32 = default
    __pad4 : u32 = default
    __cur_writer : i32 = default
    __shared : i32 = default
    __rwelision : i8 = default
    __pad1 : [7]u8 = default
    __pad2 : u32 = default
    __flags : u32 = default
}
__pthread_internal_list :: struct #copy {
    __prev : &__pthread_internal_list = default
    __next : &__pthread_internal_list = default
}
__pthread_mutex_s :: struct #copy {
    __lock : i32 = default
    __count : u32 = default
    __owner : i32 = default
    __nusers : u32 = default
    __kind : i32 = default
    __spins : i16 = default
    __elision : i16 = default
    __list : __pthread_list_t = default
}
__pthread_cond_s :: struct #copy {
    __g_refs : [2]u32 = default
    __g_size : [2]u32 = default
    __g1_orig_size : u32 = default
    __wrefs : u32 = default
    __g_signals : [2]u32 = default
}
random_data :: struct #copy {
    fptr : &int32_t = default
    rptr : &int32_t = default
    state : &int32_t = default
    rand_type : i32 = default
    rand_deg : i32 = default
    rand_sep : i32 = default
    end_ptr : &int32_t = default
}
drand48_data :: struct #copy {
    __x : [3]u16 = default
    __old_x : [3]u16 = default
    __c : u16 = default
    __init : u16 = default
    __a : u64 = default
}
__locale_struct :: struct #copy {
    __locales : [13]&__locale_data = default
    __ctype_b : &u16 = default
    __ctype_tolower : &i32 = default
    __ctype_toupper : &i32 = default
    __names : [13]&char8 = default
}
__underflow :: (_0: &_IO_FILE) -> i32 {
    result : i32 = default
    __c____underflow(&result, _0)
    return result
}
__uflow :: (_0: &_IO_FILE) -> i32 {
    result : i32 = default
    __c____uflow(&result, _0)
    return result
}
__overflow :: (_0: &_IO_FILE, _1: i32) -> i32 {
    result : i32 = default
    __c____overflow(&result, _0, _1)
    return result
}
_IO_getc :: (___fp: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_getc(&result, ___fp)
    return result
}
_IO_putc :: (___c: i32, ___fp: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_putc(&result, ___c, ___fp)
    return result
}
_IO_feof :: (___fp: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_feof(&result, ___fp)
    return result
}
_IO_ferror :: (___fp: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_ferror(&result, ___fp)
    return result
}
_IO_peekc_locked :: (___fp: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_peekc_locked(&result, ___fp)
    return result
}
_IO_flockfile :: (_0: &_IO_FILE) {
    __c___IO_flockfile(_0)
}
_IO_funlockfile :: (_0: &_IO_FILE) {
    __c___IO_funlockfile(_0)
}
_IO_ftrylockfile :: (_0: &_IO_FILE) -> i32 {
    result : i32 = default
    __c___IO_ftrylockfile(&result, _0)
    return result
}
_IO_vfscanf :: (_0: &_IO_FILE, _1: &char8, _2: __gnuc_va_list, _3: &i32) -> i32 {
    result : i32 = default
    __c___IO_vfscanf(&result, _0, _1, _2, _3)
    return result
}
_IO_vfprintf :: (_0: &_IO_FILE, _1: &char8, _2: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c___IO_vfprintf(&result, _0, _1, _2)
    return result
}
_IO_padn :: (_0: &_IO_FILE, _1: i32, _2: __ssize_t) -> __ssize_t {
    result : __ssize_t = default
    __c___IO_padn(&result, _0, _1, _2)
    return result
}
_IO_sgetn :: (_0: &_IO_FILE, _1: &void, _2: size_t) -> size_t {
    result : size_t = default
    __c___IO_sgetn(&result, _0, _1, _2)
    return result
}
_IO_seekoff :: (_0: &_IO_FILE, _1: __off64_t, _2: i32, _3: i32) -> __off64_t {
    result : __off64_t = default
    __c___IO_seekoff(&result, _0, _1, _2, _3)
    return result
}
_IO_seekpos :: (_0: &_IO_FILE, _1: __off64_t, _2: i32) -> __off64_t {
    result : __off64_t = default
    __c___IO_seekpos(&result, _0, _1, _2)
    return result
}
_IO_free_backup_area :: (_0: &_IO_FILE) {
    __c___IO_free_backup_area(_0)
}
remove :: (___filename: &char8) -> i32 {
    result : i32 = default
    __c__remove(&result, ___filename)
    return result
}
rename :: (___old: &char8, ___new: &char8) -> i32 {
    result : i32 = default
    __c__rename(&result, ___old, ___new)
    return result
}
renameat :: (___oldfd: i32, ___old: &char8, ___newfd: i32, ___new: &char8) -> i32 {
    result : i32 = default
    __c__renameat(&result, ___oldfd, ___old, ___newfd, ___new)
    return result
}
tmpfile :: () -> &FILE {
    result : &FILE = default
    __c__tmpfile(&result)
    return result
}
tmpnam :: (___s: &char8) -> &char8 {
    result : &char8 = default
    __c__tmpnam(&result, ___s)
    return result
}
tmpnam_r :: (___s: &char8) -> &char8 {
    result : &char8 = default
    __c__tmpnam_r(&result, ___s)
    return result
}
tempnam :: (___dir: &char8, ___pfx: &char8) -> &char8 {
    result : &char8 = default
    __c__tempnam(&result, ___dir, ___pfx)
    return result
}
fclose :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fclose(&result, ___stream)
    return result
}
fflush :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fflush(&result, ___stream)
    return result
}
fflush_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fflush_unlocked(&result, ___stream)
    return result
}
fopen :: (___filename: &char8, ___modes: &char8) -> &FILE {
    result : &FILE = default
    __c__fopen(&result, ___filename, ___modes)
    return result
}
freopen :: (___filename: &char8, ___modes: &char8, ___stream: &FILE) -> &FILE {
    result : &FILE = default
    __c__freopen(&result, ___filename, ___modes, ___stream)
    return result
}
fdopen :: (___fd: i32, ___modes: &char8) -> &FILE {
    result : &FILE = default
    __c__fdopen(&result, ___fd, ___modes)
    return result
}
fmemopen :: (___s: &void, ___len: size_t, ___modes: &char8) -> &FILE {
    result : &FILE = default
    __c__fmemopen(&result, ___s, ___len, ___modes)
    return result
}
open_memstream :: (___bufloc: &&char8, ___sizeloc: &size_t) -> &FILE {
    result : &FILE = default
    __c__open_memstream(&result, ___bufloc, ___sizeloc)
    return result
}
setbuf :: (___stream: &FILE, ___buf: &char8) {
    __c__setbuf(___stream, ___buf)
}
setvbuf :: (___stream: &FILE, ___buf: &char8, ___modes: i32, ___n: size_t) -> i32 {
    result : i32 = default
    __c__setvbuf(&result, ___stream, ___buf, ___modes, ___n)
    return result
}
setbuffer :: (___stream: &FILE, ___buf: &char8, ___size: size_t) {
    __c__setbuffer(___stream, ___buf, ___size)
}
setlinebuf :: (___stream: &FILE) {
    __c__setlinebuf(___stream)
}
fprintf :: (___stream: &FILE, ___format: &char8) -> i32 {
    result : i32 = default
    __c__fprintf(&result, ___stream, ___format)
    return result
}
printf :: (___format: &char8) -> i32 {
    result : i32 = default
    __c__printf(&result, ___format)
    return result
}
sprintf :: (___s: &char8, ___format: &char8) -> i32 {
    result : i32 = default
    __c__sprintf(&result, ___s, ___format)
    return result
}
vfprintf :: (___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vfprintf(&result, ___s, ___format, ___arg)
    return result
}
vprintf :: (___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vprintf(&result, ___format, ___arg)
    return result
}
vsprintf :: (___s: &char8, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vsprintf(&result, ___s, ___format, ___arg)
    return result
}
snprintf :: (___s: &char8, ___maxlen: size_t, ___format: &char8) -> i32 {
    result : i32 = default
    __c__snprintf(&result, ___s, ___maxlen, ___format)
    return result
}
vsnprintf :: (___s: &char8, ___maxlen: size_t, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vsnprintf(&result, ___s, ___maxlen, ___format, ___arg)
    return result
}
vdprintf :: (___fd: i32, ___fmt: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vdprintf(&result, ___fd, ___fmt, ___arg)
    return result
}
dprintf :: (___fd: i32, ___fmt: &char8) -> i32 {
    result : i32 = default
    __c__dprintf(&result, ___fd, ___fmt)
    return result
}
fscanf :: (___stream: &FILE, ___format: &char8) -> i32 {
    result : i32 = default
    __c__fscanf(&result, ___stream, ___format)
    return result
}
scanf :: (___format: &char8) -> i32 {
    result : i32 = default
    __c__scanf(&result, ___format)
    return result
}
sscanf :: (___s: &char8, ___format: &char8) -> i32 {
    result : i32 = default
    __c__sscanf(&result, ___s, ___format)
    return result
}
fscanf_2 :: (___stream: &FILE, ___format: &char8) -> i32 {
    result : i32 = default
    __c__fscanf_2(&result, ___stream, ___format)
    return result
}
scanf_2 :: (___format: &char8) -> i32 {
    result : i32 = default
    __c__scanf_2(&result, ___format)
    return result
}
sscanf_2 :: (___s: &char8, ___format: &char8) -> i32 {
    result : i32 = default
    __c__sscanf_2(&result, ___s, ___format)
    return result
}
vfscanf :: (___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vfscanf(&result, ___s, ___format, ___arg)
    return result
}
vscanf :: (___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vscanf(&result, ___format, ___arg)
    return result
}
vsscanf :: (___s: &char8, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vsscanf(&result, ___s, ___format, ___arg)
    return result
}
vfscanf_2 :: (___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vfscanf_2(&result, ___s, ___format, ___arg)
    return result
}
vscanf_2 :: (___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vscanf_2(&result, ___format, ___arg)
    return result
}
vsscanf_2 :: (___s: &char8, ___format: &char8, ___arg: __gnuc_va_list) -> i32 {
    result : i32 = default
    __c__vsscanf_2(&result, ___s, ___format, ___arg)
    return result
}
fgetc :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fgetc(&result, ___stream)
    return result
}
getc :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__getc(&result, ___stream)
    return result
}
getchar :: () -> i32 {
    result : i32 = default
    __c__getchar(&result)
    return result
}
getc_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__getc_unlocked(&result, ___stream)
    return result
}
getchar_unlocked :: () -> i32 {
    result : i32 = default
    __c__getchar_unlocked(&result)
    return result
}
fgetc_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fgetc_unlocked(&result, ___stream)
    return result
}
fputc :: (___c: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fputc(&result, ___c, ___stream)
    return result
}
putc :: (___c: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__putc(&result, ___c, ___stream)
    return result
}
putchar :: (___c: i32) -> i32 {
    result : i32 = default
    __c__putchar(&result, ___c)
    return result
}
fputc_unlocked :: (___c: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fputc_unlocked(&result, ___c, ___stream)
    return result
}
putc_unlocked :: (___c: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__putc_unlocked(&result, ___c, ___stream)
    return result
}
putchar_unlocked :: (___c: i32) -> i32 {
    result : i32 = default
    __c__putchar_unlocked(&result, ___c)
    return result
}
getw :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__getw(&result, ___stream)
    return result
}
putw :: (___w: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__putw(&result, ___w, ___stream)
    return result
}
fgets :: (___s: &char8, ___n: i32, ___stream: &FILE) -> &char8 {
    result : &char8 = default
    __c__fgets(&result, ___s, ___n, ___stream)
    return result
}
__getdelim :: (___lineptr: &&char8, ___n: &size_t, ___delimiter: i32, ___stream: &FILE) -> __ssize_t {
    result : __ssize_t = default
    __c____getdelim(&result, ___lineptr, ___n, ___delimiter, ___stream)
    return result
}
getdelim :: (___lineptr: &&char8, ___n: &size_t, ___delimiter: i32, ___stream: &FILE) -> __ssize_t {
    result : __ssize_t = default
    __c__getdelim(&result, ___lineptr, ___n, ___delimiter, ___stream)
    return result
}
getline :: (___lineptr: &&char8, ___n: &size_t, ___stream: &FILE) -> __ssize_t {
    result : __ssize_t = default
    __c__getline(&result, ___lineptr, ___n, ___stream)
    return result
}
fputs :: (___s: &char8, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fputs(&result, ___s, ___stream)
    return result
}
puts :: (___s: &char8) -> i32 {
    result : i32 = default
    __c__puts(&result, ___s)
    return result
}
ungetc :: (___c: i32, ___stream: &FILE) -> i32 {
    result : i32 = default
    __c__ungetc(&result, ___c, ___stream)
    return result
}
fread :: (___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE) -> size_t {
    result : size_t = default
    __c__fread(&result, ___ptr, ___size, ___n, ___stream)
    return result
}
fwrite :: (___ptr: &void, ___size: size_t, ___n: size_t, ___s: &FILE) -> size_t {
    result : size_t = default
    __c__fwrite(&result, ___ptr, ___size, ___n, ___s)
    return result
}
fread_unlocked :: (___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE) -> size_t {
    result : size_t = default
    __c__fread_unlocked(&result, ___ptr, ___size, ___n, ___stream)
    return result
}
fwrite_unlocked :: (___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE) -> size_t {
    result : size_t = default
    __c__fwrite_unlocked(&result, ___ptr, ___size, ___n, ___stream)
    return result
}
fseek :: (___stream: &FILE, ___off: i32, ___whence: i32) -> i32 {
    result : i32 = default
    __c__fseek(&result, ___stream, ___off, ___whence)
    return result
}
ftell :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__ftell(&result, ___stream)
    return result
}
rewind :: (___stream: &FILE) {
    __c__rewind(___stream)
}
fseeko :: (___stream: &FILE, ___off: __off_t, ___whence: i32) -> i32 {
    result : i32 = default
    __c__fseeko(&result, ___stream, ___off, ___whence)
    return result
}
ftello :: (___stream: &FILE) -> __off_t {
    result : __off_t = default
    __c__ftello(&result, ___stream)
    return result
}
fgetpos :: (___stream: &FILE, ___pos: &fpos_t) -> i32 {
    result : i32 = default
    __c__fgetpos(&result, ___stream, ___pos)
    return result
}
fsetpos :: (___stream: &FILE, ___pos: &fpos_t) -> i32 {
    result : i32 = default
    __c__fsetpos(&result, ___stream, ___pos)
    return result
}
clearerr :: (___stream: &FILE) {
    __c__clearerr(___stream)
}
feof :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__feof(&result, ___stream)
    return result
}
ferror :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__ferror(&result, ___stream)
    return result
}
clearerr_unlocked :: (___stream: &FILE) {
    __c__clearerr_unlocked(___stream)
}
feof_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__feof_unlocked(&result, ___stream)
    return result
}
ferror_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__ferror_unlocked(&result, ___stream)
    return result
}
perror :: (___s: &char8) {
    __c__perror(___s)
}
fileno :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fileno(&result, ___stream)
    return result
}
fileno_unlocked :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__fileno_unlocked(&result, ___stream)
    return result
}
popen :: (___command: &char8, ___modes: &char8) -> &FILE {
    result : &FILE = default
    __c__popen(&result, ___command, ___modes)
    return result
}
pclose :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__pclose(&result, ___stream)
    return result
}
ctermid :: (___s: &char8) -> &char8 {
    result : &char8 = default
    __c__ctermid(&result, ___s)
    return result
}
flockfile :: (___stream: &FILE) {
    __c__flockfile(___stream)
}
ftrylockfile :: (___stream: &FILE) -> i32 {
    result : i32 = default
    __c__ftrylockfile(&result, ___stream)
    return result
}
funlockfile :: (___stream: &FILE) {
    __c__funlockfile(___stream)
}
__ctype_get_mb_cur_max :: () -> size_t {
    result : size_t = default
    __c____ctype_get_mb_cur_max(&result)
    return result
}
atof :: (___nptr: &char8) -> f64 {
    result : f64 = default
    __c__atof(&result, ___nptr)
    return result
}
atoi :: (___nptr: &char8) -> i32 {
    result : i32 = default
    __c__atoi(&result, ___nptr)
    return result
}
atol :: (___nptr: &char8) -> i32 {
    result : i32 = default
    __c__atol(&result, ___nptr)
    return result
}
atoll :: (___nptr: &char8) -> i64 {
    result : i64 = default
    __c__atoll(&result, ___nptr)
    return result
}
strtod :: (___nptr: &char8, ___endptr: &&char8) -> f64 {
    result : f64 = default
    __c__strtod(&result, ___nptr, ___endptr)
    return result
}
strtof :: (___nptr: &char8, ___endptr: &&char8) -> f32 {
    result : f32 = default
    __c__strtof(&result, ___nptr, ___endptr)
    return result
}
strtold :: (___nptr: &char8, ___endptr: &&char8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__strtold(&result, ___nptr, ___endptr)
    return result
}
strtol :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> i32 {
    result : i32 = default
    __c__strtol(&result, ___nptr, ___endptr, ___base)
    return result
}
strtoul :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> u32 {
    result : u32 = default
    __c__strtoul(&result, ___nptr, ___endptr, ___base)
    return result
}
strtoq :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> i64 {
    result : i64 = default
    __c__strtoq(&result, ___nptr, ___endptr, ___base)
    return result
}
strtouq :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> u64 {
    result : u64 = default
    __c__strtouq(&result, ___nptr, ___endptr, ___base)
    return result
}
strtoll :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> i64 {
    result : i64 = default
    __c__strtoll(&result, ___nptr, ___endptr, ___base)
    return result
}
strtoull :: (___nptr: &char8, ___endptr: &&char8, ___base: i32) -> u64 {
    result : u64 = default
    __c__strtoull(&result, ___nptr, ___endptr, ___base)
    return result
}
l64a :: (___n: i32) -> &char8 {
    result : &char8 = default
    __c__l64a(&result, ___n)
    return result
}
a64l :: (___s: &char8) -> i32 {
    result : i32 = default
    __c__a64l(&result, ___s)
    return result
}
select :: (___nfds: i32, ___readfds: &fd_set, ___writefds: &fd_set, ___exceptfds: &fd_set, ___timeout: &timeval) -> i32 {
    result : i32 = default
    __c__select(&result, ___nfds, ___readfds, ___writefds, ___exceptfds, ___timeout)
    return result
}
pselect :: (___nfds: i32, ___readfds: &fd_set, ___writefds: &fd_set, ___exceptfds: &fd_set, ___timeout: &timespec, ___sigmask: &__sigset_t) -> i32 {
    result : i32 = default
    __c__pselect(&result, ___nfds, ___readfds, ___writefds, ___exceptfds, ___timeout, ___sigmask)
    return result
}
gnu_dev_major :: (___dev: __dev_t) -> u32 {
    result : u32 = default
    __c__gnu_dev_major(&result, ___dev)
    return result
}
gnu_dev_minor :: (___dev: __dev_t) -> u32 {
    result : u32 = default
    __c__gnu_dev_minor(&result, ___dev)
    return result
}
gnu_dev_makedev :: (___major: u32, ___minor: u32) -> __dev_t {
    result : __dev_t = default
    __c__gnu_dev_makedev(&result, ___major, ___minor)
    return result
}
random :: () -> i32 {
    result : i32 = default
    __c__random(&result)
    return result
}
srandom :: (___seed: u32) {
    __c__srandom(___seed)
}
initstate :: (___seed: u32, ___statebuf: &char8, ___statelen: size_t) -> &char8 {
    result : &char8 = default
    __c__initstate(&result, ___seed, ___statebuf, ___statelen)
    return result
}
setstate :: (___statebuf: &char8) -> &char8 {
    result : &char8 = default
    __c__setstate(&result, ___statebuf)
    return result
}
random_r :: (___buf: &random_data, ___result: &int32_t) -> i32 {
    result : i32 = default
    __c__random_r(&result, ___buf, ___result)
    return result
}
srandom_r :: (___seed: u32, ___buf: &random_data) -> i32 {
    result : i32 = default
    __c__srandom_r(&result, ___seed, ___buf)
    return result
}
initstate_r :: (___seed: u32, ___statebuf: &char8, ___statelen: size_t, ___buf: &random_data) -> i32 {
    result : i32 = default
    __c__initstate_r(&result, ___seed, ___statebuf, ___statelen, ___buf)
    return result
}
setstate_r :: (___statebuf: &char8, ___buf: &random_data) -> i32 {
    result : i32 = default
    __c__setstate_r(&result, ___statebuf, ___buf)
    return result
}
rand :: () -> i32 {
    result : i32 = default
    __c__rand(&result)
    return result
}
srand :: (___seed: u32) {
    __c__srand(___seed)
}
rand_r :: (___seed: &u32) -> i32 {
    result : i32 = default
    __c__rand_r(&result, ___seed)
    return result
}
drand48 :: () -> f64 {
    result : f64 = default
    __c__drand48(&result)
    return result
}
erand48 :: (___xsubi: &u16) -> f64 {
    result : f64 = default
    __c__erand48(&result, ___xsubi)
    return result
}
lrand48 :: () -> i32 {
    result : i32 = default
    __c__lrand48(&result)
    return result
}
nrand48 :: (___xsubi: &u16) -> i32 {
    result : i32 = default
    __c__nrand48(&result, ___xsubi)
    return result
}
mrand48 :: () -> i32 {
    result : i32 = default
    __c__mrand48(&result)
    return result
}
jrand48 :: (___xsubi: &u16) -> i32 {
    result : i32 = default
    __c__jrand48(&result, ___xsubi)
    return result
}
srand48 :: (___seedval: i32) {
    __c__srand48(___seedval)
}
seed48 :: (___seed16v: &u16) -> &u16 {
    result : &u16 = default
    __c__seed48(&result, ___seed16v)
    return result
}
lcong48 :: (___param: &u16) {
    __c__lcong48(___param)
}
drand48_r :: (___buffer: &drand48_data, ___result: &f64) -> i32 {
    result : i32 = default
    __c__drand48_r(&result, ___buffer, ___result)
    return result
}
erand48_r :: (___xsubi: &u16, ___buffer: &drand48_data, ___result: &f64) -> i32 {
    result : i32 = default
    __c__erand48_r(&result, ___xsubi, ___buffer, ___result)
    return result
}
lrand48_r :: (___buffer: &drand48_data, ___result: &i32) -> i32 {
    result : i32 = default
    __c__lrand48_r(&result, ___buffer, ___result)
    return result
}
nrand48_r :: (___xsubi: &u16, ___buffer: &drand48_data, ___result: &i32) -> i32 {
    result : i32 = default
    __c__nrand48_r(&result, ___xsubi, ___buffer, ___result)
    return result
}
mrand48_r :: (___buffer: &drand48_data, ___result: &i32) -> i32 {
    result : i32 = default
    __c__mrand48_r(&result, ___buffer, ___result)
    return result
}
jrand48_r :: (___xsubi: &u16, ___buffer: &drand48_data, ___result: &i32) -> i32 {
    result : i32 = default
    __c__jrand48_r(&result, ___xsubi, ___buffer, ___result)
    return result
}
srand48_r :: (___seedval: i32, ___buffer: &drand48_data) -> i32 {
    result : i32 = default
    __c__srand48_r(&result, ___seedval, ___buffer)
    return result
}
seed48_r :: (___seed16v: &u16, ___buffer: &drand48_data) -> i32 {
    result : i32 = default
    __c__seed48_r(&result, ___seed16v, ___buffer)
    return result
}
lcong48_r :: (___param: &u16, ___buffer: &drand48_data) -> i32 {
    result : i32 = default
    __c__lcong48_r(&result, ___param, ___buffer)
    return result
}
malloc :: (___size: size_t) -> &void {
    result : &void = default
    __c__malloc(&result, ___size)
    return result
}
calloc :: (___nmemb: size_t, ___size: size_t) -> &void {
    result : &void = default
    __c__calloc(&result, ___nmemb, ___size)
    return result
}
realloc :: (___ptr: &void, ___size: size_t) -> &void {
    result : &void = default
    __c__realloc(&result, ___ptr, ___size)
    return result
}
free :: (___ptr: &void) {
    __c__free(___ptr)
}
alloca :: (___size: size_t) -> &void {
    result : &void = default
    __c__alloca(&result, ___size)
    return result
}
valloc :: (___size: size_t) -> &void {
    result : &void = default
    __c__valloc(&result, ___size)
    return result
}
posix_memalign :: (___memptr: &&void, ___alignment: size_t, ___size: size_t) -> i32 {
    result : i32 = default
    __c__posix_memalign(&result, ___memptr, ___alignment, ___size)
    return result
}
aligned_alloc :: (___alignment: size_t, ___size: size_t) -> &void {
    result : &void = default
    __c__aligned_alloc(&result, ___alignment, ___size)
    return result
}
abort :: () {
    __c__abort()
}
atexit :: (___func: fn() -> void) -> i32 {
    result : i32 = default
    __c__atexit(&result, ___func)
    return result
}
at_quick_exit :: (___func: fn() -> void) -> i32 {
    result : i32 = default
    __c__at_quick_exit(&result, ___func)
    return result
}
on_exit :: (___func: fn(i32, &void) -> void, ___arg: &void) -> i32 {
    result : i32 = default
    __c__on_exit(&result, ___func, ___arg)
    return result
}
exit :: (___status: i32) {
    __c__exit(___status)
}
quick_exit :: (___status: i32) {
    __c__quick_exit(___status)
}
_Exit :: (___status: i32) {
    __c___Exit(___status)
}
getenv :: (___name: &char8) -> &char8 {
    result : &char8 = default
    __c__getenv(&result, ___name)
    return result
}
putenv :: (___string: &char8) -> i32 {
    result : i32 = default
    __c__putenv(&result, ___string)
    return result
}
setenv :: (___name: &char8, ___value: &char8, ___replace: i32) -> i32 {
    result : i32 = default
    __c__setenv(&result, ___name, ___value, ___replace)
    return result
}
unsetenv :: (___name: &char8) -> i32 {
    result : i32 = default
    __c__unsetenv(&result, ___name)
    return result
}
clearenv :: () -> i32 {
    result : i32 = default
    __c__clearenv(&result)
    return result
}
mktemp :: (___template: &char8) -> &char8 {
    result : &char8 = default
    __c__mktemp(&result, ___template)
    return result
}
mkstemp :: (___template: &char8) -> i32 {
    result : i32 = default
    __c__mkstemp(&result, ___template)
    return result
}
mkstemps :: (___template: &char8, ___suffixlen: i32) -> i32 {
    result : i32 = default
    __c__mkstemps(&result, ___template, ___suffixlen)
    return result
}
mkdtemp :: (___template: &char8) -> &char8 {
    result : &char8 = default
    __c__mkdtemp(&result, ___template)
    return result
}
system :: (___command: &char8) -> i32 {
    result : i32 = default
    __c__system(&result, ___command)
    return result
}
realpath :: (___name: &char8, ___resolved: &char8) -> &char8 {
    result : &char8 = default
    __c__realpath(&result, ___name, ___resolved)
    return result
}
bsearch :: (___key: &void, ___base: &void, ___nmemb: size_t, ___size: size_t, ___compar: __compar_fn_t) -> &void {
    result : &void = default
    __c__bsearch(&result, ___key, ___base, ___nmemb, ___size, ___compar)
    return result
}
qsort :: (___base: &void, ___nmemb: size_t, ___size: size_t, ___compar: __compar_fn_t) {
    __c__qsort(___base, ___nmemb, ___size, ___compar)
}
abs :: (___x: i32) -> i32 {
    result : i32 = default
    __c__abs(&result, ___x)
    return result
}
labs :: (___x: i32) -> i32 {
    result : i32 = default
    __c__labs(&result, ___x)
    return result
}
llabs :: (___x: i64) -> i64 {
    result : i64 = default
    __c__llabs(&result, ___x)
    return result
}
div :: (___numer: i32, ___denom: i32) -> div_t {
    result : div_t = default
    __c__div(&result, ___numer, ___denom)
    return result
}
ldiv :: (___numer: i32, ___denom: i32) -> ldiv_t {
    result : ldiv_t = default
    __c__ldiv(&result, ___numer, ___denom)
    return result
}
lldiv :: (___numer: i64, ___denom: i64) -> lldiv_t {
    result : lldiv_t = default
    __c__lldiv(&result, ___numer, ___denom)
    return result
}
ecvt :: (___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32) -> &char8 {
    result : &char8 = default
    __c__ecvt(&result, ___value, ___ndigit, ___decpt, ___sign)
    return result
}
fcvt :: (___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32) -> &char8 {
    result : &char8 = default
    __c__fcvt(&result, ___value, ___ndigit, ___decpt, ___sign)
    return result
}
gcvt :: (___value: f64, ___ndigit: i32, ___buf: &char8) -> &char8 {
    result : &char8 = default
    __c__gcvt(&result, ___value, ___ndigit, ___buf)
    return result
}
qecvt :: (___value: __UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32) -> &char8 {
    result : &char8 = default
    __c__qecvt(&result, &___value, ___ndigit, ___decpt, ___sign)
    return result
}
qfcvt :: (___value: __UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32) -> &char8 {
    result : &char8 = default
    __c__qfcvt(&result, &___value, ___ndigit, ___decpt, ___sign)
    return result
}
qgcvt :: (___value: __UNKNOWN_8, ___ndigit: i32, ___buf: &char8) -> &char8 {
    result : &char8 = default
    __c__qgcvt(&result, &___value, ___ndigit, ___buf)
    return result
}
ecvt_r :: (___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t) -> i32 {
    result : i32 = default
    __c__ecvt_r(&result, ___value, ___ndigit, ___decpt, ___sign, ___buf, ___len)
    return result
}
fcvt_r :: (___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t) -> i32 {
    result : i32 = default
    __c__fcvt_r(&result, ___value, ___ndigit, ___decpt, ___sign, ___buf, ___len)
    return result
}
qecvt_r :: (___value: __UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t) -> i32 {
    result : i32 = default
    __c__qecvt_r(&result, &___value, ___ndigit, ___decpt, ___sign, ___buf, ___len)
    return result
}
qfcvt_r :: (___value: __UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t) -> i32 {
    result : i32 = default
    __c__qfcvt_r(&result, &___value, ___ndigit, ___decpt, ___sign, ___buf, ___len)
    return result
}
mblen :: (___s: &char8, ___n: size_t) -> i32 {
    result : i32 = default
    __c__mblen(&result, ___s, ___n)
    return result
}
mbtowc :: (___pwc: &char16, ___s: &char8, ___n: size_t) -> i32 {
    result : i32 = default
    __c__mbtowc(&result, ___pwc, ___s, ___n)
    return result
}
wctomb :: (___s: &char8, ___wchar: char16) -> i32 {
    result : i32 = default
    __c__wctomb(&result, ___s, ___wchar)
    return result
}
mbstowcs :: (___pwcs: &char16, ___s: &char8, ___n: size_t) -> size_t {
    result : size_t = default
    __c__mbstowcs(&result, ___pwcs, ___s, ___n)
    return result
}
wcstombs :: (___s: &char8, ___pwcs: &char16, ___n: size_t) -> size_t {
    result : size_t = default
    __c__wcstombs(&result, ___s, ___pwcs, ___n)
    return result
}
rpmatch :: (___response: &char8) -> i32 {
    result : i32 = default
    __c__rpmatch(&result, ___response)
    return result
}
getsubopt :: (___optionp: &&char8, ___tokens: &&char8, ___valuep: &&char8) -> i32 {
    result : i32 = default
    __c__getsubopt(&result, ___optionp, ___tokens, ___valuep)
    return result
}
getloadavg :: (___loadavg: &f64, ___nelem: i32) -> i32 {
    result : i32 = default
    __c__getloadavg(&result, ___loadavg, ___nelem)
    return result
}
stbi_load_from_memory :: (_buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi_load_from_memory(&result, _buffer, _len, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi_load_from_callbacks(&result, _clbk, _user, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load :: (_filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi_load(&result, _filename, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_from_file :: (_f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi_load_from_file(&result, _f, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_gif_from_memory :: (_buffer: &stbi_uc, _len: i32, _delays: &&i32, _x: &i32, _y: &i32, _z: &i32, _comp: &i32, _req_comp: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi_load_gif_from_memory(&result, _buffer, _len, _delays, _x, _y, _z, _comp, _req_comp)
    return result
}
stbi_load_16_from_memory :: (_buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_us {
    result : &stbi_us = default
    __c__stbi_load_16_from_memory(&result, _buffer, _len, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_16_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_us {
    result : &stbi_us = default
    __c__stbi_load_16_from_callbacks(&result, _clbk, _user, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_16 :: (_filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_us {
    result : &stbi_us = default
    __c__stbi_load_16(&result, _filename, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_load_from_file_16 :: (_f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &stbi_us {
    result : &stbi_us = default
    __c__stbi_load_from_file_16(&result, _f, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_loadf_from_memory :: (_buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &f32 {
    result : &f32 = default
    __c__stbi_loadf_from_memory(&result, _buffer, _len, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_loadf_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &f32 {
    result : &f32 = default
    __c__stbi_loadf_from_callbacks(&result, _clbk, _user, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_loadf :: (_filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &f32 {
    result : &f32 = default
    __c__stbi_loadf(&result, _filename, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_loadf_from_file :: (_f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32) -> &f32 {
    result : &f32 = default
    __c__stbi_loadf_from_file(&result, _f, _x, _y, _channels_in_file, _desired_channels)
    return result
}
stbi_hdr_to_ldr_gamma :: (_gamma: f32) {
    __c__stbi_hdr_to_ldr_gamma(_gamma)
}
stbi_hdr_to_ldr_scale :: (_scale: f32) {
    __c__stbi_hdr_to_ldr_scale(_scale)
}
stbi_ldr_to_hdr_gamma :: (_gamma: f32) {
    __c__stbi_ldr_to_hdr_gamma(_gamma)
}
stbi_ldr_to_hdr_scale :: (_scale: f32) {
    __c__stbi_ldr_to_hdr_scale(_scale)
}
stbi_is_hdr_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void) -> i32 {
    result : i32 = default
    __c__stbi_is_hdr_from_callbacks(&result, _clbk, _user)
    return result
}
stbi_is_hdr_from_memory :: (_buffer: &stbi_uc, _len: i32) -> i32 {
    result : i32 = default
    __c__stbi_is_hdr_from_memory(&result, _buffer, _len)
    return result
}
stbi_is_hdr :: (_filename: &char8) -> i32 {
    result : i32 = default
    __c__stbi_is_hdr(&result, _filename)
    return result
}
stbi_is_hdr_from_file :: (_f: &FILE) -> i32 {
    result : i32 = default
    __c__stbi_is_hdr_from_file(&result, _f)
    return result
}
stbi_failure_reason :: () -> &char8 {
    result : &char8 = default
    __c__stbi_failure_reason(&result)
    return result
}
stbi_image_free :: (_retval_from_stbi_load: &void) {
    __c__stbi_image_free(_retval_from_stbi_load)
}
stbi_info_from_memory :: (_buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi_info_from_memory(&result, _buffer, _len, _x, _y, _comp)
    return result
}
stbi_info_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi_info_from_callbacks(&result, _clbk, _user, _x, _y, _comp)
    return result
}
stbi_is_16_bit_from_memory :: (_buffer: &stbi_uc, _len: i32) -> i32 {
    result : i32 = default
    __c__stbi_is_16_bit_from_memory(&result, _buffer, _len)
    return result
}
stbi_is_16_bit_from_callbacks :: (_clbk: &stbi_io_callbacks, _user: &void) -> i32 {
    result : i32 = default
    __c__stbi_is_16_bit_from_callbacks(&result, _clbk, _user)
    return result
}
stbi_info :: (_filename: &char8, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi_info(&result, _filename, _x, _y, _comp)
    return result
}
stbi_info_from_file :: (_f: &FILE, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi_info_from_file(&result, _f, _x, _y, _comp)
    return result
}
stbi_is_16_bit :: (_filename: &char8) -> i32 {
    result : i32 = default
    __c__stbi_is_16_bit(&result, _filename)
    return result
}
stbi_is_16_bit_from_file :: (_f: &FILE) -> i32 {
    result : i32 = default
    __c__stbi_is_16_bit_from_file(&result, _f)
    return result
}
stbi_set_unpremultiply_on_load :: (_flag_true_if_should_unpremultiply: i32) {
    __c__stbi_set_unpremultiply_on_load(_flag_true_if_should_unpremultiply)
}
stbi_convert_iphone_png_to_rgb :: (_flag_true_if_should_convert: i32) {
    __c__stbi_convert_iphone_png_to_rgb(_flag_true_if_should_convert)
}
stbi_set_flip_vertically_on_load :: (_flag_true_if_should_flip: i32) {
    __c__stbi_set_flip_vertically_on_load(_flag_true_if_should_flip)
}
stbi_set_flip_vertically_on_load_thread :: (_flag_true_if_should_flip: i32) {
    __c__stbi_set_flip_vertically_on_load_thread(_flag_true_if_should_flip)
}
stbi_zlib_decode_malloc_guesssize :: (_buffer: &char8, _len: i32, _initial_size: i32, _outlen: &i32) -> &char8 {
    result : &char8 = default
    __c__stbi_zlib_decode_malloc_guesssize(&result, _buffer, _len, _initial_size, _outlen)
    return result
}
stbi_zlib_decode_malloc_guesssize_headerflag :: (_buffer: &char8, _len: i32, _initial_size: i32, _outlen: &i32, _parse_header: i32) -> &char8 {
    result : &char8 = default
    __c__stbi_zlib_decode_malloc_guesssize_headerflag(&result, _buffer, _len, _initial_size, _outlen, _parse_header)
    return result
}
stbi_zlib_decode_malloc :: (_buffer: &char8, _len: i32, _outlen: &i32) -> &char8 {
    result : &char8 = default
    __c__stbi_zlib_decode_malloc(&result, _buffer, _len, _outlen)
    return result
}
stbi_zlib_decode_buffer :: (_obuffer: &char8, _olen: i32, _ibuffer: &char8, _ilen: i32) -> i32 {
    result : i32 = default
    __c__stbi_zlib_decode_buffer(&result, _obuffer, _olen, _ibuffer, _ilen)
    return result
}
stbi_zlib_decode_noheader_malloc :: (_buffer: &char8, _len: i32, _outlen: &i32) -> &char8 {
    result : &char8 = default
    __c__stbi_zlib_decode_noheader_malloc(&result, _buffer, _len, _outlen)
    return result
}
stbi_zlib_decode_noheader_buffer :: (_obuffer: &char8, _olen: i32, _ibuffer: &char8, _ilen: i32) -> i32 {
    result : i32 = default
    __c__stbi_zlib_decode_noheader_buffer(&result, _obuffer, _olen, _ibuffer, _ilen)
    return result
}
memcpy :: (___dest: &void, ___src: &void, ___n: size_t) -> &void {
    result : &void = default
    __c__memcpy(&result, ___dest, ___src, ___n)
    return result
}
memmove :: (___dest: &void, ___src: &void, ___n: size_t) -> &void {
    result : &void = default
    __c__memmove(&result, ___dest, ___src, ___n)
    return result
}
memccpy :: (___dest: &void, ___src: &void, ___c: i32, ___n: size_t) -> &void {
    result : &void = default
    __c__memccpy(&result, ___dest, ___src, ___c, ___n)
    return result
}
memset :: (___s: &void, ___c: i32, ___n: size_t) -> &void {
    result : &void = default
    __c__memset(&result, ___s, ___c, ___n)
    return result
}
memcmp :: (___s1: &void, ___s2: &void, ___n: size_t) -> i32 {
    result : i32 = default
    __c__memcmp(&result, ___s1, ___s2, ___n)
    return result
}
memchr :: (___s: &void, ___c: i32, ___n: size_t) -> &void {
    result : &void = default
    __c__memchr(&result, ___s, ___c, ___n)
    return result
}
strcpy :: (___dest: &char8, ___src: &char8) -> &char8 {
    result : &char8 = default
    __c__strcpy(&result, ___dest, ___src)
    return result
}
strncpy :: (___dest: &char8, ___src: &char8, ___n: size_t) -> &char8 {
    result : &char8 = default
    __c__strncpy(&result, ___dest, ___src, ___n)
    return result
}
strcat :: (___dest: &char8, ___src: &char8) -> &char8 {
    result : &char8 = default
    __c__strcat(&result, ___dest, ___src)
    return result
}
strncat :: (___dest: &char8, ___src: &char8, ___n: size_t) -> &char8 {
    result : &char8 = default
    __c__strncat(&result, ___dest, ___src, ___n)
    return result
}
strcmp :: (___s1: &char8, ___s2: &char8) -> i32 {
    result : i32 = default
    __c__strcmp(&result, ___s1, ___s2)
    return result
}
strncmp :: (___s1: &char8, ___s2: &char8, ___n: size_t) -> i32 {
    result : i32 = default
    __c__strncmp(&result, ___s1, ___s2, ___n)
    return result
}
strcoll :: (___s1: &char8, ___s2: &char8) -> i32 {
    result : i32 = default
    __c__strcoll(&result, ___s1, ___s2)
    return result
}
strxfrm :: (___dest: &char8, ___src: &char8, ___n: size_t) -> size_t {
    result : size_t = default
    __c__strxfrm(&result, ___dest, ___src, ___n)
    return result
}
strcoll_l :: (___s1: &char8, ___s2: &char8, ___l: locale_t) -> i32 {
    result : i32 = default
    __c__strcoll_l(&result, ___s1, ___s2, ___l)
    return result
}
strxfrm_l :: (___dest: &char8, ___src: &char8, ___n: size_t, ___l: locale_t) -> size_t {
    result : size_t = default
    __c__strxfrm_l(&result, ___dest, ___src, ___n, ___l)
    return result
}
strdup :: (___s: &char8) -> &char8 {
    result : &char8 = default
    __c__strdup(&result, ___s)
    return result
}
strndup :: (___string: &char8, ___n: size_t) -> &char8 {
    result : &char8 = default
    __c__strndup(&result, ___string, ___n)
    return result
}
strchr :: (___s: &char8, ___c: i32) -> &char8 {
    result : &char8 = default
    __c__strchr(&result, ___s, ___c)
    return result
}
strrchr :: (___s: &char8, ___c: i32) -> &char8 {
    result : &char8 = default
    __c__strrchr(&result, ___s, ___c)
    return result
}
strcspn :: (___s: &char8, ___reject: &char8) -> size_t {
    result : size_t = default
    __c__strcspn(&result, ___s, ___reject)
    return result
}
strspn :: (___s: &char8, ___accept: &char8) -> size_t {
    result : size_t = default
    __c__strspn(&result, ___s, ___accept)
    return result
}
strpbrk :: (___s: &char8, ___accept: &char8) -> &char8 {
    result : &char8 = default
    __c__strpbrk(&result, ___s, ___accept)
    return result
}
strstr :: (___haystack: &char8, ___needle: &char8) -> &char8 {
    result : &char8 = default
    __c__strstr(&result, ___haystack, ___needle)
    return result
}
strtok :: (___s: &char8, ___delim: &char8) -> &char8 {
    result : &char8 = default
    __c__strtok(&result, ___s, ___delim)
    return result
}
__strtok_r :: (___s: &char8, ___delim: &char8, ___save_ptr: &&char8) -> &char8 {
    result : &char8 = default
    __c____strtok_r(&result, ___s, ___delim, ___save_ptr)
    return result
}
strtok_r :: (___s: &char8, ___delim: &char8, ___save_ptr: &&char8) -> &char8 {
    result : &char8 = default
    __c__strtok_r(&result, ___s, ___delim, ___save_ptr)
    return result
}
strlen :: (___s: &char8) -> size_t {
    result : size_t = default
    __c__strlen(&result, ___s)
    return result
}
strnlen :: (___string: &char8, ___maxlen: size_t) -> size_t {
    result : size_t = default
    __c__strnlen(&result, ___string, ___maxlen)
    return result
}
strerror :: (___errnum: i32) -> &char8 {
    result : &char8 = default
    __c__strerror(&result, ___errnum)
    return result
}
strerror_r :: (___errnum: i32, ___buf: &char8, ___buflen: size_t) -> i32 {
    result : i32 = default
    __c__strerror_r(&result, ___errnum, ___buf, ___buflen)
    return result
}
strerror_l :: (___errnum: i32, ___l: locale_t) -> &char8 {
    result : &char8 = default
    __c__strerror_l(&result, ___errnum, ___l)
    return result
}
bcmp :: (___s1: &void, ___s2: &void, ___n: size_t) -> i32 {
    result : i32 = default
    __c__bcmp(&result, ___s1, ___s2, ___n)
    return result
}
bcopy :: (___src: &void, ___dest: &void, ___n: size_t) {
    __c__bcopy(___src, ___dest, ___n)
}
bzero :: (___s: &void, ___n: size_t) {
    __c__bzero(___s, ___n)
}
index :: (___s: &char8, ___c: i32) -> &char8 {
    result : &char8 = default
    __c__index(&result, ___s, ___c)
    return result
}
rindex :: (___s: &char8, ___c: i32) -> &char8 {
    result : &char8 = default
    __c__rindex(&result, ___s, ___c)
    return result
}
ffs :: (___i: i32) -> i32 {
    result : i32 = default
    __c__ffs(&result, ___i)
    return result
}
ffsl :: (___l: i32) -> i32 {
    result : i32 = default
    __c__ffsl(&result, ___l)
    return result
}
ffsll :: (___ll: i64) -> i32 {
    result : i32 = default
    __c__ffsll(&result, ___ll)
    return result
}
strcasecmp :: (___s1: &char8, ___s2: &char8) -> i32 {
    result : i32 = default
    __c__strcasecmp(&result, ___s1, ___s2)
    return result
}
strncasecmp :: (___s1: &char8, ___s2: &char8, ___n: size_t) -> i32 {
    result : i32 = default
    __c__strncasecmp(&result, ___s1, ___s2, ___n)
    return result
}
strcasecmp_l :: (___s1: &char8, ___s2: &char8, ___loc: locale_t) -> i32 {
    result : i32 = default
    __c__strcasecmp_l(&result, ___s1, ___s2, ___loc)
    return result
}
strncasecmp_l :: (___s1: &char8, ___s2: &char8, ___n: size_t, ___loc: locale_t) -> i32 {
    result : i32 = default
    __c__strncasecmp_l(&result, ___s1, ___s2, ___n, ___loc)
    return result
}
explicit_bzero :: (___s: &void, ___n: size_t) {
    __c__explicit_bzero(___s, ___n)
}
strsep :: (___stringp: &&char8, ___delim: &char8) -> &char8 {
    result : &char8 = default
    __c__strsep(&result, ___stringp, ___delim)
    return result
}
strsignal :: (___sig: i32) -> &char8 {
    result : &char8 = default
    __c__strsignal(&result, ___sig)
    return result
}
__stpcpy :: (___dest: &char8, ___src: &char8) -> &char8 {
    result : &char8 = default
    __c____stpcpy(&result, ___dest, ___src)
    return result
}
stpcpy :: (___dest: &char8, ___src: &char8) -> &char8 {
    result : &char8 = default
    __c__stpcpy(&result, ___dest, ___src)
    return result
}
__stpncpy :: (___dest: &char8, ___src: &char8, ___n: size_t) -> &char8 {
    result : &char8 = default
    __c____stpncpy(&result, ___dest, ___src, ___n)
    return result
}
stpncpy :: (___dest: &char8, ___src: &char8, ___n: size_t) -> &char8 {
    result : &char8 = default
    __c__stpncpy(&result, ___dest, ___src, ___n)
    return result
}
__fpclassify :: (___value: f64) -> i32 {
    result : i32 = default
    __c____fpclassify(&result, ___value)
    return result
}
__signbit :: (___value: f64) -> i32 {
    result : i32 = default
    __c____signbit(&result, ___value)
    return result
}
__isinf :: (___value: f64) -> i32 {
    result : i32 = default
    __c____isinf(&result, ___value)
    return result
}
__finite :: (___value: f64) -> i32 {
    result : i32 = default
    __c____finite(&result, ___value)
    return result
}
__isnan :: (___value: f64) -> i32 {
    result : i32 = default
    __c____isnan(&result, ___value)
    return result
}
__iseqsig :: (___x: f64, ___y: f64) -> i32 {
    result : i32 = default
    __c____iseqsig(&result, ___x, ___y)
    return result
}
__issignaling :: (___value: f64) -> i32 {
    result : i32 = default
    __c____issignaling(&result, ___value)
    return result
}
acos :: (___x: f64) -> f64 {
    result : f64 = default
    __c__acos(&result, ___x)
    return result
}
__acos :: (___x: f64) -> f64 {
    result : f64 = default
    __c____acos(&result, ___x)
    return result
}
asin :: (___x: f64) -> f64 {
    result : f64 = default
    __c__asin(&result, ___x)
    return result
}
__asin :: (___x: f64) -> f64 {
    result : f64 = default
    __c____asin(&result, ___x)
    return result
}
atan :: (___x: f64) -> f64 {
    result : f64 = default
    __c__atan(&result, ___x)
    return result
}
__atan :: (___x: f64) -> f64 {
    result : f64 = default
    __c____atan(&result, ___x)
    return result
}
atan2 :: (___y: f64, ___x: f64) -> f64 {
    result : f64 = default
    __c__atan2(&result, ___y, ___x)
    return result
}
__atan2 :: (___y: f64, ___x: f64) -> f64 {
    result : f64 = default
    __c____atan2(&result, ___y, ___x)
    return result
}
cos :: (___x: f64) -> f64 {
    result : f64 = default
    __c__cos(&result, ___x)
    return result
}
__cos :: (___x: f64) -> f64 {
    result : f64 = default
    __c____cos(&result, ___x)
    return result
}
sin :: (___x: f64) -> f64 {
    result : f64 = default
    __c__sin(&result, ___x)
    return result
}
__sin :: (___x: f64) -> f64 {
    result : f64 = default
    __c____sin(&result, ___x)
    return result
}
tan :: (___x: f64) -> f64 {
    result : f64 = default
    __c__tan(&result, ___x)
    return result
}
__tan :: (___x: f64) -> f64 {
    result : f64 = default
    __c____tan(&result, ___x)
    return result
}
cosh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__cosh(&result, ___x)
    return result
}
__cosh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____cosh(&result, ___x)
    return result
}
sinh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__sinh(&result, ___x)
    return result
}
__sinh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____sinh(&result, ___x)
    return result
}
tanh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__tanh(&result, ___x)
    return result
}
__tanh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____tanh(&result, ___x)
    return result
}
acosh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__acosh(&result, ___x)
    return result
}
__acosh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____acosh(&result, ___x)
    return result
}
asinh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__asinh(&result, ___x)
    return result
}
__asinh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____asinh(&result, ___x)
    return result
}
atanh :: (___x: f64) -> f64 {
    result : f64 = default
    __c__atanh(&result, ___x)
    return result
}
__atanh :: (___x: f64) -> f64 {
    result : f64 = default
    __c____atanh(&result, ___x)
    return result
}
exp :: (___x: f64) -> f64 {
    result : f64 = default
    __c__exp(&result, ___x)
    return result
}
__exp :: (___x: f64) -> f64 {
    result : f64 = default
    __c____exp(&result, ___x)
    return result
}
frexp :: (___x: f64, ___exponent: &i32) -> f64 {
    result : f64 = default
    __c__frexp(&result, ___x, ___exponent)
    return result
}
__frexp :: (___x: f64, ___exponent: &i32) -> f64 {
    result : f64 = default
    __c____frexp(&result, ___x, ___exponent)
    return result
}
ldexp :: (___x: f64, ___exponent: i32) -> f64 {
    result : f64 = default
    __c__ldexp(&result, ___x, ___exponent)
    return result
}
__ldexp :: (___x: f64, ___exponent: i32) -> f64 {
    result : f64 = default
    __c____ldexp(&result, ___x, ___exponent)
    return result
}
log :: (___x: f64) -> f64 {
    result : f64 = default
    __c__log(&result, ___x)
    return result
}
__log :: (___x: f64) -> f64 {
    result : f64 = default
    __c____log(&result, ___x)
    return result
}
log10 :: (___x: f64) -> f64 {
    result : f64 = default
    __c__log10(&result, ___x)
    return result
}
__log10 :: (___x: f64) -> f64 {
    result : f64 = default
    __c____log10(&result, ___x)
    return result
}
modf :: (___x: f64, ___iptr: &f64) -> f64 {
    result : f64 = default
    __c__modf(&result, ___x, ___iptr)
    return result
}
__modf :: (___x: f64, ___iptr: &f64) -> f64 {
    result : f64 = default
    __c____modf(&result, ___x, ___iptr)
    return result
}
expm1 :: (___x: f64) -> f64 {
    result : f64 = default
    __c__expm1(&result, ___x)
    return result
}
__expm1 :: (___x: f64) -> f64 {
    result : f64 = default
    __c____expm1(&result, ___x)
    return result
}
log1p :: (___x: f64) -> f64 {
    result : f64 = default
    __c__log1p(&result, ___x)
    return result
}
__log1p :: (___x: f64) -> f64 {
    result : f64 = default
    __c____log1p(&result, ___x)
    return result
}
logb :: (___x: f64) -> f64 {
    result : f64 = default
    __c__logb(&result, ___x)
    return result
}
__logb :: (___x: f64) -> f64 {
    result : f64 = default
    __c____logb(&result, ___x)
    return result
}
exp2 :: (___x: f64) -> f64 {
    result : f64 = default
    __c__exp2(&result, ___x)
    return result
}
__exp2 :: (___x: f64) -> f64 {
    result : f64 = default
    __c____exp2(&result, ___x)
    return result
}
log2 :: (___x: f64) -> f64 {
    result : f64 = default
    __c__log2(&result, ___x)
    return result
}
__log2 :: (___x: f64) -> f64 {
    result : f64 = default
    __c____log2(&result, ___x)
    return result
}
pow :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__pow(&result, ___x, ___y)
    return result
}
__pow :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____pow(&result, ___x, ___y)
    return result
}
sqrt :: (___x: f64) -> f64 {
    result : f64 = default
    __c__sqrt(&result, ___x)
    return result
}
__sqrt :: (___x: f64) -> f64 {
    result : f64 = default
    __c____sqrt(&result, ___x)
    return result
}
hypot :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__hypot(&result, ___x, ___y)
    return result
}
__hypot :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____hypot(&result, ___x, ___y)
    return result
}
cbrt :: (___x: f64) -> f64 {
    result : f64 = default
    __c__cbrt(&result, ___x)
    return result
}
__cbrt :: (___x: f64) -> f64 {
    result : f64 = default
    __c____cbrt(&result, ___x)
    return result
}
ceil :: (___x: f64) -> f64 {
    result : f64 = default
    __c__ceil(&result, ___x)
    return result
}
__ceil :: (___x: f64) -> f64 {
    result : f64 = default
    __c____ceil(&result, ___x)
    return result
}
fabs :: (___x: f64) -> f64 {
    result : f64 = default
    __c__fabs(&result, ___x)
    return result
}
__fabs :: (___x: f64) -> f64 {
    result : f64 = default
    __c____fabs(&result, ___x)
    return result
}
floor :: (___x: f64) -> f64 {
    result : f64 = default
    __c__floor(&result, ___x)
    return result
}
__floor :: (___x: f64) -> f64 {
    result : f64 = default
    __c____floor(&result, ___x)
    return result
}
fmod :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__fmod(&result, ___x, ___y)
    return result
}
__fmod :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____fmod(&result, ___x, ___y)
    return result
}
isinf :: (___value: f64) -> i32 {
    result : i32 = default
    __c__isinf(&result, ___value)
    return result
}
finite :: (___value: f64) -> i32 {
    result : i32 = default
    __c__finite(&result, ___value)
    return result
}
drem :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__drem(&result, ___x, ___y)
    return result
}
__drem :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____drem(&result, ___x, ___y)
    return result
}
significand :: (___x: f64) -> f64 {
    result : f64 = default
    __c__significand(&result, ___x)
    return result
}
__significand :: (___x: f64) -> f64 {
    result : f64 = default
    __c____significand(&result, ___x)
    return result
}
copysign :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__copysign(&result, ___x, ___y)
    return result
}
__copysign :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____copysign(&result, ___x, ___y)
    return result
}
nan :: (___tagb: &char8) -> f64 {
    result : f64 = default
    __c__nan(&result, ___tagb)
    return result
}
__nan :: (___tagb: &char8) -> f64 {
    result : f64 = default
    __c____nan(&result, ___tagb)
    return result
}
isnan :: (___value: f64) -> i32 {
    result : i32 = default
    __c__isnan(&result, ___value)
    return result
}
j0 :: (_0: f64) -> f64 {
    result : f64 = default
    __c__j0(&result, _0)
    return result
}
__j0 :: (_0: f64) -> f64 {
    result : f64 = default
    __c____j0(&result, _0)
    return result
}
j1 :: (_0: f64) -> f64 {
    result : f64 = default
    __c__j1(&result, _0)
    return result
}
__j1 :: (_0: f64) -> f64 {
    result : f64 = default
    __c____j1(&result, _0)
    return result
}
jn :: (_0: i32, _1: f64) -> f64 {
    result : f64 = default
    __c__jn(&result, _0, _1)
    return result
}
__jn :: (_0: i32, _1: f64) -> f64 {
    result : f64 = default
    __c____jn(&result, _0, _1)
    return result
}
y0 :: (_0: f64) -> f64 {
    result : f64 = default
    __c__y0(&result, _0)
    return result
}
__y0 :: (_0: f64) -> f64 {
    result : f64 = default
    __c____y0(&result, _0)
    return result
}
y1 :: (_0: f64) -> f64 {
    result : f64 = default
    __c__y1(&result, _0)
    return result
}
__y1 :: (_0: f64) -> f64 {
    result : f64 = default
    __c____y1(&result, _0)
    return result
}
yn :: (_0: i32, _1: f64) -> f64 {
    result : f64 = default
    __c__yn(&result, _0, _1)
    return result
}
__yn :: (_0: i32, _1: f64) -> f64 {
    result : f64 = default
    __c____yn(&result, _0, _1)
    return result
}
erf :: (_0: f64) -> f64 {
    result : f64 = default
    __c__erf(&result, _0)
    return result
}
__erf :: (_0: f64) -> f64 {
    result : f64 = default
    __c____erf(&result, _0)
    return result
}
erfc :: (_0: f64) -> f64 {
    result : f64 = default
    __c__erfc(&result, _0)
    return result
}
__erfc :: (_0: f64) -> f64 {
    result : f64 = default
    __c____erfc(&result, _0)
    return result
}
lgamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c__lgamma(&result, _0)
    return result
}
__lgamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c____lgamma(&result, _0)
    return result
}
tgamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c__tgamma(&result, _0)
    return result
}
__tgamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c____tgamma(&result, _0)
    return result
}
gamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c__gamma(&result, _0)
    return result
}
__gamma :: (_0: f64) -> f64 {
    result : f64 = default
    __c____gamma(&result, _0)
    return result
}
lgamma_r :: (_0: f64, ___signgamp: &i32) -> f64 {
    result : f64 = default
    __c__lgamma_r(&result, _0, ___signgamp)
    return result
}
__lgamma_r :: (_0: f64, ___signgamp: &i32) -> f64 {
    result : f64 = default
    __c____lgamma_r(&result, _0, ___signgamp)
    return result
}
rint :: (___x: f64) -> f64 {
    result : f64 = default
    __c__rint(&result, ___x)
    return result
}
__rint :: (___x: f64) -> f64 {
    result : f64 = default
    __c____rint(&result, ___x)
    return result
}
nextafter :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__nextafter(&result, ___x, ___y)
    return result
}
__nextafter :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____nextafter(&result, ___x, ___y)
    return result
}
nexttoward :: (___x: f64, ___y: __UNKNOWN_8) -> f64 {
    result : f64 = default
    __c__nexttoward(&result, ___x, &___y)
    return result
}
__nexttoward :: (___x: f64, ___y: __UNKNOWN_8) -> f64 {
    result : f64 = default
    __c____nexttoward(&result, ___x, &___y)
    return result
}
remainder :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__remainder(&result, ___x, ___y)
    return result
}
__remainder :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____remainder(&result, ___x, ___y)
    return result
}
scalbn :: (___x: f64, ___n: i32) -> f64 {
    result : f64 = default
    __c__scalbn(&result, ___x, ___n)
    return result
}
__scalbn :: (___x: f64, ___n: i32) -> f64 {
    result : f64 = default
    __c____scalbn(&result, ___x, ___n)
    return result
}
ilogb :: (___x: f64) -> i32 {
    result : i32 = default
    __c__ilogb(&result, ___x)
    return result
}
__ilogb :: (___x: f64) -> i32 {
    result : i32 = default
    __c____ilogb(&result, ___x)
    return result
}
scalbln :: (___x: f64, ___n: i32) -> f64 {
    result : f64 = default
    __c__scalbln(&result, ___x, ___n)
    return result
}
__scalbln :: (___x: f64, ___n: i32) -> f64 {
    result : f64 = default
    __c____scalbln(&result, ___x, ___n)
    return result
}
nearbyint :: (___x: f64) -> f64 {
    result : f64 = default
    __c__nearbyint(&result, ___x)
    return result
}
__nearbyint :: (___x: f64) -> f64 {
    result : f64 = default
    __c____nearbyint(&result, ___x)
    return result
}
round :: (___x: f64) -> f64 {
    result : f64 = default
    __c__round(&result, ___x)
    return result
}
__round :: (___x: f64) -> f64 {
    result : f64 = default
    __c____round(&result, ___x)
    return result
}
trunc :: (___x: f64) -> f64 {
    result : f64 = default
    __c__trunc(&result, ___x)
    return result
}
__trunc :: (___x: f64) -> f64 {
    result : f64 = default
    __c____trunc(&result, ___x)
    return result
}
remquo :: (___x: f64, ___y: f64, ___quo: &i32) -> f64 {
    result : f64 = default
    __c__remquo(&result, ___x, ___y, ___quo)
    return result
}
__remquo :: (___x: f64, ___y: f64, ___quo: &i32) -> f64 {
    result : f64 = default
    __c____remquo(&result, ___x, ___y, ___quo)
    return result
}
lrint :: (___x: f64) -> i32 {
    result : i32 = default
    __c__lrint(&result, ___x)
    return result
}
__lrint :: (___x: f64) -> i32 {
    result : i32 = default
    __c____lrint(&result, ___x)
    return result
}
llrint :: (___x: f64) -> i64 {
    result : i64 = default
    __c__llrint(&result, ___x)
    return result
}
__llrint :: (___x: f64) -> i64 {
    result : i64 = default
    __c____llrint(&result, ___x)
    return result
}
lround :: (___x: f64) -> i32 {
    result : i32 = default
    __c__lround(&result, ___x)
    return result
}
__lround :: (___x: f64) -> i32 {
    result : i32 = default
    __c____lround(&result, ___x)
    return result
}
llround :: (___x: f64) -> i64 {
    result : i64 = default
    __c__llround(&result, ___x)
    return result
}
__llround :: (___x: f64) -> i64 {
    result : i64 = default
    __c____llround(&result, ___x)
    return result
}
fdim :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__fdim(&result, ___x, ___y)
    return result
}
__fdim :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____fdim(&result, ___x, ___y)
    return result
}
fmax :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__fmax(&result, ___x, ___y)
    return result
}
__fmax :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____fmax(&result, ___x, ___y)
    return result
}
fmin :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c__fmin(&result, ___x, ___y)
    return result
}
__fmin :: (___x: f64, ___y: f64) -> f64 {
    result : f64 = default
    __c____fmin(&result, ___x, ___y)
    return result
}
fma :: (___x: f64, ___y: f64, ___z: f64) -> f64 {
    result : f64 = default
    __c__fma(&result, ___x, ___y, ___z)
    return result
}
__fma :: (___x: f64, ___y: f64, ___z: f64) -> f64 {
    result : f64 = default
    __c____fma(&result, ___x, ___y, ___z)
    return result
}
scalb :: (___x: f64, ___n: f64) -> f64 {
    result : f64 = default
    __c__scalb(&result, ___x, ___n)
    return result
}
__scalb :: (___x: f64, ___n: f64) -> f64 {
    result : f64 = default
    __c____scalb(&result, ___x, ___n)
    return result
}
__fpclassifyf :: (___value: f32) -> i32 {
    result : i32 = default
    __c____fpclassifyf(&result, ___value)
    return result
}
__signbitf :: (___value: f32) -> i32 {
    result : i32 = default
    __c____signbitf(&result, ___value)
    return result
}
__isinff :: (___value: f32) -> i32 {
    result : i32 = default
    __c____isinff(&result, ___value)
    return result
}
__finitef :: (___value: f32) -> i32 {
    result : i32 = default
    __c____finitef(&result, ___value)
    return result
}
__isnanf :: (___value: f32) -> i32 {
    result : i32 = default
    __c____isnanf(&result, ___value)
    return result
}
__iseqsigf :: (___x: f32, ___y: f32) -> i32 {
    result : i32 = default
    __c____iseqsigf(&result, ___x, ___y)
    return result
}
__issignalingf :: (___value: f32) -> i32 {
    result : i32 = default
    __c____issignalingf(&result, ___value)
    return result
}
acosf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__acosf(&result, ___x)
    return result
}
__acosf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____acosf(&result, ___x)
    return result
}
asinf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__asinf(&result, ___x)
    return result
}
__asinf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____asinf(&result, ___x)
    return result
}
atanf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__atanf(&result, ___x)
    return result
}
__atanf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____atanf(&result, ___x)
    return result
}
atan2f :: (___y: f32, ___x: f32) -> f32 {
    result : f32 = default
    __c__atan2f(&result, ___y, ___x)
    return result
}
__atan2f :: (___y: f32, ___x: f32) -> f32 {
    result : f32 = default
    __c____atan2f(&result, ___y, ___x)
    return result
}
cosf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__cosf(&result, ___x)
    return result
}
__cosf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____cosf(&result, ___x)
    return result
}
sinf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__sinf(&result, ___x)
    return result
}
__sinf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____sinf(&result, ___x)
    return result
}
tanf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__tanf(&result, ___x)
    return result
}
__tanf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____tanf(&result, ___x)
    return result
}
coshf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__coshf(&result, ___x)
    return result
}
__coshf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____coshf(&result, ___x)
    return result
}
sinhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__sinhf(&result, ___x)
    return result
}
__sinhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____sinhf(&result, ___x)
    return result
}
tanhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__tanhf(&result, ___x)
    return result
}
__tanhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____tanhf(&result, ___x)
    return result
}
acoshf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__acoshf(&result, ___x)
    return result
}
__acoshf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____acoshf(&result, ___x)
    return result
}
asinhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__asinhf(&result, ___x)
    return result
}
__asinhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____asinhf(&result, ___x)
    return result
}
atanhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__atanhf(&result, ___x)
    return result
}
__atanhf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____atanhf(&result, ___x)
    return result
}
expf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__expf(&result, ___x)
    return result
}
__expf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____expf(&result, ___x)
    return result
}
frexpf :: (___x: f32, ___exponent: &i32) -> f32 {
    result : f32 = default
    __c__frexpf(&result, ___x, ___exponent)
    return result
}
__frexpf :: (___x: f32, ___exponent: &i32) -> f32 {
    result : f32 = default
    __c____frexpf(&result, ___x, ___exponent)
    return result
}
ldexpf :: (___x: f32, ___exponent: i32) -> f32 {
    result : f32 = default
    __c__ldexpf(&result, ___x, ___exponent)
    return result
}
__ldexpf :: (___x: f32, ___exponent: i32) -> f32 {
    result : f32 = default
    __c____ldexpf(&result, ___x, ___exponent)
    return result
}
logf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__logf(&result, ___x)
    return result
}
__logf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____logf(&result, ___x)
    return result
}
log10f :: (___x: f32) -> f32 {
    result : f32 = default
    __c__log10f(&result, ___x)
    return result
}
__log10f :: (___x: f32) -> f32 {
    result : f32 = default
    __c____log10f(&result, ___x)
    return result
}
modff :: (___x: f32, ___iptr: &f32) -> f32 {
    result : f32 = default
    __c__modff(&result, ___x, ___iptr)
    return result
}
__modff :: (___x: f32, ___iptr: &f32) -> f32 {
    result : f32 = default
    __c____modff(&result, ___x, ___iptr)
    return result
}
expm1f :: (___x: f32) -> f32 {
    result : f32 = default
    __c__expm1f(&result, ___x)
    return result
}
__expm1f :: (___x: f32) -> f32 {
    result : f32 = default
    __c____expm1f(&result, ___x)
    return result
}
log1pf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__log1pf(&result, ___x)
    return result
}
__log1pf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____log1pf(&result, ___x)
    return result
}
logbf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__logbf(&result, ___x)
    return result
}
__logbf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____logbf(&result, ___x)
    return result
}
exp2f :: (___x: f32) -> f32 {
    result : f32 = default
    __c__exp2f(&result, ___x)
    return result
}
__exp2f :: (___x: f32) -> f32 {
    result : f32 = default
    __c____exp2f(&result, ___x)
    return result
}
log2f :: (___x: f32) -> f32 {
    result : f32 = default
    __c__log2f(&result, ___x)
    return result
}
__log2f :: (___x: f32) -> f32 {
    result : f32 = default
    __c____log2f(&result, ___x)
    return result
}
powf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__powf(&result, ___x, ___y)
    return result
}
__powf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____powf(&result, ___x, ___y)
    return result
}
sqrtf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__sqrtf(&result, ___x)
    return result
}
__sqrtf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____sqrtf(&result, ___x)
    return result
}
hypotf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__hypotf(&result, ___x, ___y)
    return result
}
__hypotf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____hypotf(&result, ___x, ___y)
    return result
}
cbrtf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__cbrtf(&result, ___x)
    return result
}
__cbrtf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____cbrtf(&result, ___x)
    return result
}
ceilf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__ceilf(&result, ___x)
    return result
}
__ceilf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____ceilf(&result, ___x)
    return result
}
fabsf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__fabsf(&result, ___x)
    return result
}
__fabsf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____fabsf(&result, ___x)
    return result
}
floorf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__floorf(&result, ___x)
    return result
}
__floorf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____floorf(&result, ___x)
    return result
}
fmodf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__fmodf(&result, ___x, ___y)
    return result
}
__fmodf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____fmodf(&result, ___x, ___y)
    return result
}
isinff :: (___value: f32) -> i32 {
    result : i32 = default
    __c__isinff(&result, ___value)
    return result
}
finitef :: (___value: f32) -> i32 {
    result : i32 = default
    __c__finitef(&result, ___value)
    return result
}
dremf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__dremf(&result, ___x, ___y)
    return result
}
__dremf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____dremf(&result, ___x, ___y)
    return result
}
significandf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__significandf(&result, ___x)
    return result
}
__significandf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____significandf(&result, ___x)
    return result
}
copysignf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__copysignf(&result, ___x, ___y)
    return result
}
__copysignf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____copysignf(&result, ___x, ___y)
    return result
}
nanf :: (___tagb: &char8) -> f32 {
    result : f32 = default
    __c__nanf(&result, ___tagb)
    return result
}
__nanf :: (___tagb: &char8) -> f32 {
    result : f32 = default
    __c____nanf(&result, ___tagb)
    return result
}
isnanf :: (___value: f32) -> i32 {
    result : i32 = default
    __c__isnanf(&result, ___value)
    return result
}
j0f :: (_0: f32) -> f32 {
    result : f32 = default
    __c__j0f(&result, _0)
    return result
}
__j0f :: (_0: f32) -> f32 {
    result : f32 = default
    __c____j0f(&result, _0)
    return result
}
j1f :: (_0: f32) -> f32 {
    result : f32 = default
    __c__j1f(&result, _0)
    return result
}
__j1f :: (_0: f32) -> f32 {
    result : f32 = default
    __c____j1f(&result, _0)
    return result
}
jnf :: (_0: i32, _1: f32) -> f32 {
    result : f32 = default
    __c__jnf(&result, _0, _1)
    return result
}
__jnf :: (_0: i32, _1: f32) -> f32 {
    result : f32 = default
    __c____jnf(&result, _0, _1)
    return result
}
y0f :: (_0: f32) -> f32 {
    result : f32 = default
    __c__y0f(&result, _0)
    return result
}
__y0f :: (_0: f32) -> f32 {
    result : f32 = default
    __c____y0f(&result, _0)
    return result
}
y1f :: (_0: f32) -> f32 {
    result : f32 = default
    __c__y1f(&result, _0)
    return result
}
__y1f :: (_0: f32) -> f32 {
    result : f32 = default
    __c____y1f(&result, _0)
    return result
}
ynf :: (_0: i32, _1: f32) -> f32 {
    result : f32 = default
    __c__ynf(&result, _0, _1)
    return result
}
__ynf :: (_0: i32, _1: f32) -> f32 {
    result : f32 = default
    __c____ynf(&result, _0, _1)
    return result
}
erff :: (_0: f32) -> f32 {
    result : f32 = default
    __c__erff(&result, _0)
    return result
}
__erff :: (_0: f32) -> f32 {
    result : f32 = default
    __c____erff(&result, _0)
    return result
}
erfcf :: (_0: f32) -> f32 {
    result : f32 = default
    __c__erfcf(&result, _0)
    return result
}
__erfcf :: (_0: f32) -> f32 {
    result : f32 = default
    __c____erfcf(&result, _0)
    return result
}
lgammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c__lgammaf(&result, _0)
    return result
}
__lgammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c____lgammaf(&result, _0)
    return result
}
tgammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c__tgammaf(&result, _0)
    return result
}
__tgammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c____tgammaf(&result, _0)
    return result
}
gammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c__gammaf(&result, _0)
    return result
}
__gammaf :: (_0: f32) -> f32 {
    result : f32 = default
    __c____gammaf(&result, _0)
    return result
}
lgammaf_r :: (_0: f32, ___signgamp: &i32) -> f32 {
    result : f32 = default
    __c__lgammaf_r(&result, _0, ___signgamp)
    return result
}
__lgammaf_r :: (_0: f32, ___signgamp: &i32) -> f32 {
    result : f32 = default
    __c____lgammaf_r(&result, _0, ___signgamp)
    return result
}
rintf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__rintf(&result, ___x)
    return result
}
__rintf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____rintf(&result, ___x)
    return result
}
nextafterf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__nextafterf(&result, ___x, ___y)
    return result
}
__nextafterf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____nextafterf(&result, ___x, ___y)
    return result
}
nexttowardf :: (___x: f32, ___y: __UNKNOWN_8) -> f32 {
    result : f32 = default
    __c__nexttowardf(&result, ___x, &___y)
    return result
}
__nexttowardf :: (___x: f32, ___y: __UNKNOWN_8) -> f32 {
    result : f32 = default
    __c____nexttowardf(&result, ___x, &___y)
    return result
}
remainderf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__remainderf(&result, ___x, ___y)
    return result
}
__remainderf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____remainderf(&result, ___x, ___y)
    return result
}
scalbnf :: (___x: f32, ___n: i32) -> f32 {
    result : f32 = default
    __c__scalbnf(&result, ___x, ___n)
    return result
}
__scalbnf :: (___x: f32, ___n: i32) -> f32 {
    result : f32 = default
    __c____scalbnf(&result, ___x, ___n)
    return result
}
ilogbf :: (___x: f32) -> i32 {
    result : i32 = default
    __c__ilogbf(&result, ___x)
    return result
}
__ilogbf :: (___x: f32) -> i32 {
    result : i32 = default
    __c____ilogbf(&result, ___x)
    return result
}
scalblnf :: (___x: f32, ___n: i32) -> f32 {
    result : f32 = default
    __c__scalblnf(&result, ___x, ___n)
    return result
}
__scalblnf :: (___x: f32, ___n: i32) -> f32 {
    result : f32 = default
    __c____scalblnf(&result, ___x, ___n)
    return result
}
nearbyintf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__nearbyintf(&result, ___x)
    return result
}
__nearbyintf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____nearbyintf(&result, ___x)
    return result
}
roundf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__roundf(&result, ___x)
    return result
}
__roundf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____roundf(&result, ___x)
    return result
}
truncf :: (___x: f32) -> f32 {
    result : f32 = default
    __c__truncf(&result, ___x)
    return result
}
__truncf :: (___x: f32) -> f32 {
    result : f32 = default
    __c____truncf(&result, ___x)
    return result
}
remquof :: (___x: f32, ___y: f32, ___quo: &i32) -> f32 {
    result : f32 = default
    __c__remquof(&result, ___x, ___y, ___quo)
    return result
}
__remquof :: (___x: f32, ___y: f32, ___quo: &i32) -> f32 {
    result : f32 = default
    __c____remquof(&result, ___x, ___y, ___quo)
    return result
}
lrintf :: (___x: f32) -> i32 {
    result : i32 = default
    __c__lrintf(&result, ___x)
    return result
}
__lrintf :: (___x: f32) -> i32 {
    result : i32 = default
    __c____lrintf(&result, ___x)
    return result
}
llrintf :: (___x: f32) -> i64 {
    result : i64 = default
    __c__llrintf(&result, ___x)
    return result
}
__llrintf :: (___x: f32) -> i64 {
    result : i64 = default
    __c____llrintf(&result, ___x)
    return result
}
lroundf :: (___x: f32) -> i32 {
    result : i32 = default
    __c__lroundf(&result, ___x)
    return result
}
__lroundf :: (___x: f32) -> i32 {
    result : i32 = default
    __c____lroundf(&result, ___x)
    return result
}
llroundf :: (___x: f32) -> i64 {
    result : i64 = default
    __c__llroundf(&result, ___x)
    return result
}
__llroundf :: (___x: f32) -> i64 {
    result : i64 = default
    __c____llroundf(&result, ___x)
    return result
}
fdimf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__fdimf(&result, ___x, ___y)
    return result
}
__fdimf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____fdimf(&result, ___x, ___y)
    return result
}
fmaxf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__fmaxf(&result, ___x, ___y)
    return result
}
__fmaxf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____fmaxf(&result, ___x, ___y)
    return result
}
fminf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c__fminf(&result, ___x, ___y)
    return result
}
__fminf :: (___x: f32, ___y: f32) -> f32 {
    result : f32 = default
    __c____fminf(&result, ___x, ___y)
    return result
}
fmaf :: (___x: f32, ___y: f32, ___z: f32) -> f32 {
    result : f32 = default
    __c__fmaf(&result, ___x, ___y, ___z)
    return result
}
__fmaf :: (___x: f32, ___y: f32, ___z: f32) -> f32 {
    result : f32 = default
    __c____fmaf(&result, ___x, ___y, ___z)
    return result
}
scalbf :: (___x: f32, ___n: f32) -> f32 {
    result : f32 = default
    __c__scalbf(&result, ___x, ___n)
    return result
}
__scalbf :: (___x: f32, ___n: f32) -> f32 {
    result : f32 = default
    __c____scalbf(&result, ___x, ___n)
    return result
}
__fpclassifyl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____fpclassifyl(&result, &___value)
    return result
}
__signbitl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____signbitl(&result, &___value)
    return result
}
__isinfl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____isinfl(&result, &___value)
    return result
}
__finitel :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____finitel(&result, &___value)
    return result
}
__isnanl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____isnanl(&result, &___value)
    return result
}
__iseqsigl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____iseqsigl(&result, &___x, &___y)
    return result
}
__issignalingl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____issignalingl(&result, &___value)
    return result
}
acosl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__acosl(&result, &___x)
    return result
}
__acosl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____acosl(&result, &___x)
    return result
}
asinl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__asinl(&result, &___x)
    return result
}
__asinl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____asinl(&result, &___x)
    return result
}
atanl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__atanl(&result, &___x)
    return result
}
__atanl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____atanl(&result, &___x)
    return result
}
atan2l :: (___y: __UNKNOWN_8, ___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__atan2l(&result, &___y, &___x)
    return result
}
__atan2l :: (___y: __UNKNOWN_8, ___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____atan2l(&result, &___y, &___x)
    return result
}
cosl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__cosl(&result, &___x)
    return result
}
__cosl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____cosl(&result, &___x)
    return result
}
sinl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__sinl(&result, &___x)
    return result
}
__sinl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____sinl(&result, &___x)
    return result
}
tanl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__tanl(&result, &___x)
    return result
}
__tanl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____tanl(&result, &___x)
    return result
}
coshl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__coshl(&result, &___x)
    return result
}
__coshl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____coshl(&result, &___x)
    return result
}
sinhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__sinhl(&result, &___x)
    return result
}
__sinhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____sinhl(&result, &___x)
    return result
}
tanhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__tanhl(&result, &___x)
    return result
}
__tanhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____tanhl(&result, &___x)
    return result
}
acoshl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__acoshl(&result, &___x)
    return result
}
__acoshl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____acoshl(&result, &___x)
    return result
}
asinhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__asinhl(&result, &___x)
    return result
}
__asinhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____asinhl(&result, &___x)
    return result
}
atanhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__atanhl(&result, &___x)
    return result
}
__atanhl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____atanhl(&result, &___x)
    return result
}
expl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__expl(&result, &___x)
    return result
}
__expl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____expl(&result, &___x)
    return result
}
frexpl :: (___x: __UNKNOWN_8, ___exponent: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__frexpl(&result, &___x, ___exponent)
    return result
}
__frexpl :: (___x: __UNKNOWN_8, ___exponent: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____frexpl(&result, &___x, ___exponent)
    return result
}
ldexpl :: (___x: __UNKNOWN_8, ___exponent: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__ldexpl(&result, &___x, ___exponent)
    return result
}
__ldexpl :: (___x: __UNKNOWN_8, ___exponent: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____ldexpl(&result, &___x, ___exponent)
    return result
}
logl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__logl(&result, &___x)
    return result
}
__logl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____logl(&result, &___x)
    return result
}
log10l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__log10l(&result, &___x)
    return result
}
__log10l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____log10l(&result, &___x)
    return result
}
modfl :: (___x: __UNKNOWN_8, ___iptr: &__UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__modfl(&result, &___x, ___iptr)
    return result
}
__modfl :: (___x: __UNKNOWN_8, ___iptr: &__UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____modfl(&result, &___x, ___iptr)
    return result
}
expm1l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__expm1l(&result, &___x)
    return result
}
__expm1l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____expm1l(&result, &___x)
    return result
}
log1pl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__log1pl(&result, &___x)
    return result
}
__log1pl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____log1pl(&result, &___x)
    return result
}
logbl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__logbl(&result, &___x)
    return result
}
__logbl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____logbl(&result, &___x)
    return result
}
exp2l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__exp2l(&result, &___x)
    return result
}
__exp2l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____exp2l(&result, &___x)
    return result
}
log2l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__log2l(&result, &___x)
    return result
}
__log2l :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____log2l(&result, &___x)
    return result
}
powl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__powl(&result, &___x, &___y)
    return result
}
__powl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____powl(&result, &___x, &___y)
    return result
}
sqrtl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__sqrtl(&result, &___x)
    return result
}
__sqrtl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____sqrtl(&result, &___x)
    return result
}
hypotl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__hypotl(&result, &___x, &___y)
    return result
}
__hypotl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____hypotl(&result, &___x, &___y)
    return result
}
cbrtl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__cbrtl(&result, &___x)
    return result
}
__cbrtl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____cbrtl(&result, &___x)
    return result
}
ceill :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__ceill(&result, &___x)
    return result
}
__ceill :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____ceill(&result, &___x)
    return result
}
fabsl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fabsl(&result, &___x)
    return result
}
__fabsl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fabsl(&result, &___x)
    return result
}
floorl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__floorl(&result, &___x)
    return result
}
__floorl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____floorl(&result, &___x)
    return result
}
fmodl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fmodl(&result, &___x, &___y)
    return result
}
__fmodl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fmodl(&result, &___x, &___y)
    return result
}
isinfl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__isinfl(&result, &___value)
    return result
}
finitel :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__finitel(&result, &___value)
    return result
}
dreml :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__dreml(&result, &___x, &___y)
    return result
}
__dreml :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____dreml(&result, &___x, &___y)
    return result
}
significandl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__significandl(&result, &___x)
    return result
}
__significandl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____significandl(&result, &___x)
    return result
}
copysignl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__copysignl(&result, &___x, &___y)
    return result
}
__copysignl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____copysignl(&result, &___x, &___y)
    return result
}
nanl :: (___tagb: &char8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__nanl(&result, ___tagb)
    return result
}
__nanl :: (___tagb: &char8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____nanl(&result, ___tagb)
    return result
}
isnanl :: (___value: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__isnanl(&result, &___value)
    return result
}
j0l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__j0l(&result, &_0)
    return result
}
__j0l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____j0l(&result, &_0)
    return result
}
j1l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__j1l(&result, &_0)
    return result
}
__j1l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____j1l(&result, &_0)
    return result
}
jnl :: (_0: i32, _1: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__jnl(&result, _0, &_1)
    return result
}
__jnl :: (_0: i32, _1: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____jnl(&result, _0, &_1)
    return result
}
y0l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__y0l(&result, &_0)
    return result
}
__y0l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____y0l(&result, &_0)
    return result
}
y1l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__y1l(&result, &_0)
    return result
}
__y1l :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____y1l(&result, &_0)
    return result
}
ynl :: (_0: i32, _1: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__ynl(&result, _0, &_1)
    return result
}
__ynl :: (_0: i32, _1: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____ynl(&result, _0, &_1)
    return result
}
erfl :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__erfl(&result, &_0)
    return result
}
__erfl :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____erfl(&result, &_0)
    return result
}
erfcl :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__erfcl(&result, &_0)
    return result
}
__erfcl :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____erfcl(&result, &_0)
    return result
}
lgammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__lgammal(&result, &_0)
    return result
}
__lgammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____lgammal(&result, &_0)
    return result
}
tgammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__tgammal(&result, &_0)
    return result
}
__tgammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____tgammal(&result, &_0)
    return result
}
gammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__gammal(&result, &_0)
    return result
}
__gammal :: (_0: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____gammal(&result, &_0)
    return result
}
lgammal_r :: (_0: __UNKNOWN_8, ___signgamp: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__lgammal_r(&result, &_0, ___signgamp)
    return result
}
__lgammal_r :: (_0: __UNKNOWN_8, ___signgamp: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____lgammal_r(&result, &_0, ___signgamp)
    return result
}
rintl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__rintl(&result, &___x)
    return result
}
__rintl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____rintl(&result, &___x)
    return result
}
nextafterl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__nextafterl(&result, &___x, &___y)
    return result
}
__nextafterl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____nextafterl(&result, &___x, &___y)
    return result
}
nexttowardl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__nexttowardl(&result, &___x, &___y)
    return result
}
__nexttowardl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____nexttowardl(&result, &___x, &___y)
    return result
}
remainderl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__remainderl(&result, &___x, &___y)
    return result
}
__remainderl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____remainderl(&result, &___x, &___y)
    return result
}
scalbnl :: (___x: __UNKNOWN_8, ___n: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__scalbnl(&result, &___x, ___n)
    return result
}
__scalbnl :: (___x: __UNKNOWN_8, ___n: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____scalbnl(&result, &___x, ___n)
    return result
}
ilogbl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__ilogbl(&result, &___x)
    return result
}
__ilogbl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____ilogbl(&result, &___x)
    return result
}
scalblnl :: (___x: __UNKNOWN_8, ___n: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__scalblnl(&result, &___x, ___n)
    return result
}
__scalblnl :: (___x: __UNKNOWN_8, ___n: i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____scalblnl(&result, &___x, ___n)
    return result
}
nearbyintl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__nearbyintl(&result, &___x)
    return result
}
__nearbyintl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____nearbyintl(&result, &___x)
    return result
}
roundl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__roundl(&result, &___x)
    return result
}
__roundl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____roundl(&result, &___x)
    return result
}
truncl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__truncl(&result, &___x)
    return result
}
__truncl :: (___x: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____truncl(&result, &___x)
    return result
}
remquol :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8, ___quo: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__remquol(&result, &___x, &___y, ___quo)
    return result
}
__remquol :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8, ___quo: &i32) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____remquol(&result, &___x, &___y, ___quo)
    return result
}
lrintl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__lrintl(&result, &___x)
    return result
}
__lrintl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____lrintl(&result, &___x)
    return result
}
llrintl :: (___x: __UNKNOWN_8) -> i64 {
    result : i64 = default
    __c__llrintl(&result, &___x)
    return result
}
__llrintl :: (___x: __UNKNOWN_8) -> i64 {
    result : i64 = default
    __c____llrintl(&result, &___x)
    return result
}
lroundl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c__lroundl(&result, &___x)
    return result
}
__lroundl :: (___x: __UNKNOWN_8) -> i32 {
    result : i32 = default
    __c____lroundl(&result, &___x)
    return result
}
llroundl :: (___x: __UNKNOWN_8) -> i64 {
    result : i64 = default
    __c__llroundl(&result, &___x)
    return result
}
__llroundl :: (___x: __UNKNOWN_8) -> i64 {
    result : i64 = default
    __c____llroundl(&result, &___x)
    return result
}
fdiml :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fdiml(&result, &___x, &___y)
    return result
}
__fdiml :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fdiml(&result, &___x, &___y)
    return result
}
fmaxl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fmaxl(&result, &___x, &___y)
    return result
}
__fmaxl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fmaxl(&result, &___x, &___y)
    return result
}
fminl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fminl(&result, &___x, &___y)
    return result
}
__fminl :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fminl(&result, &___x, &___y)
    return result
}
fmal :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8, ___z: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__fmal(&result, &___x, &___y, &___z)
    return result
}
__fmal :: (___x: __UNKNOWN_8, ___y: __UNKNOWN_8, ___z: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____fmal(&result, &___x, &___y, &___z)
    return result
}
scalbl :: (___x: __UNKNOWN_8, ___n: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c__scalbl(&result, &___x, &___n)
    return result
}
__scalbl :: (___x: __UNKNOWN_8, ___n: __UNKNOWN_8) -> __UNKNOWN_8 {
    result : __UNKNOWN_8 = default
    __c____scalbl(&result, &___x, &___n)
    return result
}
__assert_fail :: (___assertion: &char8, ___file: &char8, ___line: u32, ___function: &char8) {
    __c____assert_fail(___assertion, ___file, ___line, ___function)
}
__assert_perror_fail :: (___errnum: i32, ___file: &char8, ___line: u32, ___function: &char8) {
    __c____assert_perror_fail(___errnum, ___file, ___line, ___function)
}
__assert :: (___assertion: &char8, ___file: &char8, ___line: i32) {
    __c____assert(___assertion, ___file, ___line)
}
posix_memalign_2 :: (___memptr: &&void, ___alignment: size_t, ___size: size_t) -> i32 {
    result : i32 = default
    __c__posix_memalign_2(&result, ___memptr, ___alignment, ___size)
    return result
}
_mm_sfence :: () {
    __c___mm_sfence()
}
_mm_getcsr :: () -> u32 {
    result : u32 = default
    __c___mm_getcsr(&result)
    return result
}
_mm_setcsr :: (___i: u32) {
    __c___mm_setcsr(___i)
}
_mm_clflush :: (___p: &void) {
    __c___mm_clflush(___p)
}
_mm_lfence :: () {
    __c___mm_lfence()
}
_mm_mfence :: () {
    __c___mm_mfence()
}
_mm_pause :: () {
    __c___mm_pause()
}
stbi__refill_buffer :: (_s: &stbi__context) {
    __c__stbi__refill_buffer(_s)
}
stbi__jpeg_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__jpeg_test(&result, _s)
    return result
}
stbi__jpeg_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__jpeg_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__jpeg_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__jpeg_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__png_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__png_test(&result, _s)
    return result
}
stbi__png_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__png_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__png_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__png_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__png_is16 :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__png_is16(&result, _s)
    return result
}
stbi__bmp_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__bmp_test(&result, _s)
    return result
}
stbi__bmp_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__bmp_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__bmp_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__bmp_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__tga_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__tga_test(&result, _s)
    return result
}
stbi__tga_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__tga_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__tga_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__tga_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__psd_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__psd_test(&result, _s)
    return result
}
stbi__psd_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info, _bpc: i32) -> &void {
    result : &void = default
    __c__stbi__psd_load(&result, _s, _x, _y, _comp, _req_comp, _ri, _bpc)
    return result
}
stbi__psd_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__psd_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__psd_is16 :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__psd_is16(&result, _s)
    return result
}
stbi__hdr_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__hdr_test(&result, _s)
    return result
}
stbi__hdr_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &f32 {
    result : &f32 = default
    __c__stbi__hdr_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__hdr_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__hdr_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__pic_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__pic_test(&result, _s)
    return result
}
stbi__pic_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__pic_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__pic_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__pic_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__gif_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__gif_test(&result, _s)
    return result
}
stbi__gif_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__gif_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__load_gif_main :: (_s: &stbi__context, _delays: &&i32, _x: &i32, _y: &i32, _z: &i32, _comp: &i32, _req_comp: i32) -> &void {
    result : &void = default
    __c__stbi__load_gif_main(&result, _s, _delays, _x, _y, _z, _comp, _req_comp)
    return result
}
stbi__gif_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__gif_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__pnm_test :: (_s: &stbi__context) -> i32 {
    result : i32 = default
    __c__stbi__pnm_test(&result, _s)
    return result
}
stbi__pnm_load :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info) -> &void {
    result : &void = default
    __c__stbi__pnm_load(&result, _s, _x, _y, _comp, _req_comp, _ri)
    return result
}
stbi__pnm_info :: (_s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32) -> i32 {
    result : i32 = default
    __c__stbi__pnm_info(&result, _s, _x, _y, _comp)
    return result
}
stbi__ldr_to_hdr :: (_data: &stbi_uc, _x: i32, _y: i32, _comp: i32) -> &f32 {
    result : &f32 = default
    __c__stbi__ldr_to_hdr(&result, _data, _x, _y, _comp)
    return result
}
stbi__hdr_to_ldr :: (_data: &f32, _x: i32, _y: i32, _comp: i32) -> &stbi_uc {
    result : &stbi_uc = default
    __c__stbi__hdr_to_ldr(&result, _data, _x, _y, _comp)
    return result
}

// ==========================================================
// ==========================================================
// ==========================================================

#file_scope

__c____underflow :: (ret: &i32, _0: &_IO_FILE);
__c____uflow :: (ret: &i32, _0: &_IO_FILE);
__c____overflow :: (ret: &i32, _0: &_IO_FILE, _1: i32);
__c___IO_getc :: (ret: &i32, ___fp: &_IO_FILE);
__c___IO_putc :: (ret: &i32, ___c: i32, ___fp: &_IO_FILE);
__c___IO_feof :: (ret: &i32, ___fp: &_IO_FILE);
__c___IO_ferror :: (ret: &i32, ___fp: &_IO_FILE);
__c___IO_peekc_locked :: (ret: &i32, ___fp: &_IO_FILE);
__c___IO_flockfile :: (_0: &_IO_FILE);
__c___IO_funlockfile :: (_0: &_IO_FILE);
__c___IO_ftrylockfile :: (ret: &i32, _0: &_IO_FILE);
__c___IO_vfscanf :: (ret: &i32, _0: &_IO_FILE, _1: &char8, _2: __gnuc_va_list, _3: &i32);
__c___IO_vfprintf :: (ret: &i32, _0: &_IO_FILE, _1: &char8, _2: __gnuc_va_list);
__c___IO_padn :: (ret: &__ssize_t, _0: &_IO_FILE, _1: i32, _2: __ssize_t);
__c___IO_sgetn :: (ret: &size_t, _0: &_IO_FILE, _1: &void, _2: size_t);
__c___IO_seekoff :: (ret: &__off64_t, _0: &_IO_FILE, _1: __off64_t, _2: i32, _3: i32);
__c___IO_seekpos :: (ret: &__off64_t, _0: &_IO_FILE, _1: __off64_t, _2: i32);
__c___IO_free_backup_area :: (_0: &_IO_FILE);
__c__remove :: (ret: &i32, ___filename: &char8);
__c__rename :: (ret: &i32, ___old: &char8, ___new: &char8);
__c__renameat :: (ret: &i32, ___oldfd: i32, ___old: &char8, ___newfd: i32, ___new: &char8);
__c__tmpfile :: (ret: &&FILE);
__c__tmpnam :: (ret: &&char8, ___s: &char8);
__c__tmpnam_r :: (ret: &&char8, ___s: &char8);
__c__tempnam :: (ret: &&char8, ___dir: &char8, ___pfx: &char8);
__c__fclose :: (ret: &i32, ___stream: &FILE);
__c__fflush :: (ret: &i32, ___stream: &FILE);
__c__fflush_unlocked :: (ret: &i32, ___stream: &FILE);
__c__fopen :: (ret: &&FILE, ___filename: &char8, ___modes: &char8);
__c__freopen :: (ret: &&FILE, ___filename: &char8, ___modes: &char8, ___stream: &FILE);
__c__fdopen :: (ret: &&FILE, ___fd: i32, ___modes: &char8);
__c__fmemopen :: (ret: &&FILE, ___s: &void, ___len: size_t, ___modes: &char8);
__c__open_memstream :: (ret: &&FILE, ___bufloc: &&char8, ___sizeloc: &size_t);
__c__setbuf :: (___stream: &FILE, ___buf: &char8);
__c__setvbuf :: (ret: &i32, ___stream: &FILE, ___buf: &char8, ___modes: i32, ___n: size_t);
__c__setbuffer :: (___stream: &FILE, ___buf: &char8, ___size: size_t);
__c__setlinebuf :: (___stream: &FILE);
__c__fprintf :: (ret: &i32, ___stream: &FILE, ___format: &char8);
__c__printf :: (ret: &i32, ___format: &char8);
__c__sprintf :: (ret: &i32, ___s: &char8, ___format: &char8);
__c__vfprintf :: (ret: &i32, ___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list);
__c__vprintf :: (ret: &i32, ___format: &char8, ___arg: __gnuc_va_list);
__c__vsprintf :: (ret: &i32, ___s: &char8, ___format: &char8, ___arg: __gnuc_va_list);
__c__snprintf :: (ret: &i32, ___s: &char8, ___maxlen: size_t, ___format: &char8);
__c__vsnprintf :: (ret: &i32, ___s: &char8, ___maxlen: size_t, ___format: &char8, ___arg: __gnuc_va_list);
__c__vdprintf :: (ret: &i32, ___fd: i32, ___fmt: &char8, ___arg: __gnuc_va_list);
__c__dprintf :: (ret: &i32, ___fd: i32, ___fmt: &char8);
__c__fscanf :: (ret: &i32, ___stream: &FILE, ___format: &char8);
__c__scanf :: (ret: &i32, ___format: &char8);
__c__sscanf :: (ret: &i32, ___s: &char8, ___format: &char8);
__c__fscanf_2 :: (ret: &i32, ___stream: &FILE, ___format: &char8);
__c__scanf_2 :: (ret: &i32, ___format: &char8);
__c__sscanf_2 :: (ret: &i32, ___s: &char8, ___format: &char8);
__c__vfscanf :: (ret: &i32, ___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list);
__c__vscanf :: (ret: &i32, ___format: &char8, ___arg: __gnuc_va_list);
__c__vsscanf :: (ret: &i32, ___s: &char8, ___format: &char8, ___arg: __gnuc_va_list);
__c__vfscanf_2 :: (ret: &i32, ___s: &FILE, ___format: &char8, ___arg: __gnuc_va_list);
__c__vscanf_2 :: (ret: &i32, ___format: &char8, ___arg: __gnuc_va_list);
__c__vsscanf_2 :: (ret: &i32, ___s: &char8, ___format: &char8, ___arg: __gnuc_va_list);
__c__fgetc :: (ret: &i32, ___stream: &FILE);
__c__getc :: (ret: &i32, ___stream: &FILE);
__c__getchar :: (ret: &i32);
__c__getc_unlocked :: (ret: &i32, ___stream: &FILE);
__c__getchar_unlocked :: (ret: &i32);
__c__fgetc_unlocked :: (ret: &i32, ___stream: &FILE);
__c__fputc :: (ret: &i32, ___c: i32, ___stream: &FILE);
__c__putc :: (ret: &i32, ___c: i32, ___stream: &FILE);
__c__putchar :: (ret: &i32, ___c: i32);
__c__fputc_unlocked :: (ret: &i32, ___c: i32, ___stream: &FILE);
__c__putc_unlocked :: (ret: &i32, ___c: i32, ___stream: &FILE);
__c__putchar_unlocked :: (ret: &i32, ___c: i32);
__c__getw :: (ret: &i32, ___stream: &FILE);
__c__putw :: (ret: &i32, ___w: i32, ___stream: &FILE);
__c__fgets :: (ret: &&char8, ___s: &char8, ___n: i32, ___stream: &FILE);
__c____getdelim :: (ret: &__ssize_t, ___lineptr: &&char8, ___n: &size_t, ___delimiter: i32, ___stream: &FILE);
__c__getdelim :: (ret: &__ssize_t, ___lineptr: &&char8, ___n: &size_t, ___delimiter: i32, ___stream: &FILE);
__c__getline :: (ret: &__ssize_t, ___lineptr: &&char8, ___n: &size_t, ___stream: &FILE);
__c__fputs :: (ret: &i32, ___s: &char8, ___stream: &FILE);
__c__puts :: (ret: &i32, ___s: &char8);
__c__ungetc :: (ret: &i32, ___c: i32, ___stream: &FILE);
__c__fread :: (ret: &size_t, ___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE);
__c__fwrite :: (ret: &size_t, ___ptr: &void, ___size: size_t, ___n: size_t, ___s: &FILE);
__c__fread_unlocked :: (ret: &size_t, ___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE);
__c__fwrite_unlocked :: (ret: &size_t, ___ptr: &void, ___size: size_t, ___n: size_t, ___stream: &FILE);
__c__fseek :: (ret: &i32, ___stream: &FILE, ___off: i32, ___whence: i32);
__c__ftell :: (ret: &i32, ___stream: &FILE);
__c__rewind :: (___stream: &FILE);
__c__fseeko :: (ret: &i32, ___stream: &FILE, ___off: __off_t, ___whence: i32);
__c__ftello :: (ret: &__off_t, ___stream: &FILE);
__c__fgetpos :: (ret: &i32, ___stream: &FILE, ___pos: &fpos_t);
__c__fsetpos :: (ret: &i32, ___stream: &FILE, ___pos: &fpos_t);
__c__clearerr :: (___stream: &FILE);
__c__feof :: (ret: &i32, ___stream: &FILE);
__c__ferror :: (ret: &i32, ___stream: &FILE);
__c__clearerr_unlocked :: (___stream: &FILE);
__c__feof_unlocked :: (ret: &i32, ___stream: &FILE);
__c__ferror_unlocked :: (ret: &i32, ___stream: &FILE);
__c__perror :: (___s: &char8);
__c__fileno :: (ret: &i32, ___stream: &FILE);
__c__fileno_unlocked :: (ret: &i32, ___stream: &FILE);
__c__popen :: (ret: &&FILE, ___command: &char8, ___modes: &char8);
__c__pclose :: (ret: &i32, ___stream: &FILE);
__c__ctermid :: (ret: &&char8, ___s: &char8);
__c__flockfile :: (___stream: &FILE);
__c__ftrylockfile :: (ret: &i32, ___stream: &FILE);
__c__funlockfile :: (___stream: &FILE);
__c____ctype_get_mb_cur_max :: (ret: &size_t);
__c__atof :: (ret: &f64, ___nptr: &char8);
__c__atoi :: (ret: &i32, ___nptr: &char8);
__c__atol :: (ret: &i32, ___nptr: &char8);
__c__atoll :: (ret: &i64, ___nptr: &char8);
__c__strtod :: (ret: &f64, ___nptr: &char8, ___endptr: &&char8);
__c__strtof :: (ret: &f32, ___nptr: &char8, ___endptr: &&char8);
__c__strtold :: (ret: &__UNKNOWN_8, ___nptr: &char8, ___endptr: &&char8);
__c__strtol :: (ret: &i32, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__strtoul :: (ret: &u32, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__strtoq :: (ret: &i64, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__strtouq :: (ret: &u64, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__strtoll :: (ret: &i64, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__strtoull :: (ret: &u64, ___nptr: &char8, ___endptr: &&char8, ___base: i32);
__c__l64a :: (ret: &&char8, ___n: i32);
__c__a64l :: (ret: &i32, ___s: &char8);
__c__select :: (ret: &i32, ___nfds: i32, ___readfds: &fd_set, ___writefds: &fd_set, ___exceptfds: &fd_set, ___timeout: &timeval);
__c__pselect :: (ret: &i32, ___nfds: i32, ___readfds: &fd_set, ___writefds: &fd_set, ___exceptfds: &fd_set, ___timeout: &timespec, ___sigmask: &__sigset_t);
__c__gnu_dev_major :: (ret: &u32, ___dev: __dev_t);
__c__gnu_dev_minor :: (ret: &u32, ___dev: __dev_t);
__c__gnu_dev_makedev :: (ret: &__dev_t, ___major: u32, ___minor: u32);
__c__random :: (ret: &i32);
__c__srandom :: (___seed: u32);
__c__initstate :: (ret: &&char8, ___seed: u32, ___statebuf: &char8, ___statelen: size_t);
__c__setstate :: (ret: &&char8, ___statebuf: &char8);
__c__random_r :: (ret: &i32, ___buf: &random_data, ___result: &int32_t);
__c__srandom_r :: (ret: &i32, ___seed: u32, ___buf: &random_data);
__c__initstate_r :: (ret: &i32, ___seed: u32, ___statebuf: &char8, ___statelen: size_t, ___buf: &random_data);
__c__setstate_r :: (ret: &i32, ___statebuf: &char8, ___buf: &random_data);
__c__rand :: (ret: &i32);
__c__srand :: (___seed: u32);
__c__rand_r :: (ret: &i32, ___seed: &u32);
__c__drand48 :: (ret: &f64);
__c__erand48 :: (ret: &f64, ___xsubi: &u16);
__c__lrand48 :: (ret: &i32);
__c__nrand48 :: (ret: &i32, ___xsubi: &u16);
__c__mrand48 :: (ret: &i32);
__c__jrand48 :: (ret: &i32, ___xsubi: &u16);
__c__srand48 :: (___seedval: i32);
__c__seed48 :: (ret: &&u16, ___seed16v: &u16);
__c__lcong48 :: (___param: &u16);
__c__drand48_r :: (ret: &i32, ___buffer: &drand48_data, ___result: &f64);
__c__erand48_r :: (ret: &i32, ___xsubi: &u16, ___buffer: &drand48_data, ___result: &f64);
__c__lrand48_r :: (ret: &i32, ___buffer: &drand48_data, ___result: &i32);
__c__nrand48_r :: (ret: &i32, ___xsubi: &u16, ___buffer: &drand48_data, ___result: &i32);
__c__mrand48_r :: (ret: &i32, ___buffer: &drand48_data, ___result: &i32);
__c__jrand48_r :: (ret: &i32, ___xsubi: &u16, ___buffer: &drand48_data, ___result: &i32);
__c__srand48_r :: (ret: &i32, ___seedval: i32, ___buffer: &drand48_data);
__c__seed48_r :: (ret: &i32, ___seed16v: &u16, ___buffer: &drand48_data);
__c__lcong48_r :: (ret: &i32, ___param: &u16, ___buffer: &drand48_data);
__c__malloc :: (ret: &&void, ___size: size_t);
__c__calloc :: (ret: &&void, ___nmemb: size_t, ___size: size_t);
__c__realloc :: (ret: &&void, ___ptr: &void, ___size: size_t);
__c__free :: (___ptr: &void);
__c__alloca :: (ret: &&void, ___size: size_t);
__c__valloc :: (ret: &&void, ___size: size_t);
__c__posix_memalign :: (ret: &i32, ___memptr: &&void, ___alignment: size_t, ___size: size_t);
__c__aligned_alloc :: (ret: &&void, ___alignment: size_t, ___size: size_t);
__c__abort :: ();
__c__atexit :: (ret: &i32, ___func: fn() -> void);
__c__at_quick_exit :: (ret: &i32, ___func: fn() -> void);
__c__on_exit :: (ret: &i32, ___func: fn(i32, &void) -> void, ___arg: &void);
__c__exit :: (___status: i32);
__c__quick_exit :: (___status: i32);
__c___Exit :: (___status: i32);
__c__getenv :: (ret: &&char8, ___name: &char8);
__c__putenv :: (ret: &i32, ___string: &char8);
__c__setenv :: (ret: &i32, ___name: &char8, ___value: &char8, ___replace: i32);
__c__unsetenv :: (ret: &i32, ___name: &char8);
__c__clearenv :: (ret: &i32);
__c__mktemp :: (ret: &&char8, ___template: &char8);
__c__mkstemp :: (ret: &i32, ___template: &char8);
__c__mkstemps :: (ret: &i32, ___template: &char8, ___suffixlen: i32);
__c__mkdtemp :: (ret: &&char8, ___template: &char8);
__c__system :: (ret: &i32, ___command: &char8);
__c__realpath :: (ret: &&char8, ___name: &char8, ___resolved: &char8);
__c__bsearch :: (ret: &&void, ___key: &void, ___base: &void, ___nmemb: size_t, ___size: size_t, ___compar: __compar_fn_t);
__c__qsort :: (___base: &void, ___nmemb: size_t, ___size: size_t, ___compar: __compar_fn_t);
__c__abs :: (ret: &i32, ___x: i32);
__c__labs :: (ret: &i32, ___x: i32);
__c__llabs :: (ret: &i64, ___x: i64);
__c__div :: (ret: &div_t, ___numer: i32, ___denom: i32);
__c__ldiv :: (ret: &ldiv_t, ___numer: i32, ___denom: i32);
__c__lldiv :: (ret: &lldiv_t, ___numer: i64, ___denom: i64);
__c__ecvt :: (ret: &&char8, ___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32);
__c__fcvt :: (ret: &&char8, ___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32);
__c__gcvt :: (ret: &&char8, ___value: f64, ___ndigit: i32, ___buf: &char8);
__c__qecvt :: (ret: &&char8, ___value: &__UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32);
__c__qfcvt :: (ret: &&char8, ___value: &__UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32);
__c__qgcvt :: (ret: &&char8, ___value: &__UNKNOWN_8, ___ndigit: i32, ___buf: &char8);
__c__ecvt_r :: (ret: &i32, ___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t);
__c__fcvt_r :: (ret: &i32, ___value: f64, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t);
__c__qecvt_r :: (ret: &i32, ___value: &__UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t);
__c__qfcvt_r :: (ret: &i32, ___value: &__UNKNOWN_8, ___ndigit: i32, ___decpt: &i32, ___sign: &i32, ___buf: &char8, ___len: size_t);
__c__mblen :: (ret: &i32, ___s: &char8, ___n: size_t);
__c__mbtowc :: (ret: &i32, ___pwc: &char16, ___s: &char8, ___n: size_t);
__c__wctomb :: (ret: &i32, ___s: &char8, ___wchar: char16);
__c__mbstowcs :: (ret: &size_t, ___pwcs: &char16, ___s: &char8, ___n: size_t);
__c__wcstombs :: (ret: &size_t, ___s: &char8, ___pwcs: &char16, ___n: size_t);
__c__rpmatch :: (ret: &i32, ___response: &char8);
__c__getsubopt :: (ret: &i32, ___optionp: &&char8, ___tokens: &&char8, ___valuep: &&char8);
__c__getloadavg :: (ret: &i32, ___loadavg: &f64, ___nelem: i32);
__c__stbi_load_from_memory :: (ret: &&stbi_uc, _buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_from_callbacks :: (ret: &&stbi_uc, _clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load :: (ret: &&stbi_uc, _filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_from_file :: (ret: &&stbi_uc, _f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_gif_from_memory :: (ret: &&stbi_uc, _buffer: &stbi_uc, _len: i32, _delays: &&i32, _x: &i32, _y: &i32, _z: &i32, _comp: &i32, _req_comp: i32);
__c__stbi_load_16_from_memory :: (ret: &&stbi_us, _buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_16_from_callbacks :: (ret: &&stbi_us, _clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_16 :: (ret: &&stbi_us, _filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_load_from_file_16 :: (ret: &&stbi_us, _f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_loadf_from_memory :: (ret: &&f32, _buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_loadf_from_callbacks :: (ret: &&f32, _clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_loadf :: (ret: &&f32, _filename: &char8, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_loadf_from_file :: (ret: &&f32, _f: &FILE, _x: &i32, _y: &i32, _channels_in_file: &i32, _desired_channels: i32);
__c__stbi_hdr_to_ldr_gamma :: (_gamma: f32);
__c__stbi_hdr_to_ldr_scale :: (_scale: f32);
__c__stbi_ldr_to_hdr_gamma :: (_gamma: f32);
__c__stbi_ldr_to_hdr_scale :: (_scale: f32);
__c__stbi_is_hdr_from_callbacks :: (ret: &i32, _clbk: &stbi_io_callbacks, _user: &void);
__c__stbi_is_hdr_from_memory :: (ret: &i32, _buffer: &stbi_uc, _len: i32);
__c__stbi_is_hdr :: (ret: &i32, _filename: &char8);
__c__stbi_is_hdr_from_file :: (ret: &i32, _f: &FILE);
__c__stbi_failure_reason :: (ret: &&char8);
__c__stbi_image_free :: (_retval_from_stbi_load: &void);
__c__stbi_info_from_memory :: (ret: &i32, _buffer: &stbi_uc, _len: i32, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi_info_from_callbacks :: (ret: &i32, _clbk: &stbi_io_callbacks, _user: &void, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi_is_16_bit_from_memory :: (ret: &i32, _buffer: &stbi_uc, _len: i32);
__c__stbi_is_16_bit_from_callbacks :: (ret: &i32, _clbk: &stbi_io_callbacks, _user: &void);
__c__stbi_info :: (ret: &i32, _filename: &char8, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi_info_from_file :: (ret: &i32, _f: &FILE, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi_is_16_bit :: (ret: &i32, _filename: &char8);
__c__stbi_is_16_bit_from_file :: (ret: &i32, _f: &FILE);
__c__stbi_set_unpremultiply_on_load :: (_flag_true_if_should_unpremultiply: i32);
__c__stbi_convert_iphone_png_to_rgb :: (_flag_true_if_should_convert: i32);
__c__stbi_set_flip_vertically_on_load :: (_flag_true_if_should_flip: i32);
__c__stbi_set_flip_vertically_on_load_thread :: (_flag_true_if_should_flip: i32);
__c__stbi_zlib_decode_malloc_guesssize :: (ret: &&char8, _buffer: &char8, _len: i32, _initial_size: i32, _outlen: &i32);
__c__stbi_zlib_decode_malloc_guesssize_headerflag :: (ret: &&char8, _buffer: &char8, _len: i32, _initial_size: i32, _outlen: &i32, _parse_header: i32);
__c__stbi_zlib_decode_malloc :: (ret: &&char8, _buffer: &char8, _len: i32, _outlen: &i32);
__c__stbi_zlib_decode_buffer :: (ret: &i32, _obuffer: &char8, _olen: i32, _ibuffer: &char8, _ilen: i32);
__c__stbi_zlib_decode_noheader_malloc :: (ret: &&char8, _buffer: &char8, _len: i32, _outlen: &i32);
__c__stbi_zlib_decode_noheader_buffer :: (ret: &i32, _obuffer: &char8, _olen: i32, _ibuffer: &char8, _ilen: i32);
__c__memcpy :: (ret: &&void, ___dest: &void, ___src: &void, ___n: size_t);
__c__memmove :: (ret: &&void, ___dest: &void, ___src: &void, ___n: size_t);
__c__memccpy :: (ret: &&void, ___dest: &void, ___src: &void, ___c: i32, ___n: size_t);
__c__memset :: (ret: &&void, ___s: &void, ___c: i32, ___n: size_t);
__c__memcmp :: (ret: &i32, ___s1: &void, ___s2: &void, ___n: size_t);
__c__memchr :: (ret: &&void, ___s: &void, ___c: i32, ___n: size_t);
__c__strcpy :: (ret: &&char8, ___dest: &char8, ___src: &char8);
__c__strncpy :: (ret: &&char8, ___dest: &char8, ___src: &char8, ___n: size_t);
__c__strcat :: (ret: &&char8, ___dest: &char8, ___src: &char8);
__c__strncat :: (ret: &&char8, ___dest: &char8, ___src: &char8, ___n: size_t);
__c__strcmp :: (ret: &i32, ___s1: &char8, ___s2: &char8);
__c__strncmp :: (ret: &i32, ___s1: &char8, ___s2: &char8, ___n: size_t);
__c__strcoll :: (ret: &i32, ___s1: &char8, ___s2: &char8);
__c__strxfrm :: (ret: &size_t, ___dest: &char8, ___src: &char8, ___n: size_t);
__c__strcoll_l :: (ret: &i32, ___s1: &char8, ___s2: &char8, ___l: locale_t);
__c__strxfrm_l :: (ret: &size_t, ___dest: &char8, ___src: &char8, ___n: size_t, ___l: locale_t);
__c__strdup :: (ret: &&char8, ___s: &char8);
__c__strndup :: (ret: &&char8, ___string: &char8, ___n: size_t);
__c__strchr :: (ret: &&char8, ___s: &char8, ___c: i32);
__c__strrchr :: (ret: &&char8, ___s: &char8, ___c: i32);
__c__strcspn :: (ret: &size_t, ___s: &char8, ___reject: &char8);
__c__strspn :: (ret: &size_t, ___s: &char8, ___accept: &char8);
__c__strpbrk :: (ret: &&char8, ___s: &char8, ___accept: &char8);
__c__strstr :: (ret: &&char8, ___haystack: &char8, ___needle: &char8);
__c__strtok :: (ret: &&char8, ___s: &char8, ___delim: &char8);
__c____strtok_r :: (ret: &&char8, ___s: &char8, ___delim: &char8, ___save_ptr: &&char8);
__c__strtok_r :: (ret: &&char8, ___s: &char8, ___delim: &char8, ___save_ptr: &&char8);
__c__strlen :: (ret: &size_t, ___s: &char8);
__c__strnlen :: (ret: &size_t, ___string: &char8, ___maxlen: size_t);
__c__strerror :: (ret: &&char8, ___errnum: i32);
__c__strerror_r :: (ret: &i32, ___errnum: i32, ___buf: &char8, ___buflen: size_t);
__c__strerror_l :: (ret: &&char8, ___errnum: i32, ___l: locale_t);
__c__bcmp :: (ret: &i32, ___s1: &void, ___s2: &void, ___n: size_t);
__c__bcopy :: (___src: &void, ___dest: &void, ___n: size_t);
__c__bzero :: (___s: &void, ___n: size_t);
__c__index :: (ret: &&char8, ___s: &char8, ___c: i32);
__c__rindex :: (ret: &&char8, ___s: &char8, ___c: i32);
__c__ffs :: (ret: &i32, ___i: i32);
__c__ffsl :: (ret: &i32, ___l: i32);
__c__ffsll :: (ret: &i32, ___ll: i64);
__c__strcasecmp :: (ret: &i32, ___s1: &char8, ___s2: &char8);
__c__strncasecmp :: (ret: &i32, ___s1: &char8, ___s2: &char8, ___n: size_t);
__c__strcasecmp_l :: (ret: &i32, ___s1: &char8, ___s2: &char8, ___loc: locale_t);
__c__strncasecmp_l :: (ret: &i32, ___s1: &char8, ___s2: &char8, ___n: size_t, ___loc: locale_t);
__c__explicit_bzero :: (___s: &void, ___n: size_t);
__c__strsep :: (ret: &&char8, ___stringp: &&char8, ___delim: &char8);
__c__strsignal :: (ret: &&char8, ___sig: i32);
__c____stpcpy :: (ret: &&char8, ___dest: &char8, ___src: &char8);
__c__stpcpy :: (ret: &&char8, ___dest: &char8, ___src: &char8);
__c____stpncpy :: (ret: &&char8, ___dest: &char8, ___src: &char8, ___n: size_t);
__c__stpncpy :: (ret: &&char8, ___dest: &char8, ___src: &char8, ___n: size_t);
__c____fpclassify :: (ret: &i32, ___value: f64);
__c____signbit :: (ret: &i32, ___value: f64);
__c____isinf :: (ret: &i32, ___value: f64);
__c____finite :: (ret: &i32, ___value: f64);
__c____isnan :: (ret: &i32, ___value: f64);
__c____iseqsig :: (ret: &i32, ___x: f64, ___y: f64);
__c____issignaling :: (ret: &i32, ___value: f64);
__c__acos :: (ret: &f64, ___x: f64);
__c____acos :: (ret: &f64, ___x: f64);
__c__asin :: (ret: &f64, ___x: f64);
__c____asin :: (ret: &f64, ___x: f64);
__c__atan :: (ret: &f64, ___x: f64);
__c____atan :: (ret: &f64, ___x: f64);
__c__atan2 :: (ret: &f64, ___y: f64, ___x: f64);
__c____atan2 :: (ret: &f64, ___y: f64, ___x: f64);
__c__cos :: (ret: &f64, ___x: f64);
__c____cos :: (ret: &f64, ___x: f64);
__c__sin :: (ret: &f64, ___x: f64);
__c____sin :: (ret: &f64, ___x: f64);
__c__tan :: (ret: &f64, ___x: f64);
__c____tan :: (ret: &f64, ___x: f64);
__c__cosh :: (ret: &f64, ___x: f64);
__c____cosh :: (ret: &f64, ___x: f64);
__c__sinh :: (ret: &f64, ___x: f64);
__c____sinh :: (ret: &f64, ___x: f64);
__c__tanh :: (ret: &f64, ___x: f64);
__c____tanh :: (ret: &f64, ___x: f64);
__c__acosh :: (ret: &f64, ___x: f64);
__c____acosh :: (ret: &f64, ___x: f64);
__c__asinh :: (ret: &f64, ___x: f64);
__c____asinh :: (ret: &f64, ___x: f64);
__c__atanh :: (ret: &f64, ___x: f64);
__c____atanh :: (ret: &f64, ___x: f64);
__c__exp :: (ret: &f64, ___x: f64);
__c____exp :: (ret: &f64, ___x: f64);
__c__frexp :: (ret: &f64, ___x: f64, ___exponent: &i32);
__c____frexp :: (ret: &f64, ___x: f64, ___exponent: &i32);
__c__ldexp :: (ret: &f64, ___x: f64, ___exponent: i32);
__c____ldexp :: (ret: &f64, ___x: f64, ___exponent: i32);
__c__log :: (ret: &f64, ___x: f64);
__c____log :: (ret: &f64, ___x: f64);
__c__log10 :: (ret: &f64, ___x: f64);
__c____log10 :: (ret: &f64, ___x: f64);
__c__modf :: (ret: &f64, ___x: f64, ___iptr: &f64);
__c____modf :: (ret: &f64, ___x: f64, ___iptr: &f64);
__c__expm1 :: (ret: &f64, ___x: f64);
__c____expm1 :: (ret: &f64, ___x: f64);
__c__log1p :: (ret: &f64, ___x: f64);
__c____log1p :: (ret: &f64, ___x: f64);
__c__logb :: (ret: &f64, ___x: f64);
__c____logb :: (ret: &f64, ___x: f64);
__c__exp2 :: (ret: &f64, ___x: f64);
__c____exp2 :: (ret: &f64, ___x: f64);
__c__log2 :: (ret: &f64, ___x: f64);
__c____log2 :: (ret: &f64, ___x: f64);
__c__pow :: (ret: &f64, ___x: f64, ___y: f64);
__c____pow :: (ret: &f64, ___x: f64, ___y: f64);
__c__sqrt :: (ret: &f64, ___x: f64);
__c____sqrt :: (ret: &f64, ___x: f64);
__c__hypot :: (ret: &f64, ___x: f64, ___y: f64);
__c____hypot :: (ret: &f64, ___x: f64, ___y: f64);
__c__cbrt :: (ret: &f64, ___x: f64);
__c____cbrt :: (ret: &f64, ___x: f64);
__c__ceil :: (ret: &f64, ___x: f64);
__c____ceil :: (ret: &f64, ___x: f64);
__c__fabs :: (ret: &f64, ___x: f64);
__c____fabs :: (ret: &f64, ___x: f64);
__c__floor :: (ret: &f64, ___x: f64);
__c____floor :: (ret: &f64, ___x: f64);
__c__fmod :: (ret: &f64, ___x: f64, ___y: f64);
__c____fmod :: (ret: &f64, ___x: f64, ___y: f64);
__c__isinf :: (ret: &i32, ___value: f64);
__c__finite :: (ret: &i32, ___value: f64);
__c__drem :: (ret: &f64, ___x: f64, ___y: f64);
__c____drem :: (ret: &f64, ___x: f64, ___y: f64);
__c__significand :: (ret: &f64, ___x: f64);
__c____significand :: (ret: &f64, ___x: f64);
__c__copysign :: (ret: &f64, ___x: f64, ___y: f64);
__c____copysign :: (ret: &f64, ___x: f64, ___y: f64);
__c__nan :: (ret: &f64, ___tagb: &char8);
__c____nan :: (ret: &f64, ___tagb: &char8);
__c__isnan :: (ret: &i32, ___value: f64);
__c__j0 :: (ret: &f64, _0: f64);
__c____j0 :: (ret: &f64, _0: f64);
__c__j1 :: (ret: &f64, _0: f64);
__c____j1 :: (ret: &f64, _0: f64);
__c__jn :: (ret: &f64, _0: i32, _1: f64);
__c____jn :: (ret: &f64, _0: i32, _1: f64);
__c__y0 :: (ret: &f64, _0: f64);
__c____y0 :: (ret: &f64, _0: f64);
__c__y1 :: (ret: &f64, _0: f64);
__c____y1 :: (ret: &f64, _0: f64);
__c__yn :: (ret: &f64, _0: i32, _1: f64);
__c____yn :: (ret: &f64, _0: i32, _1: f64);
__c__erf :: (ret: &f64, _0: f64);
__c____erf :: (ret: &f64, _0: f64);
__c__erfc :: (ret: &f64, _0: f64);
__c____erfc :: (ret: &f64, _0: f64);
__c__lgamma :: (ret: &f64, _0: f64);
__c____lgamma :: (ret: &f64, _0: f64);
__c__tgamma :: (ret: &f64, _0: f64);
__c____tgamma :: (ret: &f64, _0: f64);
__c__gamma :: (ret: &f64, _0: f64);
__c____gamma :: (ret: &f64, _0: f64);
__c__lgamma_r :: (ret: &f64, _0: f64, ___signgamp: &i32);
__c____lgamma_r :: (ret: &f64, _0: f64, ___signgamp: &i32);
__c__rint :: (ret: &f64, ___x: f64);
__c____rint :: (ret: &f64, ___x: f64);
__c__nextafter :: (ret: &f64, ___x: f64, ___y: f64);
__c____nextafter :: (ret: &f64, ___x: f64, ___y: f64);
__c__nexttoward :: (ret: &f64, ___x: f64, ___y: &__UNKNOWN_8);
__c____nexttoward :: (ret: &f64, ___x: f64, ___y: &__UNKNOWN_8);
__c__remainder :: (ret: &f64, ___x: f64, ___y: f64);
__c____remainder :: (ret: &f64, ___x: f64, ___y: f64);
__c__scalbn :: (ret: &f64, ___x: f64, ___n: i32);
__c____scalbn :: (ret: &f64, ___x: f64, ___n: i32);
__c__ilogb :: (ret: &i32, ___x: f64);
__c____ilogb :: (ret: &i32, ___x: f64);
__c__scalbln :: (ret: &f64, ___x: f64, ___n: i32);
__c____scalbln :: (ret: &f64, ___x: f64, ___n: i32);
__c__nearbyint :: (ret: &f64, ___x: f64);
__c____nearbyint :: (ret: &f64, ___x: f64);
__c__round :: (ret: &f64, ___x: f64);
__c____round :: (ret: &f64, ___x: f64);
__c__trunc :: (ret: &f64, ___x: f64);
__c____trunc :: (ret: &f64, ___x: f64);
__c__remquo :: (ret: &f64, ___x: f64, ___y: f64, ___quo: &i32);
__c____remquo :: (ret: &f64, ___x: f64, ___y: f64, ___quo: &i32);
__c__lrint :: (ret: &i32, ___x: f64);
__c____lrint :: (ret: &i32, ___x: f64);
__c__llrint :: (ret: &i64, ___x: f64);
__c____llrint :: (ret: &i64, ___x: f64);
__c__lround :: (ret: &i32, ___x: f64);
__c____lround :: (ret: &i32, ___x: f64);
__c__llround :: (ret: &i64, ___x: f64);
__c____llround :: (ret: &i64, ___x: f64);
__c__fdim :: (ret: &f64, ___x: f64, ___y: f64);
__c____fdim :: (ret: &f64, ___x: f64, ___y: f64);
__c__fmax :: (ret: &f64, ___x: f64, ___y: f64);
__c____fmax :: (ret: &f64, ___x: f64, ___y: f64);
__c__fmin :: (ret: &f64, ___x: f64, ___y: f64);
__c____fmin :: (ret: &f64, ___x: f64, ___y: f64);
__c__fma :: (ret: &f64, ___x: f64, ___y: f64, ___z: f64);
__c____fma :: (ret: &f64, ___x: f64, ___y: f64, ___z: f64);
__c__scalb :: (ret: &f64, ___x: f64, ___n: f64);
__c____scalb :: (ret: &f64, ___x: f64, ___n: f64);
__c____fpclassifyf :: (ret: &i32, ___value: f32);
__c____signbitf :: (ret: &i32, ___value: f32);
__c____isinff :: (ret: &i32, ___value: f32);
__c____finitef :: (ret: &i32, ___value: f32);
__c____isnanf :: (ret: &i32, ___value: f32);
__c____iseqsigf :: (ret: &i32, ___x: f32, ___y: f32);
__c____issignalingf :: (ret: &i32, ___value: f32);
__c__acosf :: (ret: &f32, ___x: f32);
__c____acosf :: (ret: &f32, ___x: f32);
__c__asinf :: (ret: &f32, ___x: f32);
__c____asinf :: (ret: &f32, ___x: f32);
__c__atanf :: (ret: &f32, ___x: f32);
__c____atanf :: (ret: &f32, ___x: f32);
__c__atan2f :: (ret: &f32, ___y: f32, ___x: f32);
__c____atan2f :: (ret: &f32, ___y: f32, ___x: f32);
__c__cosf :: (ret: &f32, ___x: f32);
__c____cosf :: (ret: &f32, ___x: f32);
__c__sinf :: (ret: &f32, ___x: f32);
__c____sinf :: (ret: &f32, ___x: f32);
__c__tanf :: (ret: &f32, ___x: f32);
__c____tanf :: (ret: &f32, ___x: f32);
__c__coshf :: (ret: &f32, ___x: f32);
__c____coshf :: (ret: &f32, ___x: f32);
__c__sinhf :: (ret: &f32, ___x: f32);
__c____sinhf :: (ret: &f32, ___x: f32);
__c__tanhf :: (ret: &f32, ___x: f32);
__c____tanhf :: (ret: &f32, ___x: f32);
__c__acoshf :: (ret: &f32, ___x: f32);
__c____acoshf :: (ret: &f32, ___x: f32);
__c__asinhf :: (ret: &f32, ___x: f32);
__c____asinhf :: (ret: &f32, ___x: f32);
__c__atanhf :: (ret: &f32, ___x: f32);
__c____atanhf :: (ret: &f32, ___x: f32);
__c__expf :: (ret: &f32, ___x: f32);
__c____expf :: (ret: &f32, ___x: f32);
__c__frexpf :: (ret: &f32, ___x: f32, ___exponent: &i32);
__c____frexpf :: (ret: &f32, ___x: f32, ___exponent: &i32);
__c__ldexpf :: (ret: &f32, ___x: f32, ___exponent: i32);
__c____ldexpf :: (ret: &f32, ___x: f32, ___exponent: i32);
__c__logf :: (ret: &f32, ___x: f32);
__c____logf :: (ret: &f32, ___x: f32);
__c__log10f :: (ret: &f32, ___x: f32);
__c____log10f :: (ret: &f32, ___x: f32);
__c__modff :: (ret: &f32, ___x: f32, ___iptr: &f32);
__c____modff :: (ret: &f32, ___x: f32, ___iptr: &f32);
__c__expm1f :: (ret: &f32, ___x: f32);
__c____expm1f :: (ret: &f32, ___x: f32);
__c__log1pf :: (ret: &f32, ___x: f32);
__c____log1pf :: (ret: &f32, ___x: f32);
__c__logbf :: (ret: &f32, ___x: f32);
__c____logbf :: (ret: &f32, ___x: f32);
__c__exp2f :: (ret: &f32, ___x: f32);
__c____exp2f :: (ret: &f32, ___x: f32);
__c__log2f :: (ret: &f32, ___x: f32);
__c____log2f :: (ret: &f32, ___x: f32);
__c__powf :: (ret: &f32, ___x: f32, ___y: f32);
__c____powf :: (ret: &f32, ___x: f32, ___y: f32);
__c__sqrtf :: (ret: &f32, ___x: f32);
__c____sqrtf :: (ret: &f32, ___x: f32);
__c__hypotf :: (ret: &f32, ___x: f32, ___y: f32);
__c____hypotf :: (ret: &f32, ___x: f32, ___y: f32);
__c__cbrtf :: (ret: &f32, ___x: f32);
__c____cbrtf :: (ret: &f32, ___x: f32);
__c__ceilf :: (ret: &f32, ___x: f32);
__c____ceilf :: (ret: &f32, ___x: f32);
__c__fabsf :: (ret: &f32, ___x: f32);
__c____fabsf :: (ret: &f32, ___x: f32);
__c__floorf :: (ret: &f32, ___x: f32);
__c____floorf :: (ret: &f32, ___x: f32);
__c__fmodf :: (ret: &f32, ___x: f32, ___y: f32);
__c____fmodf :: (ret: &f32, ___x: f32, ___y: f32);
__c__isinff :: (ret: &i32, ___value: f32);
__c__finitef :: (ret: &i32, ___value: f32);
__c__dremf :: (ret: &f32, ___x: f32, ___y: f32);
__c____dremf :: (ret: &f32, ___x: f32, ___y: f32);
__c__significandf :: (ret: &f32, ___x: f32);
__c____significandf :: (ret: &f32, ___x: f32);
__c__copysignf :: (ret: &f32, ___x: f32, ___y: f32);
__c____copysignf :: (ret: &f32, ___x: f32, ___y: f32);
__c__nanf :: (ret: &f32, ___tagb: &char8);
__c____nanf :: (ret: &f32, ___tagb: &char8);
__c__isnanf :: (ret: &i32, ___value: f32);
__c__j0f :: (ret: &f32, _0: f32);
__c____j0f :: (ret: &f32, _0: f32);
__c__j1f :: (ret: &f32, _0: f32);
__c____j1f :: (ret: &f32, _0: f32);
__c__jnf :: (ret: &f32, _0: i32, _1: f32);
__c____jnf :: (ret: &f32, _0: i32, _1: f32);
__c__y0f :: (ret: &f32, _0: f32);
__c____y0f :: (ret: &f32, _0: f32);
__c__y1f :: (ret: &f32, _0: f32);
__c____y1f :: (ret: &f32, _0: f32);
__c__ynf :: (ret: &f32, _0: i32, _1: f32);
__c____ynf :: (ret: &f32, _0: i32, _1: f32);
__c__erff :: (ret: &f32, _0: f32);
__c____erff :: (ret: &f32, _0: f32);
__c__erfcf :: (ret: &f32, _0: f32);
__c____erfcf :: (ret: &f32, _0: f32);
__c__lgammaf :: (ret: &f32, _0: f32);
__c____lgammaf :: (ret: &f32, _0: f32);
__c__tgammaf :: (ret: &f32, _0: f32);
__c____tgammaf :: (ret: &f32, _0: f32);
__c__gammaf :: (ret: &f32, _0: f32);
__c____gammaf :: (ret: &f32, _0: f32);
__c__lgammaf_r :: (ret: &f32, _0: f32, ___signgamp: &i32);
__c____lgammaf_r :: (ret: &f32, _0: f32, ___signgamp: &i32);
__c__rintf :: (ret: &f32, ___x: f32);
__c____rintf :: (ret: &f32, ___x: f32);
__c__nextafterf :: (ret: &f32, ___x: f32, ___y: f32);
__c____nextafterf :: (ret: &f32, ___x: f32, ___y: f32);
__c__nexttowardf :: (ret: &f32, ___x: f32, ___y: &__UNKNOWN_8);
__c____nexttowardf :: (ret: &f32, ___x: f32, ___y: &__UNKNOWN_8);
__c__remainderf :: (ret: &f32, ___x: f32, ___y: f32);
__c____remainderf :: (ret: &f32, ___x: f32, ___y: f32);
__c__scalbnf :: (ret: &f32, ___x: f32, ___n: i32);
__c____scalbnf :: (ret: &f32, ___x: f32, ___n: i32);
__c__ilogbf :: (ret: &i32, ___x: f32);
__c____ilogbf :: (ret: &i32, ___x: f32);
__c__scalblnf :: (ret: &f32, ___x: f32, ___n: i32);
__c____scalblnf :: (ret: &f32, ___x: f32, ___n: i32);
__c__nearbyintf :: (ret: &f32, ___x: f32);
__c____nearbyintf :: (ret: &f32, ___x: f32);
__c__roundf :: (ret: &f32, ___x: f32);
__c____roundf :: (ret: &f32, ___x: f32);
__c__truncf :: (ret: &f32, ___x: f32);
__c____truncf :: (ret: &f32, ___x: f32);
__c__remquof :: (ret: &f32, ___x: f32, ___y: f32, ___quo: &i32);
__c____remquof :: (ret: &f32, ___x: f32, ___y: f32, ___quo: &i32);
__c__lrintf :: (ret: &i32, ___x: f32);
__c____lrintf :: (ret: &i32, ___x: f32);
__c__llrintf :: (ret: &i64, ___x: f32);
__c____llrintf :: (ret: &i64, ___x: f32);
__c__lroundf :: (ret: &i32, ___x: f32);
__c____lroundf :: (ret: &i32, ___x: f32);
__c__llroundf :: (ret: &i64, ___x: f32);
__c____llroundf :: (ret: &i64, ___x: f32);
__c__fdimf :: (ret: &f32, ___x: f32, ___y: f32);
__c____fdimf :: (ret: &f32, ___x: f32, ___y: f32);
__c__fmaxf :: (ret: &f32, ___x: f32, ___y: f32);
__c____fmaxf :: (ret: &f32, ___x: f32, ___y: f32);
__c__fminf :: (ret: &f32, ___x: f32, ___y: f32);
__c____fminf :: (ret: &f32, ___x: f32, ___y: f32);
__c__fmaf :: (ret: &f32, ___x: f32, ___y: f32, ___z: f32);
__c____fmaf :: (ret: &f32, ___x: f32, ___y: f32, ___z: f32);
__c__scalbf :: (ret: &f32, ___x: f32, ___n: f32);
__c____scalbf :: (ret: &f32, ___x: f32, ___n: f32);
__c____fpclassifyl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c____signbitl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c____isinfl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c____finitel :: (ret: &i32, ___value: &__UNKNOWN_8);
__c____isnanl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c____iseqsigl :: (ret: &i32, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____issignalingl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c__acosl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____acosl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__asinl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____asinl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__atanl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____atanl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__atan2l :: (ret: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____atan2l :: (ret: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__cosl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____cosl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__sinl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____sinl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__tanl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____tanl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__coshl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____coshl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__sinhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____sinhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__tanhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____tanhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__acoshl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____acoshl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__asinhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____asinhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__atanhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____atanhl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__expl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____expl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__frexpl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___exponent: &i32);
__c____frexpl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___exponent: &i32);
__c__ldexpl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___exponent: i32);
__c____ldexpl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___exponent: i32);
__c__logl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____logl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__log10l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____log10l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__modfl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___iptr: &__UNKNOWN_8);
__c____modfl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___iptr: &__UNKNOWN_8);
__c__expm1l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____expm1l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__log1pl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____log1pl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__logbl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____logbl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__exp2l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____exp2l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__log2l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____log2l :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__powl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____powl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__sqrtl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____sqrtl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__hypotl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____hypotl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__cbrtl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____cbrtl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__ceill :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____ceill :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__fabsl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____fabsl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__floorl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____floorl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__fmodl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____fmodl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__isinfl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c__finitel :: (ret: &i32, ___value: &__UNKNOWN_8);
__c__dreml :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____dreml :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__significandl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____significandl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__copysignl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____copysignl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__nanl :: (ret: &__UNKNOWN_8, ___tagb: &char8);
__c____nanl :: (ret: &__UNKNOWN_8, ___tagb: &char8);
__c__isnanl :: (ret: &i32, ___value: &__UNKNOWN_8);
__c__j0l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____j0l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__j1l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____j1l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__jnl :: (ret: &__UNKNOWN_8, _0: i32, _1: &__UNKNOWN_8);
__c____jnl :: (ret: &__UNKNOWN_8, _0: i32, _1: &__UNKNOWN_8);
__c__y0l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____y0l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__y1l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____y1l :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__ynl :: (ret: &__UNKNOWN_8, _0: i32, _1: &__UNKNOWN_8);
__c____ynl :: (ret: &__UNKNOWN_8, _0: i32, _1: &__UNKNOWN_8);
__c__erfl :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____erfl :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__erfcl :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____erfcl :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__lgammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____lgammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__tgammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____tgammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__gammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c____gammal :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8);
__c__lgammal_r :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8, ___signgamp: &i32);
__c____lgammal_r :: (ret: &__UNKNOWN_8, _0: &__UNKNOWN_8, ___signgamp: &i32);
__c__rintl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____rintl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__nextafterl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____nextafterl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__nexttowardl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____nexttowardl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__remainderl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____remainderl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__scalbnl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: i32);
__c____scalbnl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: i32);
__c__ilogbl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c____ilogbl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c__scalblnl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: i32);
__c____scalblnl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: i32);
__c__nearbyintl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____nearbyintl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__roundl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____roundl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__truncl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c____truncl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8);
__c__remquol :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___quo: &i32);
__c____remquol :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___quo: &i32);
__c__lrintl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c____lrintl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c__llrintl :: (ret: &i64, ___x: &__UNKNOWN_8);
__c____llrintl :: (ret: &i64, ___x: &__UNKNOWN_8);
__c__lroundl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c____lroundl :: (ret: &i32, ___x: &__UNKNOWN_8);
__c__llroundl :: (ret: &i64, ___x: &__UNKNOWN_8);
__c____llroundl :: (ret: &i64, ___x: &__UNKNOWN_8);
__c__fdiml :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____fdiml :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__fmaxl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____fmaxl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__fminl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c____fminl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8);
__c__fmal :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___z: &__UNKNOWN_8);
__c____fmal :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___y: &__UNKNOWN_8, ___z: &__UNKNOWN_8);
__c__scalbl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: &__UNKNOWN_8);
__c____scalbl :: (ret: &__UNKNOWN_8, ___x: &__UNKNOWN_8, ___n: &__UNKNOWN_8);
__c____assert_fail :: (___assertion: &char8, ___file: &char8, ___line: u32, ___function: &char8);
__c____assert_perror_fail :: (___errnum: i32, ___file: &char8, ___line: u32, ___function: &char8);
__c____assert :: (___assertion: &char8, ___file: &char8, ___line: i32);
__c__posix_memalign_2 :: (ret: &i32, ___memptr: &&void, ___alignment: size_t, ___size: size_t);
__c___mm_sfence :: ();
__c___mm_getcsr :: (ret: &u32);
__c___mm_setcsr :: (___i: u32);
__c___mm_clflush :: (___p: &void);
__c___mm_lfence :: ();
__c___mm_mfence :: ();
__c___mm_pause :: ();
__c__stbi__refill_buffer :: (_s: &stbi__context);
__c__stbi__jpeg_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__jpeg_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__jpeg_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__png_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__png_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__png_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__png_is16 :: (ret: &i32, _s: &stbi__context);
__c__stbi__bmp_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__bmp_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__bmp_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__tga_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__tga_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__tga_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__psd_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__psd_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info, _bpc: i32);
__c__stbi__psd_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__psd_is16 :: (ret: &i32, _s: &stbi__context);
__c__stbi__hdr_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__hdr_load :: (ret: &&f32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__hdr_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__pic_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__pic_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__pic_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__gif_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__gif_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__load_gif_main :: (ret: &&void, _s: &stbi__context, _delays: &&i32, _x: &i32, _y: &i32, _z: &i32, _comp: &i32, _req_comp: i32);
__c__stbi__gif_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__pnm_test :: (ret: &i32, _s: &stbi__context);
__c__stbi__pnm_load :: (ret: &&void, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32, _req_comp: i32, _ri: &stbi__result_info);
__c__stbi__pnm_info :: (ret: &i32, _s: &stbi__context, _x: &i32, _y: &i32, _comp: &i32);
__c__stbi__ldr_to_hdr :: (ret: &&f32, _data: &stbi_uc, _x: i32, _y: i32, _comp: i32);
__c__stbi__hdr_to_ldr :: (ret: &&stbi_uc, _data: &f32, _x: i32, _y: i32, _comp: i32);
