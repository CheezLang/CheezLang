#load("std:preload")

struct S1 {
    t: DWORD
}
struct S2(T: TYPE) {
    t: T
    next: &S2[T]
}

enum E1 {
    t
}
enum E2(T: TYPE) {
    t: T
    next: &E2[T]
}

trait T1 {
    fn t(ref Self) -> int;
}
trait T2(T: TYPE) {
    fn t(ref Self) -> T;
}

impl T1 for S1 {
    fn t(ref Self) -> int {
        return 0
    }
}

impl T2[string] for S1 {
    fn t(ref Self) -> string {
        return ""
    }
}

impl T1 for int {
    fn t(ref Self) -> int {
        return 0
    }
}

impl T2[string] for int {
    fn t(ref Self) -> string {
        return ""
    }
}

let const (A, B): TUPLE = default
let const (C, D): (TD1, DWORD) = default

typedef TYPE = type
typedef TUPLE = (int, string)
typedef DWORD = int
typedef TD1 = S1
typedef TD2 = &S1
typedef TD3 = []S1
typedef TD4 = ref S1
typedef TD5 = fn (S1) -> E1
typedef TD6 = S2[DWORD]
typedef TD7 = [10]S1
typedef TD8 = (S1, E1)
typedef TD9 = E2[DWORD]
typedef TD10 = T2[DWORD]

typedef X1 = int
typedef Y1 = X1
typedef Z1 = Y1

typedef Z2 = Y2
typedef Y2 = X2
typedef X2 = int

let const S: Z2 = 10

let a : [S]DWORD = b
let b : [S]DWORD = c
let c : [S]DWORD = default
let d : S2[X1] = test(S)

fn test(a: Z2 = get_val()) -> S2[X1] {
    return S2[X1]()
}

fn get_val() -> Z2 {
    return 0
}

let uiae : int = xvlc()
let nrtd : int = uiae
let const hgfq : int = 1
fn xvlc(x: int = hgfq) -> int {
    return x
}

fn Main() { }