fn f1(x: double) -> Option(Complex) {
    return Some(C(x, -x))
}

fn f2(x: double) -> Option(Complex) {
    if abs(x) < 0.001 {
        return None
    }

    let result = (Complex::poww(C(-1), x) * 2.0 + 3.0 * x) / x
    return Some(result)
}

fn f3(n: double) -> Option(Complex) {
    let x = 5.0
    let t = Complex::poww(C(x), n) * n
    let b = t + 1.0

    if b.r == 0 and b.i == 0 {
        return None
    }
    return Some(t / b)
}

fn f4(x: double) -> Option(Complex) {
    if x == 0 {
        return None
    }

    return Some(C(1/x))
}

fn f5(x: double) -> Option(Complex) {
    return Some(C(sin(x), cos(x)))
}

fn f6(x: double) -> Option(Complex) {
    return Some(C(sin(x), cos(x)))
}

let functions: []fn(double) -> Option(Complex) = [ f1, f2, f3, f4, f5, f6 ]