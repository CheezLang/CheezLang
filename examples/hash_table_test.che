#load("std:mem/std_heap_allocator")
#load("std:string")
#load("std:io/io")

trait Hashable {
    fn hash() -> u32;
}

impl Hashable for c_string {
    fn hash() -> u32 {
        let self = <<self
        let h: u32 = 2166136261

        while let i = 0; (i32)self[i] != 0; i += 1 {
            h += (u32)self[i]
            h *= 16777619
        }

        return h
    }
}

struct Entry(T: type) {
    key: c_string
    value: T
}

struct Table(T: type) {
    max_load: float
    count: u32
    entries: Entry(T)[]
    allocator: Allocator
}

impl Table($T) {
    ref fn init(all: Allocator) {
        allocator = all
        max_load = 0.75
        count = 0
        entries = (Entry(T)&)null
        self.adjust_capacity(13)
    }

    ref fn dispose() {
        free_n(allocator, entries)
    }

    ref fn find_entry(the_entries: Entry(T)[], key: c_string) -> Entry(T)& {
        let index = key.hash() % (u32)the_entries.length

        while true {
            let entry: Entry(T)& = &the_entries[index]

            if (char&)entry.key == null or streq(entry.key, key) {
                return entry
            }

            index = (index + 1) % (u32)the_entries.length
        }

        // unreachable
        return null
    }

    ref fn set(key: c_string, value: T) -> bool {
        if (float)count + 1 > (float)entries.length * max_load {
            self.adjust_capacity((u32)entries.length * 2)
        }

        let entry = self.find_entry(entries, key)

        let is_new_key = (char&)entry.key == null
        entry.key = key
        entry.value = value

        if is_new_key {
            count += 1
        }

        return is_new_key
    }

    ref fn get(key: c_string, value: T&) -> bool {
        if (Entry(T)&)entries == null {
            return false
        }

        let entry = self.find_entry(entries, key)
        if (char&)entry.key == null {
            return false
        }

        <<value = entry.value
        return true
    }

    ref fn adjust_capacity(cap: u32) {
        let entries_new: Entry(T)[] = alloc_n(allocator, cap)

        while let i = 0; i < entries_new.length; i += 1 {
            entries_new[i].key = (c_string)null
        }

        // copy entries to new array
        if (Entry(T)&)entries != null {
            while let i = 0; i < entries.length; i += 1 {
                let entry: Entry(T)& = &entries[i]
                if (char&)entry.key != null {
                    let dest = self.find_entry(entries_new, entry.key)
                    dest.key = entry.key
                    dest.value = entry.value
                }
            }

            free_n(allocator, entries)
        }

        entries = entries_new
    }
}

fn test(t: Table(i32)&) {
    println("testing...")
    let v: i32 = -1
    print_f("t[`"{}`"] = {} : {}`n", ["lol", t.get("lol", &v), v])
    print_f("t[`"{}`"] = {} : {}`n", ["one", t.get("one", &v), v])
    print_f("t[`"{}`"] = {} : {}`n", ["two", t.get("two", &v), v])
    print_f("t[`"{}`"] = {} : {}`n", ["three", t.get("three", &v), v])
    print_f("t[`"{}`"] = {} : {}`n", ["zero", t.get("zero", &v), v])

    println("__________________________________")
}

fn Main() {
    let t: Table(i32)
    t.init(new StdHeapAllocator{})
    defer t.dispose()

    test(&t)

    println("setting zero = 0     ")
    t.set("zero", 0)
    test(&t)

    println("setting one = 1      ")
    t.set("one", 1)
    test(&t)

    println("setting two = 2      ")
    t.set("two", 2)
    test(&t)

    println("setting three = 3        ")
    t.set("three", 3)
    test(&t)
}
