#load("io.che")
// #load("stdio.che")

fn Main()
{
    let a: byte = 1
    let b: short = 2
    let c: int = 3
    let d: long = 4

    let arr: int[]^

    PrintlnInt(@sizeof(byte))
    PrintlnInt(@sizeof(short))
    PrintlnInt(@sizeof(int))
    PrintlnInt(@sizeof(long))

    Println("")
    PrintlnInt(@sizeof(a))
    PrintlnInt(@sizeof(b))
    PrintlnInt(@sizeof(c))
    PrintlnInt(@sizeof(d))
}

struct IntArray {
    data: void^
    capacity: uint
    count: uint
    elementSize: uint
}

impl IntArray {
    ref fn Init(elSize: uint) {
        count = 0
        capacity = 10
        self.elementSize = elSize

        data = malloc((int)(capacity * elementSize))
    }

    ref fn Add(val: $T) {
        if capacity <= count {
            self.Grow(2)
        }

        let d: T^ = (T^)data
        d[count] = val
        count = count + 1
    }

    ref fn Grow(fac: uint) {
        capacity = capacity * fac
        data = realloc(data, (int)(capacity * elementSize))
    }

    ref fn Get(id: uint) -> $T {
        if id >= count {
            return 0
        }

        let d: T^ = (T^)data
        return d[id]
    }

    ref fn Print() -> $T {
        PrintString("(")
        PrintInt((int)count)
        PrintString("/")
        PrintInt((int)capacity)
        PrintString(")[")
        let i: uint = 0
        while i < capacity {
            if i > 0 {
                PrintString(", ")
            }
            
            if i < count {
                PrintInt((int)(T)self.Get(i))
            }

            i = i + 1
        }

        Println("]")

        return (T)self.Get(0)
    }
}
