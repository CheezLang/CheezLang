#load("io.che")
// #load("stdio.che")

fn Main()
{
    let T = byte

    let a: T = 1
    let b: T = 2
    let c: T = 3
    let d: T = 4

    let arr: IntArray
    arr.Init(@sizeof(T))
    (T)arr.Print()

    arr.Add(a)
    (T)arr.Print()

    arr.Add(b)
    (T)arr.Print()

    arr.Add(c)
    (T)arr.Print()

    arr.Add(d)
    (T)arr.Print()

}

struct IntArray {
    data: void^
    capacity: uint
    count: uint
    elementSize: uint
}

impl IntArray {
    ref fn Init(elSize: uint) {
        count = 0
        capacity = 10
        self.elementSize = elSize

        data = malloc((int)(capacity * elementSize))
    }

    ref fn Add(val: $T) {
        if capacity <= count {
            self.Grow(2)
        }

        let d: T^ = (T^)data
        d[count] = val
        count = count + 1
    }

    ref fn Grow(fac: uint) {
        capacity = capacity * fac
        data = realloc(data, (int)(capacity * elementSize))
    }

    ref fn Get(id: uint) -> $T {
        if id >= count {
            return 0
        }

        let d: T^ = (T^)data
        return d[id]
    }

    ref fn Print() -> $T {
        PrintString("(")
        PrintInt((int)count)
        PrintString("/")
        PrintInt((int)capacity)
        PrintString(")[")
        let i: uint = 0
        while i < capacity {
            if i > 0 {
                PrintString(", ")
            }
            
            if i < count {
                PrintInt((int)(T)self.Get(i))
            }

            i = i + 1
        }

        Println("]")

        return (T)self.Get(0)
    }
}
