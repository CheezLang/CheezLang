#load("std:printable")
#load("std:math")

struct Complex #copy {
    pub r: double
    pub i: double
}

impl Complex {
    fn real(r: double) -> Self {
        return new {r, 0}
    }

    fn imaginary(i: double) -> Self {
        return new {0, i}
    }

    fn add(a: Complex, b: Complex) -> Self #operator("+") {
        return new {
            r = a.r + b.r
            i = a.i + b.i
        }
    }

    fn add2(a: Complex, b: double) -> Self #operator("+") {
        return new {
            r = a.r + b
            i = a.i
        }
    }

    fn sub(a: Complex, b: Complex) -> Self #operator("-") {
        return new {
            r = a.r - b.r
            i = a.i - b.i
        }
    }

    fn sub2(a: Complex, b: double) -> Self #operator("-") {
        return new {
            r = a.r - b
            i = a.i
        }
    }

    fn neg(a: Complex) -> Self #operator("-") {
        return new {
            r = -a.r
            i = -a.i
        }
    }

    fn conj(a: Complex) -> Self #operator("!") {
        return new {
            r = a.r
            i = -a.i
        }
    }

    fn mul(a: Complex, b: Complex) -> Self #operator("*") {
        return new {
            r = a.r * b.r - a.i * b.i
            i = a.r * b.i + a.i * b.r
        }
    }

    fn mul2(a: Complex, b: double) -> Self #operator("*") {
        return new {
            r = a.r * b
            i = a.i * b
        }
    }

    fn div(a: Complex, b: Complex) -> Self #operator("/") {
        let fac = 1 / (b.r * b.r + b.i * b.i)
        return new {
            r = fac * (a.r * b.r + a.i * b.i)
            i = fac * (a.r * b.i - a.i * b.r)
        }
    }

    fn div2(a: Complex, b: double) -> Self #operator("/") {
        return new {
            r = a.r / b
            i = a.i / b
        }
    }

    fn poww(a: Complex, e: double) -> Self {
        if a.r == 0 and a.i == 0 {
            return a
        }

        let r = sqrt(a.r * a.r + a.i * a.i)
        let p = atan2(a.i, a.r)

        r = pow(r, e)
        p = p * e

        return new {
            r * cos(p)
            r * sin(p)
        }
    }
}

impl Printable for Complex {
    fn print(ref Self, str: ref String, format: string) {
        str.appendf("{} + {}i", [r, i])
    }
}

fn C(r: double, i: double = 0.0) -> Complex {
    return new {r, i}
}
