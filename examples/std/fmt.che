use import std.string
use import std.printable
use import std.util
C  :: import std.c
io :: import std.io

#export_scope

FmtAlign :: struct #copy {
    amount: int
}

align :: (amount: int) -> FmtAlign {
    return FmtAlign(amount)
}

impl Printable for FmtAlign {
    print :: (&Self, str: &String, format: string) {
        while str.get_length() < amount {
            str += ' '
        }
    }
}

parse_int :: (str: string) -> int {
    val := 0
    sign := 1

    if str.bytes.length > 0 and char(*str[0]) == '-' {
        sign = -1
        str = str[1..]
    }

    for c in str {
        val *= 10
        val += int(c - '0')
    }

    return val * sign
}

format_int :: (buffer: &String, val: $T, _base: int = 10) {
    digit_to_char :: (i: $T) -> char {
        c := char(i)
        return if i < 10 { c + '0' } else { (c - char(10)) + 'A' }
    }

    base := T(_base)

    // calculate length and sign
    len, sign : int, T = if val < 0 then (1, -1)
    else if val == 0 then (1, 1)
    else (0, 1)

    while v := val, v != 0, v /= base {
        len += 1
    }

    // reserve memory
    buffer.resize(buffer.length + len)
    
    if val == 0 {
        buffer[buffer.length - 1] = u8('0')
    } else {
        i := buffer.length - 1
        while val != 0, i -= 1 {
            lastDigit := (val % base) * sign

            val = val / base
            buffer[i] = u8(digit_to_char(lastDigit))
        }

        if sign < 0 {
            buffer[i] = u8('-')
            i -= 1
        }
    }
}

format_any :: (arg: ^any) -> String {
    return format("{}", [arg])
}

format_into :: (result: &String, text: string, args: []^any = []) {
    State :: enum #copy { Text, Format, Escape }
    use State

    formatSpecifier := {
        len :: 64
        mem := @alloca(u8, len)
        String.from_raw_ptr(mem.data, len)
    }

    len      := text.bytes.length
    argIndex := 0
    state    := Text

    for c in text {
        match state {
            Text -> {
                if c == '``' {
                    state = Escape
                } else if c == '{' {
                    state = Format
                } else {
                    result += c
                }
            }

            Escape -> {
                result += c
                state = Text
            }

            Format -> {
                if c == '}' {
                    state = Text
                    value := @ptr_of_any(args[argIndex])
                    typ := @type_info_of_any(args[argIndex])
                    formatArg : string = ""

                    colon := formatSpecifier.index_of(':')
                    if colon >= 1 {
                        // colon -> arg index before colon
                        argIndex = parse_int(formatSpecifier.sliceL(colon))
                    } else if colon == -1 and formatSpecifier.length > 0 {
                        // no colon but non empty -> arg index
                        argIndex = parse_int(formatSpecifier.slice())
                    }
                    if colon != -1 {
                        // colon -> formatArg after colon
                        formatArg = formatSpecifier.sliceF(colon + 1)
                    }

                    if argIndex >= args.length {
                        C.puts("error")
                    }
                    @assert(argIndex >= 0 and argIndex < args.length)

                    if streq(formatArg, "?") {
                        format_any_into_string(result, value, typ, "", true)
                    } else {
                        format_any_into_string(result, value, typ, formatArg, false)
                    }

                    argIndex += 1
                    formatSpecifier.length = 0

                } else {
                    formatSpecifier += c
                }
            }
        }
    }
}

format :: (text: string, args: []^any = []) -> String {
    result := String.empty()
    format_into(&result, text, args)
    return result
}

#file_scope

format_any_into_string :: (result: &String, data: ^void, typ: ^TypeInfo, format: string, recursive: bool) {
    @assert(data != null)
    @assert(typ != null)
    if !recursive {
        trait_func := typ.get_trait_function(Printable, "print", fn(^void, &String, string))
        if trait_func != null {
            trait_func(data, result, "")
            return
        }
    }

    match &*typ {
        // TypeInfoStruct($str) if str.get_trait_function(Printable, "print", fn(^void, &String, string)) != null -> {
        //     trait_func := str.get_trait_function(Printable, "print", fn(^void, &String, string))
        //     if trait_func != null {
        //         trait_func(data, result, "")
        //         return
        //     }
        // }

        TypeInfoString(_) -> {
            ptr := cast(^string) data
            result.append_string(*ptr)
        }

        TypeInfoInt($ti) -> {
            match (ti.size, ti.signed) {
                (1, true)  -> format_int(result, *cast(^i8) data)
                (2, true)  -> format_int(result, *cast(^i16) data)
                (4, true)  -> format_int(result, *cast(^i32) data)
                (8, true)  -> format_int(result, *cast(^i64) data)
                (1, false) -> format_int(result, *cast(^u8) data)
                (2, false) -> format_int(result, *cast(^u16) data)
                (4, false) -> format_int(result, *cast(^u32) data)
                (8, false) -> format_int(result, *cast(^u64) data)
            }
        }

        TypeInfoFloat(_) -> {
            if typ.size == 4 {
                ptr := cast(^float) data
                result.appendf("{}", *ptr)
            } else if typ.size == 8 {
                ptr := cast(^double) data
                result.appendf("{}", *ptr)
            } else {
                result.appendf("<float: invalid size {}>", typ.size)
                @assert(false)
            }
        }

        TypeInfoBool(_) -> {
            ptr := cast(^bool) data
            if *ptr then result.append_string("true") else result.append_string("false")
        }

        TypeInfoChar(_) -> {
            ptr := cast(^char) data
            result.appendf("'{}'", *ptr)
        }

        TypeInfoPointer($ti) -> {
            ptr := cast(^^void) data
            result.appendf("0x{:x}", int(*ptr))
        }

        TypeInfoSlice($ti) -> {
            ptr := *cast(^[]void) data
            result += "["
            for i in 0..ptr.length {
                if i > 0 {
                    result += ", "
                }

                if i >= 100 {
                    result += "..."
                    break
                }

                elem := pointer_add(ptr.data, i * ti.target.size)
                format_any_into_string(result, elem, ti.target, format, recursive)
            }
            result += "]"
        }

        TypeInfoArray($ti) -> {
            ptr := cast(^void) data
            result += "["
            for i in 0..ti.count {
                if i > 0 {
                    result += ", "
                }

                if i >= 100 {
                    result += "..."
                    break
                }

                elem := pointer_add(ptr, i * ti.target.size)
                format_any_into_string(result, elem, ti.target, format, recursive)
            }
            result += "]"
        }

        TypeInfoStruct($tstruct) -> {
            ptr := cast(^void) data
            result += tstruct.name

            result += "("
            if tstruct.members.data != null {
                comma := false
                for i in 0..tstruct.members.length {
                    member_info := tstruct.members[i]
                    if member_info.has_attribute("fmt_ignore") then continue

                    if comma {
                        result += ", "
                    }
                    comma = true

                    member_ptr  := pointer_add(ptr, member_info.offset)
                    result += member_info.name
                    result += " = "
                    format_any_into_string(result, member_ptr, member_info.typ, format, recursive)
                }
            }
            result += ")"
        }

        TypeInfoEnum($tenum) -> {
            ptr := cast(^void) data
            result += tenum.name
            result += '.'

            tag := match tenum.tag_type.size {
                1  -> int(*cast(^u8) ptr)
                2  -> int(*cast(^u16) ptr)
                4  -> int(*cast(^u32) ptr)
                8  -> int(*cast(^u64) ptr)
                $_ -> {
                    @panic("Unsupported tag size")
                    0
                }
            }

            for(by_ref=true) mem in tenum.members {
                if mem.tag == tag {
                    result += mem.name

                    if mem.typ != null {
                        mem_val_ptr := pointer_add(ptr, tenum.tag_type.size)

                        result += "("
                        format_any_into_string(result, mem_val_ptr, mem.typ, format, recursive)
                        result += ")"
                    }
                }
            }
        }

        TypeInfoTuple($ti) -> {
            ptr := cast(^void) data

            result += "("
            if ti.members.data != null {
                for(by_ref=true) member_info in ti.members {
                    if it_index > 0 {
                        result += ", "
                    }

                    member_ptr  := pointer_add(ptr, member_info.offset)
                    format_any_into_string(result, member_ptr, member_info.typ, format, recursive)
                }
            }
            result += ")"
        }

        TypeInfoFunction($ti) -> {
            ptr := cast(^^void) data
            result.appendf("fn 0x{:x}", int(*ptr))
        }

        $_ -> {
            format_into(result, "<unknown {}>", [typ])
        }
    }
}
