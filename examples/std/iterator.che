#load("std:preload")
#load("std:array")

trait Iterator(T: type) {
    fn next(ref Self) -> Option[T];
}

// impl(It: type, T: type) It if It : Iterator(T) {
//     fn max(ref Self) -> T {
//         let max: T

//         while true {
//             match self.next() {
//                 Some($v) if v > max -> {
//                     max = v
//                 }

//                 None -> { break }
//             }
//         }

//         return max
//     }

//     fn sum(ref Self) -> T {
//         let sum: T

//         while true {
//             match self.next() {
//                 Some($v) -> {
//                     sum += v
//                 }

//                 None -> {
//                     break
//                 }
//             }
//         }

//         return sum
//     }
// }

impl(It: type, T: type) It if It : Iterator[T] {
    fn skip(ref Self, count: int) -> Self {
        for :count {
            self.next()
        }

        return self
    }

    fn take(ref Self, count: int) -> TakeIterator[T] {
        return new {self, count}
    }

    fn map(ref Self, mapFunc: fn (T) -> $X) -> MapIterator[T, X] {
        return new {self, mapFunc}
    }

    fn foreach(ref Self, func: fn (T)) {
        while true {
            match self.next() {
                Some($v) -> func(v)
                None -> {break}
            }
        }
    }

    fn to_array(ref Self) -> Array[T] {
        let a = Array[T]::create()
        while match self.next() {
            Some($v) -> {
                a.add(v)
                true
            }
            None -> false
        }{}
        return a
    }
}

// take
struct TakeIterator(T: type) {
    it      : Iterator[T]
    count   : int
}

impl(T: type) Iterator[T] for TakeIterator[T] {
    fn next(ref Self) -> Option[T] {
        if count > 0 {
            count -= 1
            return it.next()
        } else {
            return None
        }
    }
}

// map
struct MapIterator(T: type, X: type) {
    it      : Iterator[T]
    mapFunc : fn(T) -> X
}

impl(T: type, X: type) Iterator[X] for MapIterator[T, X] {
    fn next(ref Self) -> Option[X] {
        return match it.next() {
            Some($v) -> Some(mapFunc(v))
            None -> None
        }
    }
}

// range
struct RangeIterator {
    from    : int
    to      : int
}

impl Iterator[int] for RangeIterator {
    fn next(ref Self) -> Option[int] {
        if from > to {
            return None
        }

        let n = from
        from += 1
        return Some(n)
    }
}

fn range(start: int, end: int) -> RangeIterator {
    return new {start, end}
}
