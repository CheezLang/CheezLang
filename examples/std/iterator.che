#load("std:preload")
#load("std:array")

trait Iterator(T: type) {
    fn next(ref Self) -> Option(T);
    fn dispose(ref Self);
}

struct TakeIterator(T: type) {
    it      : Iterator(T)
    count   : int
}

struct MapIterator(T: type, X: type) {
    it      : Iterator(T)
    mapFunc : fn(T) -> X
}

impl Iterator($T) for MapIterator($T2, T) {
    fn next(ref Self) -> Option(T) {
        return match it.next() {
            Some($v) -> Some(mapFunc(v))
            None -> None
        }
    }

    fn dispose(ref Self) {
        it.dispose()
        free(&self)
    }
}

impl Iterator($T) for TakeIterator(T) {
    fn next(ref Self) -> Option(T) {
        if count > 0 {
            count -= 1
            return it.next()
        } else {
            return None
        }
    }

    fn dispose(ref Self) {
        it.dispose()
        free(&self)
    }
}

impl Iterator($T) {
    fn max(ref Self) -> T {
        let max: T

        while true {
            match self.next() {
                Some($v) if v > max -> {
                    max = v
                }

                None -> {
                    break
                }
            }
        }

        return max
    }

    fn sum(ref Self) -> T {
        let sum: T

        while true {
            match self.next() {
                Some($v) -> {
                    sum += v
                }

                None -> {
                    break
                }
            }
        }

        return sum
    }

    fn take(ref Self, count: int) -> Iterator(T) {
        let it = alloc(TakeIterator(T))
        <<it = new {self, count}
        return <<it
    }

    fn map(ref Self, mapFunc: fn (T) -> $X) -> Iterator(X) {
        let it = alloc(MapIterator(T, X))
        <<it = new {self, mapFunc}
        return <<it
    }

    fn foreach(ref Self, func: fn (T)) {
        while true {
            match self.next() {
                Some($v) -> func(v)
                None -> {break}
            }
        }
    }

    fn to_array(ref Self) -> Array(T) {
        let a = Array(T)::create()
        while match self.next() {
            Some($v) -> {
                a.add(v)
                true
            }
            None -> false
        }{}
        return a
    }
}
