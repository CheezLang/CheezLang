mem :: import std.mem.allocator
io  :: import std.io

#export_scope

RcData :: struct {
    count           : int
    internal_count  : int
}

Rc :: struct(T: type) {
    data        : &RcData
    value       : &T
    drop_impl   : fn(&T)
    owns_memory : bool
}

impl(T: type) Rc[T] {
    empty :: () -> Rc[T] {
        return Rc[T](null, null, null, false)
    }

    from_pointer :: (ptr: &$K, owned: bool) -> Rc[T] {
        data := mem.alloc(RcData)
        <<data = RcData(1, 1)
        drop_impl : fn(&T) = cast if const @type_has_trait(K, Drop) then data.value.drop else null
        return Rc[T](data, cast ptr, drop_impl, owned)
    }

    new :: (value: $K) -> Rc[T] {
        data    := mem.alloc(RcData)
        <<data  = RcData(1, 1)
        ptr     := mem.alloc(K)
        <<ptr   = value
        drop_impl : fn(&T) = cast if const @type_has_trait(K, Drop) then ptr.drop else null
        return Rc[T](data, cast ptr, drop_impl, true)
    }

    clone :: (ref Self) -> Rc[T] {
        data.count += 1
        return Rc[T](data, value, drop_impl, owns_memory)
    }

    count :: (ref Self) -> int {
        @assert(data != null)
        return data.count
    }

    is_null :: (ref Self) -> bool {
        return value == null
    }

    try_get :: (ref Self) -> Option[ref T] {
        return if value == null
            then None
            else Some(<<value)
    }

    get :: (ref Self) -> ref T {
        @assert(value != null)
        return <<value
    }

    change_type :: (Self, $R: type) -> Rc[R] {
        result := Rc[R](data, cast value, owns_memory)
        data = null
        value = null
        return result
    }
}

impl(T: type) Drop for Rc[T] {
    drop :: (ref Self) {
        if data == null {
            return
        }

        @assert(data.count > 0)
        data.count -= 1
        if data.count == 0 {
            if drop_impl != null {
                drop_impl(value)
            }
            if owns_memory {
                mem.free(data)
            }
        }
    }
}
