#load("std:random")

STATE_VECTOR_LENGTH   : u32 : 624
STATE_VECTOR_M        : u32 : 397
STATE_VECTOR_DIFF     : u32 : STATE_VECTOR_LENGTH - STATE_VECTOR_M

struct MTwister {
    mt      : [STATE_VECTOR_LENGTH]u32
    mt_temp : [STATE_VECTOR_LENGTH]u32
    index   : u32
}

impl PseudoRandomGen for MTwister {
    fn next_u32(ref Self) -> u32 {
        return self.next()
    }

    fn next_double(ref Self) -> double {
        r := double(self.next())
        m := double(u32.max)
        return r / m
    }
}

impl MTwister {
    fn create(seed: u32) -> Self {
        result := MTwister(index = STATE_VECTOR_LENGTH)
        result.mt[0] = seed
        for i : 1..int(STATE_VECTOR_LENGTH) {
            result.mt[i] = 0x6c078965 * @bin_xor(result.mt[i - 1], @bin_lsr(result.mt[i - 1], 30)) + u32(i)
        }
        return result
    }

    fn m32(x: u32) -> u32 {
        return @bin_and(x, 0x80000000)
    }

    fn l31(x: u32) -> u32 {
        return @bin_and(x, 0x7FFFFFFF)
    }

    fn unroll(ref Self, y: ref u32, i: ref u64, expr: u64) {
        y = @bin_or(m32(mt[i]), l31(mt[i + 1]))
        mt[i] = @bin_xor(
            mt[expr],
            @bin_lsr(y, 1),
            @bin_and(u32(@bin_lsr(@bin_lsl(i32(y), 31), 31)), 0x9908b0df)
        )
        i += 1
    }

    fn generate_numbers(ref Self) {
        let i: u64 = 0
        let y: u32 = 0

        while i < STATE_VECTOR_DIFF {
            unroll(y, i, i + STATE_VECTOR_M)
            unroll(y, i, i + STATE_VECTOR_M)
        }

        while i < STATE_VECTOR_LENGTH - 1 {
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
        }

        {
            y = @bin_or(m32(mt[STATE_VECTOR_LENGTH - 1]), l31(mt[0]))
            mt[STATE_VECTOR_LENGTH - 1] = @bin_xor(
                mt[STATE_VECTOR_M - 1],
                @bin_lsr(y, 1),
                @bin_and(u32(@bin_lsr(@bin_lsl(i32(y), 31), 31)), 0x9908b0df)
            )
            i += 1
        }

        for i : 0..int(STATE_VECTOR_LENGTH) {
            y = mt[i]
            y = @bin_xor(y, @bin_lsr(y, 11))
            y = @bin_xor(y, @bin_and(@bin_lsl(y, 7), 0x9d2c5680))
            y = @bin_xor(y, @bin_and(@bin_lsl(y, 15), 0xefc60000))
            y = @bin_xor(y, @bin_lsr(y, 18))
            mt_temp[i] = y
        }

        index = 0
    }

    fn next(ref Self) -> u32 {
        if index >= STATE_VECTOR_LENGTH {
            generate_numbers()
            index = 0
        }

        index += 1
        return mt_temp[index - 1]
    }

    fn next_uint(ref Self, min: u64 = 0, max: u64 = cast u64.max) -> u64 {
        a := u64(next())
        b := u64(next())
        rand := @bin_or(@bin_lsl(b, 32), a)
        return rand % (max - min) + min
    }

    fn next_int(ref Self, min: int = 0, max: int = cast i64.max) -> int {
        a := u64(next())
        b := u64(next())
        rand := @bin_or(@bin_lsl(b, 32), a)
        return int(rand) % (max - min) + min
    }
}