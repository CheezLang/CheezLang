
let const STATE_VECTOR_LENGTH   : u32 = 624
let const STATE_VECTOR_M        : u32 = 397
let const STATE_VECTOR_DIFF     : u32 = STATE_VECTOR_LENGTH - STATE_VECTOR_M

struct MTwister {
    mt      : [STATE_VECTOR_LENGTH]u32
    mt_temp : [STATE_VECTOR_LENGTH]u32
    index   : u32
}

impl PseudoRandomGen for MTwister {
    fn next_u32(ref Self) -> u32 {
        return self.next()
    }

    fn next_double(ref Self) -> double {
        let r = double(self.next())
        let m = double(u32_max())
        return r / m
    }
}

impl MTwister {
    fn create(seed: u32) -> Self {
        let result = new MTwister { index = STATE_VECTOR_LENGTH }
        result.mt[0] = seed
        loop! i in 1 -> int(STATE_VECTOR_LENGTH) {
            result.mt[i] = 0x6c078965 * @bin_xor(result.mt[i - 1], @bin_lsr(result.mt[i - 1], 30u32)) + u32(i)
        }
        return result
    }

    fn m32(x: u32) -> u32 {
        return @bin_and(0x80000000u32, x)
    }

    fn l31(x: u32) -> u32 {
        return @bin_and(0x7FFFFFFFu32, x)
    }

    fn unroll(ref Self, y: ref u32, i: ref u64, expr: u64) {
        y = @bin_or(m32(mt[i+0u64]), l31(mt[i + 1u64]))
        mt[i+0u64] = @bin_xor(
            mt[expr],
            @bin_lsr(<<&y, 1u32),
            @bin_and(u32(@bin_lsr(@bin_lsl(i32(y), 31i32), 31i32)), 0x9908b0dfu32)
        )
        i += 1
    }

    fn generate_numbers(ref Self) {
        let i: u64 = 0
        let y: u32 = 0

        while i < STATE_VECTOR_DIFF {
            unroll(y, i, i + STATE_VECTOR_M)
            unroll(y, i, i + STATE_VECTOR_M)
        }

        while i < STATE_VECTOR_LENGTH - 1 {
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
            unroll(y, i, i - STATE_VECTOR_DIFF)
        }

        {
            y = @bin_or(m32(mt[STATE_VECTOR_LENGTH - 1]), l31(mt[0]))
            mt[STATE_VECTOR_LENGTH - 1] = @bin_xor(
                mt[STATE_VECTOR_M - 1],
                @bin_lsr(<<&y, 1u32),
                @bin_and(u32(@bin_lsr(@bin_lsl(i32(y), 31i32), 31i32)), 0x9908b0dfu32)
            )
            i += 1
        }

        loop! i in 0 -> int(STATE_VECTOR_LENGTH) {
            y = mt[i]
            y = @bin_xor(y, @bin_lsr(y, 11u32))
            y = @bin_xor(y, @bin_and(@bin_lsl(y, 7u32), 0x9d2c5680u32))
            y = @bin_xor(y, @bin_and(@bin_lsl(y, 15u32), 0xefc60000u32))
            y = @bin_xor(y, @bin_lsr(y, 18u32))
            mt_temp[i] = y
        }

        index = 0
    }

    fn next(ref Self) -> u32 {
        if index >= STATE_VECTOR_LENGTH {
            generate_numbers()
            index = 0
        }

        index += 1
        return mt_temp[index - 1]
    }

    fn next_uint(ref Self, min: u64 = 0, max: u64 = cast u64_max()) -> u64 {
        let a = u64(next())
        let b = u64(next())
        let rand = @bin_or(@bin_lsl(b, 32), a)
        return rand % (max - min) + min
    }

    fn next_int(ref Self, min: int = 0, max: int = cast i64_max()) -> int {
        let a = u64(next())
        let b = u64(next())
        let rand = @bin_or(@bin_lsl(b, 32), a)
        return int(rand) % (max - min) + min
    }
}