use import std.mem.allocator
use import std.os.windows
use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
use import std.os.windows_macros

#export_scope

// @fixme cyclic dependency, but should work
// thread_fiber : Fiber = Fiber(ConvertThreadToFiber(^thread_fiber), null)

Fiber :: struct {
    ptr             : ^void
    parent          : ^Fiber = null
    func            : Fn(^void)
    user_data       : ^void
}

impl Drop for Fiber {
    drop :: (&Self) {
        DeleteFiber(ptr)
    }
}

impl Fiber {
    init :: () {
        f := alloc(Fiber)
        *f = Fiber(
            ptr     = ConvertThreadToFiber(f)
            parent  = null
            func    = null
            user_data = null
        )
        // printfln("[{}] Fiber.init: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr)))
    }

    new :: (func: Fn(^$T), user_data: ^T = null) -> ^Fiber {
        fiber_func :: (param: ^void) #stdcall #nostacktrace {
            f := cast(^Fiber)param
            f.func(f.user_data)
            while true {
                Fiber.yield()
            }
        }

        f := alloc(Fiber)
        f.ptr = CreateFiber(0, fiber_func, cast f)
        f.func = cast func
        f.parent = current()
        f.user_data = user_data
        // printfln("[{}] Fiber.new: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr)))
        return f
    }

    to_func :: (&Self) -> Fn() {
        return cast self.resume
    }

    resume :: (&Self) #nostacktrace {
        parent = current()
        SwitchToFiber(ptr)
    }

    yield :: () #nostacktrace {
        f := current()
        if f.parent == null {
            @panic("Can't yield from a fiber without parent")
        } else {
            // printfln("[{}] Fiber.yield: ({:x}:{:x}) parent: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr), int(f.parent), int(f.parent.ptr)))
            SwitchToFiber(f.parent.ptr)
        }
    }

    current :: () -> ^Fiber {
        return cast GetFiberData()
    }

    user_data :: ($T: type) -> ^T {
        return cast(^T) Fiber.current().user_data
    }
}
