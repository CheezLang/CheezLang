#load("std:os/windows")

let thread_fiber: Fiber = new{ConvertThreadToFiber(&thread_fiber), null}

fn fiber_func(param: &any) #stdcall {
    let f = cast(&Fiber)param
    f.func()
    while true {
        Fiber::yield()
    }
}

struct Fiber {
    ptr             : &any
    parent          : &Fiber = null
    pub const func  : fn()
    pub const user_data : &any
}

impl Fiber {
    fn create(func: fn(), ud: &any = null) -> &Fiber {
        let f = alloc(Fiber)
        f.ptr = CreateFiber(0, fiber_func, cast f)
        f.func = func
        f.parent = current()
        f.user_data = ud
        return f
    }

    fn dispose(ref Self) {
        free(&self)
    }

    fn resume(ref Self) {
        parent = current()
        SwitchToFiber(ptr)
    }

    fn yield() {
        let f = current()
        if f.parent == null {
            @panic("Can't yield from a fiber without parent")
        } else {
            SwitchToFiber(f.parent.ptr)
        }
    }

    fn current() -> &Fiber {
        return cast GetFiberData()
    }
}

fn generator_func() {
    let g = Generator(any)::current()
    g.func(ref <<g)
}

struct Generator(T: type) {
    fiber       : &Fiber
    user_data   : Option(T)
    pub const func  : fn(ref Generator(T))
}

impl Generator($T) {
    fn create(func: fn(ref Generator(T))) -> &Generator(T) {
        let g = alloc(Generator(T))
        g.fiber = Fiber::create(generator_func, cast g)
        g.func = func
        return g
    }

    fn resume(ref Self) -> Option(T) {
        fiber.resume()
        match user_data {
            Some($d) -> {
                user_data = None
                return Some(d)
            }
            None -> {
                return None
            }
        }

        return None
    }

    fn yield(ref Self, val: T) {
        user_data = Some(val)
        Fiber::yield()
    }

    fn current() -> &Generator(T) {
        return cast Fiber::current().user_data
    }
}

impl Iterator(double) for Generator(double) {
    fn next(ref Self) -> Option(double) {
        return self.resume()
    }

    fn dispose(ref Self) {
    }
}


// experimental
fn generator_with_arg_func() {
    let g = GeneratorWithArg(double, any)::current()
    g.func(g.arg, ref <<g)
}

struct GeneratorWithArg(A: type, T: type) {
    fiber       : &Fiber
    user_data   : Option(T)
    pub const arg   : A
    pub const func  : fn(A, ref GeneratorWithArg(A, T))
}

impl GeneratorWithArg($A, $T) {
    fn create(func: fn(A, ref GeneratorWithArg(A, T)), arg: A) -> &GeneratorWithArg(A, T) {
        let g = alloc(GeneratorWithArg(A, T))
        g.fiber = Fiber::create(generator_with_arg_func, cast g)
        g.arg = arg
        g.func = func
        return g
    }

    fn resume(ref Self) -> Option(T) {
        fiber.resume()
        match user_data {
            Some($d) -> {
                user_data = None
                return Some(d)
            }
            None -> {
                return None
            }
        }

        return None
    }

    fn yield(ref Self, val: T) {
        user_data = Some(val)
        Fiber::yield()
    }

    fn current() -> &GeneratorWithArg(A, T) {
        return cast Fiber::current().user_data
    }
}

impl Iterator(double) for GeneratorWithArg(double, double) {
    fn next(ref Self) -> Option(double) {
        return self.resume()
    }

    fn dispose(ref Self) {
    }
}
