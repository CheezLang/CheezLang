#load("std:mem/allocator")
#load("std:os/windows")

// @fixme cyclic dependency, but should work
// thread_fiber : Fiber = Fiber(ConvertThreadToFiber(&thread_fiber), null)

Fiber :: struct {
    ptr             : &any
    parent          : &Fiber = null
    func            : fn(&any)
    user_data       : &any
}

impl Drop for Fiber {
    drop :: (ref Self) {
        DeleteFiber(ptr)
    }
}

impl Fiber {
    init :: () {
        f := alloc(Fiber)
        <<f = Fiber(
            ptr     = ConvertThreadToFiber(f)
            parent  = null
            func    = null
            user_data = null
        )
        // printfln("[{}] Fiber.init: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr)))
    }

    new :: (func: fn(&$T), ud: &T = null) -> &Fiber {
        fiber_func :: (param: &any) #stdcall #nostacktrace {
            f := cast(&Fiber)param
            f.func(f.user_data)
            while true {
                Fiber.yield()
            }
        }

        f := alloc(Fiber)
        f.ptr = CreateFiber(0, fiber_func, cast f)
        f.func = cast func
        f.parent = current()
        f.user_data = ud
        // printfln("[{}] Fiber.new: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr)))
        return f
    }

    to_func :: (ref Self) -> Fn() {
        return cast self.resume
    }

    resume :: (ref Self) #nostacktrace {
        parent = current()
        SwitchToFiber(ptr)
    }

    yield :: () #nostacktrace {
        f := current()
        if f.parent == null {
            @panic("Can't yield from a fiber without parent")
        } else {
            // printfln("[{}] Fiber.yield: ({:x}:{:x}) parent: ({:x}:{:x})", (Thread.current().id, int(f), int(f.ptr), int(f.parent), int(f.parent.ptr)))
            SwitchToFiber(f.parent.ptr)
        }
    }

    current :: () -> &Fiber {
        return cast GetFiberData()
    }
}
