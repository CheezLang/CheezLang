#load("std:mem/allocator")
#load("std:os/windows")

// @fixme cyclic dependency, but should work
// let thread_fiber: Fiber = Fiber(ConvertThreadToFiber(&thread_fiber), null)

fn fiber_func(param: &any) #stdcall {
    f := cast(&Fiber)param
    f.func()
    while true {
        Fiber.yield()
    }
}

struct Fiber {
    ptr             : &any
    parent          : &Fiber = null
    pub const func  : fn()
    pub const user_data : &any
}

impl Fiber {
    fn create(func: fn(), ud: &any = null) -> &Fiber {
        f := alloc(Fiber)
        f.ptr = CreateFiber(0, fiber_func, cast f)
        f.func = func
        f.parent = current()
        f.user_data = ud
        return f
    }

    fn dispose(ref Self) {
        free(&self)
    }

    fn resume(ref Self) {
        parent = current()
        SwitchToFiber(ptr)
    }

    fn yield() {
        f := current()
        if f.parent == null {
            @panic("Can't yield from a fiber without parent")
        } else {
            SwitchToFiber(f.parent.ptr)
        }
    }

    fn current() -> &Fiber {
        return cast GetFiberData()
    }
}
