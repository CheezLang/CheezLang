#load("std:mem/allocator")
#load("std:os/windows")

// @fixme cyclic dependency, but should work
// thread_fiber : Fiber = Fiber(ConvertThreadToFiber(&thread_fiber), null)


Fiber :: struct {
    ptr             : &any
    parent          : &Fiber = null
    func  : fn()
    user_data : &any
}

impl Fiber {
    create :: (func: fn(), ud: &any = null) -> &Fiber {
        fiber_func :: (param: &any) #stdcall {
            f := cast(&Fiber)param
            f.func()
            while true {
                Fiber.yield()
            }
        }

        f := alloc(Fiber)
        f.ptr = CreateFiber(0, fiber_func, cast f)
        f.func = func
        f.parent = current()
        f.user_data = ud
        return f
    }

    dispose :: (ref Self) {
        free(&self)
    }

    resume :: (ref Self) {
        parent = current()
        SwitchToFiber(ptr)
    }

    yield :: () {
        f := current()
        if f.parent == null {
            @panic("Can't yield from a fiber without parent")
        } else {
            SwitchToFiber(f.parent.ptr)
        }
    }

    current :: () -> &Fiber {
        return cast GetFiberData()
    }
}
