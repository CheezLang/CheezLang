#load("std:mem/memory")
#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:iterator")

struct Array(T: type) {
    data: []T
    pub const length: int
    allocator: Allocator
}

impl(T: type) Array(T) {
    fn create(initial_capacity: int = 10, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        let s = new Array(T) { null, 0, allocator }
        s.reserve(initial_capacity)
        c_memset(cast s.get_raw(), 0, cast(uint) (s.get_capacity() * @sizeof(T)))
        return s
    }

    fn reserve(ref Self, size: int) {
        if data.length > size {
            return
        }

        data.length = size
        data = realloc_n(data, cast size, allocator)

        if size > length {
            c_memset(cast &data[length], 0, cast(uint) ((size - length) * @sizeof(T)))
        }

        if length > data.length {
            length = data.length
        }
    }

    fn dispose(ref Self) {
        free_n(data, allocator)
        data = null
        length = 0
    }

    fn get_length(ref Self) -> int {
        return length
    }

    fn get_capacity(ref Self) -> int {
        return data.length
    }

    fn get_raw(ref Self) -> &T {
        return data.data
    }

    fn resize(ref Self, size: int) {
        reserve(size)
        length = size
    }

    fn add(ref Self, val: T) #operator("+=") {
        if get_capacity() <= get_length() {
            reserve(get_capacity() * 2)
        }

        data[length] = val
        length += 1
    }

    fn get(ref Self, index: int) -> Option(T) {
        if index < 0 or index >= length {
            return None
        } else {
            return Some(data[index])
        }
    }

    fn access_unchecked(ref Self, index: int) -> ref T #operator("[]") {
        @assert(index >= 0 and index < length, "Index was out of range")
        return data[index]
    }

    fn sliceFL(ref Self, from: int, len: int) -> []T {
        @assert(from >= 0 and len >= 0 and from + len <= length, "Invalid range")
        let slice: []T = &data[from]
        slice.length = len
        return slice
    }

    fn slice(ref Self) -> []T {
        return self.sliceFL(0, length)
    }

    fn sliceF(ref Self, from: int) -> []T {
        return self.sliceFL(from, length - from)
    }
    
    fn sliceL(ref Self, len: int) -> []T {
        return self.sliceFL(0, len)
    }

    fn sort(ref Self, cmp: fn (ref T, ref T) -> int) -> ref Self {
        quick_sort(0, length - 1, cmp)

        return self
    }

    fn quick_sort(ref Self, from: int, to: int, cmp: fn (ref T, ref T) -> int) {
        if from >= to {
            return
        }

        let idx = from
        let pivot = data[to]
        while let i = from, i < to, i += 1 {
            if cmp(data[i], pivot) > 0 {
                (data[idx], data[i]) = (data[i], data[idx])
                idx += 1
            }
        }
        (data[idx], data[to]) = (data[to], data[idx])

        quick_sort(from, idx - 1, cmp)
        quick_sort(idx + 1, to, cmp)
    }

    fn iterator(ref Self) -> ArrayIterator(T) {
        return new { self, 0 }
    }
}

struct ArrayIterator(T: type) {
    array: ref Array(T)
    index: int
}

impl(T: type) Iterator(T) for ArrayIterator(T) {
    fn next(ref Self) -> Option(T) {
        index += 1
        return if index > array.length { None } else { Some(array[index - 1]) }
    }
}

impl(F: type, T: type) Into(Array(T)) for Array(F) if F : Into(T), #notyet {
    fn into(ref Self) -> Array(T) {
        let result = Array(T)::create(self.get_length())
        for :0..self.get_length() {
            result.add(self.access_unchecked(it)::into())
        }
        return result
    }
}

impl(F: type, T: type) From(Array(F)) for Array(T) if T : From(F), #notyet {
    fn from(value: Array(F)) -> Array(T) {
        let result = Array(T)::create(value.get_length())
        for :0..value.get_length() {
            result.add(value.access_unchecked(it)::into())
        }
        return result
    }
}

fn for_extension_array_T(arr: Array($T), code: Code, reverse: bool = false,
                            by_reference: bool = true) #for {
    while let it_index = 0, it_index < arr.get_length(), it_index += 1 {
        if const reverse {
            let it_index_rev = arr.length - it_index - 1
            if const by_reference {
                let it = ref arr[it_index_rev]
            } else {
                let it = arr[it_index_rev]
            }
            @insert(code, link=[it_index_rev])
        } else {
            
            if const by_reference {
                let it = ref arr[it_index]
            } else {
                let it = arr[it_index]
            }
            @insert(code)
        }
    }
}
