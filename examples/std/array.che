#load("std:mem/memory")
#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")

struct Array(ElementType: type) {
    data: *ElementType
    length: u32
    capacity: u32
    allocator: Allocator
}

fn newArray() -> Array($T) {
    let a: Array(T)
    a.init()
    return a
}

impl Array($ElementType) {
    ref fn init() {
        allocator = new StdHeapAllocator{}
        length = 0
        capacity = 10
        data = allocator.allocate(cast(u64) capacity, @sizeof(ElementType), @alignof(ElementType))
    }
    
    ref fn initSize(size: u32) {
        allocator = new StdHeapAllocator{}
        length = 0
        capacity = size
        data = allocator.allocate(cast(u64) capacity, @sizeof(ElementType), @alignof(ElementType))
    }

    ref fn dispose() {
        allocator.free(data)
    }

    ref fn rawData() -> *ElementType {
        return data
    }

    ref fn reserve(s: u32) {
        if s <= capacity {
            return
        }
        capacity = s
        data = allocator.reallocate(data, cast(u64) capacity, @sizeof(ElementType), @alignof(ElementType))
    }

    ref fn resize(s: u32) {
        self.reserve(s)
        length = s
    }

    ref fn add(val: ElementType) {
        if capacity <= length {
            capacity = capacity * 2
            data = allocator.reallocate(data, cast(u64) capacity, @sizeof(ElementType), @alignof(ElementType))
        }

        data[length] = val
        length += 1
    }

    ref fn get(index: $IndexType) -> ElementType {
        if !@isint(IndexType) {
            @error("Index must be an i32")
            return data[0]
        }
        else {
            return data[index]
        }
    }

    ref fn set(index: $IndexType, value: ElementType) {
        if !@isint(IndexType) {
            @error("Index must be an i32")
            return
        }
        else {
            data[index] = value
        }
    }

    ref fn convert() -> Array($X) {
        let r: Array(X)
        r.init()
        r.reserve(length)

        while r.length < length {
            r.data[r.length] = cast(X) data[r.length]
            r.length += 1
        }

        return r
    }

    ref fn slice() -> []ElementType {
        let slice: []ElementType = self.data
        slice.length = cast(i32) self.length
        return slice
    }
}
