_C :: import std.c

// OS
Platform :: enum {
    Unknown
    Windows
    Linux
    OSX
}

__platform__ : Platform = if const @is_os("Windows") {
    Platform.Windows
} else if const @is_os("Linux") {
    Platform.Linux
} else if const @is_os("OSX") {
    Platform.OSX
} else {
    Platform.Unknown
}

// drop
Drop :: trait {
    drop :: (ref Self);
}

// drops a values
Memory :: struct{}
impl Memory {
    drop :: (_: $T) {}
}

// option and result
Option :: enum(T: type) #copy(T) {
    Some : T
    None
}

Result :: enum(V: type, E: type) #copy(V, E) {
    Ok  : V
    Err : E
}

use Option
use Result

From :: trait(T: type) {
    from :: (value: T) -> Self;
}

Into :: trait(T: type) {
    into :: (ref Self) -> T;
}

// impl(F: type, T: type) From[F] for T if F : Into[T], #notyet {
//     from :: (value: F) -> T {
//         return F.into(value)
//     }
// }

// impl(F: type, T: type) Into[T] for F if T : From[F], #notyet {
//     into :: (ref Self) -> T {
//         return T.from(self)
//     }
// }

// standard for loops
for_extension_range :: (r: $T..T, code: Code, reverse: bool = false, inclusive: bool = false) #for {
    start, end, inc := {
        end := if const inclusive then r.end else r.end - 1
        if const reverse then (end, r.start, T(-1)) else (r.start, end, T(1))
    }

    compare :: @code(if const reverse then it >= end else it <= end)

    while (it, it_index) := (start, 0),
        @insert(compare, link=[it], _break={}, _continue={}),
        it_index += 1; it += inc {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_slice :: (arr: []$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
    while it_index := 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            it_index_rev := arr.length - it_index - 1
            it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
            @insert(code, link=[it_index_rev], _break=break, _continue=continue)
        } else {
            it := if const by_ref then ref arr[it_index] else arr[it_index]
            @insert(code, _break=break, _continue=continue)
        }
    }
}

// for_extension_array :: (arr: [$Size]$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
//     while it_index := 0, it_index < arr.length, it_index += 1 {
//         if const reverse {
//             it_index_rev := arr.length - it_index - 1
//             it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
//             @insert(code, link=[it_index_rev], _break=break, _continue=continue)
//         } else {
//             it := if const by_ref then ref arr[it_index] else arr[it_index]
//             @insert(code, _break=break, _continue=continue)
//         }
//     }
// }

// type info stuff
TypeInfo :: struct #copy {
    size        : int
    alignment   : int
    kind        : TypeInfoKind
}

impl TypeInfo {
    get_trait_function :: (ref Self, $Trait: type, name: string, $F: type) -> F {
        return match kind {
            TypeInfoKind.Struct($s) ->  s.get_trait_function(Trait, name, F)

            $_ -> {
                // @panic("Not implemented!")
                null
            }
        }
    }
}

TypeInfoKind :: enum #copy {
    Int         : TypeInfoInt    = 0
    Float                        = 1
    Bool                         = 2
    Char                         = 3
    Struct      : TypeInfoStruct = 4
    Pointer     : &TypeInfo      = 5
    Reference   : &TypeInfo      = 6
    Slice       : &TypeInfo      = 7
    Enum        : TypeInfoEnum   = 8
    Trait       : TypeInfoTrait  = 9
    Void                         = 10
}

TypeInfoTrait :: struct #copy {
    name      : string
    functions : []TypeInfoTraitFunction
}

TypeInfoTraitFunction :: struct #copy {
    name  : string
    index : int
}

TypeInfoInt :: struct #copy {
    signed : bool
}

TypeInfoStruct :: struct #copy {
    name    : string
    members : []TypeInfoStructMember
    traits  : []TypeInfoTraitImpl
    // parameters    : []any
    // const_members : []TypeInfoStructMember
}

TypeInfoTraitImpl :: struct #copy {
    trait_type : &TypeInfo
    vtable     : &void
}

TypeInfoStructMember :: struct #copy {
    offset     : int
    name       : string
    typ        : &TypeInfo
    attributes : []TypeInfoAttribute
}

TypeInfoAttribute :: struct {
    name : string
    args : []any
}

TypeInfoEnum :: struct #copy {
    name     : string
    members  : []TypeInfoEnumMember
    tag_type : &TypeInfo
}

TypeInfoEnumMember :: struct #copy {
    name : string
    typ  : &TypeInfo
    tag  : int
}

impl TypeInfoStruct {
    get_member :: (ref Self, name: string) -> &TypeInfoStructMember {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }

    get_trait_impl :: (ref Self, $T: type) -> &TypeInfoTraitImpl {
        ti := @type_info(T)
        match ti.kind {
            TypeInfoKind.Trait -> {
                for(by_ref=true) traits {
                    if it.trait_type == ti {
                        return &it
                    }
                }
            }
        }
        return null
    }

    get_trait_function :: (ref Self, $Trait : type, func_name: string, $F: type) -> F {
        ti_impl := self.get_trait_impl(Trait)
        if ti_impl == null {
            return null
        }
        ti_trait := ti_impl.trait_type
        vtable := ti_impl.vtable
        func_info := ti_trait.kind.Trait.get_function(func_name)
        function := cast(F) @cast(&fn(), vtable)[func_info.index]
        return function
    }
}

impl TypeInfoStructMember {
    get_attribute :: (ref Self, name: string) -> &TypeInfoAttribute {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return &att
            }
        }

        return null
    }

    has_attribute :: (ref Self, name: string) -> bool {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return true
            }
        }

        return false
    }
}

impl TypeInfoTrait {
    get_function :: (ref Self, name: string) -> &TypeInfoTraitFunction {
        for(by_ref=true) functions {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }
}


strings_equal :: (a: string, b: string) -> bool {
    if a.length != b.length {
        return false
    }

    for 0..a.length {
        if a[it] != b[it] {
            return false
        }
    }

    return true
}