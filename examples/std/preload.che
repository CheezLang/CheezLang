_C :: import std.c

// OS
Platform :: enum {
    Unknown
    Windows
    Linux
    OSX
}

__platform__ : Platform = if const @is_os("Windows") {
    Platform.Windows
} else if const @is_os("Linux") {
    Platform.Linux
} else if const @is_os("OSX") {
    Platform.OSX
} else {
    Platform.Unknown
}

// 
push_var :: (var: Code, x: Code) #macro #transparent {
    prev := @insert(var) #local
    defer {@insert(var) = prev}
    @insert(var) = @insert(x)
}

// try
try :: (code: Code) #macro {
    match @insert(code, _break=break, _continue=continue) {
        Ok($val) -> val
        Err($err) -> {
            ReturnType :: @function_type().return_type
            return if const ReturnType == bool {
                false
            } else {
                TargetType :: ReturnType.E
                ErrorType :: @typeof(err)

                if const @type_has_trait(ErrorType, Into[TargetType]) {
                    ReturnType.Err(cast(TargetType) @typeof(err).into(err))
                } else {
                    ReturnType.Err(err)
                }
                // bug?
                // if const @type_has_trait(ErrorType, Into[TargetType]) {
                //     return ReturnType.Err(cast(TargetType) @typeof(err).into(err))
                // } else {
                //     return ReturnType.Err(err)
                // }
            }
        }
    }
}

try_with :: (code: Code, with: Code) #macro {
    match @insert(code, _break=break, _continue=continue) {
        Ok($val) -> val
        Err($err) -> @insert(with, link=[err], _break=break, _continue=continue)
    }
}

// drop
Drop :: trait {
    drop :: (ref Self);
}

// drops a values
Memory :: struct{}
impl Memory {
    drop :: (_: $T) {}
}

// option and result
Option :: enum(T: type) #copy(T) {
    None
    Some : T
}

Result :: enum(V: type, E: type) #copy(V, E) {
    Ok  : V
    Err : E
}

use Option
use Result

impl(T: type) Option[T] {
    unwrap :: (Self) -> T {
        return match self {
            Some($v) -> v
            None -> @assert(false)
        }
    }
}

impl(V: type, E: type) Result[V, E] {
    unwrap :: (Self) -> V {
        return match self {
            Ok($v) -> v
            Err(_) -> @assert(false)
        }
    }
}

From :: trait(T: type) {
    from :: (value: T) -> Self;
}

Into :: trait(T: type) {
    into :: (ref Self) -> T;
}

impl Into[()] for () {
    into :: (ref Self) -> () {
        return ()
    }
}

impl From[()] for () {
    from :: (value: ()) -> () {
        return ()
    }
}

// impl(F: type, T: type) From[F] for T if F : Into[T], #notyet {
//     from :: (value: F) -> T {
//         return F.into(value)
//     }
// }

// impl(F: type, T: type) Into[T] for F if T : From[F], #notyet {
//     into :: (ref Self) -> T {
//         return T.from(self)
//     }
// }

// Ranges
Range :: struct(T: type) {
    start : T = default
    end   : T = default
}

RangeInclusive :: struct(T: type) {
    start : T = default
    end   : T = default
}

RangeFrom :: struct(T: type) {
    start : T = default
}

RangeTo :: struct(T: type) {
    end : T = default
}

RangeToInclusive :: struct(T: type) {
    end : T = default
}

RangeFull :: struct {}

impl(T: type) Range[T] {
    reverse :: (self: Range[T]) -> Range[T] {
        return Range[T](self.end - 1, self.start - 1)
    }
}

impl string {
    get_index :: (Self, index: int) -> ref u8 #operator("[]") {
        return self.bytes[index]
    }

    get_range :: (Self, range: Range[int]) -> string #operator("[]") {
        data := int(self.bytes.data) + range.start
        length := range.end - range.start
        return string(cast data, length)
    }

    get_range_inclusive :: (Self, range: RangeInclusive[int]) -> string #operator("[]") {
        data := int(self.bytes.data) + range.start
        length := range.end - range.start + 1
        return string(cast data, length)
    }

    get_range_to :: (Self, range: RangeTo[int]) -> string #operator("[]") {
        @assert(range.end >= 0 and range.end <= self.bytes.length)
        data := int(self.bytes.data)
        length := range.end
        return string(cast data, length)
    }

    get_range_to_incl :: (Self, range: RangeToInclusive[int]) -> string #operator("[]") {
        @assert(range.end >= 0 and range.end < self.bytes.length)
        data := int(self.bytes.data)
        length := range.end + 1
        return string(cast data, length)
    }

    get_range_from :: (Self, range: RangeFrom[int]) -> string #operator("[]") {
        @assert(range.start >= 0 and range.start <= self.bytes.length)
        data := int(self.bytes.data) + range.start
        length := self.bytes.length - range.start
        return string(cast data, length)
    }

    get_range_full :: (Self, range: RangeFull) -> string #operator("[]") {
        return self
    }
}

impl(T: type) []T {
    get_index :: (Self, index: int) -> ref T #operator("[]") {
        return <<cast(&T) int(self.data) + index * @sizeof(T)
    }

    get_range :: (Self, range: Range[int]) -> []T #operator("[]") {
        result := self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = range.end - range.start
        return result
    }

    get_range_inclusive :: (Self, range: RangeInclusive[int]) -> []T #operator("[]") {
        result := self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = range.end - range.start + 1
        return result
    }

    get_range_to :: (Self, range: RangeTo[int]) -> []T #operator("[]") {
        @assert(range.end >= 0 and range.end <= self.length)
        result := self
        result.length = range.end
        return result
    }

    get_range_to_incl :: (Self, range: RangeToInclusive[int]) -> []T #operator("[]") {
        @assert(range.end >= 0 and range.end < self.length)
        result := self
        result.length = range.end + 1
        return result
    }

    get_range_from :: (Self, range: RangeFrom[int]) -> []T #operator("[]") {
        @assert(range.start >= 0 and range.start <= self.length)
        result := self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = self.length - range.start
        return result
    }

    get_range_full :: (Self, range: RangeFull) -> []T #operator("[]") {
        return self
    }
}

impl(T: type, Size: int) [Size]T {
    get_index :: (ref Self, index: int) -> ref T #operator("[]") {
        return <<cast(&T) int(self.data) + index * @sizeof(T)
    }

    get_range :: (ref Self, range: Range[int]) -> []T #operator("[]") {
        result : []T = self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = range.end - range.start
        return result
    }

    get_range_inclusive :: (ref Self, range: RangeInclusive[int]) -> []T #operator("[]") {
        result : []T = self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = range.end - range.start + 1
        return result
    }

    get_range_to :: (ref Self, range: RangeTo[int]) -> []T #operator("[]") {
        @assert(range.end >= 0 and range.end <= self.length)
        result : []T = self
        result.length = range.end
        return result
    }

    get_range_to_incl :: (ref Self, range: RangeToInclusive[int]) -> []T #operator("[]") {
        @assert(range.end >= 0 and range.end < self.length)
        result : []T = self
        result.length = range.end + 1
        return result
    }

    get_range_from :: (ref Self, range: RangeFrom[int]) -> []T #operator("[]") {
        @assert(range.start >= 0 and range.start <= self.length)
        result : []T = self
        result.data = cast int(result.data) + range.start * @sizeof(T)
        result.length = self.length - range.start
        return result
    }

    get_range_full :: (ref Self, range: RangeFull) -> []T #operator("[]") {
        return cast([]T) self
    }
}

// standard for loops
for_extension_range :: (r: Range[$T], code: Code) #for {
    rev := r.end < r.start
    inc := if rev then T(-1) else T(1)

    compare :: @code(if rev then it > r.end else it < r.end)

    while (it, it_index) := (r.start, 0),
            @insert(compare, link=[it], _break={}, _continue={}),
            it_index += 1; it += inc {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_range_inclusive :: (r: RangeInclusive[$T], code: Code, reverse: bool = false) #for {
    start, end, inc := {
        end := r.end
        if const reverse then (end, r.start, T(-1)) else (r.start, end, T(1))
    }

    compare :: @code(if const reverse then it >= end else it <= end)

    while (it, it_index) := (start, 0),
            @insert(compare, link=[it], _break={}, _continue={}),
            it_index += 1; it += inc {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_range_from :: (r: RangeFrom[$T], code: Code) #for {
    while (it, it_index) := (r.start, 0), true, it_index += 1; it += 1 {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_slice :: (arr: []$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
    while it_index := 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            it_index_rev := arr.length - it_index - 1
            it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
            @insert(code, link=[it_index_rev], _break=break, _continue=continue)
        } else {
            it := ref if const by_ref then ref arr[it_index] else arr[it_index]
            @insert(code, _break=break, _continue=continue)
        }
    }
}

for_extension_array :: (arr: [$Size]$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
    while it_index := 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            it_index_rev := arr.length - it_index - 1
            it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
            @insert(code, link=[it_index_rev], _break=break, _continue=continue)
        } else {
            it := if const by_ref then ref arr[it_index] else arr[it_index]
            @insert(code, _break=break, _continue=continue)
        }
    }
}

// trait stuff
__Trait :: struct {
    value  : &void
    vtable : &void
}

Traits :: struct {
    from_vtable_and_pointer :: ($T: type, vtable: &void, value: &void) -> &T {
        t := __Trait(value, vtable)
        return <<cast(&&T)&t
    }
}

// type info stuff
__ti_type_info := @type_info(TypeInfo)
TypeInfo :: struct #copy {
    size        : int
    alignment   : int
    kind        : TypeInfoKind
}

impl TypeInfo {
    get_trait_function :: (ref Self, $Trait: type, name: string, $F: type) -> F {
        return match kind {
            TypeInfoKind.Struct($s) ->  s.get_trait_function(Trait, name, F)

            $_ -> {
                // @panic("Not implemented!")
                null
            }
        }
    }
}

TypeInfoKind :: enum #copy {
    Int         : TypeInfoInt    = 0
    Float                        = 1
    Bool                         = 2
    Char                         = 3
    Struct      : TypeInfoStruct = 4
    Pointer     : &TypeInfo      = 5
    Reference   : &TypeInfo      = 6
    Slice       : &TypeInfo      = 7
    Enum        : TypeInfoEnum   = 8
    Trait       : TypeInfoTrait  = 9
    Void                         = 10
    String                       = 11
    Any                          = 12
    Array                        = 13 // @todo
    Function                     = 14 // @todo
    Tuple                        = 15 // @todo
}

TypeInfoTrait :: struct #copy {
    name      : string
    functions : []TypeInfoTraitFunction
}

TypeInfoTraitFunction :: struct #copy {
    name  : string
    index : int
}

TypeInfoInt :: struct #copy {
    signed : bool
}

TypeInfoStruct :: struct #copy {
    name    : string
    members : []TypeInfoStructMember
    traits  : []TypeInfoTraitImpl
    // parameters    : []any
    // const_members : []TypeInfoStructMember
}

TypeInfoTraitImpl :: struct #copy {
    trait_type : &TypeInfo
    vtable     : &void
}

TypeInfoStructMember :: struct #copy {
    index       : int
    offset      : int
    name        : string
    typ         : &TypeInfo
    value       : &any
    initializer : fn(&void)
    attributes  : []TypeInfoAttribute
}

TypeInfoAttribute :: struct {
    name : string
    args : []&any
}

TypeInfoEnum :: struct #copy {
    name     : string
    members  : []TypeInfoEnumMember
    tag_type : &TypeInfo
}

TypeInfoEnumMember :: struct #copy {
    name       : string
    typ        : &TypeInfo
    tag        : int
    attributes : []TypeInfoAttribute
}

impl TypeInfoStruct {
    has_member :: (ref Self, name: string) -> bool {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return true
            }
        }
        return false
    }

    get_member :: (ref Self, name: string) -> &TypeInfoStructMember {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }

    get_trait_impl :: (ref Self, $T: type) -> &TypeInfoTraitImpl {
        ti := @type_info(T)
        match ti.kind {
            TypeInfoKind.Trait -> {
                for(by_ref=true) traits {
                    if it.trait_type == ti {
                        return &it
                    }
                }
            }
        }
        return null
    }

    get_trait_function :: (ref Self, $Trait : type, func_name: string, $F: type) -> F {
        ti_impl := self.get_trait_impl(Trait)
        if ti_impl == null {
            return null
        }
        ti_trait := ti_impl.trait_type
        vtable := ti_impl.vtable
        func_info := ti_trait.kind.Trait.get_function(func_name)
        @assert(func_info != null)
        function := cast(F) @cast(&fn(), vtable)[func_info.index]
        return function
    }
}

impl TypeInfoTraitImpl {
    get_function :: (ref Self, func_name: string, $F: type) -> F {
        func_info := trait_type.kind.Trait.get_function(func_name)
        @assert(func_info != null)
        function := cast(F) @cast(&fn(), vtable)[func_info.index]
        return function
    }
}

impl TypeInfoAttribute {
    get_arg :: (ref Self, index: int, $T: type) -> T {
        @assert(index >= 0 and index < self.args.length)

        arg := self.args[index]
        @assert(@type_info(T) == @type_info_of_any(arg))

        return <<cast(&T) arg
    }
}

impl TypeInfoStructMember {
    get_attribute :: (ref Self, name: string) -> &TypeInfoAttribute {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return &att
            }
        }

        return null
    }

    has_attribute :: (ref Self, name: string) -> bool {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return true
            }
        }

        return false
    }
}

impl TypeInfoEnumMember {
    get_attribute :: (ref Self, name: string) -> &TypeInfoAttribute {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return &att
            }
        }

        return null
    }

    has_attribute :: (ref Self, name: string) -> bool {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return true
            }
        }

        return false
    }
}

impl TypeInfoTrait {
    get_function :: (ref Self, name: string) -> &TypeInfoTraitFunction {
        for(by_ref=true) functions {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }
}


strings_equal :: (a: string, b: string) -> bool {
    a_bytes := a.bytes
    b_bytes := b.bytes
    if a_bytes.length != b_bytes.length {
        return false
    }

    for 0..a_bytes.length {
        if a_bytes[it] != b_bytes[it] {
            return false
        }
    }

    return true
}