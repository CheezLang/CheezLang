_C :: import std.c

// OS
Platform :: enum {
    Unknown
    Windows
    Linux
    OSX
}

__platform__ : Platform = if const @is_os("Windows") {
    Platform.Windows
} else if const @is_os("Linux") {
    Platform.Linux
} else if const @is_os("OSX") {
    Platform.OSX
} else {
    Platform.Unknown
}

// try
try :: (code: Code) #macro {
    match @insert(code, _break=break, _continue=continue) {
        Ok($val) -> val
        Err($err) -> {
            ReturnType :: @function_type().return_type
            TargetType :: ReturnType.E
            return ReturnType.Err(cast(TargetType) @typeof(err).into(err))
        }
    }
}

try_with :: (code: Code, with: Code) #macro {
    match @insert(code, _break=break, _continue=continue) {
        Ok($val) -> val
        Err($err) -> @insert(with, _break=break, _continue=continue)
    }
}

// drop
Drop :: trait {
    drop :: (ref Self);
}

// drops a values
Memory :: struct{}
impl Memory {
    drop :: (_: $T) {}
}

// option and result
Option :: enum(T: type) #copy(T) {
    Some : T
    None
}

Result :: enum(V: type, E: type) #copy(V, E) {
    Ok  : V
    Err : E
}

use Option
use Result

From :: trait(T: type) {
    from :: (value: T) -> Self;
}

Into :: trait(T: type) {
    into :: (ref Self) -> T;
}

impl Into[()] for () {
    into :: (ref Self) -> () {
        return ()
    }
}

impl From[()] for () {
    from :: (value: ()) -> () {
        return ()
    }
}

// impl(F: type, T: type) From[F] for T if F : Into[T], #notyet {
//     from :: (value: F) -> T {
//         return F.into(value)
//     }
// }

// impl(F: type, T: type) Into[T] for F if T : From[F], #notyet {
//     into :: (ref Self) -> T {
//         return T.from(self)
//     }
// }

// standard for loops
for_extension_range :: (r: $T..T, code: Code, reverse: bool = false, inclusive: bool = false) #for {
    start, end, inc := {
        end := if const inclusive then r.end else r.end - 1
        if const reverse then (end, r.start, T(-1)) else (r.start, end, T(1))
    }

    compare :: @code(if const reverse then it >= end else it <= end)

    while (it, it_index) := (start, 0),
        @insert(compare, link=[it], _break={}, _continue={}),
        it_index += 1; it += inc {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_slice :: (arr: []$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
    while it_index := 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            it_index_rev := arr.length - it_index - 1
            it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
            @insert(code, link=[it_index_rev], _break=break, _continue=continue)
        } else {
            it := if const by_ref then ref arr[it_index] else arr[it_index]
            @insert(code, _break=break, _continue=continue)
        }
    }
}

for_extension_string_builtin :: (arr: string, code: Code) #for {
    bytes := arr.bytes
    while it_index := 0, it_index < bytes.length {
        b0 : u32 = cast bytes[it_index]

        code_point : u32 = 0
        if @bin_lsr(b0, 7) == 0 {
            code_point = cast b0
            it_index += 1
        } else if @bin_lsr(b0, 5) == 0b110 {
            b1 : u32 = cast bytes[it_index + 1]

            b0_masked := @bin_and(b0, 0b00011111)
            b1_masked := @bin_and(b1, 0b00111111)

            code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
            it_index += 2
        } else if @bin_lsr(b0, 4) == 0b1110 {
            b1 : u32 = cast bytes[it_index + 1]
            b2 : u32 = cast bytes[it_index + 2]

            b0_masked := @bin_and(b0, 0b00001111)
            b1_masked := @bin_and(b1, 0b00111111)
            b2_masked := @bin_and(b2, 0b00111111)

            code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
            code_point = @bin_or(@bin_lsl(code_point, 6), b2_masked)
            it_index += 3
        } else if @bin_lsr(b0, 3) == 0b11110 {
            b1 : u32 = cast bytes[it_index + 1]
            b2 : u32 = cast bytes[it_index + 2]
            b3 : u32 = cast bytes[it_index + 3]

            b0_masked := @bin_and(b0, 0b00000111)
            b1_masked := @bin_and(b1, 0b00111111)
            b2_masked := @bin_and(b2, 0b00111111)
            b3_masked := @bin_and(b3, 0b00111111)

            code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
            code_point = @bin_or(@bin_lsl(code_point, 6), b2_masked)
            code_point = @bin_or(@bin_lsl(code_point, 6), b3_masked)
            it_index += 4
        }

        it : char = cast code_point

        @insert(code, _break=break, _continue=continue)
    }
}

// for_extension_array :: (arr: [$Size]$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
//     while it_index := 0, it_index < arr.length, it_index += 1 {
//         if const reverse {
//             it_index_rev := arr.length - it_index - 1
//             it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
//             @insert(code, link=[it_index_rev], _break=break, _continue=continue)
//         } else {
//             it := if const by_ref then ref arr[it_index] else arr[it_index]
//             @insert(code, _break=break, _continue=continue)
//         }
//     }
// }

// type info stuff
TypeInfo :: struct #copy {
    size        : int
    alignment   : int
    kind        : TypeInfoKind
}

impl TypeInfo {
    get_trait_function :: (ref Self, $Trait: type, name: string, $F: type) -> F {
        return match kind {
            TypeInfoKind.Struct($s) ->  s.get_trait_function(Trait, name, F)

            $_ -> {
                // @panic("Not implemented!")
                null
            }
        }
    }
}

TypeInfoKind :: enum #copy {
    Int         : TypeInfoInt    = 0
    Float                        = 1
    Bool                         = 2
    Char                         = 3
    Struct      : TypeInfoStruct = 4
    Pointer     : &TypeInfo      = 5
    Reference   : &TypeInfo      = 6
    Slice       : &TypeInfo      = 7
    Enum        : TypeInfoEnum   = 8
    Trait       : TypeInfoTrait  = 9
    Void                         = 10
}

TypeInfoTrait :: struct #copy {
    name      : string
    functions : []TypeInfoTraitFunction
}

TypeInfoTraitFunction :: struct #copy {
    name  : string
    index : int
}

TypeInfoInt :: struct #copy {
    signed : bool
}

TypeInfoStruct :: struct #copy {
    name    : string
    members : []TypeInfoStructMember
    traits  : []TypeInfoTraitImpl
    // parameters    : []any
    // const_members : []TypeInfoStructMember
}

TypeInfoTraitImpl :: struct #copy {
    trait_type : &TypeInfo
    vtable     : &void
}

TypeInfoStructMember :: struct #copy {
    offset     : int
    name       : string
    typ        : &TypeInfo
    value      : any
    attributes : []TypeInfoAttribute
}

TypeInfoAttribute :: struct {
    name : string
    args : []any
}

TypeInfoEnum :: struct #copy {
    name     : string
    members  : []TypeInfoEnumMember
    tag_type : &TypeInfo
}

TypeInfoEnumMember :: struct #copy {
    name       : string
    typ        : &TypeInfo
    tag        : int
    attributes : []TypeInfoAttribute
}

impl TypeInfoStruct {
    has_member :: (ref Self, name: string) -> bool {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return true
            }
        }
        return false
    }

    get_member :: (ref Self, name: string) -> &TypeInfoStructMember {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }

    get_trait_impl :: (ref Self, $T: type) -> &TypeInfoTraitImpl {
        ti := @type_info(T)
        match ti.kind {
            TypeInfoKind.Trait -> {
                for(by_ref=true) traits {
                    if it.trait_type == ti {
                        return &it
                    }
                }
            }
        }
        return null
    }

    get_trait_function :: (ref Self, $Trait : type, func_name: string, $F: type) -> F {
        ti_impl := self.get_trait_impl(Trait)
        if ti_impl == null {
            return null
        }
        ti_trait := ti_impl.trait_type
        vtable := ti_impl.vtable
        func_info := ti_trait.kind.Trait.get_function(func_name)
        function := cast(F) @cast(&fn(), vtable)[func_info.index]
        return function
    }
}

impl TypeInfoStructMember {
    get_attribute :: (ref Self, name: string) -> &TypeInfoAttribute {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return &att
            }
        }

        return null
    }

    has_attribute :: (ref Self, name: string) -> bool {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return true
            }
        }

        return false
    }
}

impl TypeInfoEnumMember {
    get_attribute :: (ref Self, name: string) -> &TypeInfoAttribute {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return &att
            }
        }

        return null
    }

    has_attribute :: (ref Self, name: string) -> bool {
        for(by_ref=true) att : attributes {
            if strings_equal(att.name, name) {
                return true
            }
        }

        return false
    }
}

impl TypeInfoTrait {
    get_function :: (ref Self, name: string) -> &TypeInfoTraitFunction {
        for(by_ref=true) functions {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }
}


strings_equal :: (a: string, b: string) -> bool {
    a_bytes := a.bytes
    b_bytes := b.bytes
    if a_bytes.length != b_bytes.length {
        return false
    }

    for 0..a_bytes.length {
        if a_bytes[it] != b_bytes[it] {
            return false
        }
    }

    return true
}