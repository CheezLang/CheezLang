// OS
Platform :: enum {
    Unknown
    Windows
    Linux
    OSX
}

__platform__ : Platform = if const @is_os("Windows") {
    Platform.Windows
} else if const @is_os("Linux") {
    Platform.Linux
} else if const @is_os("OSX") {
    Platform.OSX
} else {
    Platform.Unknown
}

// drop
Drop :: trait {
    drop :: (ref Self);
}

// drops a values
Memory :: struct{}
impl Memory {
    drop :: (_: $T) {}
}

// option and result
Option :: enum(T: type) #copy(T) {
    Some : T
    None
}

Result :: enum(V: type, E: type) #copy(V, E) {
    Ok  : V
    Err : E
}

use Option
use Result

From :: trait(T: type) {
    from :: (value: T) -> Self;
}

Into :: trait(T: type) {
    into :: (ref Self) -> T;
}

// impl(F: type, T: type) From[F] for T if F : Into[T], #notyet {
//     from :: (value: F) -> T {
//         return F.into(value)
//     }
// }

// impl(F: type, T: type) Into[T] for F if T : From[F], #notyet {
//     into :: (ref Self) -> T {
//         return T.from(self)
//     }
// }

// standard for loops
for_extension_range :: (r: $T..T, code: Code, reverse: bool = false, inclusive: bool = false) #for {
    start, end, inc := {
        end := if const inclusive then r.end else r.end - 1
        if const reverse then (end, r.start, T(-1)) else (r.start, end, T(1))
    }

    compare :: @code(if const reverse then it >= end else it <= end)

    while (it, it_index) := (start, 0),
        @insert(compare, link=[it], _break={}, _continue={}),
        it_index += 1; it += inc {
        @insert(code, _break=break, _continue=continue)
    }
}

for_extension_slice :: (arr: []$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
    while it_index := 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            it_index_rev := arr.length - it_index - 1
            it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
            @insert(code, link=[it_index_rev], _break=break, _continue=continue)
        } else {
            it := if const by_ref then ref arr[it_index] else arr[it_index]
            @insert(code, _break=break, _continue=continue)
        }
    }
}

// for_extension_array :: (arr: [$Size]$T, code: Code, reverse: bool = false, by_ref: bool = false) #for {
//     while it_index := 0, it_index < arr.length, it_index += 1 {
//         if const reverse {
//             it_index_rev := arr.length - it_index - 1
//             it := if const by_ref then ref arr[it_index_rev] else arr[it_index_rev]
//             @insert(code, link=[it_index_rev], _break=break, _continue=continue)
//         } else {
//             it := if const by_ref then ref arr[it_index] else arr[it_index]
//             @insert(code, _break=break, _continue=continue)
//         }
//     }
// }

// type info stuff
TypeInfo :: struct #copy {
    size        : int
    alignment   : int
    kind        : TypeInfoKind
}

TypeInfoKind :: enum #copy {
    Int         : TypeInfoInt    = 0
    Float                        = 1
    Bool                         = 2
    Char                         = 3
    Struct      : TypeInfoStruct = 4
    Pointer     : &TypeInfo      = 5
    Reference   : &TypeInfo      = 6
    Slice       : &TypeInfo      = 7
    Enum        : TypeInfoEnum   = 8
    Trait       : TypeInfoTrait  = 9
}

TypeInfoTrait :: struct #copy {
    name : string
}

TypeInfoInt :: struct #copy {
    signed : bool
}

TypeInfoStruct :: struct #copy {
    name          : string
    members       : []TypeInfoStructMember
    // parameters    : []any
    // const_members : []TypeInfoStructMember
}

TypeInfoStructMember :: struct #copy {
    offset : int
    name   : string
    typ    : &TypeInfo
}

TypeInfoEnum :: struct #copy {
    name    : string
    members : []TypeInfoEnumMember
    tag_type: &TypeInfo
}

TypeInfoEnumMember :: struct #copy {
    name : string
    typ  : &TypeInfo
    tag  : int
}

impl TypeInfoStruct {
    get_member :: (ref Self, name: string) -> &TypeInfoStructMember {
        for(by_ref=true) members {
            if strings_equal(name, it.name) {
                return &it
            }
        }
        return null
    }
}

strings_equal :: (a: string, b: string) -> bool {
    if a.length != b.length {
        return false
    }

    for 0..a.length {
        if a[it] != b[it] {
            return false
        }
    }

    return true
}