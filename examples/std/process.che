if const @is_os("windows") {
    use import std.os.windows
    use import std.os.windows_functions
    use import std.os.windows_constants
    use import std.os.windows_types
}
if const @is_os("linux") {
    import std.os.linux
}

use import std.string
C   :: import std.c
io  :: import std.io
fmt :: import std.fmt

#export_scope

find_on_path :: (program: string) -> Option[String] {
    buffer: [MAX_PATH]char = default
    C.memcpy(buffer.data, program.data, cast program.length)
    ok := 0 != PathFindOnPathA(buffer.data, null)
    if !ok {
        return None
    }

    result := String.from_cstring(buffer.data)
    return Some(result)
}

run_process :: (program: string, args: []string, working_dir: string) -> bool {
    si := STARTUPINFOA()
    pi := PROCESS_INFORMATION()

    command_line := String.empty()
    command_line.appendf("`"{}`"", program)
    for arg : args {
        command_line.appendf(" `"{}`"", arg)
    }
    command_line.append_char(char(0))

    current_directory := String.from_string(working_dir)
    current_directory.append_char(char(0))
    ok := 0 != CreateProcessA(null, command_line.get_raw(), null, null, 0, 0, null, current_directory.get_raw(), &si, &pi)

    if !ok {
        lastError := GetLastError();
        io.println(fmt.format("failed to create process: 0x{:x}", [lastError]))
        return false
    }

    WaitForSingleObject(pi.hProcess, INFINITE)

    CloseHandle(pi.hThread)
    CloseHandle(pi.hProcess)

    return true
}
