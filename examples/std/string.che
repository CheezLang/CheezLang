#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")

fn strlen(s: c_string) -> int {
    let len: int = 0
    while s[len] != '`0' {
        len += 1
    }
    return len
}

fn streql(a: $T, b: $T2, len: ulong) -> bool {
    let alen: ulong = (ulong)a.getLength()
    let blen: ulong = (ulong)b.getLength()
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    while let i: ulong = 0; i < len; i += 1 {
        if a.charAt(i) != b.charAt(i) {
            return false
        }
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len: ulong = (ulong)a.getLength()
    let blen: ulong = (ulong)b.getLength()

    if len != blen {
        return false
    }

    while let i: ulong = 0; i < len; i += 1 {
        if a.charAt(i) != b.charAt(i) {
            return false
        }
    }
    return true
}

impl c_string {
    fn getLength() -> int {
        return strlen(self)
    }
    
    fn charAt(i: $T) -> char {
        return self[i]
    }
}

impl string {
    fn getLength() -> int {
        return self.length
    }
    
    fn charAt(i: $T) -> char {
        return self[i]
    }
}

impl Printable for c_string {
    fn print(str: String&, format: char[]) {
        str.append_cstring(<<self)
    }
}

impl Printable for string {
    fn print(str: String&, format: char[]) {
        str.append_string(<<self)
    }
}

struct StringBase(CharType: type) {
    data: CharType&         = null
    length: int             = 0
    capacity: int           = 0
    allocator: Allocator    = null
}

let String = StringBase(char)
let Utf32String = StringBase(int)

impl StringBase($CharType) {
    ref fn getLength() -> int {
        return length
    }

    ref fn charAt(i: $T) -> CharType {
        return data[i]
    }

    ref fn init(alloc: Allocator) {
        allocator = alloc
        data = null
        length = 0
        capacity = 0
        self.reserve(10)
    }

    ref fn reserve(size: int) {
        capacity = size
        if data == null {
            length = 0
            data = allocator.allocate((ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        else {
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
            if length > capacity {
                length = capacity
            }
        }
    }
    
    ref fn resize(size: int) {
        length = size
        capacity = size
        if data == null {
            data = allocator.allocate((ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        else {
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
    }

    ref fn fromString(str: c_string) -> StringBase(CharType)& {
        if (ulong)data != 0 {
            // @Todo:
            //self.dispose()
            allocator.free(data)
            data = null
            length = 0
            capacity = 0
        }

        length = strlen(str)
        capacity = length
        data = allocator.allocate((ulong)capacity, @sizeof(CharType), @alignof(CharType))

        if @sizeof(CharType) == 1 {
            c_memcpy(data, str, length)
        } else {
            while let i = 0; i < length; i += 1 {
                data[i] = (CharType)str[i]
            }
        }

        return &self
    }

    ref fn append(other: StringBase(CharType)) -> StringBase(CharType)& {
        let newLength = length + other.length

        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other.data, other.length * @sizeof(CharType))

        length = newLength

        return &self
    }

    ref fn append_cstring(other: c_string) -> StringBase(CharType)& {
        let otherLength = strlen(other)
        let newLength = length + otherLength
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other, otherLength)

        length = newLength

        return &self
    }

    ref fn append_string(other: char[]) -> StringBase(CharType)& {
        let newLength = length + other.length
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other.data, other.length)

        length = newLength

        return &self
    }

    ref fn appendChar(ch: CharType) -> StringBase(CharType)& {
        let newLength = length + 1
        
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, (ulong)capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        
        data[length] = ch
        length = newLength

        return &self
    }

    ref fn equals(other: $T) -> bool {
        if @isstring(T) { 
            let len: @typeof(length) = strlen(other)
            if len != length {
                return false
            }
            
            while let i: ulong = 0; i < len; i += 1 {

                if data[i] != other[i] {
                    return false
                }
            }
            return true
        }
        else {
            @error("Not implemented")
        }
    }

    ref fn dispose() {
        allocator.free(data)
        data = null
        length = 0
    }

    ref fn slice() -> CharType[] {
        return self.sliceFL(0, length)
    }

    ref fn sliceFL(from: int, len: int) -> CharType[] {
        let slice: CharType[] = &data[from]
        slice.length = len
        return slice
    }

    ref fn sliceF(from: int) -> CharType[] {
        return self.sliceFL(from, length - from)
    }
    
    ref fn sliceL(len: int) -> CharType[] {
        return self.sliceFL(0, len)
    }

    ref fn indexOf(ch: CharType) -> int {
        let i = 0
        while i < length {
            if data[i] == ch {
                return i
            }

            i += 1
        }

        return -1
    }
}

fn newString() -> String {
    let t = new String {
        null, 0, 0, new StdHeapAllocator {}
    }
    t.reserve(10)
    return t
}

fn newString2(alloc: Allocator) -> String {
    let t = new String {
        null, 0, 0, alloc
    }
    t.reserve(10)
    return t
}

impl c_string {
    fn toString() -> String {
        let s = newString()
        s.append_cstring(self)
        return s
    }
}

impl string {
    fn toString() -> String {
        let s = newString()
        s.append_string(self)
        return s
    }
}
