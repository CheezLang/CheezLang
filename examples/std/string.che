io   :: import std.io
util :: import std.util
C    :: import std.c
fmt  :: import std.fmt

use import std.array
use import std.hash
use import std.unicode
use import std.printable
use import std.mem.allocator
use import std.mem.std_heap_allocator
import std.alloca

if const @is_os("windows") {
    use import std.os.windows_functions
    use import std.os.windows_constants
}

#export_scope

String :: struct {
    data      : []u8
    length    : int
    allocator : ^Allocator
}

impl Drop for String {
    drop :: (&Self) {
        if allocator != null {
            free_n(data, allocator)
        }
        data = null
        length = 0
    }
}

impl String {
    empty :: (allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        return String(null, 0, allocator)
    }

    with_capacity :: (cap: int, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        result := String(null, 0, allocator)
        result.reserve(cap)
        return result
    }

    from_raw_ptr :: (ptr: ^u8, cap: int) -> Self {
        sl : []u8 = ptr
        sl.length = cap
        return String(sl, 0, null)
    }

    from_string :: (str: string, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        s := Self.empty(allocator)
        s.append_string(str)
        return s
    }

    from_cstring :: (str: c_string, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        s := Self.empty(allocator)
        s.append_cstring(str)
        return s
    }

    from_utf16 :: (str: []u16) -> Result[String, ()] {
        required_size := WideCharToMultiByte(CP_UTF8, 0, str.data, cast str.length, null, 0, null, null)
        result := String.empty()
        result.resize(required_size)
        bytes_written := WideCharToMultiByte(CP_UTF8, 0, str.data, cast str.length, result.get_raw(), required_size, null, null)
        if bytes_written == 0 {
            return Err(())
        }
        return Ok(result)
    }

    get_capacity :: (&Self) -> int {
        return data.length
    }

    get_length :: (&Self) -> int {
        return length
    }

    get_raw :: (&Self) -> ^u8 {
        return data.data
    }

    char_at :: (&Self, i: int) -> char #operator("[]") {
        code_point, len := Utf8.decode(data[i..data.length])
        return code_point
    }

    set_char_at :: (&Self, i: int, c: u8) #operator("set[]") {
        *data[i] = c
    }

    reserve_more :: (&Self, amount: int) {
        reserve(length + amount)
    }

    reserve :: (&Self, size: int) {
        if data.length > size {
            return
        }

        data.length = size
        if data.data == null {
            length = 0
            data = alloc_n(u8, cast size, allocator)
        } else {
            data = realloc_n(data, cast size, allocator)
            if length > data.length {
                length = data.length
            }
        }
    }

    clear :: (&Self) {
        length = 0
    }

    resize :: (&Self, size: int) {
        self.reserve(size)
        length = size
    }

    append :: (&Self, other: &Self) -> &Self #operator("+=") {
        if other.data.data == null {
            return self
        }
        newLength := length + other.length
        self.reserve(newLength)
        C.memcpy(cast ^data.data[length], cast other.data.data, cast(uint) (other.length * @sizeof(u8)))
        length = newLength
        return self
    }

    append_string :: (&Self, other: string) -> &Self #operator("+=") {
        newLength := length + other.bytes.length
        self.reserve(newLength)
        C.memcpy(cast ^data.data[length], cast other.bytes.data, cast other.bytes.length)
        length = newLength
        return self
    }

    append_cstring :: (&Self, other: c_string) -> &Self #operator("+=") {
        otherLen := C.strlen(other)
        newLength := length + int(otherLen)
        self.reserve(newLength)
        C.memcpy(cast ^data.data[length], cast other, cast otherLen)
        length = newLength
        return self
    }

    append_char :: (&Self, ch: char) -> &Self #operator("+=") {
        bytes, count := Utf8.encode(ch)
        newLength := length + int(count)
        self.reserve(newLength)
        C.memcpy(^*data[length], ^*bytes[0], cast count)
        length = newLength
        return self
    }

    sliceFT :: (&Self, from: int, to: int) -> string {
        slice := string(^*data[from], to - from)
        return slice
    }

    sliceFL :: (&Self, from: int, len: int) -> string {
        slice := string(^*data[from], len)
        return slice
    }

    slice :: (&Self) -> string {
        return self.sliceFL(0, length)
    }

    sliceF :: (&Self, from: int) -> string {
        return self.sliceFL(from, length - from)
    }
    
    sliceL :: (&Self, len: int) -> string {
        return self.sliceFL(0, len)
    }

    index_of :: (&Self, ch: char) -> int {
        for i in 0..length {
            if *data[i] == u8(ch) {
                return i
            }
        }

        return -1
    }

    as_cstring :: (&Self) -> c_string {
        reserve(length + 1)
        *data[length] = 0u8
        return cast data.data
    }
}

impl Equatable[String] for String {
    equal :: (&Self, other: &String) -> bool {
        str := self.slice()
        oth := other.slice()
        return streq_string(str, oth)
    }
}

impl Equatable[string] for String {
    equal :: (&Self, other: &string) -> bool {
        str := self.slice()
        return streq_string(str, *other)
    }
}

impl Equatable[string] for string {
    equal :: (&Self, b: &string) -> bool {
        return streq_string(*self, *b)
    }
}

impl Hashable for String {
    hash :: (&Self) -> uint {
        str := self.slice()
        return str.hash()
    }
}

impl Clone for String {
    clone :: (&Self) -> Self {
        other := String.empty()
        other.append(self)
        return other
    }
}

impl String {
    append_print :: (&Self, pr: ^Printable) -> &Self #operator("+=") {
        pr.print(self, "")
        return self
    }

    appendf :: (&Self, format: string, arguments: $T) {
        if const @is_tuple(T) {
            if const T.length == 0 {
                args : [1]^Printable = [^arguments]
            } else {
                args : [T.length]^Printable = default
                @for_tuple_values(arguments, (v, i) => {
                    if const @types_match(@typeof(v), &$_) {
                        *args[i] = ^*v
                    } else {
                        *args[i] = ^v
                    }
                })
            }
        } else {
            args : [1]^Printable = [^arguments]
        }
        self.append_printables(format, args)
    }


    append_printables :: (&Self, format: string, args: []^Printable) {
        formatSpecifier := {
            len :: 64
            mem := @alloca(u8, len)
            String.from_raw_ptr(mem.data, mem.length)
        }

        //len      := format.bytes.length
        state    := 0
        argIndex := 0

        // state    - desc
        // 0        - normal
        // 1        - in format
        // 2        - escape

        for c in format {
            if state == 0 {
                if c == '``' {
                    state = 2
                } else if c == '{' {
                    state = 1
                } else {
                    self += c
                }
            } else if state == 2 {
                self += c
                state = 0
            } else if state == 1 {
                if c == '}' {
                    state = 0

                    format := ""

                    colon := formatSpecifier.index_of(':')
                    if colon >= 1 {
                        // colon -> arg index before colon
                        argIndex = fmt.parse_int(formatSpecifier.sliceL(colon))
                    } else if colon == -1 and formatSpecifier.length > 0 {
                        // no colon but non empty -> arg index
                        argIndex = fmt.parse_int(formatSpecifier.slice())
                    }
                    if colon != -1 {
                        // colon -> format after colon
                        format = formatSpecifier.sliceF(colon + 1)
                    }

                    if argIndex >= args.length {
                        C.printf("[%lld] `"%.*s`": arg index to out of bounds: %lld, args: %lld`n", it_index, format.bytes.length, format.bytes.data, argIndex, args.length)
                        return
                    }

                    (*args[argIndex]).print(self, format)
                    argIndex += 1
                    formatSpecifier.length = 0

                } else {
                    &formatSpecifier += c
                }
            }
        }
    }

    format :: (format: string, args: $T) -> Self {
        s := Self.empty()
        s.appendf(format, args)
        return s
    }

    split_at_char :: (&Self, c: char, remove_empty: bool = false) -> Array[string] {
        result := Array[string].create()

        start := 0
        for i in 0..length {
            if *data[i] == u8(c) {
                sub := self.sliceFT(start, i)
                if sub.bytes.length > 0 or !remove_empty {
                    result.add(sub)
                }

                start = i + 1
            }
        }

        if start < length {
            sub := self.sliceF(start)
            if sub.bytes.length > 0 or !remove_empty {
                result.add(sub)
            }
        }

        return result
    }
}

StringLineIterator :: struct {
    remaining: string
}

for_extension_string_line_iterator :: (self: StringLineIterator, body: Code) #for {
    it_index := 0
    bytes := self.remaining.bytes

    loop {
        if bytes.length <= 0 then break
        defer {it_index += 1}

        line_end  := -1
        for c, i in bytes {
            if char(c) == '`n' {
                line_end = i
                break
            }
        }

        // if no newline was found, then the line is the remainder of the string
        if line_end == -1 {
            line_end = bytes.length
        }

        line    := bytes[0 .. line_end]
        bytes   = bytes[(line_end + 1) .. bytes.length]
        it      := string(line.data, line.length)
        @insert(body)
    }
}

StringSplitCharIterator :: struct {
    remaining   : string
    split_at    : char
    remove_empty: bool
}

impl StringSplitCharIterator {
    to_array :: (Self) -> Array[string] {
        result := Array[string].create()
        for part in self {
            result.add(part)
        }
        return result
    }
}

for_extension_string_split_char_iterator :: (self: StringSplitCharIterator, body: Code) #for {
    it_index := 0

    while self.remaining.bytes.length > 0 {
        index := self.remaining.index_of(self.split_at)
        it := if index < 0 {
            self.remaining <- ""
        } else {
            tmp := self.remaining[..index]
            self.remaining = self.remaining[(index+1)..]
            tmp
        }

        if it.bytes.length != 0 {
            @insert(body)
            it_index += 1
        }
    }
}

impl Printable for String {
    print :: (&Self, str: &String, format: string) {
        str += self
    }
}

streql :: (a: $T, b: $T2, len: int) -> bool {
    alen := T.get_length(a)
    blen := T2.get_length(b)
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    for i in 0..len {
        if T.char_at(a, i) != T2.char_at(b, i) {
            return false
        }
    }
    return true
}

streq :: (a: $T, b: $T2) -> bool {
    len  := T.get_length(a)
    blen := T2.get_length(b)

    if len != blen {
        return false
    }

    for i in 0..len {
        if T.char_at(a, i) != T2.char_at(b, i) {
            return false
        }
    }
    return true
}

streq_string :: (a: string, b: string) -> bool {
    return streq(a, b)
}

impl string {
    get_length :: (Self) -> int {
        // @todo: calculate length in chars
        return self.bytes.length
    }
    
    char_at :: (Self, i: int) -> char {
        return char(*self[i])
    }

    to_string :: (Self) -> String {
        return String.from_string(self)
    }

    to_owned :: (Self) -> String {
        return String.from_string(self)
    }

    slice :: (Self, from: int = 0, length: int = -1) -> string {
        if length < 0 {
            length = self.bytes.length - from
        }

        result := string(util.pointer_add_sized(self.bytes.data, from), length)
        return result
    }

    lines :: (Self) -> StringLineIterator {
        return StringLineIterator(self)
    }

    split_at_char :: (Self, c: char, remove_empty: bool = false) -> StringSplitCharIterator {
        return StringSplitCharIterator(self, c, remove_empty)
    }

    starts_with :: (Self, prefix: string) -> bool {
        self_bytes := self.bytes
        pref_bytes := prefix.bytes
        if pref_bytes.length > self_bytes.length {
            return false
        }

        for i in 0 .. pref_bytes.length {
            if *self_bytes[i] != *pref_bytes[i] {
                return false
            }
        }

        return true
    }

    ends_with :: (Self, postfix: string) -> bool {
        self_bytes := self.bytes
        post_bytes := postfix.bytes
        if post_bytes.length > self_bytes.length {
            return false
        }

        offset := self_bytes.length - post_bytes.length

        for i in 0 .. post_bytes.length {
            if *self_bytes[offset + i] != *post_bytes[i] {
                return false
            }
        }

        return true
    }

    sub_string :: (Self, from_byte: int, to_byte: int = -1) -> string {
        if to_byte == -1 {
            to_byte = self.bytes.length
        }
        @assert(
            from_byte >= 0 and
            from_byte <= self.bytes.length and
            from_byte <= to_byte and
            to_byte <= self.bytes.length)
        sub_bytes := self.bytes[from_byte .. to_byte]
        return string(sub_bytes.data, sub_bytes.length)
    }

    trim :: (Self) -> string {
        if self.bytes.length == 0 {
            return ""
        }

        start := -1
        end   := -1

        for self.bytes {
            c := char(it)
            if !char.is_whitespace(c) {
                if start == -1 {
                    start = it_index
                }

                end = it_index
            }
        }

        if start == -1 and end == -1 {
            // only whitespace in string
            return ""
        }

        end += 1
        @assert(start >= 0 and start < self.bytes.length and start <= end and end <= self.bytes.length)
        return self.sub_string(start, end)
    }

    contains :: (Self, ch: char) -> bool {
        for c in self {
            if c == ch {
                return true
            }
        }

        return false
    }

    count_char :: (Self, ch: char) -> int {
        count := 0
        for c in self {
            if c == ch {
                count += 1
            }
        }

        return count
    }

    index_of :: (Self, ch: char) -> int {
        // @todo: properly handle utf8
        bytes := self.bytes
        for i in 0..bytes.length {
            if *bytes[i] == u8(ch) {
                return i
            }
        }

        return -1
    }

    last_index_of :: (Self, ch: char) -> int {
        ch_bytes, ch_len := Utf8.encode(ch)

        for i in self.bytes.length - int(ch_len) .. 0 #label outer {
            for k in 0 .. int(ch_len) {
                if *self.bytes[i + k] != *ch_bytes[k] then continue outer
            }
            return i
        }

        return -1
    }

    index_of_string :: (Self, str: string) -> int {
        if str.bytes.length == 0 {
            return 0
        }

        bytes := self.bytes
        for i in 0..self.bytes.length #label outer {
            for k in 0..str.bytes.length {
                if *self[i + k] != *str[k] then continue outer
            }

            return i
        }

        return -1
    }

    to_cstring :: (Self) -> c_string {
        str_c := alloc_raw(char8, cast self.bytes.length + 1)
        str_c[self.bytes.length] = cast 0
        C.memcpy(cast str_c, cast self.bytes.data, cast self.bytes.length)
        return str_c
    }

    to_utf16 :: (Self) -> Result[Array[u16], ()] {
        required_size := MultiByteToWideChar(CP_UTF8, 0, self.bytes.data, cast self.bytes.length, null, 0)
        wide_char_str := Array[u16].create(cast required_size + 1)
        wide_char_str.resize(required_size)
        *wide_char_str.access_unchecked(required_size) = 0
        bytes_written := MultiByteToWideChar(CP_UTF8, 0, self.bytes.data, cast self.bytes.length, wide_char_str.get_raw(), required_size)
        if bytes_written < required_size {
            @assert(false)
            return Err(())
        }
        return Ok(wide_char_str)
    }
}

impl Into[String] for string {
    into :: (&Self) -> String {
        return self.to_owned()
    }
}

impl char {
    is_whitespace :: (Self) -> bool {
        return match self {
            ' ' -> true
            '`t' -> true
            '`r' -> true
            '`n' -> true
            _ -> false
        }
    }

    is_alpha :: (Self) -> bool {
        return (self >= 'a'  and self <= 'z') or (self >= 'A' and self <= 'Z')
    }

    is_digit :: (Self) -> bool {
        return (self >= '0'  and self <= '9')
    }

    is_bin_digit :: (Self) -> bool {
        return (self >= '0'  and self <= '1')
    }

    is_hex_digit :: (Self) -> bool {
        return (self >= '0'  and self <= '9') or (self >= 'a'  and self <= 'f') or (self >= 'A' and self <= 'F')
    }
}

impl c_string {
    get_length :: (Self) -> int {
        return cast C.strlen(self)
    }
    
    char_at :: (Self, i: int) -> char {
        return char(self[i])
    }

    to_string :: (Self) -> String {
        return String.from_cstring(self)
    }
}

for_extension_string_builtin :: (arr: string, code: Code) #for {
    bytes := arr.bytes

    while it_index := 0, it_index < bytes.length {
        it, len := Utf8.decode(bytes[it_index..bytes.length])
        @insert(code, _break=break, _continue=continue)
        it_index += int(len)
    }
}