// #load("std:mem/allocator")
// #load("std:mem/std_heap_allocator")
#load("std:mem/memory")
#load("std:io/io")
#load("std:printable")
#load("std:c")

struct StringBase(CharType: type) {
    data: []CharType
    length: int
}

typedef String = StringBase(char)
typedef Utf32String = StringBase(i32)

impl StringBase($CharType) {
    fn empty() -> Self {
        return new { null, 0 }
    }

    fn from_string(str: string) -> Self {
        let s = Self::empty()
        s.append_string(str)
        return s
    }

    fn from_cstring(str: c_string) -> Self {
        let s = Self::empty()
        s.append_cstring(str)
        return s
    }

    fn free(ref Self) {
        c_free(cast data.data)
        data = null
        length = 0
    }

    fn get_length(ref Self) -> int {
        return length
    }

    fn get_capacity(ref Self) -> int {
        return data.length
    }

    fn get_raw(ref Self) -> &CharType {
        return data.data
    }

    fn char_at(ref Self, i: int) -> CharType {
        return data[i]
    }

    fn reserve(ref Self, size: int) {
        if data.length > size {
            return
        }

        data.length = size
        if data.data == null {
            length = 0
            data.data = cast c_malloc(cast(i32) (size * @sizeof(CharType)))
        }
        else {
            data.data = cast c_realloc(cast data.data, cast(i32) (size * @sizeof(CharType)))
            if length > data.length {
                length = data.length
            }
        }
    }

    fn resize(ref Self, size: int) {
        self.reserve(size)
        length = size
    }

    fn append(ref Self, other: ref Self) -> ref Self #operator("+=") {
        let newLength = length + other.length
        self.reserve(newLength)
        c_memcpy(cast &data.data[length], cast other.data.data, cast(i32) (other.length * @sizeof(CharType)))
        length = newLength
        return self
    }

    fn append_string(ref Self, other: string) -> ref Self #operator("+=") {
        let newLength = length + other.length
        self.reserve(newLength)
        c_memcpy(cast &data.data[length], cast other.data, cast other.length)
        length = newLength
        return self
    }

    fn append_cstring(ref Self, other: c_string) -> ref Self #operator("+=") {
        let otherLen = other::get_length()
        let newLength = length + otherLen
        self.reserve(newLength)
        c_memcpy(cast &data.data[length], cast other, cast otherLen)
        length = newLength
        return self
    }

    fn append_char(ref Self, ch: CharType) -> ref Self #operator("+=") {
        let newLength = length + 1
        self.reserve(newLength)
        data[length] = ch
        length = newLength
        return self
    }

    fn sliceFL(ref Self, from: int, len: int) -> []CharType {
        let slice: []CharType = &data[from]
        slice.length = len
        return slice
    }

    fn slice(ref Self) -> []CharType {
        return self.sliceFL(0, length)
    }

    fn sliceF(ref Self, from: int) -> []CharType {
        return self.sliceFL(from, length - from)
    }
    
    fn sliceL(ref Self, len: int) -> []CharType {
        return self.sliceFL(0, len)
    }

    fn index_of(ref Self, ch: CharType) -> int {
        while let i = 0; i < length; i += 1 {
            if data[i] == ch {
                return i
            }
        }

        return -1
    }

    fn appendf(ref Self, format: string, args: []Printable) {
        let formatSpecifier = String::empty()
        formatSpecifier.reserve(10)

        let len = format.length
        let state = 0
        let argIndex = 0

        // state    - desc
        // 0        - normal
        // 1        - in format

        while let i = 0; i < len; i += 1 {
            let c = format[i]

            if state == 0 {
                if c == '{' {
                    state = 1
                }
                else {
                    self += c
                }
            }
            else if state == 1 {
                if c == '}' {
                    state = 0
                    
                    let format: string = null

                    let colon = formatSpecifier.index_of(':')
                    if colon >= 1 {
                        // colon -> arg index before colon
                        argIndex = parse_int(formatSpecifier.sliceL(colon))
                    }
                    else if colon == -1 and formatSpecifier.get_length() > 0 {
                        // no colon but non empty -> arg index
                        argIndex = parse_int(formatSpecifier.slice())
                    }
                    if colon != -1 {
                        // colon -> format after colon
                        format = formatSpecifier.sliceF(colon + 1)
                    }

                    if argIndex >= args.length {
                        c_printf("[%lld] `"%.*s`": arg index to out of bounds: %lld, args: %lld`n", i, format.length, format.data, argIndex, args.length)
                        return
                    }

                    args[argIndex].print(self, format)
                    argIndex += 1
                    formatSpecifier.length = 0

                } else {
                    formatSpecifier += c
                }
            }
        }

        formatSpecifier.free()
    }
}

impl Printable for String {
    fn print(ref Self, str: ref String, format: string) {
        str += self
    }
}

fn streql(a: $T, b: $T2, len: int) -> bool {
    let alen = cast a::get_length()
    let blen = cast b::get_length()
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    while let i = 0; i < len; i += 1 {
        if a::char_at(i) != b::char_at(i) {
            return false
        }
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len = a::get_length()
    let blen = b::get_length()

    if len != blen {
        return false
    }

    while let i = 0; i < len; i += 1 {
        if a::char_at(i) != b::char_at(i) {
            return false
        }
    }
    return true
}

impl string {
    fn get_length(Self) -> int {
        return self.length
    }
    
    fn char_at(Self, i: int) -> char {
        return self[i]
    }

    fn to_string(Self) -> String {
        return String::from_string(self)
    }
}

impl c_string {
    fn get_length(Self) -> int {
        return cast c_strlen(self)
    }
    
    fn char_at(Self, i: int) -> char {
        return self[i]
    }

    fn to_string(Self) -> String {
        return String::from_cstring(self)
    }
}
