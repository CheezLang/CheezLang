io   :: import std.io
util :: import std.util
C    :: import std.c
fmt  :: import std.fmt

use import std.array
use import std.printable
use import std.mem.allocator
use import std.mem.std_heap_allocator
import std.alloca

#export_scope

StringBase :: struct(CharType: type) {
    data: []CharType
    length: int
    allocator: Allocator
}

String :: StringBase[char]

impl(CharType: type) Drop for StringBase[CharType] {
    drop :: (ref Self) {
        if allocator != null {
            free_n(data, allocator)
        }
        data = null
        length = 0
    }
}

impl(CharType: type) StringBase[CharType] {
    empty :: (allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        return StringBase[CharType](null, 0, allocator)
    }

    with_capacity :: (cap: int, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        result := StringBase[CharType](null, 0, allocator)
        result.reserve(cap)
        return result
    }

    from_raw_ptr :: (ptr: &CharType, cap: int) -> Self {
        sl : []CharType = ptr
        sl.length = cap
        return StringBase[CharType](sl, 0, null)
    }

    from_string :: (str: string, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        s := Self.empty(allocator)
        s.append_string(str)
        return s
    }

    from_cstring :: (str: c_string, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        s := Self.empty(allocator)
        s.append_cstring(str)
        return s
    }

    get_capacity :: (ref Self) -> int {
        return data.length
    }

    get_length :: (ref Self) -> int {
        return length
    }

    get_raw :: (ref Self) -> &CharType {
        return data.data
    }

    char_at :: (ref Self, i: int) -> CharType #operator("[]") {
        return data[i]
    }

    set_char_at :: (ref Self, i: int, c: CharType) #operator("set[]") {
        data[i] = c
    }

    reserve_more :: (ref Self, amount: int) {
        reserve(length + amount)
    }

    reserve :: (ref Self, size: int) {
        if data.length > size {
            return
        }

        data.length = size
        if data.data == null {
            length = 0
            data = alloc_n(CharType, cast size, allocator)
        } else {
            data = realloc_n(data, cast size, allocator)
            if length > data.length {
                length = data.length
            }
        }
    }

    clone :: (ref Self) -> Self {
        other := Self.empty()
        other.append(self)
        return other
    }

    clear :: (ref Self) {
        length = 0
    }

    resize :: (ref Self, size: int) {
        self.reserve(size)
        length = size
    }

    append :: (ref Self, other: ref Self) -> ref Self #operator("+=") {
        if other.data.data == null {
            return self
        }
        newLength := length + other.length
        self.reserve(newLength)
        C.memcpy(cast &data.data[length], cast other.data.data, cast(uint) (other.length * @sizeof(CharType)))
        length = newLength
        return self
    }

    append_string :: (ref Self, other: string) -> ref Self #operator("+=") {
        newLength := length + other.length
        self.reserve(newLength)
        C.memcpy(cast &data.data[length], cast other.data, cast other.length)
        length = newLength
        return self
    }

    append_cstring :: (ref Self, other: c_string) -> ref Self #operator("+=") {
        otherLen := C.strlen(other)
        newLength := length + int(otherLen)
        self.reserve(newLength)
        C.memcpy(cast &data.data[length], cast other, cast otherLen)
        length = newLength
        return self
    }

    append_char :: (ref Self, ch: CharType) -> ref Self #operator("+=") {
        newLength := length + 1
        self.reserve(newLength)
        data[length] = ch
        length = newLength
        return self
    }

    sliceFT :: (ref Self, from: int, to: int) -> []CharType {
        slice : []CharType = &data[from]
        slice.length = to - from
        return slice
    }

    sliceFL :: (ref Self, from: int, len: int) -> []CharType {
        slice : []CharType = &data[from]
        slice.length = len
        return slice
    }

    slice :: (ref Self) -> []CharType {
        return self.sliceFL(0, length)
    }

    sliceF :: (ref Self, from: int) -> []CharType {
        return self.sliceFL(from, length - from)
    }
    
    sliceL :: (ref Self, len: int) -> []CharType {
        return self.sliceFL(0, len)
    }

    index_of :: (ref Self, ch: CharType) -> int {
        for i : 0..length {
            if data[i] == ch {
                return i
            }
        }

        return -1
    }
}


impl String {
    append_print :: (ref Self, pr: Printable) -> ref Self #operator("+=") {
        pr.print(self, "")
        return self
    }

    appendf :: (ref Self, format: string, arguments: $T) {
        if const @is_tuple(T) {
            args : [T.length] Printable = default
            @for_tuple_values(arguments, |v, i| {
                args[i] = Printable(v)
            })
        } else {
            args : [1]Printable = [Printable(arguments)]
        }

        formatSpecifier := {
            len :: 64
            String.from_raw_ptr(@alloca(char, len), len)
        }

        len      := format.length
        state    := 0
        argIndex := 0

        // state    - desc
        // 0        - normal
        // 1        - in format
        // 2        - escape

        for c : format {
            if state == 0 {
                if c == '``' {
                    state = 2
                } else if c == '{' {
                    state = 1
                } else {
                    self += c
                }
            } else if state == 2 {
                self += c
                state = 0
            } else if state == 1 {
                if c == '}' {
                    state = 0

                    format : string = null

                    colon := formatSpecifier.index_of(':')
                    if colon >= 1 {
                        // colon -> arg index before colon
                        argIndex = fmt.parse_int(formatSpecifier.sliceL(colon))
                    } else if colon == -1 and formatSpecifier.length > 0 {
                        // no colon but non empty -> arg index
                        argIndex = fmt.parse_int(formatSpecifier.slice())
                    }
                    if colon != -1 {
                        // colon -> format after colon
                        format = formatSpecifier.sliceF(colon + 1)
                    }

                    if argIndex >= args.length {
                        C.printf("[%lld] `"%.*s`": arg index to out of bounds: %lld, args: %lld`n", it_index, format.length, format.data, argIndex, args.length)
                        return
                    }

                    args[argIndex].print(self, format)
                    argIndex += 1
                    formatSpecifier.length = 0

                } else {
                    formatSpecifier += c
                }
            }
        }
    }

    format :: (format: string, args: $T) -> Self {
        s := Self.empty()
        s.appendf(format, args)
        return s
    }

    split_at_char :: (ref Self, c: char, remove_empty: bool = false) -> Array[string] {
        result := Array[string].create()

        start := 0
        for i : 0..length {
            if data[i] == c {
                sub := self.sliceFT(start, i)
                if sub.length > 0 or !remove_empty {
                    result.add(sub)
                }

                start = i + 1
            }
        }

        if start < length {
            sub := self.sliceF(start)
            if sub.length > 0 or !remove_empty {
                result.add(sub)
            }
        }

        return result
    }
}

impl Printable for String {
    print :: (ref Self, str: ref String, format: string) {
        str += self
    }
}

streql :: (a: $T, b: $T2, len: int) -> bool {
    alen := T.get_length(a)
    blen := T2.get_length(b)
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    for i : 0..len {
        if T.char_at(a, i) != T2.char_at(b, i) {
            return false
        }
    }
    return true
}

streq :: (a: $T, b: $T2) -> bool {
    len  := T.get_length(a)
    blen := T2.get_length(b)

    if len != blen {
        return false
    }

    for i : 0..len {
        if T.char_at(a, i) != T2.char_at(b, i) {
            return false
        }
    }
    return true
}

impl string {
    get_length :: (Self) -> int {
        return self.length
    }
    
    char_at :: (Self, i: int) -> char {
        return self[i]
    }

    to_string :: (Self) -> String {
        return String.from_string(self)
    }

    slice :: (Self, from: int = 0, length: int = -1) -> string {
        if length < 0 {
            length = self.length - from
        }

        result := self
        result.data = util.pointer_add_sized(result.data, from)
        result.length = length

        return result
    }

    to_cstring :: (Self) -> c_string {
        str_c := alloc_raw(char, cast self.length + 1)
        str_c[self.length] = cast 0
        C.memcpy(cast str_c, cast self.data, cast self.length)
        return str_c
    }
}

string_to_cstring_stack :: (str: string) #macro {
    result := @alloca(char, str.length + 1)
    C.memcpy(result, str.data, cast str.length)
    result[str.length] = char(0)
    result
}

impl c_string {
    get_length :: (Self) -> int {
        return cast C.strlen(self)
    }
    
    char_at :: (Self, i: int) -> char {
        return self[i]
    }

    to_string :: (Self) -> String {
        return String.from_cstring(self)
    }
}