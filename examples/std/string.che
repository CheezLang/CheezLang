#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")

fn strlen(s: c_string) -> i32 {
    let len: i32 = 0
    while s[len] != '`0' {
        len += 1
    }
    return len
}

fn streql(a: $T, b: $T2, len: u64) -> bool {
    let alen: u64 = cast a.getLength()
    let blen: u64 = cast b.getLength()
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    while let i: u64 = 0; i < len; i += 1 {
        if a.charAt(i) != b.charAt(i) {
            return false
        }
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len: u64 = cast a.getLength()
    let blen: u64 = cast b.getLength()

    if len != blen {
        return false
    }

    while let i: u64 = 0; i < len; i += 1 {
        if a.charAt(i) != b.charAt(i) {
            return false
        }
    }
    return true
}

impl c_string {
    fn getLength() -> i32 {
        return strlen(self)
    }
    
    fn charAt(i: $T) -> char {
        return self[i]
    }

    fn to_string() -> String {
        let s = new_string()
        s.append_cstring(self)
        return s
    }
}

impl string {
    fn getLength() -> i32 {
        return self.length
    }
    
    fn charAt(i: $T) -> char {
        return self[i]
    }

    fn to_string() -> String {
        let s = new_string()
        s.append_string(self)
        return s
    }
}

impl Printable for c_string {
    fn print(str: *String, format: string) {
        str.append_cstring(<<self)
    }
}

impl Printable for string {
    fn print(str: *String, format: string) {
        str.append_string(<<self)
    }
}

struct StringBase(CharType: type) {
    data: *CharType         = null
    length: i32             = 0
    capacity: i32           = 0
    allocator: Allocator    = null
}

typedef String = StringBase(char)
typedef Utf32String = StringBase(i32)

impl StringBase($CharType) {
    ref fn getLength() -> i32 {
        return length
    }

    ref fn charAt(i: $T) -> CharType {
        return data[i]
    }

    ref fn init(alloc: Allocator) {
        allocator = alloc
        data = null
        length = 0
        capacity = 0
        self.reserve(10)
    }

    ref fn reserve(size: i32) {
        capacity = size
        if data == null {
            length = 0
            data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        else {
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
            if length > capacity {
                length = capacity
            }
        }
    }
    
    ref fn resize(size: i32) {
        length = size
        capacity = size
        if data == null {
            data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        else {
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
        }
    }

    ref fn fromString(str: c_string) -> *StringBase(CharType) {
        if cast(u64) data != 0 {
            // @Todo:
            //self.dispose()
            allocator.free(data)
            data = null
            length = 0
            capacity = 0
        }

        length = strlen(str)
        capacity = length
        data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))

        if @sizeof(CharType) == 1 {
            c_memcpy(data, str, length)
        } else {
            while let i = 0; i < length; i += 1 {
                data[i] = cast(CharType) str[i]
            }
        }

        return &self
    }

    ref fn append(other: *StringBase(CharType)) -> *StringBase(CharType) {
        let newLength = length + other.length

        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other.data, other.length * @sizeof(CharType))

        length = newLength

        return &self
    }

    ref fn append_cstring(other: c_string) -> *StringBase(CharType) {
        let otherLength = strlen(other)
        let newLength = length + otherLength
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other, otherLength)

        length = newLength

        return &self
    }

    ref fn append_string(other: string) -> *StringBase(CharType) {
        let newLength = length + other.length
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        let end = &data[length]
        c_memcpy(end, other.data, other.length)

        length = newLength

        return &self
    }

    ref fn append_char(ch: CharType) -> *StringBase(CharType) {
        let newLength = length + 1
        
        if newLength >= capacity {
            capacity = newLength * 2
            data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        
        
        data[length] = ch
        length = newLength

        return &self
    }

    ref fn equals(other: $T) -> bool {
        if @isstring(T) { 
            let len: @typeof(length) = strlen(other)
            if len != length {
                return false
            }
            
            while let i: u64 = 0; i < len; i += 1 {

                if data[i] != other[i] {
                    return false
                }
            }
            return true
        }
        else {
            @error("Not implemented")
        }
    }

    ref fn dispose() {
        allocator.free(data)
        data = null
        length = 0
    }

    ref fn slice() -> []CharType {
        return self.sliceFL(0, length)
    }

    ref fn sliceFL(from: i32, len: i32) -> []CharType {
        let slice: []CharType = &data[from]
        slice.length = len
        return slice
    }

    ref fn sliceF(from: i32) -> []CharType {
        return self.sliceFL(from, length - from)
    }
    
    ref fn sliceL(len: i32) -> []CharType {
        return self.sliceFL(0, len)
    }

    ref fn indexOf(ch: CharType) -> i32 {
        let i = 0
        while i < length {
            if data[i] == ch {
                return i
            }

            i += 1
        }

        return -1
    }
}

fn new_string() -> String {
    let t = new String { allocator = DEFAULT_STD_HEAP_ALLOCATOR }
    t.reserve(10)
    return t
}

fn new_string2(alloc: Allocator) -> String {
    let t = new String { allocator = alloc }
    t.reserve(10)
    return t
}
