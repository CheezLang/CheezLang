// #load("std:mem/allocator")
// #load("std:mem/std_heap_allocator")
#load("std:mem/memory")



fn c_strlen(str: c_string) -> i32 #linkname("strlen");

fn streql(a: $T, b: $T2, len: int) -> bool {
    let alen: int = cast a.getLength()
    let blen: int = cast b.getLength()
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    while let i: int = 0; i < len; i += 1 {
        if a.charAt(i) != b.charAt(i) {
            return false
        }
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len: int = cast a::get_length()
    let blen: int = cast b::get_length()

    if len != blen {
        return false
    }

    while let i: int = 0; i < len; i += 1 {
        if a::char_at(i) != b::char_at(i) {
            return false
        }
    }
    return true
}

impl c_string {
    fn get_length(self) -> int {
        return cast c_strlen(self)
    }
    
    fn char_at(self, i: int) -> char {
        return self[i]
    }

    // fn to_string() -> String {
    //     let s = new_string()
    //     s.append_cstring(self)
    //     return s
    // }
}

impl string {
    fn get_length(self) -> int {
        return self.length
    }
    
    fn char_at(self, i: int) -> char {
        return self[i]
    }

    // fn to_string() -> String {
    //     let s = new_string()
    //     s.append_string(self)
    //     return s
    // }
}

// impl Printable for c_string {
//     fn print(str: *String, format: string) {
//         str.append_cstring(<<self)
//     }
// }

// impl Printable for string {
//     fn print(str: *String, format: string) {
//         str.append_string(<<self)
//     }
// }

struct StringBase(CharType: type) {
    data: []CharType
    length: int
    // allocator: Allocator    = null
}

typedef String = StringBase(char)
typedef Utf32String = StringBase(i32)

impl StringBase($CharType) {
    fn empty() -> self {
        return new {
            data = null
            length = 0
        }
    }

    fn get_length(*self) -> int {
        return length
    }

    fn char_at(*self, i: int) -> CharType {
        return data[i]
    }

    fn reserve(*self, size: int) {
        if data.length > size {
            return
        }

        data.length = size
        if data.data == null {
            length = 0
            data.data = cast c_malloc(cast(i32) (size * @sizeof(CharType)))
            // data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))
        }
        else {
            data.data = cast c_realloc(cast data.data, cast(i32) (size * @sizeof(CharType)))
            // data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
            if length > data.length {
                length = data.length
            }
        }
    }

//     ref fn init(alloc: Allocator) {
//         allocator = alloc
//         data = null
//         length = 0
//         capacity = 0
//         self.reserve(10)
//     }
    
//     ref fn resize(size: i32) {
//         length = size
//         capacity = size
//         if data == null {
//             data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))
//         }
//         else {
//             data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
//         }
//     }

//     ref fn fromString(str: c_string) -> *StringBase(CharType) {
//         if cast(u64) data != 0 {
//             // @Todo:
//             //self.dispose()
//             allocator.free(data)
//             data = null
//             length = 0
//             capacity = 0
//         }

//         length = strlen(str)
//         capacity = length
//         data = allocator.allocate(cast capacity, @sizeof(CharType), @alignof(CharType))

//         if @sizeof(CharType) == 1 {
//             c_memcpy(data, str, length)
//         } else {
//             while let i = 0; i < length; i += 1 {
//                 data[i] = cast(CharType) str[i]
//             }
//         }

//         return &self
//     }

//     ref fn append(other: *StringBase(CharType)) -> *StringBase(CharType) {
//         let newLength = length + other.length

//         if newLength >= capacity {
//             capacity = newLength * 2
//             data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
//         }
        
//         let end = &data[length]
//         c_memcpy(end, other.data, other.length * @sizeof(CharType))

//         length = newLength

//         return &self
//     }

//     ref fn append_cstring(other: c_string) -> *StringBase(CharType) {
//         let otherLength = strlen(other)
//         let newLength = length + otherLength
                
//         if newLength >= capacity {
//             capacity = newLength * 2
//             data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
//         }
        
//         let end = &data[length]
//         c_memcpy(end, other, otherLength)

//         length = newLength

//         return &self
//     }

    fn append_string(*self, other: string) -> *self #operator("+=") {
        let newLength = length + other.length
        self.reserve(newLength)
        c_memcpy(cast &data.data[length], cast other.data, cast other.length)
        length = newLength
        return self
    }

//     ref fn append_char(ch: CharType) -> *StringBase(CharType) {
//         let newLength = length + 1
        
//         if newLength >= capacity {
//             capacity = newLength * 2
//             data = allocator.reallocate(data, cast capacity, @sizeof(CharType), @alignof(CharType))
//         }
        
        
//         data[length] = ch
//         length = newLength

//         return &self
//     }

//     ref fn equals(other: $T) -> bool {
//         if @isstring(T) { 
//             let len: @typeof(length) = strlen(other)
//             if len != length {
//                 return false
//             }
            
//             while let i: u64 = 0; i < len; i += 1 {

//                 if data[i] != other[i] {
//                     return false
//                 }
//             }
//             return true
//         }
//         else {
//             @error("Not implemented")
//         }
//     }

//     ref fn dispose() {
//         allocator.free(data)
//         data = null
//         length = 0
//     }

//     ref fn slice() -> []CharType {
//         return self.sliceFL(0, length)
//     }

//     ref fn sliceFL(from: i32, len: i32) -> []CharType {
//         let slice: []CharType = &data[from]
//         slice.length = len
//         return slice
//     }

//     ref fn sliceF(from: i32) -> []CharType {
//         return self.sliceFL(from, length - from)
//     }
    
//     ref fn sliceL(len: i32) -> []CharType {
//         return self.sliceFL(0, len)
//     }

//     ref fn indexOf(ch: CharType) -> i32 {
//         let i = 0
//         while i < length {
//             if data[i] == ch {
//                 return i
//             }

//             i += 1
//         }

//         return -1
//     }
}

// fn new_string() -> String {
//     let t = new String { allocator = DEFAULT_STD_HEAP_ALLOCATOR }
//     t.reserve(10)
//     return t
// }

// fn new_string2(alloc: Allocator) -> String {
//     let t = new String { allocator = alloc }
//     t.reserve(10)
//     return t
// }
