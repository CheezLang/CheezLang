#load("std:mem/std_heap_allocator")

Allocator :: trait {
    allocate :: (ref Self, count: uint, elementSize: uint, alignment: uint) -> &void;
    reallocate :: (ref Self, mem: &void, count: uint, elementSize: uint, alignment: uint) -> &void;
    free :: (ref Self, mem: &void);
}

alloc :: ($T: type, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> &T {
    return alloc_raw(T, 1, allocator)
}

alloc_raw :: ($T: type, count: uint, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> &T {
    return cast(&T)allocator.allocate(cast count, @sizeof(T), @alignof(T))
}

realloc_raw :: (mem: &$T, count: uint, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> &T {
    return cast allocator.reallocate(cast mem, count, @sizeof(T), @alignof(T))
}

alloc_n :: ($T: type, count: uint, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> []T {
    mem : []T = cast(&T) allocator.allocate(count, @sizeof(T), @alignof(T))
    mem.length = cast count
    return mem
}

realloc_n :: (mem: []$T, count: uint, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> []T {
    mem.data = cast allocator.reallocate(cast mem.data, count, @sizeof(T), @alignof(T))
    mem.length = cast count
    return mem
}

free :: (mem: &$T, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) {
    allocator.free(cast mem)
}

free_n :: (mem: []$T, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) {
    allocator.free(cast mem.data)
}
