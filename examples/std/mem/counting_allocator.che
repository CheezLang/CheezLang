#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")

struct CountingAllocator {
    parent: Allocator
    allocated: u64
    freed: u64
}

fn newCountingAllocator() -> CountingAllocator {
    return CountingAllocator(StdHeapAllocator(), 0, 0)
}

fn newCountingAllocator2(alloc: Allocator) -> CountingAllocator {
    return CountingAllocator(alloc, 0, 0)
}

impl CountingAllocator {
    ref fn printDiagnostics() {
        printfn("( Allocated: {i32}, Freed: {i32} ) `n", [(any)allocated, freed])
    }
}

impl Allocator for CountingAllocator {
    fn allocate(count: u64, elementSize: u64, alignment: u64) -> any& {
        let size = count * elementSize
        allocated += size

        let mem = parent.allocate(size + @sizeof(u64), 1, alignment)

        // store size before allocated memory
        let sizePtr = (u64&)mem
        <<sizePtr = size

        return pointerAdd(mem, @sizeof(u64))
    }

    fn reallocate(mem: any&, count: u64, elementSize: u64, alignment: u64) -> any& {
        let size = count * elementSize
        let actualMem = pointerAdd(mem, -@sizeof(u64))
        
        {
            let sizePtr = (u64&)actualMem
            allocated += size - <<sizePtr
        }

        mem = parent.reallocate(actualMem, size + @sizeof(u64), 1, alignment)

        let sizePtr = (u64&)mem
        <<sizePtr = size
        return pointerAdd(mem, @sizeof(u64))
    }

    fn free(mem: any&) {
        let actualMem = pointerAdd(mem, -@sizeof(u64))
        let sizePtr = (u64&)actualMem
        freed += <<sizePtr
        parent.free(actualMem)
    }
}
