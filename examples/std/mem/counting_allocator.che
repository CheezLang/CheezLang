#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")

struct CountingAllocator {
    parent: Allocator
    allocated: ulong
    freed: ulong
}

fn newCountingAllocator() -> CountingAllocator {
    return new CountingAllocator {
        new StdHeapAllocator {}, 0, 0
    }
}

fn newCountingAllocator2(alloc: Allocator) -> CountingAllocator {
    return new CountingAllocator {
        alloc, 0, 0
    }
}

impl CountingAllocator {
    ref fn printDiagnostics() {
        printfn("( Allocated: {i32}, Freed: {i32} ) `n", [(any)allocated, freed])
    }
}

impl Allocator for CountingAllocator {
    fn allocate(count: ulong, elementSize: ulong, alignment: ulong) -> any& {
        let size = count * elementSize
        allocated += size

        let mem = parent.allocate(size + @sizeof(ulong), 1, alignment)

        // store size before allocated memory
        let sizePtr = (ulong&)mem
        <<sizePtr = size

        return pointerAdd(mem, @sizeof(ulong))
    }

    fn reallocate(mem: any&, count: ulong, elementSize: ulong, alignment: ulong) -> any& {
        let size = count * elementSize
        let actualMem = pointerAdd(mem, -@sizeof(ulong))
        
        {
            let sizePtr = (ulong&)actualMem
            allocated += size - <<sizePtr
        }

        mem = parent.reallocate(actualMem, size + @sizeof(ulong), 1, alignment)

        let sizePtr = (ulong&)mem
        <<sizePtr = size
        return pointerAdd(mem, @sizeof(ulong))
    }

    fn free(mem: any&) {
        let actualMem = pointerAdd(mem, -@sizeof(ulong))
        let sizePtr = (ulong&)actualMem
        freed += <<sizePtr
        parent.free(actualMem)
    }
}
