#load("std:preload")
#load("std:mem/memory")
#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:io/io")

CountingAllocator :: struct {
    parent: Allocator
    allocated: u64
    freed: u64
}

fn newCountingAllocator() -> CountingAllocator {
    return CountingAllocator(DEFAULT_STD_HEAP_ALLOCATOR, 0, 0)
}

fn newCountingAllocator2(alloc: Allocator) -> CountingAllocator {
    return CountingAllocator(alloc, 0, 0)
}

impl CountingAllocator {
    fn printDiagnostics(ref Self) {
        printfln("( Allocated: {}, Freed: {} )", (allocated, freed))
    }
}

impl Allocator for CountingAllocator {
    fn allocate(ref Self, count: u64, elementSize: u64, alignment: u64) -> &any {
        size := count * elementSize
        allocated += size

        mem := parent.allocate(size + @sizeof(u64), 1, alignment)

        // store size before allocated memory
        sizePtr := cast(&u64)mem
        <<sizePtr = size

        return pointer_add(mem, @sizeof(u64))
    }

    fn reallocate(ref Self, mem: &any, count: u64, elementSize: u64, alignment: u64) -> &any {
        size := count * elementSize
        actualMem := pointer_add(mem, -@sizeof(u64))
        
        {
            sizePtr := cast(&u64)actualMem
            allocated += size - <<sizePtr
        }

        mem = parent.reallocate(actualMem, size + @sizeof(u64), 1, alignment)

        sizePtr := cast(&u64)mem
        <<sizePtr = size
        return pointer_add(mem, @sizeof(u64))
    }

    fn free(ref Self, mem: &any) {
        actualMem := pointer_add(mem, -@sizeof(u64))
        sizePtr := cast(&u64)actualMem
        freed += <<sizePtr
        parent.free(actualMem)
    }
}
