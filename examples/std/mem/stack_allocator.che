#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:array")
#load("std:util")

fn nextAligned(_add: *$T, align: u64) -> *T {
    let add = cast(u64) _add
    let mul = add + align - 1
    mul -= (mul % align)
    
    return cast mul
}

struct StackAllocation {
    offset: u64
    size: u64
}

impl Printable for StackAllocation {
    fn print(ref Self, str: ref String, format: string) {
        str.appendf("({}:{})", [offset, size])
    }
}

struct StackAllocator {
    parent: Allocator

    memory: *any
    capacity: u64

    allocations: Array(StackAllocation)
}

impl Printable for StackAllocator {
    fn print(ref Self, s: ref String, format: string) {
        s += "( ["
        while let i = 0; i < allocations.length; i += 1 {
            if i > 0 {
                s += ", "
            }
            s.appendf("{}", [allocations[i]])
        }
        s += "]"

        let free: u64 = capacity
        if let lastAllocation = self.getLastAllocation(); lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        s.appendf(", Free: {} )", [free])
    }
}

impl StackAllocator {
    fn create(size: u64, alloc: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        let a = new StackAllocator {
            parent = alloc
            memory = null
            capacity = 0
            allocations = type Array(StackAllocation)::create()
        }
        a.reserve(size)
        return a
    }

    fn reserve(ref Self, s: u64) {
        if s <= capacity {
            return
        }
        capacity = s

        if memory == null {
            memory = parent.allocate(capacity, @sizeof(i8), 8)
        }
        else {
            memory = parent.reallocate(memory, capacity, @sizeof(i8), 8)
        }
    }

    fn clear(ref Self) {
        allocations.length = 0
    }

    fn dispose(ref Self) {
        clear()
        parent.free(memory)
        allocations.free()
    }

    fn print_diagnostics(ref Self) {
        let s = String::empty()
        s += "( ["
        while let i = 0; i < allocations.length; i += 1 {
            if i > 0 {
                s += ", "
            }
            s.appendf("{}", [allocations[i]])
        }
        s += "]"

        let free: u64 = capacity
        
        if let lastAllocation = self.getLastAllocation(); lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        s.appendf(", Free: {} )`n", [free])
        print_stringl(s)

        s.free()
    }

    fn getLastAllocation(ref Self) -> *StackAllocation {
        if allocations.length == 0 {
            return null
        } else {
            return &allocations[allocations.length - 1]
        }
    }

    fn getNextAllocationOffset(ref Self) -> u64 {
        if let last = self.getLastAllocation(); last == null {
            return 0
        } else {
            return last.offset + last.size
        }
    }
}

impl Allocator for StackAllocator {
    fn allocate(ref Self, count: u64, elementSize: u64, alignment: u64) -> *any {
        let nextAddress = pointer_add(memory, cast(i64) self.getNextAllocationOffset())
        nextAddress = nextAligned(nextAddress, alignment)

        let newAllocation = new StackAllocation {
            offset = cast(u64) (cast(u64) nextAddress - cast(u64) memory)
            size = count * elementSize
        }

        let end = newAllocation.offset + newAllocation.size

        if end > capacity {
            self.reserve(2 * end)
        }

        allocations.add(newAllocation)

        return nextAddress
    }

    fn reallocate(ref Self, mem: *any, count: u64, elementSize: u64, alignment: u64) -> *any {
        let size = count * elementSize

        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return null
        }

        let lastAllocationAddress = pointer_add(memory, cast(i64) lastAllocation.offset)
        if mem == lastAllocationAddress {
            let newEnd = lastAllocation.offset + size
            if newEnd > capacity {
                self.reserve(2 * newEnd)
            }

            lastAllocation.size = size
            return mem
        } else {
            let newMem = self.allocate(count, elementSize, 8)
            c_memcpy(newMem, mem, cast(i32) size)
            return newMem
        }
    }

    fn free(ref Self, mem: *any) {
        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return
        }
        if mem == pointer_add(memory, cast(i64) lastAllocation.offset) {
            allocations.length -= 1
        }
    }
}
