#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:array")
#load("std:util")

fn nextAligned(add: $T&, align: ulong) -> T& {
    let add = (ulong)add
    let mul = add + align - 1
    mul -= (mul % align)
    
    return (T&)mul
}

struct StackAllocation {
    offset: ulong
    size: ulong
}

impl Printable for StackAllocation {
    fn print(str: String&, format: char[]) {
        sprint_f(str, "({}:{})", [offset, size])
    }
}

struct StackAllocator {
    parent: Allocator

    memory: byte&
    capacity: ulong

    allocations: Array(StackAllocation)
}

impl Printable for StackAllocator {
    fn print(s: String&, format: char[]) {
        s.append_string("( [")
        while let i: uint = 0; i < allocations.length; i += 1 {
            if i > 0 {
                s.append_string(", ")
            }
            sprint_f(s, "{}", [allocations.get(i)])
        }
        s.append_string("]")

        let free: ulong = capacity
        if let lastAllocation = self.getLastAllocation(); lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        sprint_f(s, ", Free: {} )", [free])
    }
}

fn newStackAllocator(size: ulong) -> StackAllocator {
    let a = new StackAllocator {
        parent = new StdHeapAllocator {}
        memory = null
        capacity = 0
        allocations = (Array(StackAllocation))newArray()
    }
    a.reserve(size)
    return a
}

fn newStackAllocator2(size: ulong, alloc: Allocator) -> StackAllocator {
    let a = new StackAllocator {
        parent = alloc
        memory = null
        capacity = 0
        allocations = (Array(StackAllocation))newArray()
    }
    a.reserve(size)
    return a
}

impl StackAllocator {
    ref fn reserve(s: ulong) {
        if s <= capacity {
            return
        }
        capacity = s

        if memory == null {
            memory = parent.allocate(capacity, @sizeof(byte), 8)
        }
        else {
            memory = parent.reallocate(memory, capacity, @sizeof(byte), 8)
        }
    }

    ref fn clear() {
        allocations.length = 0
    }

    ref fn dispose() {
        self.clear()
        parent.free(memory)
        allocations.dispose()
    }

    ref fn printDiagnostics() {
        let s = new_string()
        defer s.dispose()
        s.append_string("( [")
        while let i: uint = 0; i < allocations.length; i += 1 {
            if i > 0 {
                s.append_string(", ")
            }
            sprint_f(&s, "{}", [allocations.get(i)])
        }
        s.append_string("]")

        let free: ulong = capacity
        
        if let lastAllocation = self.getLastAllocation(); lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        sprint_f(&s, ", Free: {} )", [free])
        println(s)
    }

    ref fn getLastAllocation() -> StackAllocation& {
        if allocations.length == 0 {
            return null
        } else {
            return &allocations.data[allocations.length - 1]
        }
    }

    ref fn getNextAllocationOffset() -> ulong {
        if let last = self.getLastAllocation(); last == null {
            return 0
        } else {
            return last.offset + last.size
        }
    }
}

impl Allocator for StackAllocator {
    fn allocate(count: ulong, elementSize: ulong, alignment: ulong) -> any& {
        let nextAddress = pointerAdd(memory, (long)self.getNextAllocationOffset())
        nextAddress = nextAligned(nextAddress, alignment)

        let newAllocation = new StackAllocation {
            offset = (ulong)((ulong)nextAddress - (ulong)memory)
            size = count * elementSize
        }

        let end = newAllocation.offset + newAllocation.size

        if end > capacity {
            self.reserve(2 * end)
        }

        allocations.add(newAllocation)
        return nextAddress
    }

    fn reallocate(mem: any&, count: ulong, elementSize: ulong, alignment: ulong) -> any& {
        let size = count * elementSize

        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return null
        }

        let lastAllocationAddress = pointerAdd(memory, lastAllocation.offset)
        if mem == lastAllocationAddress {
            let newEnd = lastAllocation.offset + size
            if newEnd > capacity {
                self.reserve(2 * newEnd)
            }

            lastAllocation.size = size
            return mem
        } else {
            let newMem = self.allocate(count, elementSize, 8)
            c_memcpy(newMem, mem, (int)size)
            return newMem
        }
    }

    fn free(mem: any&) {
        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return
        }
        if mem == pointerAdd(memory, lastAllocation.offset) {
            allocations.length -= 1
        }
    }
}
