#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:array")
#load("std:util")
#load("std:printable")

struct StackAllocation {
    pub offset: u64
    pub size: u64
}

impl Printable for StackAllocation {
    fn print(ref Self, str: ref String, format: string) {
        str.appendf("({}:{})", (offset, size))
    }
}

struct StackAllocator {
    parent: Allocator

    memory: &any
    capacity: u64

    allocations: Array[StackAllocation]
}

impl Drop for StackAllocator {
    fn drop(ref Self) {
        self.clear()
        parent.free(memory)
    }
}

impl Printable for StackAllocator {
    fn print(ref Self, s: ref String, format: string) {
        s += "( ["
        while let i = 0, i < allocations.length, i += 1 {
            if i > 0 {
                s += ", "
            }
            s.appendf("{}", allocations[i])
        }
        s += "]"

        let free: u64 = capacity
        if let lastAllocation = self.getLastAllocation(), lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        s.appendf(", Free: {} )", free)
    }
}

impl StackAllocator {
    fn create(size: u64, alloc: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        let a = StackAllocator(
            parent = alloc
            memory = null
            capacity = 0
            allocations = Array[StackAllocation]::create()
        )
        a.reserve(size)
        return a
    }

    fn reserve(ref Self, s: u64) {
        if s <= capacity {
            return
        }
        capacity = s

        if memory == null {
            memory = parent.allocate(capacity, @sizeof(i8), 8)
        } else {
            memory = parent.reallocate(memory, capacity, @sizeof(i8), 8)
        }
    }

    fn clear(ref Self) {
        allocations.resize(0)
    }

    fn print_diagnostics(ref Self) {
        let s = String::empty()
        s += "( ["
        while let i = 0, i < allocations.length, i += 1 {
            if i > 0 {
                s += ", "
            }
            s.appendf("{}", allocations[i])
        }
        s += "]"

        let free: u64 = capacity
        
        if let lastAllocation = self.getLastAllocation(), lastAllocation != null {
            free = capacity - (lastAllocation.offset + lastAllocation.size)
        }
        s.appendf(", Free: {} )`n", free)
        print_string(s)
    }

    fn getLastAllocation(ref Self) -> &StackAllocation {
        if allocations.length == 0 {
            return null
        } else {
            return &allocations[allocations.length - 1]
        }
    }

    fn getNextAllocationOffset(ref Self) -> u64 {
        if let last = self.getLastAllocation(), last == null {
            return 0
        } else {
            return last.offset + last.size
        }
    }
}

impl Allocator for StackAllocator {
    fn allocate(ref Self, count: u64, elementSize: u64, alignment: u64) -> &any {

        let nextAddress = {
            let unaligned = pointer_add(memory, cast(i64) self.getNextAllocationOffset())
            next_aligned(unaligned, alignment)
        }

        let newAllocation = StackAllocation(
            offset = (cast(u64) nextAddress) - (cast(u64) memory)
            size = count * elementSize
        )

        let end = newAllocation.offset + newAllocation.size

        if end > capacity {
            self.reserve(2 * end)
        }

        allocations.add(newAllocation)

        return nextAddress
    }

    fn reallocate(ref Self, mem: &any, count: u64, elementSize: u64, alignment: u64) -> &any {
        let size = count * elementSize

        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return null
        }

        let lastAllocationAddress = pointer_add(memory, cast(i64) lastAllocation.offset)
        if mem == lastAllocationAddress {
            let newEnd = lastAllocation.offset + size
            if newEnd > capacity {
                self.reserve(2 * newEnd)
            }

            lastAllocation.size = size
            return mem
        } else {
            let newMem = self.allocate(count, elementSize, 8)
            c_memcpy(newMem, mem, cast(uint) size)
            return newMem
        }
    }

    fn free(ref Self, mem: &any) {
        let lastAllocation = self.getLastAllocation()
        if lastAllocation == null {
            return
        }
        if mem == pointer_add(memory, cast(i64) lastAllocation.offset) {
            allocations.resize(allocations.length - 1)
        }
    }
}
