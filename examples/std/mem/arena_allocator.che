#load("std:mem/allocator")
#load("std:mem/std_heap_allocator")
#load("std:array")
#load("std:util")
#load("std:printable")

fn align(add: uint, align: uint) -> uint {
    let mul = add + align - 1
    mul -= (mul % align)
    
    return mul
}


struct Bucket {
    pub memory  : []u8
    pub filled  : uint
}

impl Bucket {
    fn can_store(ref Self, size: uint, align: uint) -> bool {
        let next_address = next_aligned(pointer_add(memory.data, cast(int)filled), align)
        let next_offset = (cast(uint)next_address) - (cast(uint)memory.data)
        let free = (cast(uint)memory.length) - next_offset
        return free >= size
    }

    fn allocate(ref Self, size: uint, align: uint) -> &u8 {
        let next_address = next_aligned(pointer_add(memory.data, cast(int)filled), align)
        let next_offset = (cast(uint)next_address) - (cast(uint)memory.data)
        filled = next_offset + size
        return next_address
    }
}

struct ArenaAllocator {
    parent      : Allocator

    bucket_size : uint
    buckets     : Array(Bucket)
}

impl Drop for ArenaAllocator {
    fn drop(ref Self) {
        for :buckets {
            parent.free(it.memory.data)
        }
    }
}

impl ArenaAllocator {
    fn create(size: uint, alloc: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        let a = new ArenaAllocator {
            parent      = alloc
            bucket_size = size
            buckets     = Array(Bucket)::create()
        }
        return a
    }

    fn clear(ref Self) {
        while let i = 0, i < buckets.length, i += 1 {
            buckets[i].filled = 0
        }
    }

    fn dump(ref Self, dump_buckets: bool = false) {
        printfln("ArenaAllocator ({} buckets)", [buckets.length])
        while let i = 0, i < buckets.length, i += 1 {
            let bucket: ref Bucket = buckets[i]

            printfln("  Bucket {}: {}/{} bytes", [i, bucket.filled, bucket.memory.length])
            if dump_buckets {
                let current: uint = 0

                while current < bucket.filled {
                    let len = <<cast(&uint)pointer_add(bucket.memory.data, cast(int)current)
                    if len == 0 {
                        current += 8
                        continue
                    }

                    printfln("    {}: {} bytes", [current, len])

                    // find next allocation
                    current += len + 8
                    current = align(current, 8)
                }
            }
        }
    }
}

impl Allocator for ArenaAllocator {
    fn allocate(ref Self, count: u64, elementSize: u64, alignment: u64) -> &any {
        let required_size = count * elementSize + 8
        if alignment < 8 {
            alignment = 8
        }

        // find bucket with enough room for required size
        let free_bucket : &Bucket = null
        while let i = 0, i < buckets.length, i += 1 {
            let bucket: ref Bucket = buckets[i]
            if bucket.can_store(required_size, alignment) {
                free_bucket = &bucket
                break
            }
        }

        // no bucket with enough space
        if free_bucket == null {
            let new_bucket_size = required_size * 2
            if new_bucket_size < bucket_size {
                new_bucket_size = bucket_size
            }

            let new_mem: []u8 = cast(&u8) parent.allocate(new_bucket_size, @sizeof(u8), alignment)
            new_mem.length = cast new_bucket_size
            buckets.add(new Bucket {
                memory = new_mem
                filled = 0
            })

            free_bucket = &buckets[buckets.length - 1]
        }

        let ptr = free_bucket.allocate(required_size, alignment)
        let len_ptr = cast(&uint)ptr
        <<len_ptr = count * elementSize
        return pointer_add(ptr, 8)
    }

    fn reallocate(ref Self, mem: &any, count: u64, elementSize: u64, alignment: u64) -> &any {
        if mem == null {
            return allocate(count, elementSize, alignment)
        } else {
            let len = <<cast(&uint)pointer_add(mem, -8)

            if len >= count * elementSize {
                return mem
            }

            let new_mem = allocate(count, elementSize, alignment)
            c_memcpy(new_mem, mem, len)
            return new_mem
        }
    }

    fn free(ref Self, mem: &any) {
        // do nothing
    }
}
