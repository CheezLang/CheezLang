#load("std:os/windows")
#load("std:string")
#load("std:preload")

fn load_file(filename: string) -> Result(String, String) {
    let str_c = @alloca(char, filename.length + 1)
    str_c[filename.length] = cast 0
    c_memcpy(cast str_c, cast filename.data, cast filename.length)
    return load_filec(str_c)
}

fn load_filec(filename: c_string) -> Result(String, String) {
    let content = String::empty()

    let handle = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if (cast(int)handle) == -1 {
        return Err(String::format("failed to open file: {}", [GetLastError()]))
    }

    let size: int
    if GetFileSizeEx(handle, &size) == 0 {
        return Err(String::format("failed to get file size: {}", [GetLastError()]))
    }

    content.resize(size)
    
    let bytesRead: u32 = 0
    if ReadFile(handle, content.get_raw(), cast(u32)size, &bytesRead, null) == 0 {
        content.free()
        return Err(String::format("failed to read content: {}", [GetLastError()]))
    }

    if CloseHandle(handle) == 0 {
        content.free()
        return Err(String::format("failed to close handle: {}", [GetLastError()]))
    }

    return Ok(content)
}

// fn get_working_dir() -> wd: String {
//     let len = cast(int) GetCurrentDirectory(0, null)

//     wd = String::empty()
//     wd.reserve(len)
//     wd.resize(len - 1)
//     GetCurrentDirectory(cast wd.length, wd.get_raw())
// }
