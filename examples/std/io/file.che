#load("std:os/windows")
#load("std:string")

enum OptionFile {
    Some : String
    None
}

fn load_file(filename: string) -> OptionFile {
    let str_c = @alloca(char, filename.length + 1)
    str_c[filename.length] = cast 0
    c_memcpy(cast str_c, cast filename.data, cast filename.length)
    if let (ok, content) = load_filec(str_c); ok {
        return OptionFile.Some(content)
    } else {
        return OptionFile.None
    }
}

fn load_filec(filename: c_string) -> (ok: bool, content: String) {
    content = String::empty()
    ok = false

    let handle = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if cast(int)handle == -1 {
        content.appendf("failed to open file: {}", [GetLastError()])
        return
    }

    let size: int
    if GetFileSizeEx(handle, &size) == 0 {
        content.appendf("failed to get file size: {}", [GetLastError()])
        return
    }

    content.resize(size)
    
    let bytesRead: u32 = 0
    if ReadFile(handle, content.get_raw(), cast(u32)size, &bytesRead, null) == 0 {
        content.appendf("failed to read content: {}", [GetLastError()])
        content.free()
        return
    }

    if CloseHandle(handle) == 0 {
        content.appendf("failed to close handle: {}", [GetLastError()])
        content.free()
        return
    }

    ok = true
}

// fn get_working_dir() -> wd: String {
//     let len = cast(int) GetCurrentDirectory(0, null)

//     wd = String::empty()
//     wd.reserve(len)
//     wd.resize(len - 1)
//     GetCurrentDirectory(cast wd.length, wd.get_raw())
// }
