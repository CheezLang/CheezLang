#load("std:os/windows")
#load("std:string")
#load("std:preload")

fn load_file(filename: string) -> Result[String, String] {
    str_c := @alloca(char, filename.length + 1)
    str_c[filename.length] = cast 0
    c_memcpy(cast str_c, cast filename.data, cast filename.length)
    return load_filec(str_c)
}

fn load_filec(filename: c_string) -> Result[String, String] {
    content := String.empty()

    handle := CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if (cast(int)handle) == -1 {
        lastError := GetLastError();
        return Err(String.format("failed to open file: 0x{:x}", lastError))
    }

    let size: int = 0
    if GetFileSizeEx(handle, &size) == 0 {
        lastError := GetLastError();
        return Err(String.format("failed to get file size: 0x{:x}", lastError))
    }

    content.resize(size)
    
    let bytesRead: u32 = 0
    if ReadFile(handle, content.get_raw(), cast(u32)size, &bytesRead, null) == 0 {
        lastError := GetLastError();
        return Err(String.format("failed to read content: 0x{:x}", lastError))
    }

    if CloseHandle(handle) == 0 {
        lastError := GetLastError();
        return Err(String.format("failed to close handle: 0x{:x}", lastError))
    }

    return Ok(content)
}

fn load_filecb(filename: c_string) -> Option[[]u8] {
    handle := CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if (cast(int)handle) == -1 {
        return None
    }

    let size: int = 0
    if GetFileSizeEx(handle, &size) == 0 {
        return None
    }

    content := alloc_n(u8, cast size)
    
    let bytesRead: u32 = 0
    if ReadFile(handle, cast content.data, cast(u32)size, &bytesRead, null) == 0 {
        free_n(content)
        return None
    }

    if CloseHandle(handle) == 0 {
        free_n(content)
        return None
    }

    return Some(content)
}

fn write_filecb(filename: c_string, data: []u8) -> bool {
    handle := CreateFileA(filename, GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if (cast(int)handle) == -1 {
        println("failed to create file")
        return false
    }

    let bytesRead: u32 = 0
    if WriteFile(handle, cast data.data, cast(u32)data.length, &bytesRead, null) == 0 {
        println("failed to write data")
        return false
    }

    if CloseHandle(handle) == 0 {
        println("failed to close handle")
        return false
    }

    return true
}

fn write_file_string(filename: string, str: string) -> bool {
    filename_c := {
        str_c := @alloca(char, filename.length + 1)
        str_c[filename.length] = cast 0
        c_memcpy(cast str_c, cast filename.data, cast filename.length)
        str_c
    }

    handle := CreateFileA(filename_c, GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if (cast(int)handle) == -1 {
        println("failed to create file")
        return false
    }

    let bytesRead: u32 = 0
    if WriteFile(handle, cast str.data, cast(u32)str.length, &bytesRead, null) == 0 {
        println("failed to write data")
        return false
    }

    if CloseHandle(handle) == 0 {
        println("failed to close handle")
        return false
    }

    return true
}

// fn get_working_dir() -> wd: String {
//     len := cast(int) GetCurrentDirectory(0, null)

//     wd = String.empty()
//     wd.reserve(len)
//     wd.resize(len - 1)
//     GetCurrentDirectory(cast wd.length, wd.get_raw())
// }
