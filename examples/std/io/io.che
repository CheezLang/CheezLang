#load("std:string")
#load("std:mem/memory")
#load("std:os/windows")

let isize = int

fn c_sprintf(buff: char&, f: c_string, a: double) -> int #varargs #linkname("sprintf");

let NEW_LINE: char = '`n'

fn printString(s: $T) {
    if @typeseq(c_string, T) {
        let len = strlen(s)
        let bytesWritten: int
        WriteFile(__std_out_handle, s, len, &bytesWritten, 0)
    } else if @typeseq(string, T) {
        let bytesWritten: int
        WriteFile(__std_out_handle, s.data, s.length, &bytesWritten, 0)
    } else {
        @error(@concat("Can't call printString($T) with type ", @typename(T)))
    }
}

fn printStringl(s: String&) {
    let bytesWritten: int
    WriteFile(__std_out_handle, s.data, s.length, &bytesWritten, 0)
}

fn printChar(c: char) { 
    let bytesWritten: int
    WriteFile(__std_out_handle, &c, 1, &bytesWritten, 0)
}

fn printFloat(val: float) {
    let buff: char[32]
    let buff: char[] = buff
    c_sprintf(buff.data, "%f", (double)val)
    printString(buff.data)
}

fn printDouble(val: double) {
    let buff: char[32]
    let buff: char[] = buff
    c_sprintf(buff.data, "%f", val)
    printString(buff.data)
}

fn printInt(val: $T) {
    let v = val
    let len = 0

    let neg = false
    if v < 0 {
        neg = true
        len = 1
        v = -v
        val = -val
    }
    else if v == 0 {
        len = 1
    }

    while v != 0 {
        v = v / 10
        len = len + 1
    }


    let buffer: String = newString()
    defer buffer.dispose()
    buffer.resize(len)

    if val == 0 {
        buffer.data[0] = '0'
    }
    else {
        let minimum = false
        if neg and val < 0 {
            // val is minimum value
            val = -(val + 1)
            minimum = true
        }

        let i = len - 1
        while val != 0 {
            defer i -= 1

            let lastDigit = val % 10
            if i == len - 1 and minimum {
                lastDigit = lastDigit + 1
            }

            val = val / 10
            buffer.data[i] = (char)(lastDigit + 48)
        }

        if (neg) {
            buffer.data[0] = '-'
        }
    }

    printStringl(&buffer)
}

fn b_print_i(buffer: String&, val: $T) {
    let v = val
    let len = 0

    let neg = false
    if v < 0 {
        neg = true
        len = 1
        v = -v
    }
    else if v == 0 {
        len = 1
    }

    while v != 0 {
        v = v / 10
        len = len + 1
    }

    if buffer.length + len > buffer.capacity {
        buffer.reserve(buffer.length + len)
    }

    buffer.length = buffer.length + len
    
    if val == 0 {
        buffer.data[buffer.length - 1] = '0'
    }
    else {
        let minimum = false
        if neg and val < 0 {
            // val is minimum value
            val = -(val + 1)
            minimum = true
        }

        let i = buffer.length - 1
        while val != 0 {
            defer i -= 1
            let lastDigit = val % 10
            if i == len - 1 and minimum {
                lastDigit = lastDigit + 1
            }

            val = val / 10
            buffer.data[i] = (char)(lastDigit + 48)
        }

        if (neg) {
            buffer.data[i] = '-'
            i -= 1
        }
    }
}

fn println(v: $T) {
    print(v)
    printChar(NEW_LINE)
}

fn print(v: $T) {
    if @isbool(T) {
        if v {
            printString("true")
        } else {
            printString("false")
        }
    } else if (@typeseq(string, T)) {
        printString(v)
    } else if @isint(T) {
        printInt(v)
    } else if @typeseq(T, f64) {
        printDouble(v)
    } else if @isstring(T) {
        printString(v)
    } else if @typeseq(String, T) {
        printStringl(&v)
    } else if @typeseq(String&, T) {
        printStringl(v)
    } else if @isenum(T) {
        printInt((int)v)
    } else if @typeseq(T, char) {
        printChar(v)
    } else if @typeseq(T, $X[]) {
        printSlice(v)
    } else {
        @error(@typename(T))
    }
}

fn printSlice(slice: $T[]) {
    print("[")
    while let i = 0; i < slice.length; i += 1 {
        if i > 0 {
            print(", ")
        }
        print(slice[i])
    }
    print("]")
}
/////////////////////////// new functions ///////////////////////////

trait Printable {
    fn print(str: String&, format: char[]);
}

fn parseInt(str: $String) -> int {
    let val = 0

    while let i = 0; i < str::getLength(); i += 1 {
        val *= 10
        val += (int)str::charAt(i) - (int)'0'
    }

    return val
}

fn print_f(format: string, args: Printable[]) {
    let s = newString()
    defer s.dispose()

    sprint_f(&s, format, args)
    print(s)
}

fn sprint_f(buffer: String&, format: string, args: Printable[]) {
    let formatSpecifier = newString()
    defer formatSpecifier.dispose()
    formatSpecifier.reserve(5)

    let len = (ulong)format.length
    let state = 0
    let argIndex = 0

    while let i: ulong = 0; i < len; i += 1 {
        let c = format[i]

        if state == 0 {
            if (c == '{') {
                state = 1
            }
            else {
                buffer.appendChar(c)
            }
        }
        else if state == 1 {
            if (c == '}') {
                let format: char[] = []

                let colon = formatSpecifier.indexOf(':')
                if colon >= 1 {
                    argIndex = parseInt(formatSpecifier.sliceL(colon))
                }
                else if colon == -1 and formatSpecifier.getLength() > 0 {
                    argIndex = parseInt(formatSpecifier)
                }
                if (colon != -1) {
                    format = formatSpecifier.sliceF(colon + 1)
                }

                if argIndex >= args.length {
                    println("argindex to large")
                    argIndex = 0
                    return
                }

                state = 0
                args[argIndex].print(buffer, format)
                argIndex += 1
                formatSpecifier.length = 0

            } else {
                formatSpecifier.appendChar(c)
            }
        }
    }
}

impl Printable for u8 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for u16 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for u32 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for u64 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for i8 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for i16 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for i32 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for i64 {
    fn print(str: String&, format: char[]) {
        b_print_i(str, <<self)
    }
}

impl Printable for f32 {
    fn print(str: String&, format: char[]) {
        let buff: char[32]
        let buff: char[] = buff
        buff.length = c_sprintf(buff.data, "%f", (double)<<self)
        str.append_string(buff)
    }
}

impl Printable for f64 {
    fn print(str: String&, format: char[]) {
        let buff: char[32]
        let buff: char[] = buff
        buff.length = c_sprintf(buff.data, "%f", <<self)
        str.append_string(buff)
    }
}

impl Printable for bool {
    fn print(str: String&, format: char[]) {
        if <<self {
            str.append_string("true")
        } else {
            str.append_string("false")
        }
    }
}
