#load("std:string")
#load("std:printable")
#load("std:mem/memory")
#load("std:os/windows")

fn print_string(s: ref String) {
    let bytesWritten: u32 = 0
    WriteFile(__std_out_handle, cast s.get_raw(), cast s.length, &bytesWritten, null)
}

fn println(v: $T) {
    let s = String::empty()
    s.appendf("{}`n", [v])
    print_string(s)
}

fn print(v: $T) {
    let s = String::empty()
    s.appendf("{}", [v])
    print_string(s)
}

fn printf(format: string, args: []Printable) {
    let s = String::empty()
    s.appendf(format, args)
    print_string(s)
}

fn printfln(format: string, args: []Printable) {
    let s = String::empty()
    s.appendf(format, args)
    s += '`n'
    print_string(s)
}

// helper functions
fn parse_int(str: string) -> int {
    let val = 0

    while let i = 0, i < str.length, i += 1 {
        val *= 10
        val += cast(int) str[i] - '0'
    }

    return val
}

fn digit_to_char(i: $T) -> char {
    let c = cast(char) i
    return if i < 10 { c + '0' } else { (c - cast(char)10) + 'A' }
}

fn format_int(buffer: ref String, val: $T, _base: int = 10) {
    let base = cast(T) _base
    let v = val
    let len = 0
    let neg = false

    // calculate length and sign
    if v < 0 {
        neg = true
        len = 1
        v = -v
    }
    else if v == 0 {
        len = 1
    }

    while v != 0 {
        v = v / base
        len += 1
    }

    // reserve memory
    buffer.resize(buffer.length + len)
    
    if val == 0 {
        buffer[buffer.length - 1] = '0'
    }
    else {
        if neg {
            val = -val
        }

        let i = buffer.length - 1
        while val != 0, i -= 1 {
            let lastDigit = val % base

            val = val / base
            buffer[i] = digit_to_char(lastDigit)
        }

        if neg {
            buffer[i] = '-'
            i -= 1
        }
    }
}
