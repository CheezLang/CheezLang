if const @is_os("windows") {
    import std.os.windows
    use import std.os.windows_functions
    use import std.os.windows_constants
    use import std.os.windows_types
}
if const @is_os("linux") {
    linux :: import std.os.linux
}

use import std.mem.allocator
use import std.io.file
use import std.string
use import std.util
io :: import std.io
C  :: import std.c

#export_scope
FsError :: enum {
    Unknown
    AlreadyExists
    PathNotFound
    InvalidUtf8
}

create_directory :: (path: string) -> Result[(), FsError] {
    // get full path
    full_path := try_with(get_full_path(path), {return Err(FsError.Unknown)})

    // prepend \\?\ to path to remove path length limit
    path_long := String.empty()
    path_long += "\\?\"
    path_long += full_path

    // convert to utf16
    full_path_utf16 := try_with(path_long.slice().to_utf16(), {return Err(FsError.Unknown)})
    return if CreateDirectoryW(full_path_utf16.data, null) != 0 then Ok(()) else match GetLastError() {
        WindowsErrorCode.ERROR_ALREADY_EXISTS -> Err(FsError.AlreadyExists)
        WindowsErrorCode.ERROR_PATH_NOT_FOUND -> Err(FsError.PathNotFound)
        $_ -> Err(FsError.Unknown)
    }
}

write_file :: (path: string, content: string) -> Result[(), FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.Unknown)
    }

    bytes_written : u32 = 0
    if WriteFile(handle, content.bytes.data, cast content.bytes.length, &bytes_written, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(())
}

read_file :: (path: string) -> Result[String, FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.PathNotFound)
    }

    size := 0
    if GetFileSizeEx(handle, &size) == 0 {
        return Err(FsError.Unknown)
    }

    result := String.empty()
    result.resize(size)
    
    bytesRead : u32 = 0
    if ReadFile(handle, result.get_raw(), cast(u32)size, &bytesRead, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(result)
}

get_full_path :: (path: string) -> Result[String, ()] {
    path_utf16 := try(path.to_utf16())

    required_length := GetFullPathNameW(path_utf16.get_raw(), 0, null, null)
    buffer := alloc_n(u16, required_length)
    defer free_n(buffer)
    if GetFullPathNameW(path_utf16.get_raw(), required_length, cast buffer.data, null) == 0 {
        return Err(())
    }

    return String.from_utf16(buffer)
}

#file_scope