if const @is_os("windows") {
    import std.os.windows
    use import std.os.windows_functions
    use import std.os.windows_constants
    use import std.os.windows_types
}
if const @is_os("linux") {
    linux :: import std.os.linux
}

use import std.io.file
use import std.string
io :: import std.io
C  :: import std.c

#export_scope
FsError :: enum {
    Unknown
    AlreadyExists
    PathNotFound
    InvalidUtf8
}

create_directory :: (path: string) -> Result[(), FsError] {
    full_path := get_full_path(path)
    full_path += char(0)
    c_path := full_path.get_raw()
    use WindowsErrorCode
    return if CreateDirectoryA(c_path, null) != 0 then Ok(()) else match GetLastError() {
        ERROR_ALREADY_EXISTS -> Err(FsError.AlreadyExists)
        ERROR_PATH_NOT_FOUND -> Err(FsError.PathNotFound)
        $_                   -> Err(FsError.Unknown)
    }
}

write_file :: (path: string, content: string) -> Result[(), FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.Unknown)
    }

    bytes_written : u32 = 0
    if WriteFile(handle, content.bytes.data, cast content.bytes.length, &bytes_written, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(())
}

read_file :: (path: string) -> Result[String, FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.PathNotFound)
    }

    size := 0
    if GetFileSizeEx(handle, &size) == 0 {
        return Err(FsError.Unknown)
    }

    result := String.empty()
    result.resize(size)
    
    bytesRead : u32 = 0
    if ReadFile(handle, result.get_raw(), cast(u32)size, &bytesRead, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(result)
}

get_full_path :: (path: string) -> String {
    c_path := string_to_cstring_stack(path)
    required_length := GetFullPathNameA(c_path, 0, null, null)
    result := String.empty()
    result.reserve(cast required_length)
    result.resize(cast required_length - 1)
    GetFullPathNameA(c_path, required_length, cast result.get_raw(), null)
    return result
}

#file_scope