if const @is_os("windows") {
    import std.os.windows
    use import std.os.windows_functions
    use import std.os.windows_constants
    use import std.os.windows_types
}
if const @is_os("linux") {
    linux :: import std.os.linux
}

use import std.array
use import std.io.file
use import std.mem.allocator
use import std.string
use import std.util

C  :: import std.c
io :: import std.io

#export_scope
FsError :: enum {
    Unknown
    AlreadyExists
    PathNotFound
    InvalidUtf8
}

create_directory :: (path: string) -> Result[(), FsError] {
    // get full path
    full_path := try_with(get_full_path(path), {return Err(FsError.Unknown)})

    // prepend \\?\ to path to remove path length limit
    path_long := String.empty()
    &path_long += "\\?\"
    &path_long += &full_path

    // convert to utf16
    full_path_utf16 := try_with(path_long.slice().to_utf16(), {return Err(FsError.Unknown)})
    return if CreateDirectoryW(full_path_utf16.data, null) != 0 then Ok(()) else match GetLastError() {
        WindowsErrorCode.ERROR_ALREADY_EXISTS -> Err(FsError.AlreadyExists)
        WindowsErrorCode.ERROR_PATH_NOT_FOUND -> Err(FsError.PathNotFound)
        $_ -> Err(FsError.Unknown)
    }
}

write_file :: (path: string, content: string) -> Result[(), FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.Unknown)
    }

    bytes_written : u32 = 0
    if WriteFile(handle, content.bytes.data, cast content.bytes.length, ^bytes_written, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(())
}

append_file :: (path: string, content: string) -> Result[(), FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.Unknown)
    }

    SetFilePointerEx(handle, 0, null, FILE_END)

    bytes_written : u32 = 0
    if WriteFile(handle, content.bytes.data, cast content.bytes.length, ^bytes_written, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(())
}

read_file :: (path: string) -> Result[String, FsError] {
    path_utf16 := try_with(path.to_utf16(), {return Err(FsError.InvalidUtf8)})

    handle := CreateFileW(path_utf16.get_raw(), GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
    if int(handle) == -1 {
        return Err(FsError.PathNotFound)
    }

    size := 0
    if GetFileSizeEx(handle, ^size) == 0 {
        return Err(FsError.Unknown)
    }

    result := String.empty()
    result.resize(size)
    
    bytesRead : u32 = 0
    if ReadFile(handle, result.get_raw(), cast(u32)size, ^bytesRead, null) == 0 {
        return Err(FsError.Unknown)
    }

    if CloseHandle(handle) == 0 {
        return Err(FsError.Unknown)
    }

    return Ok(result)
}

get_full_path :: (path: string) -> Result[String, ()] {
    path_utf16 := try(path.to_utf16())

    required_length := GetFullPathNameW(path_utf16.get_raw(), 0, null, null)
    buffer := alloc_n(u16, required_length)
    defer free_n(buffer)

    len := GetFullPathNameW(path_utf16.get_raw(), required_length, cast buffer.data, null)
    if len == 0 {
        return Err(())
    }

    return String.from_utf16(buffer[..int(len)])
}

get_working_directory :: () -> Result[String, ()] {
    buff : [512]u16 = default
    length := GetCurrentDirectoryW(cast buff.length, buff.data)
    return String.from_utf16(buff[..int(length)])
}

Path :: struct {}

impl Path {
    get_containing_directory :: (path: string) -> string {
        index_slash     := path.last_index_of('/')
        index_backslash := path.last_index_of('\')
        index := max(index_slash, index_backslash)
        if index < 0 {
            return path
        }
        return path[.. index]
    }

    get_file_name :: (path: string) -> string {
        index_slash     := path.last_index_of('/')
        index_backslash := path.last_index_of('\')
        index := max(index_slash, index_backslash)
        if index < 0 {
            return path
        }
        return path[index+1 ..]
    }

    concat :: (path1: string, path2: string) -> String {
        result := String.with_capacity(path1.bytes.length + path2.bytes.length + 1)
        result += path1
        if !path1.ends_with("/") and !path1.ends_with("\") {
            result += "/"
        }
        result += path2
        return result
    }

    normalize :: (path: string) -> String {
        parts := Array[string].create()

        starts_with_slash := false

        start := 0
        for i in 0 .. path.bytes.length {
            c := char(*path.bytes[i])

            if c == '/' and i == 0 {
                starts_with_slash = true
            }

            if c == '/' or c == '\' {
                sub := path[start..i]
                if sub == "." {
                    // do nothing
                } else if sub == ".." and parts.count() > 0 {
                    parts.pop()
                } else if sub.bytes.length > 0 {
                    parts.add(sub)
                }

                start = i + 1
            }
        }

        if start < path.bytes.length {
            sub := path[start..]
            if sub == "." {
                // do nothing
            } else if sub == ".." and parts.count() > 0 {
                parts.pop()
            } else if sub.bytes.length > 0 {
                parts.add(sub)
            }
        }

        result := String.with_capacity(path.bytes.length)

        if starts_with_slash {
            result += "/"
        }

        for p in &parts {
            if it_index > 0 {
                result += "\"
            }
            result += *p
        }
        return result
    }
}

#file_scope