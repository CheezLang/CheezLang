use import std.mem.allocator
use import std.os.windows
use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
use import std.os.windows_macros
use import std.array
use import std.rc
use import std.ring_queue

C :: import std.c

#export_scope

current_thread_data : ^ThreadData = null #thread_local

// thread
Thread :: struct {
    data: ^ThreadData
}

ThreadData :: struct {
    handle  : HANDLE
    user    : ^void
    func    : Fn(^void)
    id      : int
}

impl Thread {
    current :: () -> ^ThreadData {
        if current_thread_data == null {
            current_thread_data = alloc(ThreadData)
            *current_thread_data = ThreadData(
                handle  = GetCurrentThread()
                user    = null
                func    = null
                id      = cast GetCurrentThreadId()
            )
        }
        return current_thread_data
    }

    create :: (func: Fn(^$T), user_data: ^$T) -> Thread {
        thread_func :: (data: ^void) -> u32 #stdcall {
            thread_data := @cast(^ThreadData, data)
            current_thread_data = thread_data
            thread_data.func(thread_data.user)
            return 0
        }

        td := alloc(ThreadData)
        handle := CreateThread(null, 0, thread_func, cast td, CREATE_SUSPENDED, null)
        @assert(handle != null)

        td.handle   = handle
        td.id       = cast GetThreadId(handle)
        td.func     = @cast(Fn(^void), func)
        td.user     = @cast(^void, user_data)

        return Thread(td)
    }

    new :: (func: Fn()) -> Thread {
        return create_without_data(func)
    }

    create_without_data :: (func: Fn()) -> Thread {
        thread_func :: (data: ^void) -> u32 #stdcall {
            thread_data := @cast(^ThreadData, data)
            current_thread_data = thread_data

            func := @cast(Fn(), thread_data.func)
            func()
            return 0
        }

        td := alloc(ThreadData)
        handle := CreateThread(null, 0, thread_func, cast td, CREATE_SUSPENDED, null)
        @assert(handle != null)

        td.handle   = handle
        td.id       = cast GetThreadId(handle)
        td.func     = @cast(Fn(^void), func)
        td.user     = null

        return Thread(td)
    }

    start :: (&Self) -> bool {
        res := ResumeThread(data.handle)
        return res != -1
    }

    join :: (&Self) {
        WaitForSingleObject(data.handle, INFINITE)
    }

    terminate :: (&Self) {
        TerminateThread(data.handle, -1)
    }

    sleep :: (millis: int) {
        Sleep(cast millis)
    }
}

impl Drop for Thread {
    drop :: (&Self) {
        self.join()
    }
}

// mutex
Mutex :: struct {
    handle: HANDLE
}

impl Mutex {
    new :: () -> Mutex {
        handle := CreateMutexA(null, 0, null)
        if handle == null {
            @panic("Failed to create mutex")
        }

        return Mutex(handle)
    }

    try_lock :: (&Self, timeout: int) -> bool {
        return match WaitForSingleObject(handle, cast timeout) {
            0x00000000 -> true
            0x00000080 -> true
            0x00000102 -> false
            0xFFFFFFFF -> false
            $_ -> false
        }
    }

    lock :: (&Self) {
        match WaitForSingleObject(handle, INFINITE) {
            0x00000000 -> {}
            0x00000080 -> {}
            0x00000102 -> @panic("failed to lock mutex (time out)")
            0xFFFFFFFF -> @panic("failed to lock mutex")
            $_ -> @panic("failed to lock mutex (unknown error)")
        }
    }

    release :: (&Self) {
        ReleaseMutex(handle)
    }
}

impl Drop for Mutex {
    drop :: (&Self) {
        CloseHandle(handle)
    }
}

// 
ConditionVariable :: struct {
    _impl : CONDITION_VARIABLE
}

impl ConditionVariable {
    new :: () -> Rc[ConditionVariable] {
        cond_var := Rc[ConditionVariable].new(CONDITION_VARIABLE())
        InitializeConditionVariable(^cond_var.get()._impl)
        return cond_var
    }

    wait :: (&Self, lock: &ReentrantLock) {
        SleepConditionVariableCS(^_impl, ^lock._impl, INFINITE)
    }

    notify :: (&Self) {
        WakeConditionVariable(^_impl)
    }

    notify_all :: (&Self) {
        WakeAllConditionVariable(^_impl)
    }
}


// lock
ReentrantLock :: struct {
    _impl : CRITICAL_SECTION
}

impl ReentrantLock {
    new :: () -> Rc[ReentrantLock] {
        lock := Rc[ReentrantLock].new(CRITICAL_SECTION())
        InitializeCriticalSection(^lock.get()._impl)
        return lock
    }

    try_lock :: (&Self, timeout: int) -> bool {
        return TryEnterCriticalSection(^_impl) != 0
    }

    lock :: (&Self) {
        EnterCriticalSection(^_impl)
    }

    release :: (&Self) {
        LeaveCriticalSection(^_impl)
    }
}

impl Drop for ReentrantLock {
    drop :: (&Self) {
        DeleteCriticalSection(^self._impl)
    }
}

// thread pool
ThreadPoolFunc :: (function: fn(^void), data: ^void)

ThreadPoolData :: struct {
    threads     : Array[Thread]
    functions   : RingQueue[ThreadPoolFunc]
    running     : bool
    mutex       : Mutex
    empty_queue : bool
}

ThreadPool :: struct {
    data: ^ThreadPoolData
}

impl ThreadPool {
    create :: (num_threads: int) -> Self {
        data := alloc(ThreadPoolData)
        *data = ThreadPoolData(
            threads = Array[Thread].create(num_threads)
            functions = RingQueue[ThreadPoolFunc].new(10)
            mutex = Mutex.new()
            running = true
            empty_queue  = false
        )

        // defined right here so it's not accessible outside
        worker :: (tp: ^ThreadPoolData) {
            while true {
                tp.mutex.lock()
                if !(tp.running or (tp.empty_queue and tp.functions.get_length() > 0)) {
                    break
                }

                next : ThreadPoolFunc = (@cast(fn(^void), null), null)
                if tp.functions.get_length() > 0 {
                    next = tp.functions.pop()
                }
                tp.mutex.release()

                if next.function != null {
                    next.function(next.data)
                } else {
                    Sleep(1)
                }
            }
        }

        for 0..num_threads {
            t := Thread.create(cast(Fn(^ThreadPoolData)) worker, data)
            t.start()
            data.threads.add(t)
        }

        return ThreadPool(data)
    }

    count :: (&Self) -> int {
        return data.functions.get_length()
    }

    enqueue :: (&Self, function: fn(^$T), data_ptr: ^T) {
        data.mutex.lock()
        data.functions.push((@cast(fn(^void), function), @cast(^void, data_ptr)))
        data.mutex.release()
    }

    terminate :: (Self, empty_queue: bool) {
        data.empty_queue = empty_queue
        data.running = false
    }
}

impl Drop for ThreadPool {
    drop :: (&Self) {
        data.running = false
        for &data.threads {
            it.join()
        }
    }
}
