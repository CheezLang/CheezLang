use import std.mem.allocator
use import std.os.windows
use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
use import std.os.windows_macros
use import std.array
use import std.ring_queue

C :: import std.c

#export_scope

current_thread_data : &ThreadData = null #thread_local

// thread
Thread :: struct {
    data: &ThreadData
}

ThreadData :: struct {
    handle  : HANDLE
    user    : &void
    func    : fn(&void)
    id      : int
}

impl Thread {
    current :: () -> &ThreadData {
        if current_thread_data == null {
            current_thread_data = alloc(ThreadData)
            <<current_thread_data = ThreadData(
                handle  = GetCurrentThread()
                user    = null
                func    = null
                id      = cast GetCurrentThreadId()
            )
        }
        return current_thread_data
    }

    create :: (func: fn(&$T), user_data: &$T) -> Thread {
        thread_func :: (data: &void) -> u32 #stdcall {
            thread_data := @cast(&ThreadData, data)
            current_thread_data = thread_data
            thread_data.func(thread_data.user)
            return 0
        }

        td := alloc(ThreadData)
        handle := CreateThread(null, 0, thread_func, cast td, CREATE_SUSPENDED, null)
        @assert(handle != null)

        td.handle   = handle
        td.id       = cast GetThreadId(handle)
        td.func     = @cast(fn(&void), func)
        td.user     = @cast(&void, user_data)

        return Thread(td)
    }

    create_without_data :: (func: fn()) -> Thread {
        thread_func :: (data: &void) -> u32 #stdcall {
            thread_data := @cast(&ThreadData, data)
            current_thread_data = thread_data

            func := @cast(fn(), thread_data.func)
            func()
            return 0
        }

        td := alloc(ThreadData)
        handle := CreateThread(null, 0, thread_func, cast td, CREATE_SUSPENDED, null)
        @assert(handle != null)

        td.handle   = handle
        td.id       = cast GetThreadId(handle)
        td.func     = @cast(fn(&void), func)
        td.user     = null

        return Thread(td)
    }

    start :: (ref Self) -> bool {
        res := ResumeThread(data.handle)
        return res != -1
    }

    join :: (ref Self) {
        WaitForSingleObject(data.handle, INFINITE)
    }

    terminate :: (ref Self) {
        TerminateThread(data.handle, -1)
    }
}

impl Drop for Thread {
    drop :: (ref Self) {
        self.join()
    }
}

// mutex
Mutex :: struct {
    handle: HANDLE
}

impl Mutex {
    create :: () -> Mutex {
        handle := CreateMutexA(null, 0, null)
        if handle == null {
            @panic("Failed to create mutex")
        }

        return Mutex(handle)
    }

    try_lock :: (ref Self, timeout: int) -> bool {
        return match WaitForSingleObject(handle, cast timeout) {
            0x00000000 -> true
            0x00000080 -> true
            0x00000102 -> false
            0xFFFFFFFF -> false
            $_ -> false
        }
    }

    lock :: (ref Self) {
        match WaitForSingleObject(handle, INFINITE) {
            0x00000000 -> {}
            0x00000080 -> {}
            0x00000102 -> @panic("failed to lock mutex (time out)")
            0xFFFFFFFF -> @panic("failed to lock mutex")
            $_ -> @panic("failed to lock mutex (unknown error)")
        }
    }

    release :: (ref Self) {
        ReleaseMutex(handle)
    }
}

impl Drop for Mutex {
    drop :: (ref Self) {
        CloseHandle(handle)
    }
}

// thread pool
ThreadPoolFunc :: (function: fn(&void), data: &void)

ThreadPoolData :: struct {
    threads     : Array[Thread]
    functions   : RingQueue[ThreadPoolFunc]
    running     : bool
    mutex       : Mutex
    empty_queue : bool
}

ThreadPool :: struct {
    data: &ThreadPoolData
}

impl ThreadPool {
    create :: (num_threads: int) -> Self {
        data := alloc(ThreadPoolData)
        <<data = ThreadPoolData(
            threads = Array[Thread].create(num_threads)
            functions = RingQueue[ThreadPoolFunc].create(10)
            mutex = Mutex.create()
            running = true
            empty_queue  = false
        )

        // defined right here so it's not accessible outside
        worker :: (tp: &ThreadPoolData) {
            while true {
                tp.mutex.lock()
                if !(tp.running or (tp.empty_queue and tp.functions.get_length() > 0)) {
                    break
                }

                next : ThreadPoolFunc = (@cast(fn(&void), null), null)
                if tp.functions.get_length() > 0 {
                    next = tp.functions.pop()
                }
                tp.mutex.release()

                if next.function != null {
                    next.function(next.data)
                } else {
                    Sleep(1)
                }
            }
        }

        for 0..num_threads {
            t := Thread.create(worker, data)
            t.start()
            data.threads.add(t)
        }

        return ThreadPool(data)
    }

    count :: (ref Self) -> int {
        return data.functions.get_length()
    }

    enqueue :: (ref Self, function: fn(&$T), data_ptr: &T) {
        data.mutex.lock()
        data.functions.push((@cast(fn(&void), function), @cast(&void, data_ptr)))
        data.mutex.release()
    }

    terminate :: (Self, empty_queue: bool) {
        data.empty_queue = empty_queue
        data.running = false
    }
}

impl Drop for ThreadPool {
    drop :: (ref Self) {
        data.running = false
        for data.threads {
            it.join()
        }
    }
}
