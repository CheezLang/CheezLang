#load("std:preload")
#load("std:os/windows")
#load("std:array")
#load("std:ring_queue")

// thread
Thread :: struct {
    data: &ThreadData
    handle: HANDLE
}

ThreadData :: struct {
    data: &any
    func: fn(&any)
}

impl Thread {
    create :: (func: fn(&$T), data: &$T) -> Thread {
        td := alloc(ThreadData)
        td.func = @cast(fn(&any), func)
        td.data = @cast(&any, data)

        thread_func :: (data: &any) -> u32 #stdcall {
            thread := @cast(&ThreadData, data)
            thread.func(thread.data)
            return 0
        }

        handle := CreateThread(null, 0, thread_func, cast td, CREATE_SUSPENDED, null)
        @assert(handle != null)
        return Thread(
            data = td
            handle = handle
        )
    }

    start :: (ref Self) -> bool {
        res := ResumeThread(handle)
        return res != -1
    }

    join :: (ref Self) {
        // use INFINITE instead of this
        WaitForSingleObject(handle, 100000000)
    }

    terminate :: (ref Self) {
        TerminateThread(handle, -1)
    }
}

impl Drop for Thread {
    drop :: (ref Self) {
        self.join()
    }
}

// mutex
Mutex :: struct {
    handle: HANDLE
}

impl Mutex {
    create :: () -> Mutex {
        handle := CreateMutexA(null, 0, null)
        if handle == null {
            @panic("Failed to create mutex")
        }

        return Mutex(handle)
    }

    try_lock :: (ref Self, timeout: int) -> bool {
        return match WaitForSingleObject(handle, cast timeout) {
            0x00000000 -> true
            0x00000080 -> true
            0x00000102 -> false
            0xFFFFFFFF -> false
            $_ -> false
        }
    }

    lock :: (ref Self) {
        match WaitForSingleObject(handle, INFINITE) {
            0x00000000 -> {}
            0x00000080 -> {}
            0x00000102 -> @panic("failed to lock mutex (time out)")
            0xFFFFFFFF -> @panic("failed to lock mutex")
            $_ -> @panic("failed to lock mutex (unknown error)")
        }
    }

    release :: (ref Self) {
        ReleaseMutex(handle)
    }
}

impl Drop for Mutex {
    drop :: (ref Self) {
        CloseHandle(handle)
    }
}

// thread pool
ThreadPoolFunc :: (function: fn(&any), data: &any)

ThreadPoolData :: struct {
    threads     : Array[Thread]
    functions   : RingQueue[ThreadPoolFunc]
    running     : bool
    mutex       : Mutex
    empty_queue : bool
}

ThreadPool :: struct {
    data: &ThreadPoolData
}

impl ThreadPool {
    create :: (num_threads: int) -> Self {
        data := alloc(ThreadPoolData)
        <<data = ThreadPoolData(
            threads = Array[Thread].create(num_threads)
            functions = RingQueue[ThreadPoolFunc].create(10)
            mutex = Mutex.create()
            running = true
            empty_queue  = false
        )

        // defined right here so it's not accessible outside
        worker :: (tp: &ThreadPoolData) {
            while true {
                tp.mutex.lock()
                if !(tp.running or (tp.empty_queue and tp.functions.get_length() > 0)) {
                    break
                }

                next : ThreadPoolFunc = (@cast(fn(&any), null), null)
                if tp.functions.get_length() > 0 {
                    next = tp.functions.pop()
                }
                tp.mutex.release()

                if next.function != null {
                    next.function(next.data)
                } else {
                    Sleep(1)
                }
            }
        }

        for 0..num_threads {
            t := Thread.create(worker, data)
            t.start()
            data.threads.add(t)
        }

        return ThreadPool(data)
    }

    enqueue :: (ref Self, function: fn(&$T), data_ptr: &T) {
        data.mutex.lock()
        data.functions.push((@cast(fn(&any), function), @cast(&any, data_ptr)))
        data.mutex.release()
    }

    terminate :: (Self, empty_queue: bool) {
        data.empty_queue = empty_queue
        data.running = false
    }
}

impl Drop for ThreadPool {
    drop :: (ref Self) {
        data.running = false
        for data.threads {
            it.join()
        }
    }
}
