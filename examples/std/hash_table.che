use import std.mem.allocator
use import std.mem.std_heap_allocator
use import std.hash
use import std.iterator

C :: import std.c

#export_scope

Table :: struct(K: type, V: type) {
    max_load  : double
    count     : uint
    entries   : []Entry[K, V]
    allocator : &Allocator
    comparer  : fn (K, K) -> bool
}

Entry :: struct(K: type, V: type) {
    key          : K
    value        : Option[V]
    filled       : bool
    is_tombstone : bool
}

impl(K: type, V: type) Drop for Table[K, V] {
    drop :: (ref Self) {
        if entries.data != null {
            free_n(entries, allocator)
        }
    }
}

impl(K: type, V: type) Table[K, V] {
    create :: (comp: fn(K, K) -> bool, allocator: &Allocator = &DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        return Table[K, V](
            allocator   = allocator
            comparer    = comp
            max_load    = 0.75
            count       = 0
            entries     = null
        )
    }

    clear :: (ref Self) {
        // @todo
        for(by_ref=true) entry : entries {
            entry.filled = false
            entry.is_tombstone = false
            entry.value = None
        }
        count = 0
    }

    empty :: (ref Self) -> bool {
        return count == 0
    }

    get_count :: (ref Self) -> int {
        return cast count
    }

    get_entries :: (ref Self) -> []Entry[K, V] {
        return entries
    }

    find_entry :: (ref Self, the_entries: []Entry[K, V], key: K) -> &Entry[K, V] {

        index := K.hash(key) % cast(uint) the_entries.length
        tombstone : &Entry[K, V] = null

        while true {
            entry := &the_entries[index]

            if !entry.filled {
                if !entry.is_tombstone {
                    if tombstone != null {
                        return tombstone
                    } else {
                        return entry
                    }
                } else if tombstone == null {
                    tombstone = entry
                }
            } else if comparer(entry.key, key) {
                return entry
            }

            index = (index + 1) % cast(uint) the_entries.length
        }

        // unreachable
        return null
    }

    set :: (ref Self, key: K, value: V) -> bool #operator("set[]") {
        if entries.data == null {
            adjust_capacity(13)
        }
        if (cast(double) count + 1) > ((cast(double)entries.length) * max_load) {
            adjust_capacity(cast(uint) entries.length * 2)
        }

        entry := find_entry(entries, key)
        is_new_key := !entry.filled
        entry.key = key
        entry.value = Some(value)
        entry.filled = true
        entry.is_tombstone = false

        if is_new_key {
            count += 1
        }

        return is_new_key
    }

    get :: (ref Self, key: K) -> Option[ref V] {
        if entries.data == null {
            return None
        }

        entry := find_entry(entries, key)
        if !entry.filled {
            return None
        }

        return match ref entry.value {
            Some($val)  -> Some(val)
            None        -> None
        }
    }

    get_unchecked :: (ref Self, key: K) -> ref V #operator("[]") {
        entry := find_entry(entries, key)
        return entry.value.Some
    }

    delete :: (ref Self, key: K) -> bool {
        if count == 0 or entries.data == null { return false }

        entry := find_entry(entries, key)
        if !entry.filled { return false }

        entry.filled = false
        entry.is_tombstone = true

        return true
    }

    adjust_capacity :: (ref Self, cap: uint) {
        entries_new := alloc_n(Entry[K, V], cap, allocator)

        for i : 0..entries_new.length {
            entries_new[i].filled = false
            entries_new[i].is_tombstone = false
        }

        // copy entries to new array
        if entries.data != null {
            count = 0
            for i : 0..entries.length {
                entry := &entries[i]
                if entry.filled {
                    dest := find_entry(entries_new, entry.key)
                    dest.key = entry.key
                    dest.value = entry.value <- None
                    dest.filled = true
                    count += 1
                }
            }

            free_n(entries, allocator)
        }

        entries = entries_new
    }

    iterator :: (ref Self) -> TableIterator[K, V] {
        return TableIterator[K, V](self, 0)
    }
}

for_extension_table :: (r: ref Table[$K, $V], code: Code) #for {
    for(by_ref=true) e : r.get_entries() {
        if !e.filled then continue
        it : (name: K, value: ref V) = e.key, ref e.value.Some
        it_index := it_index
        @insert(code, _break=@link(break), _continue=@link(continue))
    }
}

// iterator
TableIterator :: struct(K: type, V: type) {
    table: ref Table[K, V]
    index: int
}

impl(K: type, V: type) Iterator[(K, V)] for TableIterator[K, V] {
    next :: (ref Self) -> Option[(K, V)] {
        entries := table.get_entries()
        while index < entries.length {
            e := ref entries[index]
            index += 1

            if e.filled {
                return Some((e.key, e.value))
            }
        }

        return None
    }

    dispose :: (ref Self) {
        free(&self)
    }
}
