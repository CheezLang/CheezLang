#load("std:preload")
#load("std:mem/std_heap_allocator")
#load("std:hash")
#load("std:iterator")

struct Table(K: type, V: type) {
    max_load: double
    count: uint
    entries: []Entry(K, V)
    allocator: Allocator
    comparer: fn (K, K) -> bool
}

struct Entry(K: type, V: type) {
    pub key: K
    pub value: V
    pub filled: bool
    pub is_tombstone: bool
}

impl(K: type, V: type) Table(K, V) {
    fn create(comp: fn(K, K) -> bool, allocator: Allocator = DEFAULT_STD_HEAP_ALLOCATOR) -> Self {
        return new {
            allocator   = allocator
            comparer    = comp
            max_load    = 0.75
            count       = 0
            entries     = null
        }
    }

    fn get_entries(ref Self) -> []Entry(K, V) {
        return entries
    }

    fn dispose(ref Self) {
        if entries.data != null {
            free_n(entries, allocator)
        }
    }

    fn find_entry(ref Self, the_entries: []Entry(K, V), key: K) -> &Entry(K, V) {

        let index = key::hash() % cast(uint) the_entries.length
        let tombstone: &Entry(K, V) = null

        while true {
            let entry = &the_entries[index]

            if !entry.filled {
                if !entry.is_tombstone {
                    if tombstone != null {
                        return tombstone
                    }
                    else {
                        return entry
                    }
                } else if tombstone == null {
                    tombstone = entry
                }
            } else if comparer(entry.key, key) {
                return entry
            }

            index = (index + 1) % cast(uint) the_entries.length
        }

        // unreachable
        return null
    }

    fn set(ref Self, key: K, value: V) -> bool #operator("set[]") {
        if entries.data == null {
            adjust_capacity(13)
        }
        if (cast(double) count + 1) > ((cast(double)entries.length) * max_load) {
            adjust_capacity(cast(uint) entries.length * 2)
        }

        let entry = find_entry(entries, key)
        let is_new_key = !entry.filled
        entry.key = key
        entry.value = value
        entry.filled = true
        entry.is_tombstone = false

        if is_new_key {
            count += 1
        }

        return is_new_key
    }

    fn get(ref Self, key: K) -> Option(ref V) {
        if entries.data == null {
            return None
        }

        let entry = find_entry(entries, key)
        if !entry.filled {
            return None
        }

        return Some(entry.value)
    }

    fn get_unchecked(ref Self, key: K) -> ref V #operator("[]") {
        let entry = find_entry(entries, key)
        return entry.value
    }

    fn delete(ref Self, key: K) -> bool {
        if count == 0 or entries.data == null { return false }

        let entry = find_entry(entries, key)
        if !entry.filled { return false }

        entry.filled = false
        entry.is_tombstone = true

        return true
    }

    fn adjust_capacity(ref Self, cap: uint) {
        let entries_new = alloc_n(Entry(K, V), cap, allocator)

        while let i = 0, i < entries_new.length, i += 1 {
            entries_new[i].filled = false
            entries_new[i].is_tombstone = false
        }

        // copy entries to new array
        if entries.data != null {
            count = 0
            while let i = 0, i < entries.length, i += 1 {
                let entry = &entries[i]
                if entry.filled {
                    let dest = find_entry(entries_new, entry.key)
                    dest.key = entry.key
                    dest.value = entry.value
                    dest.filled = true
                    count += 1
                }
            }

            free_n(entries, allocator)
        }

        entries = entries_new
    }

    fn iterator(ref Self) -> TableIterator(K, V) {
        return new {self, 0}
    }
}

// iterator
struct TableIterator(K: type, V: type) {
    table: ref Table(K, V)
    index: int
}

impl(K: type, V: type) Iterator((K, V)) for TableIterator(K, V) {
    fn next(ref Self) -> Option((K, V)) {
        let entries = table.get_entries()
        while index < entries.length {
            let e = ref entries[index]
            index += 1

            if e.filled {
                return Some((e.key, e.value))
            }
        }

        return None
    }

    fn dispose(ref Self) {
        free(&self)
    }
}
