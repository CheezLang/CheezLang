#load("std:preload")

sqrtf :: (f: float) -> float;
sqrt :: (f: double) -> double;

abs :: (i: $T) -> T { return if i < 0 {-i} else {i} }
fabsf :: (f: float) -> float;
fabs :: (f: double) -> double;

max :: (a: $T, b: T) -> T { return if a >= b then a else b }
fmaxf :: (f1: float, f2: float) -> float;
fmax :: (f1: double, f2: double) -> double;

min :: (a: $T, b: T) -> T { return if a <= b then a else b }
fminf :: (f1: float, f2: float) -> float;
fmin :: (f1: double, f2: double) -> double;

sinf :: (f: float) -> float;
sin :: (f: double) -> double;
sinh :: (f: double) -> double;

cosf :: (f: float) -> float;
cos :: (f: double) -> double;
cosh :: (f: double) -> double;

tanf :: (f: float) -> float;
tan :: (f: double) -> double;

atan2 :: (a: double, b: double) -> double;
pow :: (a: double, b: double) -> double;
exp :: (a: double) -> double;

logf :: (f: float) -> float;
log :: (f: double) -> double;

floorf :: (float) -> float;
floor :: (double) -> double;

ceilf :: (float) -> float;
ceil :: (double) -> double;

mod_pos :: (a: $T, b: T) -> T {
    return ((a % b) + b) % b
}

clamp :: (value: $T, min: T, max: T) -> T {
    if value < min { return min }
    if value > max { return max }
    return value
}

Vector2 :: struct(T: type) #copy {
    x : T = default
    y : T = default
}

Vector3 :: struct(T: type) #copy {
    x : T = default
    y : T = default
    z : T = default
}

Vector4 :: struct(T: type) #copy {
    x : T = default
    y : T = default
    z : T = default
    w : T = default
}

impl(T: type) Vector2[T] {
    // ref
    addv :: (ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        return self
    }

    subv :: (ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        return self
    }

    mulv :: (ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        return self
    }

    muls :: (ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        return self
    }

    divv :: (ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        return self
    }

    normalize :: (ref Self) -> ref Self {
        mag := self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
        }

        return self
    }

    mag :: (Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y))
    }

    magsq :: (Self) -> T {
        return cast(T) (x*x + y*y)
    }

    neg :: (Self) -> Self #operator("-") {
        return Vector2[T](-x, -y)
    }

    // static
    addvv :: (a: Self, b: Self) -> Self #operator("+") {
        return Vector2[T](
            a.x + b.x
            a.y + b.y
        )
    }

    subvv :: (a: Self, b: Self) -> Self #operator("-") {
        return Vector2[T](
            a.x - b.x
            a.y - b.y
        )
    }

    mulvv :: (a: Self, b: Self) -> Self #operator("*") {
        return Vector2[T](
            a.x * b.x
            a.y * b.y
        )
    }

    mulvs :: (a: Self, b: T) -> Self #operator("*") {
        return Vector2[T](
            a.x * b
            a.y * b
        )
    }

    divvv :: (a: Self, b: Self) -> Self #operator("/") {
        return Vector2[T](
            a.x / b.x
            a.y / b.y
        )
    }

    divvs :: (a: Self, b: T) -> Self #operator("/") {
        return Vector2[T](
            a.x / b
            a.y / b
        )
    }

    dot :: (a: Self, b : Self) -> T {
        return a.x * b.x + a.y * b.y
    }

    eq :: (a: ref Self, b: ref Self) -> bool #operator("==") {
        return a.x == b.x and a.y == b.y
    }
}

impl(T: type) Vector3[T] {
    // ref
    addv :: (ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        z += other.z
        return self
    }

    subv :: (ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        z -= other.z
        return self
    }

    mulv :: (ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        z *= other.z
        return self
    }

    muls :: (ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        z *= other
        return self
    }

    divv :: (ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        z /= other.z
        return self
    }

    normalize :: (ref Self) -> ref Self {
        mag := self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
            z /= mag
        }

        return self
    }

    normalized :: (Self) -> Self {
        mag := self.mag()
        if mag != 0 {
            return Vector3[T](
                x / mag
                y / mag
                z / mag
            )
        } else {
            return Vector3[T](0, 0, 0)
        }
    }

    mag :: (Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y + z*z))
    }

    magsq :: (Self) -> T {
        return cast(T) (x*x + y*y + z*z)
    }

    neg :: (Self) -> Self #operator("-") {
        return Vector3[T](-x, -y, -z)
    }

    // static
    addvv :: (a: Self, b: Self) -> Self #operator("+") {
        return Vector3[T](
            a.x + b.x
            a.y + b.y
            a.z + b.z
        )
    }

    addvs :: (a: Self, b: T) -> Self #operator("+") {
        return Vector3[T](
            a.x + b
            a.y + b
            a.z + b
        )
    }

    subvv :: (a: Self, b: Self) -> Self #operator("-") {
        return Vector3[T](
            a.x - b.x
            a.y - b.y
            a.z - b.z
        )
    }

    subvs :: (a: Self, b: T) -> Self #operator("-") {
        return Vector3[T](
            a.x - b
            a.y - b
            a.z - b
        )
    }

    mulvv :: (a: Self, b: Self) -> Self #operator("*") {
        return Vector3[T](
            a.x * b.x
            a.y * b.y
            a.z * b.z
        )
    }

    mulvs :: (a: Self, b: T) -> Self #operator("*") {
        return Vector3[T](
            a.x * b
            a.y * b
            a.z * b
        )
    }

    divvv :: (a: Self, b: Self) -> Self #operator("/") {
        return Vector3[T](
            a.x / b.x
            a.y / b.y
            a.z / b.z
        )
    }

    divvs :: (a: Self, b: T) -> Self #operator("/") {
        return Vector3[T](
            a.x / b
            a.y / b
            a.z / b
        )
    }

    dot :: (a: Self, b: Self) -> T {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }

    cross :: (ref Self, other: Self) -> Self {
        return Vector3[T](
            y * other.z - z * other.y
            z * other.x - x * other.z
            x * other.y - y * other.x
        )
    }

    reflect :: (ref Self, normal: Self) -> Self {
        return normal * -Self.dot(self, normal) * T(2) + <<&self
    }

    refract :: (ref Self, normal: Self, ior: T) -> Option[Self] {
        uv := self
        dt := Self.dot(uv, normal)
        discriminant := 1 - ior * ior * (1 - dt * dt)
        if discriminant > 0 {
            refr := (uv - normal * dt) * ior - normal * T(sqrt(double(discriminant)))
            return Some(refr)
        } else {
            return None
        }
    }

    max_component :: (ref Self) -> T {
        return max(x, max(y, z))
    }

    clamped :: (ref Self, min: T, max: T) -> Self {
        return Vector3[T](
            clamp(x, min, max)
            clamp(y, min, max)
            clamp(z, min, max)
        )
    }

    change_type :: (ref Self, $TargetType: type) -> Vector3[TargetType] {
        return Vector3[TargetType](TargetType(x), TargetType(y), TargetType(z))
    }
}

Complex :: struct #copy {
    r : double = 0.0
    i : double = 0.0
}

impl Complex {
    real :: (r: double) -> Self {
        return Complex(r, 0)
    }

    imaginary :: (i: double) -> Self {
        return Complex(0, i)
    }

    from_polar :: (m: double, p: double) -> Self {
        return Complex(m * cos(p), m * sin(p))
    }

    add :: (a: Complex, b: Complex) -> Self #operator("+") {
        return Complex(a.r + b.r, a.i + b.i)
    }

    add2 :: (a: Complex, b: double) -> Self #operator("+") {
        return Complex(a.r + b, a.i)
    }

    sub :: (a: Complex, b: Complex) -> Self #operator("-") {
        return Complex(a.r - b.r, a.i - b.i)
    }

    sub2 :: (a: Complex, b: double) -> Self #operator("-") {
        return Complex(a.r - b, a.i)
    }

    neg :: (a: Complex) -> Self #operator("-") {
        return Complex(-a.r, -a.i)
    }

    conj :: (a: Complex) -> Self #operator("!") {
        return Complex(a.r, -a.i)
    }

    mul :: (a: Complex, b: Complex) -> Self #operator("*") {
        return Complex(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r)
    }

    mul2 :: (a: Complex, b: double) -> Self #operator("*") {
        return Complex(a.r * b, a.i * b)
    }

    div :: (a: Complex, b: Complex) -> Self #operator("/") {
        fac := 1 / (b.r * b.r + b.i * b.i)
        return Complex(fac * (a.r * b.r + a.i * b.i), fac * (a.r * b.i - a.i * b.r))
    }

    div2 :: (a: Complex, b: double) -> Self #operator("/") {
        return Complex(a.r / b, a.i / b)
    }

    poww :: (a: Complex, e: double) -> Self {
        if a.r == 0 and a.i == 0 {
            return a
        }

        r := sqrt(a.r * a.r + a.i * a.i)
        p := atan2(a.i, a.r)

        r = pow(r, e)
        p = p * e

        return Complex(r * cos(p), r * sin(p))
    }

    polar :: (Self) -> (m: double, p: double) {
        m = sqrt(self.r * self.r + self.i * self.i)
        p = atan2(self.i, self.r)
    }
}
