fn sqrtf(f: float) -> float;
fn sqrt(f: double) -> double;

fn fabsf(f: float) -> float;
fn fabs(f: double) -> double;

fn fmaxf(f1: float, f2: float) -> float;
fn fmax(f1: double, f2: double) -> double;

fn fminf(f1: float, f2: float) -> float;
fn fmin(f1: double, f2: double) -> double;

fn sinf(f: float) -> float;
fn sin(f: double) -> double;

fn cosf(f: float) -> float;
fn cos(f: double) -> double;

fn u8_max() -> u8 {
    return cast(u8)-1
}

fn u16_max() -> u16 {
    return cast(u16)-1
}

fn u32_max() -> u32 {
    return cast(u32)-1
}

fn u64_max() -> u64 {
    return cast(u64)-1
}

struct LinearCongruentialGenerator {
    seed: u64
}

impl LinearCongruentialGenerator {
    fn create(seed: u64 = 0) -> Self {
        return new Self { seed }
    }

    fn next(ref Self) -> u32 {
        let M: u64 = cast(u64) u32_max()
        let A: u64 = 1664525
        let B: u64 = 1013904223
        seed = (A * seed + B) % M

        return cast(u32) seed
    }

    fn next_double(ref Self) -> double {
        return cast(double) self.next() / cast(double) u32_max()
    }

    fn next_int(ref Self, min: int = 0, max: int = cast u32_max()) -> int {
        return cast(int)next() % (max - min) + min
    }
}

struct Vector2(T: type) {
    x: T
    y: T
}

struct Vector3(T: type) {
    x: T
    y: T
    z: T
}

struct Vector4(T: type) {
    x: T
    y: T
    z: T
    w: T
}

impl Vector2($T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
        }

        return self
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
        }
    }

    fn dot(a: Self, b : Self) -> T {
        return a.x * b.x + a.y * b.y
    }

    fn eq(a: ref Self, b: ref Self) -> bool #operator("==") {
        return a.x == b.x and a.y == b.y
    }
}

impl Vector3($T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        z += other.z
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        z -= other.z
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        z *= other.z
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        z *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        z /= other.z
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
            z /= mag
        }

        return self
    }

    fn normalized(ref Self) -> Self {
        let mag = self.mag()
        if mag != 0 {
            return new {
                x / mag
                y / mag
                z / mag
            }
        } else {
            return new {0, 0, 0}
        }
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y + z*z))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y + z*z)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y, -z}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
            a.z + b.z
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
            a.z - b.z
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
            a.z * b.z
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
            a.z * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
            a.z / b.z
        }
    }

    fn dot(a: Self, b : Self) -> T {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }
}
