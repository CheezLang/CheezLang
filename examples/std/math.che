fn sqrtf(f: float) -> float;
fn sqrt(f: double) -> double;

fn fabsf(f: float) -> float;
fn fabs(f: double) -> double;

fn fmaxf(f1: float, f2: float) -> float;
fn fmax(f1: double, f2: double) -> double;

fn fminf(f1: float, f2: float) -> float;
fn fmin(f1: double, f2: double) -> double;

fn sinf(f: float) -> float;
fn sin(f: double) -> double;

fn cosf(f: float) -> float;
fn cos(f: double) -> double;

fn u8_max() -> u8 {
    return cast(u8)-1
}

fn u16_max() -> u16 {
    return cast(u16)-1
}

fn u32_max() -> u32 {
    return cast(u32)-1
}

fn u64_max() -> u64 {
    return cast(u64)-1
}

struct LinearCongruentialGenerator {
    seed: u64
}

impl LinearCongruentialGenerator {
    fn create(seed: u64 = 0) -> Self {
        return new Self { seed }
    }

    fn next(*Self) -> u32 {
        let M: u64 = cast(u64) u32_max()
        let A: u64 = 1664525
        let B: u64 = 1013904223
        seed = (A * seed + B) % M

        return cast(u32) seed
    }

    fn next_double(*Self) -> double {
        return cast(double) self.next() / cast(double) u32_max()
    }
}

struct Vector2(T: type) {
    x: T
    y: T
}

struct Vector3(T: type) {
    x: T
    y: T
    y: T
}

struct Vector4(T: type) {
    x: T
    y: T
    y: T
    w: T
}

impl Vector2($T) {
    // ref
    fn addv(*Self, other: Vector2(T)) -> *Vector2(T) #operator("+=") {
        x += other.x
        y += other.y
        return self
    }

    fn subv(*Self, other: Vector2(T)) -> *Vector2(T) #operator("-=") {
        x -= other.x
        y -= other.y
        return self
    }

    fn mulv(*Self, other: Vector2(T)) -> *Vector2(T) #operator("*=") {
        x *= other.x
        y *= other.y
        return self
    }

    fn muls(*Self, other: T) -> *Vector2(T) #operator("*=") {
        x *= other
        y *= other
        return self
    }

    fn divv(*Self, other: Vector2(T)) -> *Vector2(T) #operator("/=") {
        x /= other.x
        y /= other.y
        return self
    }

    fn normalize(*Self) -> *Vector2(T) {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
        }

        return self
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y}
    }

    // static
    fn addvv(a: Vector2(T), b: Vector2(T)) -> Vector2(T) #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
        }
    }

    fn subvv(a: Vector2(T), b: Vector2(T)) -> Vector2(T) #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
        }
    }

    fn mulvv(a: Vector2(T), b: Vector2(T)) -> Vector2(T) #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
        }
    }

    fn mulvs(a: Vector2(T), b: T) -> Vector2(T) #operator("*") {
        return new {
            a.x * b
            a.y * b
        }
    }

    fn divvv(a: Vector2(T), b: Vector2(T)) -> Vector2(T) #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
        }
    }

    fn dot(a: Vector2(T), b : Vector2(T)) -> T {
        return a.x * b.x + a.y * b.y
    }
}
