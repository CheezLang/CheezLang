#load("std:preload")

fn sqrtf(f: float) -> float;
fn sqrt(f: double) -> double;

fn abs(i: $T) -> T { return if i < 0 {-i} else {i} }
fn fabsf(f: float) -> float;
fn fabs(f: double) -> double;

fn max(a: $T, b: T) -> T { return if a >= b then a else b }
fn fmaxf(f1: float, f2: float) -> float;
fn fmax(f1: double, f2: double) -> double;

fn min(a: $T, b: T) -> T { return if a <= b then a else b }
fn fminf(f1: float, f2: float) -> float;
fn fmin(f1: double, f2: double) -> double;

fn sinf(f: float) -> float;
fn sin(f: double) -> double;
fn sinh(f: double) -> double;

fn cosf(f: float) -> float;
fn cos(f: double) -> double;
fn cosh(f: double) -> double;

fn tanf(f: float) -> float;
fn tan(f: double) -> double;

fn atan2(a: double, b: double) -> double;
fn pow(a: double, b: double) -> double;
fn exp(a: double) -> double;

fn logf(f: float) -> float;
fn log(f: double) -> double;

fn floorf(float) -> float;
fn floor(double) -> double;

fn ceilf(float) -> float;
fn ceil(double) -> double;

fn mod_pos(a: $T, b: T) -> T {
    return ((a % b) + b) % b
}

fn clamp(value: $T, min: T, max: T) -> T {
    if value < min { return min }
    if value > max { return max }
    return value
}

struct Vector2(T: type) #copy {
    pub x: T
    pub y: T
}

struct Vector3(T: type) #copy {
    pub x: T
    pub y: T
    pub z: T
}

struct Vector4(T: type) #copy {
    pub x: T
    pub y: T
    pub z: T
    pub w: T
}

impl(T: type) Vector2(T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
        }

        return self
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
        }
    }

    fn divvs(a: Self, b: T) -> Self #operator("/") {
        return new {
            a.x / b
            a.y / b
        }
    }

    fn dot(a: Self, b : Self) -> T {
        return a.x * b.x + a.y * b.y
    }

    fn eq(a: ref Self, b: ref Self) -> bool #operator("==") {
        return a.x == b.x and a.y == b.y
    }
}

impl(T: type) Vector3(T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        z += other.z
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        z -= other.z
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        z *= other.z
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        z *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        z /= other.z
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
            z /= mag
        }

        return self
    }

    fn normalized(Self) -> Self {
        let mag = self.mag()
        if mag != 0 {
            return new {
                x / mag
                y / mag
                z / mag
            }
        } else {
            return new {0, 0, 0}
        }
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y + z*z))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y + z*z)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y, -z}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
            a.z + b.z
        }
    }

    fn addvs(a: Self, b: T) -> Self #operator("+") {
        return new {
            a.x + b
            a.y + b
            a.z + b
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
            a.z - b.z
        }
    }

    fn subvs(a: Self, b: T) -> Self #operator("-") {
        return new {
            a.x - b
            a.y - b
            a.z - b
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
            a.z * b.z
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
            a.z * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
            a.z / b.z
        }
    }

    fn divvs(a: Self, b: T) -> Self #operator("/") {
        return new {
            a.x / b
            a.y / b
            a.z / b
        }
    }

    fn dot(a: Self, b: Self) -> T {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }

    fn cross(ref Self, other: Self) -> Self {
        return new {
            y * other.z - z * other.y
            z * other.x - x * other.z
            x * other.y - y * other.x
        }
    }

    fn reflect(ref Self, normal: Self) -> Self {
        return normal * -Self::dot(self, normal) * T(2) + <<&self
    }

    fn refract(ref Self, normal: Self, ior: T) -> Option(Self) {
        let uv = self
        let dt = Self::dot(uv, normal)
        let discriminant = 1.0 - ior * ior * (1 - dt * dt)
        if discriminant > 0 {
            let refr = (uv - normal * dt) * ior - normal * T(sqrt(discriminant))
            return Some(refr)
        } else {
            return None
        }
    }

    fn max_component(ref Self) -> T {
        return max(x, max(y, z))
    }

    fn clamped(ref Self, min: T, max: T) -> Self {
        return new {
            clamp(x, min, max)
            clamp(y, min, max)
            clamp(z, min, max)
        }
    }

    fn change_type(ref Self, $TargetType: type) -> Vector3(TargetType) {
        return new { TargetType(x), TargetType(y), TargetType(z) }
    }
}

struct Complex #copy {
    pub r: double
    pub i: double
}

impl Complex {
    fn real(r: double) -> Self {
        return new {r, 0}
    }

    fn imaginary(i: double) -> Self {
        return new {0, i}
    }

    fn from_polar(m: double, p: double) -> Self {
        return new { r = m * cos(p), i = m * sin(p) }
    }

    fn add(a: Complex, b: Complex) -> Self #operator("+") {
        return new {
            r = a.r + b.r
            i = a.i + b.i
        }
    }

    fn add2(a: Complex, b: double) -> Self #operator("+") {
        return new {
            r = a.r + b
            i = a.i
        }
    }

    fn sub(a: Complex, b: Complex) -> Self #operator("-") {
        return new {
            r = a.r - b.r
            i = a.i - b.i
        }
    }

    fn sub2(a: Complex, b: double) -> Self #operator("-") {
        return new {
            r = a.r - b
            i = a.i
        }
    }

    fn neg(a: Complex) -> Self #operator("-") {
        return new {
            r = -a.r
            i = -a.i
        }
    }

    fn conj(a: Complex) -> Self #operator("!") {
        return new {
            r = a.r
            i = -a.i
        }
    }

    fn mul(a: Complex, b: Complex) -> Self #operator("*") {
        return new {
            r = a.r * b.r - a.i * b.i
            i = a.r * b.i + a.i * b.r
        }
    }

    fn mul2(a: Complex, b: double) -> Self #operator("*") {
        return new {
            r = a.r * b
            i = a.i * b
        }
    }

    fn div(a: Complex, b: Complex) -> Self #operator("/") {
        let fac = 1 / (b.r * b.r + b.i * b.i)
        return new {
            r = fac * (a.r * b.r + a.i * b.i)
            i = fac * (a.r * b.i - a.i * b.r)
        }
    }

    fn div2(a: Complex, b: double) -> Self #operator("/") {
        return new {
            r = a.r / b
            i = a.i / b
        }
    }

    fn poww(a: Complex, e: double) -> Self {
        if a.r == 0 and a.i == 0 {
            return a
        }

        let r = sqrt(a.r * a.r + a.i * a.i)
        let p = atan2(a.i, a.r)

        r = pow(r, e)
        p = p * e

        return new {
            r * cos(p)
            r * sin(p)
        }
    }

    fn polar(Self) -> (m: double, p: double) {
        m = sqrt(self.r * self.r + self.i * self.i)
        p = atan2(self.i, self.r)
    }
}
