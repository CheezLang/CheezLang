fn sqrtf(f: f32) -> f32;
fn sqrt(f: f64) -> f64;

fn fabsf(f: f32) -> f32;
fn fabs(f: f64) -> f64;

fn fmaxf(f1: f32, f2: f32) -> f32;
fn fmax(f1: f64, f2: f64) -> f64;

fn fminf(f1: f32, f2: f32) -> f32;
fn fmin(f1: f64, f2: f64) -> f64;

fn sinf(f: f32) -> f32;
fn sin(f: f64) -> f64;

fn cosf(f: f32) -> f32;
fn cos(f: f64) -> f64;

fn u8_max() -> u8 {
    return cast(u8)-1
}

fn u16_max() -> u16 {
    return cast(u16)-1
}

fn u32_max() -> u32 {
    return cast(u32)-1
}

fn u64_max() -> u64 {
    return cast(u64)-1
}

struct LinearCongruentialGenerator {
    seed: u64
}

impl LinearCongruentialGenerator {
    ref fn next() -> u32 {
        let M: u64 = cast(u64) u32_max()
        let A: u64 = 1664525
        let B: u64 = 1013904223
        seed = (A * seed + B) % M

        return cast(u32) seed
    }

    ref fn nextDouble() -> f64 {
        return cast(f64) self.next() / cast(f64) u32_max()
    }
}

struct Vec3 {
    x: f64
    y: f64
    z: f64
}

impl Vec3 {
    fn mul(f: f64) -> Vec3 {
        return new Vec3 { x * f, y * f, z * f }
    }

    fn mul3(v: Vec3) -> Vec3 {
        return new Vec3 { x * v.x, y * v.y, z * v.z }
    }

    fn add(v: Vec3) -> Vec3 {
        return new Vec3 { x + v.x, y + v.y, z + v.z }
    }

    fn sub(v: Vec3) -> Vec3 {
        return new Vec3 { x - v.x, y - v.y, z - v.z }
    }

    fn mag() -> f64 {
        let sum = x * x + y * y + z * z
        return sqrt(sum)
    }

    fn normaziled() -> Vec3 {
        let m = self.mag()
        return self.mul(1 / m)
    }
    
    fn dot(v: Vec3) -> f64 {
        return x * v.x + y * v.y + z * v.z
    }
}
