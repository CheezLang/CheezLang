fn sqrtf(f: float) -> float;
fn sqrt(f: double) -> double;

fn abs(i: $T) -> T { return if i < 0 {-i} else {i} }
fn fabsf(f: float) -> float;
fn fabs(f: double) -> double;

fn fmaxf(f1: float, f2: float) -> float;
fn fmax(f1: double, f2: double) -> double;

fn fminf(f1: float, f2: float) -> float;
fn fmin(f1: double, f2: double) -> double;

fn sinf(f: float) -> float;
fn sin(f: double) -> double;

fn cosf(f: float) -> float;
fn cos(f: double) -> double;

fn tanf(f: float) -> float;
fn tan(f: double) -> double;

fn logf(f: float) -> float;
fn log(f: double) -> double;

fn floorf(float) -> float;
fn floor(double) -> double;

fn ceilf(float) -> float;
fn ceil(double) -> double;

fn u8_max() -> u8 {
    return cast(u8)-1
}

fn u16_max() -> u16 {
    return cast(u16)-1
}

fn u32_max() -> u32 {
    return cast(u32)-1
}

fn u64_max() -> u64 {
    return cast(u64)-1
}

fn i64_max() -> i64 {
    return @bin_lsr(0xFFFFFFFFFFFFFFFF, 1)
}

fn mod_pos(a: $T, b: T) -> T {
    return ((a % b) + b) % b
}

fn clamp(value: $T, min: T, max: T) -> T {
    if value < min { return min }
    if value > max { return max }
    return value
}

struct Vector2(T: type) {
    pub x: T
    pub y: T
}

struct Vector3(T: type) {
    pub x: T
    pub y: T
    pub z: T
}

struct Vector4(T: type) {
    pub x: T
    pub y: T
    pub z: T
    pub w: T
}

impl(T: type) Vector2(T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
        }

        return self
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
        }
    }

    fn divvs(a: Self, b: T) -> Self #operator("/") {
        return new {
            a.x / b
            a.y / b
        }
    }

    fn dot(a: Self, b : Self) -> T {
        return a.x * b.x + a.y * b.y
    }

    fn eq(a: ref Self, b: ref Self) -> bool #operator("==") {
        return a.x == b.x and a.y == b.y
    }
}

impl(T: type) Vector3(T) {
    // ref
    fn addv(ref Self, other: Self) -> ref Self #operator("+=") {
        x += other.x
        y += other.y
        z += other.z
        return self
    }

    fn subv(ref Self, other: Self) -> ref Self #operator("-=") {
        x -= other.x
        y -= other.y
        z -= other.z
        return self
    }

    fn mulv(ref Self, other: Self) -> ref Self #operator("*=") {
        x *= other.x
        y *= other.y
        z *= other.z
        return self
    }

    fn muls(ref Self, other: T) -> ref Self #operator("*=") {
        x *= other
        y *= other
        z *= other
        return self
    }

    fn divv(ref Self, other: Self) -> ref Self #operator("/=") {
        x /= other.x
        y /= other.y
        z /= other.z
        return self
    }

    fn normalize(ref Self) -> ref Self {
        let mag = self.mag()
        if mag != 0 {
            x /= mag
            y /= mag
            z /= mag
        }

        return self
    }

    fn normalized(ref Self) -> Self {
        let mag = self.mag()
        if mag != 0 {
            return new {
                x / mag
                y / mag
                z / mag
            }
        } else {
            return new {0, 0, 0}
        }
    }

    fn mag(Self) -> T {
        return cast(T) sqrt(cast(double) (x*x + y*y + z*z))
    }

    fn magsq(Self) -> T {
        return cast(T) (x*x + y*y + z*z)
    }

    fn neg(Self) -> Self #operator("-") {
        return new {-x, -y, -z}
    }

    // static
    fn addvv(a: Self, b: Self) -> Self #operator("+") {
        return new {
            a.x + b.x
            a.y + b.y
            a.z + b.z
        }
    }

    fn subvv(a: Self, b: Self) -> Self #operator("-") {
        return new {
            a.x - b.x
            a.y - b.y
            a.z - b.z
        }
    }

    fn mulvv(a: Self, b: Self) -> Self #operator("*") {
        return new {
            a.x * b.x
            a.y * b.y
            a.z * b.z
        }
    }

    fn mulvs(a: Self, b: T) -> Self #operator("*") {
        return new {
            a.x * b
            a.y * b
            a.z * b
        }
    }

    fn divvv(a: Self, b: Self) -> Self #operator("/") {
        return new {
            a.x / b.x
            a.y / b.y
            a.z / b.z
        }
    }

    fn divvs(a: Self, b: T) -> Self #operator("/") {
        return new {
            a.x / b
            a.y / b
            a.z / b
        }
    }

    fn dot(a: Self, b: Self) -> T {
        return a.x * b.x + a.y * b.y + a.z * b.z
    }

    fn cross(ref Self, other: Self) -> Self {
        return new {
            y * other.z - z * other.y
            z * other.x - x * other.z
            x * other.y - y * other.x
        }
    }

    fn reflect(ref Self, normal: Self) -> Self {
        return normal * -Self::dot(self, normal) * T(2) + <<&self
    }

    fn max_component(ref Self) -> T {
        return fmax(x, fmax(y, z))
    }

    fn clamped(ref Self, min: T, max: T) -> Self {
        return new {
            clamp(x, min, max)
            clamp(y, min, max)
            clamp(z, min, max)
        }
    }

    fn change_type(ref Self, $TargetType: type) -> Vector3(TargetType) {
        return new { TargetType(x), TargetType(y), TargetType(z) }
    }
}
