use import std.array
use import std.string
use import std.box
use import std.math

C   :: import std.c
io  :: import std.io
fmt :: import std.fmt

#export_scope

Printable :: trait {
    print :: (ref Self, str: ref String, format: string);
}

impl Printable for () {
    print :: (ref Self, str: ref String, format: string) {
        str += "()"
    }
}

impl Printable for string {
    print :: (ref Self, str: ref String, format: string) {
        str.append_string(self)
    }
}

impl Printable for char8 {
    print :: (ref Self, str: ref String, format: string) {
        str.append_char(cast self)
    }
}

impl Printable for char16 {
    print :: (ref Self, str: ref String, format: string) {
        str.append_char(cast self)
    }
}

impl Printable for char32 {
    print :: (ref Self, str: ref String, format: string) {
        str.append_char(self)
    }
}

impl Printable for float {
    print :: (ref Self, str: ref String, format: string) {
        buff : []char8 = @alloca(char8, 128)
        buff.length = C.sprintf(buff.data, "%g", double(self))
        str.append_cstring(buff.data)
    }
}

impl Printable for double {
    print :: (ref Self, str: ref String, format: string) {
        buff : []char8 = @alloca(char8, 128)
        buff.length = C.sprintf(buff.data, "%g", self)
        str.append_cstring(buff.data)
    }
}

impl Printable for bool {
    print :: (ref Self, str: ref String, format: string) {
        str.append_string(if streq(format, "b") {
            if self {"1"} else {"0"}
        } else if streq(format, "s") {
            if self {"t"} else {"f"}
        } else {
            if self {"true"} else {"false"}
        })
    }
}

impl Printable for i8 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for i16 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for i32 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for i64 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for u8 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for u16 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for u32 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl Printable for u64 {
    print :: (ref Self, str: ref String, format: string) {
        printf_int_to_string(str, self, format)
    }
}

impl(T: type) Printable for Option[T] if T: Printable {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            Some($v) -> {
                v_str := fmt.format("Some({})", [&v])
                str.append(v_str)
            }
            None -> str.append_string("None")
        }
    }
}

impl(T: type) Printable for Box[T] {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format("Box({})", [_value])
        str.append(msg)
    }
}

impl(V: type, E: type) Printable for Result[V, E] if V: Printable, E: Printable {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            Ok($v)  -> str.appendf("Ok({})", fmt.format_any(v))
            Err($v) -> str.appendf("Err({})", fmt.format_any(v))
        }
    }
}

impl Printable for Complex {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} + {}i", (r, i))
    }
}

impl Printable for TypeInfo {
    print :: (ref Self, str: ref String, format: string) {
        use TypeInfoKind
        match kind {
            Int($ti) -> str.appendf("{}{}", (if ti.signed then "i" else "u", size * 8))
            Float    -> str.appendf("f{}", size * 8)
            $_       -> {}
        }
    }
}

#file_scope
printf_int_to_string :: (str: ref String, i: $T, format: string) {
    base := if streq("b", format) then 2
    else if streq("x", format) then 16
    else 10
    fmt.format_int(str, i, base)
}
