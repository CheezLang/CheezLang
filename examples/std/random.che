#load("std:math")
#load("std:iterator")
#load("std:util")
#load("std:hash_table")

impl PseudoRandomGen for LinearCongruentialGenerator {
    fn next_u32(ref Self) -> u32 {
        return self.next()
    }

    fn next_double(ref Self) -> double {
        let r = double(self.next())
        let m = double(u32_max())
        return r / m
    }
}

let lcg: LinearCongruentialGenerator = {
    let a = LinearCongruentialGenerator::create(cast get_time_microseconds())
    loop! _ in 0 -> 1000 { a.next() }
    a
}

trait PseudoRandomGen {
    fn next_u32(ref Self) -> u32;
    fn next_double(ref Self) -> double;
}

struct PseudoRandom {}

impl PseudoRandom {
    fn next_int() -> i32 {
        return cast lcg.next()
    }

    fn next_double() -> double {
        return lcg.next_double()
    }
}

// distributions
trait IDistribution(T: type) {
    fn sample(ref Self) -> T;
}

trait IDiscreteDistribution(T: type) {
    fn get_weight(ref Self, t: T) -> int;
    // fn support(ref Self) -> T;
}

// iterator
struct DistributionIterator(T: type) {
    dist: IDistribution(T)
}

impl Iterator($T) for DistributionIterator(T) {
    fn next(ref Self) -> Option(T) {
        return Some(dist.sample())
    }

    fn dispose(ref Self) {
        free(&self)
    }
}

impl IDistribution($T) {
    fn samples(ref Self) -> Iterator(T) {
        let it = alloc(DistributionIterator(T))
        <<it = new {self}
        return <<it
    }
}

// Standard Continuous Uniform distribution
struct StandardContinuousUniform(T: type) {
    prng: &T
}
impl IDistribution(double) for StandardContinuousUniform($T) {
    fn sample(ref Self) -> double {
        return prng.next_double()
    }
}

// normal distribution
struct NormalDistribution {
    mean    : double
    sigma   : double
    scu     : StandardContinuousUniform(LinearCongruentialGenerator)
}

impl NormalDistribution {
    fn create(mean: double, sigma: double) -> Self {
        return new{mean, sigma, new StandardContinuousUniform(LinearCongruentialGenerator) {&lcg}}
    }
}

impl IDistribution(double) for NormalDistribution {
    fn sample(ref Self) -> double {
        let a = scu.sample()
        let b = scu.sample()
        return mean + sigma * (
            sqrt(-2.0 * log(a)) * cos(2.0 * 3.1415 * b)
        )
    }
}

// standard discrete uniform distribution
struct StandardDiscreteUniform {
    min: int
    max: int
}
impl IDiscreteDistribution(int) for StandardDiscreteUniform {
    fn get_weight(ref Self, i: int) -> int {
        return if i >= min and i <= max {1} else {0}
    }
}
impl IDistribution(int) for StandardDiscreteUniform {
    fn sample(ref Self) -> int {
        let d = PseudoRandom::next_double()
        let mi = cast(double)min
        let ma = cast(double)max
        return cast(int) d * (1.0 + ma - mi) + mi
    }
}

// singleton distribution
struct SingletonDistribution(T: type) {
    value: T
}

impl IDistribution(int) for SingletonDistribution(int) {
    fn sample(ref Self) -> int {
        return value
    }
}

// bernoulli
struct BernoulliDistribution {
    zero: int
    one : int
}

impl IDistribution(int) for BernoulliDistribution {
    fn sample(ref Self) -> int {
        let z = cast(double)zero
        let o = cast(double)one
        let d = PseudoRandom::next_double()
        return if d <= (z / (z + o)) {0} else {1}
    }
}

impl BernoulliDistribution {
    fn create(zero: int, one: int) -> Self {
        @assert(zero >= 0 and one >= 0 and (zero != 0 or one != 0))
        return new BernoulliDistribution{zero, one}
    }
}

// histograms
fn print_histogram(dist: IDistribution($T), low: double, high: double){
    let const width : int = 160
    let const height: int = 30
    let const samples   : int = 1000000
    let it = dist::samples()::take(samples)

    let buckets = alloc_n(int, cast width)
    c_memset(buckets.data, 0, cast width * @sizeof(int))

    while match it.next() {
        Some($c) -> {
            let bucket = cast(int) floor((cast(double)buckets.length) * ((cast(double)c) - low) / (high - low))
            if bucket >= 0 and bucket < buckets.length {
                buckets[bucket] += 1
            }
            true
        }
        $_ -> false
    } {}

    let max = 0
    while let i = 0; i < buckets.length; i += 1 {
        if buckets[i] > max {
            max = buckets[i]
        }
    }

    let scale = if max < height {1.0} else {(cast(double)height) / (cast(double)max)}


    // top line
    let max_str = String::empty()
    max_str.appendf("{}  ", [max])
    print(max_str)
    while let i = 0; i < width - max_str.length; i += 1 {
        print("-")
    }
    println("")

    // histogram
    while let h = 0; h < height; h += 1 {

        while let w = 0; w < width; w += 1 {
            let b = cast(double)buckets[w]
            if b * scale >= cast(double)height - h {
                print("*")
            } else {
                print(" ")
            }
        }
        println("")
    }


    // bottom line
    let left_str = String::empty()
    left_str.appendf("{}  ", [low])
    let right_str = String::empty()
    right_str.appendf("  {}", [high])
    let mid_str = String::empty()
    mid_str.appendf("  {}  ", [0.5 * (low + high)])
    let p1 = width / 2
    let p2 = width - p1

    print(left_str)
    while let i = 0; i < p1 - left_str.length - mid_str.length / 2; i += 1 {
        print("-")
    }
    print(mid_str)
    while let i = 0; i < p2 - right_str.length - (mid_str.length - mid_str.length / 2); i += 1 {
        print("-")
    }
    print(right_str)
    println("")

    max_str.free()
    left_str.free()
    mid_str.free()
    right_str.free()
    free_n(buckets)
    it.dispose()
}

fn print_discrete_histogram(dist: IDistribution($T)){
    let const width : int = 40
    let const samples   : int = 100000
    let it = dist::samples()::take(samples)

    let map = Table(int, int)::create(|a: int, b: int| a == b)

    while match it.next() {
        Some($c) -> {
            match map.get(c) {
                Some($v) -> {
                    map[c] = v + 1
                }
                None -> {
                    map[c] = 1
                }
            }
            true
        }
        $_ -> false
    } {}

    let cmp: fn(ref(int, int), ref(int, int)) -> int = |a, b| b[0] - a[0]
    let arr = map.iterator()::to_array().sort(cmp)

    let max = map.iterator()::map(|t: (int, int)| t[1])::max()
    let scale = if max < width {1.0} else {(cast(double)width)/(cast(double)max)}
    while let i = 0; i < arr.length; i += 1 {
        printf("{}|", [arr[i][0]])
        let count = cast(int) (cast(double) arr[i][1]) * scale
        while let c = 0; c < count; c += 1 {
            print("*")
        }

        println("")
    }

    arr.dispose()
}
