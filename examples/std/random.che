#load("std:math")
#load("std:iterator")
#load("std:time")
#load("std:hash_table")

struct LinearCongruentialGenerator {
    seed: u64
}

impl LinearCongruentialGenerator {
    fn create(seed: u64 = 0) -> Self {
        return Self(seed)
    }

    fn next(ref Self) -> u32 {
        let M: u64 = cast(u64) u32.max
        let A: u64 = 1664525
        let B: u64 = 1013904223
        seed = (A * seed + B) % M

        return cast(u32) seed
    }

    fn next_int(ref Self, min: int = 0, max: int = cast u32.max) -> int {
        return (cast(int)next()) % (max - min) + min
    }
}

impl PseudoRandomGen for LinearCongruentialGenerator {
    fn next_u32(ref Self) -> u32 {
        return self.next()
    }

    fn next_double(ref Self) -> double {
        let r = double(self.next())
        let m = double(u32.max)
        return r / m
    }
}

let lcg: LinearCongruentialGenerator = {
    let a = LinearCongruentialGenerator::create(cast get_time_microseconds())
    for : 1000 { a.next() }
    a
}

trait PseudoRandomGen {
    fn next_u32(ref Self) -> u32;
    fn next_double(ref Self) -> double;
}

struct PseudoRandom {}

impl PseudoRandom {
    fn next_int() -> i32 {
        return cast lcg.next()
    }

    fn next_double() -> double {
        return lcg.next_double()
    }
}

// distributions
trait IDistribution(T: type) {
    fn sample(ref Self) -> T;
}

trait IDiscreteDistribution(T: type) {
    fn get_weight(ref Self, t: T) -> int;
    // fn support(ref Self) -> T;
}

// iterator
struct DistributionIterator(T: type) {
    dist: IDistribution[T]
}

impl(T: type) Iterator[T] for DistributionIterator[T] {
    fn next(ref Self) -> Option[T] {
        return Some(dist.sample())
    }

    fn dispose(ref Self) {
        free(&self)
    }
}

fn for_extension_random(dist: IDistribution[$T], code: Code) #for {
    while let it_index = 0, true, it_index += 1 {
        let it = dist.sample()
        @insert(code)
    }
}

// i
impl(T: type) IDistribution[T] {
    fn samples(ref Self) -> Iterator[T] {
        let it = alloc(DistributionIterator[T])
        <<it = new {self}
        return <<it
    }
}

// Standard Continuous Uniform distribution
struct StandardContinuousUniform(T: type) {
    prng: &T
}
impl(T: type) IDistribution[double] for StandardContinuousUniform[T] if T : PseudoRandomGen {
    fn sample(ref Self) -> double {
        return prng.next_double()
    }
}

impl(T: type) StandardContinuousUniform[T] if T : PseudoRandomGen {
    fn create(prng: &T) -> Self {
        return new {prng}
    }
}

// normal distribution
struct NormalDistribution {
    mean    : double
    sigma   : double
    scu     : StandardContinuousUniform[LinearCongruentialGenerator]
}

impl NormalDistribution {
    fn create(mean: double, sigma: double) -> Self {
        return new{mean, sigma, StandardContinuousUniform[LinearCongruentialGenerator](&lcg)}
    }
}

impl IDistribution[double] for NormalDistribution {
    fn sample(ref Self) -> double {
        let a = scu.sample()
        let b = scu.sample()
        return mean + sigma * (
            sqrt(-2.0 * log(a)) * cos(2.0 * 3.1415 * b)
        )
    }
}

// standard discrete uniform distribution
struct StandardDiscreteUniform {
    min: int
    max: int
}
impl IDiscreteDistribution[int] for StandardDiscreteUniform {
    fn get_weight(ref Self, i: int) -> int {
        return if i >= min and i <= max {1} else {0}
    }
}
impl IDistribution[int] for StandardDiscreteUniform {
    fn sample(ref Self) -> int {
        let d = PseudoRandom::next_double()
        let mi = cast(double)min
        let ma = cast(double)max
        return cast(int) d * (1.0 + ma - mi) + mi
    }
}

// singleton distribution
struct SingletonDistribution(T: type) {
    value: T
}

impl IDistribution[int] for SingletonDistribution[int] {
    fn sample(ref Self) -> int {
        return value
    }
}

// bernoulli
struct BernoulliDistribution {
    zero: int
    one : int
}

impl IDistribution[int] for BernoulliDistribution {
    fn sample(ref Self) -> int {
        let z = cast(double)zero
        let o = cast(double)one
        let d = PseudoRandom::next_double()
        return if d <= (z / (z + o)) {0} else {1}
    }
}

impl BernoulliDistribution {
    fn create(zero: int, one: int) -> Self {
        @assert(zero >= 0 and one >= 0 and (zero != 0 or one != 0))
        return BernoulliDistribution(zero, one)
    }
}

// histograms
fn print_histogram(dist: IDistribution[$T], low: double, high: double){
    let const width : int = 160
    let const height: int = 30
    let const samples   : int = 1000000
    let it = dist::samples()::take(samples)

    let buckets = alloc_n(int, cast width)
    c_memset(buckets.data, 0, cast width * @sizeof(int))

    while match it.next() {
        Some($c) -> {
            let bucket = cast(int) floor((cast(double)buckets.length) * ((cast(double)c) - low) / (high - low))
            if bucket >= 0 and bucket < buckets.length {
                buckets[bucket] += 1
            }
            true
        }
        $_ -> false
    } {}

    let max = 0
    while let i = 0, i < buckets.length, i += 1 {
        if buckets[i] > max {
            max = buckets[i]
        }
    }

    let scale = if max < height {1.0} else {(cast(double)height) / (cast(double)max)}


    // top line
    let max_str = String::empty()
    max_str.appendf("{}  ", max)
    print(max_str)
    while let i = 0, i < width - max_str.length, i += 1 {
        print("-")
    }
    println("")

    // histogram
    while let h = 0, h < height, h += 1 {

        while let w = 0, w < width, w += 1 {
            let b = cast(double)buckets[w]
            if b * scale >= cast(double)height - h {
                print("*")
            } else {
                print(" ")
            }
        }
        println("")
    }


    // bottom line
    let left_str = String::empty()
    left_str.appendf("{}  ", low)
    let right_str = String::empty()
    right_str.appendf("  {}", high)
    let mid_str = String::empty()
    mid_str.appendf("  {}  ", 0.5 * (low + high))
    let p1 = width / 2
    let p2 = width - p1

    print(left_str)
    while let i = 0, i < p1 - left_str.length - mid_str.length / 2, i += 1 {
        print("-")
    }
    print(mid_str)
    while let i = 0, i < p2 - right_str.length - (mid_str.length - mid_str.length / 2), i += 1 {
        print("-")
    }
    print(right_str)
    println("")

    max_str.dispose()
    left_str.dispose()
    mid_str.dispose()
    right_str.dispose()
    free_n(buckets)
    it.dispose()
}

fn print_discrete_histogram(dist: IDistribution[$T]){
    let const width : int = 40
    let const samples   : int = 100000
    let it = dist::samples()::take(samples)

    let map = Table(int, int)::create(|a: int, b: int| a == b)

    while match it.next() {
        Some($c) -> {
            match map.get(c) {
                Some($v) -> {
                    map[c] = v + 1
                }
                None -> {
                    map[c] = 1
                }
            }
            true
        }
        $_ -> false
    } {}

    let cmp: fn(ref(int, int), ref(int, int)) -> int = |a, b| b[0] - a[0]
    let arr = map.iterator()::to_array().sort(cmp)

    let max = map.iterator()::map(|t: (int, int)| t[1])::max()
    let scale = if max < width {1.0} else {(cast(double)width)/(cast(double)max)}
    while let i = 0, i < arr.length, i += 1 {
        printf("{}|", arr[i][0])
        let count = cast(int) (cast(double) arr[i][1]) * scale
        while let c = 0, c < count, c += 1 {
            print("*")
        }

        println("")
    }

    arr.dispose()
}
