fn malloc(size: int) -> void&;
fn realloc(mem: void&, size: int) -> void&;
fn free(mem: void&);

fn memcpy(dest: void&, src: void&, size: int);

fn Malloc(count: uint) -> $T& {
    return (T&)malloc((int)count * @sizeof(T))
}

fn Realloc(mem: $T&, count: uint) -> T& {
    return (T&)realloc((void&)mem, (int)count * @sizeof(T))
}

fn Free(mem: $T&) {
    free((void&)mem)
}

fn AllocateArray(count: uint) -> $T[] {
    return (T[])malloc((int)count * @sizeof(T))
}

fn ReallocArray(arr: $T[], count: uint) -> T[] {
    return (T[])realloc((void&)arr, (int)count * @sizeof(T))
}

fn FreeArray(arr: $T[]) {
    free((void&)arr)
}

fn ClearMemory(mem: byte&, len: uint) {
    let i: @typeof(len) = 0
    while i < len {
        mem[i] = 0
        i = i + 1
    }
}

struct Slice(T: type) {
    data: T&
    length: int
}
