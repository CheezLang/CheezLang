impl(It: type, T: type) It if It : Iterator(T) {
    fn max(ref It) -> T {}
}

impl(T: type) T {
    fn print(ref Self) {
        println(self)
    }
}

struct ArrayIterator(T: type) {}
impl(T: type) ArrayIterator(T) {}
impl(T: type) Iterator(T) for ArrayIterator(T) {}

let a = new ArrayIterator(int){}

impl(It = ArrayIterator(int), T = int) T if (ArrayIterator(int) impl Iterator(int)) {
    fn max(ref ArrayIterator(int)) -> int {}
}

impl(T: type) ArrayIterator(int) if ArrayIterator(int) : Iterator(T) {}

a.max()
ArrayIterator(int)
1. ArrayIterator(int) impl ArrayIterator(T)
    -> yes, T = int
    -> no, missing max()
2. ArrayIterator(int) impl Iterator(T) for ArrayIterator(T) 
    -> yes, T = int
    -> no, missing max()
3. ArrayIterator(int) impl It if (It : Iterator(T))
    -> yes, It = ArrayIterator(int)
    -> impl Iterator(T) for ArrayIterator(int)
        -> ArrayIterator(int) impl Iterator(T) for ArrayIterator(T)
        -> yes, T = int
    -> yes, found max()
