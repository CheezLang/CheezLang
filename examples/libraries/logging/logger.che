use import std.string
use import std.thread
use import std.rc

fmt :: import std.fmt
io  :: import std.io
fs  :: import std.io.fs

CONSOLE_LOGGER : ConsoleLogger = ConsoleLogger()

#export_scope

g_logger : &Logger = &CONSOLE_LOGGER

Logger :: trait {
    log :: (ref Self, format: string, args: []&any = [], prefix: string = "");
}

impl Logger {
    set_global_logger :: (logger: &Logger) {
        g_logger = logger
    }
}

ConsoleLogger :: struct {}

impl Logger for ConsoleLogger {
    log :: (ref Self, format: string, args: []&any = [], prefix: string = "") {
        msg := fmt.format(format, args)
        io.formatln("[{}] {}", [prefix, msg])
    }
}

FileLogger :: struct {
    log_file : String
    mutex    : Mutex
}

impl FileLogger {
    new :: (log_file: string) -> Rc[Logger] {
        logger := Rc[FileLogger].new(FileLogger(
            log_file = log_file.to_owned()
            mutex    = Mutex.new()
        ))
        logger.get().clear()
        return logger.change_type(Logger)
    }

    clear :: (ref Self) {
        mutex.lock()
        fs.write_file(log_file.slice(), "")
        mutex.release()
    }

    log_error :: (ref Self, format: string, args: []&any = []) {
        self.log(format, args, "[ERROR]")
    }
}

impl Logger for FileLogger {
    log :: (ref Self, format: string, args: []&any = [], prefix: string = "") {
        msg := fmt.format(format, args)
        str := fmt.format("[{}] {} {}`n", [Thread.current().id, prefix, msg])
        
        mutex.lock()
        fs.append_file(log_file.slice(), str.slice())
        mutex.release()
    }
}