// #lib("./lib/LLVM-C.lib")
// #lib("./lib/LTO.lib")
// #lib("./lib/Remarks.lib")
#lib("./lib/libclang.lib")
// #lib("./lib/libiomp5md.lib")
// #lib("./lib/liblldb.lib")
// #lib("./lib/libomp.lib")
#lib("./lib/CheezCBindingGenerator.lib")

#export_scope

CXIndex             :: ^void
CXTranslationUnit   :: ^void
CXClientData        :: ^void
CXFile              :: ^void
CXCursorVisitor     :: fn(^CXCursor, ^CXCursor, CXClientData) -> CXChildVisitResult

// functions
clang_getTranslationUnitCursor      :: (cursor: ^CXCursor, unit: CXTranslationUnit);
clang_createIndex                   :: (excludeDeclarationsFromPCH: i32, displayDiagnostics: i32) -> CXIndex;
clang_disposeIndex                  :: (index: CXIndex);
clang_parseTranslationUnit          :: (
    CIdx                  : CXIndex,
    source_filename       : c_string,
    command_line_args     : c_string,
    num_command_line_args : i32,
    unsaved_files         : ^CXUnsavedFile,
    num_unsaved_files     : u32,
    options               : u32) -> CXTranslationUnit;
clang_disposeTranslationUnit        :: (unit: CXTranslationUnit);
clang_visitChildrenHelper           :: (cursor: ^CXCursor, visitor: CXCursorVisitor, client_data: CXClientData) -> u32;

clang_getCursorKindHelper           :: (cursor: ^CXCursor) -> CXCursorKind;
clang_getCursorSpellingHelper       :: (ret: ^CXString, cursor: ^CXCursor);
clang_getCursorSpelling             :: (cursor: ^CXCursor) -> CXString { gen_binding(cursor) }
clang_getCursorKindSpellingHelper   :: (ret: ^CXString, kind: CXCursorKind);
clang_getCursorKindSpelling         :: (kind: CXCursorKind) -> CXString { gen_binding(kind) }
clang_getCursorTypeHelper           :: (ret: ^CXType, cursor: ^CXCursor);
clang_getCursorType                 :: (cursor: ^CXCursor) -> CXType { gen_binding(cursor) }

clang_getCStringHelper              :: (str: ^CXString) -> c_string;
clang_disposeStringHelper           :: (str: ^CXString);

// type functions
clang_getTypeSpellingHelper         :: (ret: ^CXString, typ: ^CXType);
clang_getTypeSpelling               :: (typ: CXType) -> CXString { gen_binding(^typ) }
clang_getTypeKindSpellingHelper     :: (ret: ^CXString, kind: CXTypeKind);
clang_getTypeKindSpelling           :: (kind: CXTypeKind) -> CXString { gen_binding(kind) }

clang_Type_getSizeOfHelper          :: (typ: ^CXType) -> int;
clang_Type_getSizeOf                :: (typ: CXType) -> int { gen_binding2(^typ) }
clang_getArraySizeHelper            :: (typ: ^CXType) -> int;
clang_getArraySize                  :: (typ: CXType) -> int { gen_binding2(^typ) }

clang_getResultTypeHelper           :: (ret: ^CXType, typ: ^CXType);
clang_getResultType                 :: (typ: CXType) -> CXType { gen_binding(^typ) }
clang_getPointeeTypeHelper          :: (ret: ^CXType, typ: ^CXType);
clang_getPointeeType                :: (typ: CXType) -> CXType { gen_binding(^typ) }
clang_getArrayElementTypeHelper     :: (ret: ^CXType, typ: ^CXType);
clang_getArrayElementType           :: (typ: CXType) -> CXType { gen_binding(^typ) }
clang_Type_getNamedTypeHelper       :: (ret: ^CXType, typ: ^CXType);
clang_Type_getNamedType             :: (typ: CXType) -> CXType { gen_binding(^typ) }
clang_getTypeDeclarationHelper      :: (ret: ^CXCursor, typ: ^CXType);
clang_getTypeDeclaration            :: (typ: CXType) -> CXCursor { gen_binding(^typ) }
clang_getTypedefDeclUnderlyingTypeHelper :: (ret: ^CXType, cursor: ^CXCursor);
clang_getTypedefDeclUnderlyingType       :: (cursor: CXCursor) -> CXType { gen_binding(^cursor) }
clang_getEnumDeclIntegerTypeHelper  :: (ret: ^CXType, cursor: ^CXCursor);
clang_getEnumDeclIntegerType        :: (cursor: CXCursor) -> CXType { gen_binding(^cursor) }
clang_getArgTypeHelper              :: (ret: ^CXType, T: ^CXType, index: u32);
clang_getArgType                    :: (T: CXType, index: u32) -> CXType {
    res : CXType = default
    clang_getArgTypeHelper(^res, ^T, index)
    return res
}

clang_getEnumConstantDeclValueHelper         :: (T: ^CXCursor) -> i64;
clang_getEnumConstantDeclValue               :: (T: CXCursor) -> i64 { gen_binding2(^T) }
clang_getEnumConstantDeclUnsignedValueHelper :: (T: ^CXCursor) -> u64;
clang_getEnumConstantDeclUnsignedValue       :: (T: CXCursor) -> u64 { gen_binding2(^T) }

clang_getCursorLocationHelper       :: (ret: ^CXSourceLocation, cursor: ^CXCursor);
clang_getCursorLocation             :: (cursor: CXCursor) -> CXSourceLocation { gen_binding(^cursor) }
clang_Location_isFromMainFileHelper :: (T: ^CXSourceLocation) -> i32;
clang_Location_isFromMainFile       :: (T: CXSourceLocation) -> i32 { gen_binding2(^T) }
clang_getFileLocationHelper         :: (location: ^CXSourceLocation, file: ^CXFile, line: ^u32, column: ^u32, offset: ^u32);
clang_getFileLocation               :: (location: CXSourceLocation) -> (file: CXFile, line: int, column: int, offset: int) {
    file   : CXFile = default
    line   : u32    = default
    column : u32    = default
    offset : u32    = default
    clang_getFileLocationHelper(^location, ^file, ^line, ^column, ^offset)
    return file, int(line), int(column), int(offset)
}


clang_Cursor_isExternalSymbol_result :: struct {
    language     : CXString = default
    defined_in   : CXString = default
    is_generated : u32      = default
}
clang_Cursor_isExternalSymbolHelper :: (C: ^CXCursor, language: ^CXString, defined_in: ^CXString, is_generated: ^u32) -> u32;
clang_Cursor_isExternalSymbol       :: (C: CXCursor) -> Option[clang_Cursor_isExternalSymbol_result] {
    result : clang_Cursor_isExternalSymbol_result = default
    if clang_Cursor_isExternalSymbolHelper(^C, ^result.language, ^result.defined_in, ^result.is_generated) != 0 {
        return Some(result)
    } else {
        return None
    }
}

clang_getFileNameHelper             :: (ret: ^CXString, cursor: CXFile);
clang_getFileName                   :: (cursor: CXFile) -> CXString { gen_binding(cursor) }

// binding helpers
gen_binding :: (param: Code) #macro {
    res : @function_type().return_type = default
    @id(@function_name() + "Helper")(^res, @insert(param))
    return res
}

gen_binding2 :: (param: Code) #macro {
    return @id(@function_name() + "Helper")(@insert(param))
}

// types
CXString :: struct {
    data  : ^void = null
    flags : u32   = 0
}

CXUnsavedFile :: struct #copy {
    Filename : c_string
    Contents : c_string
    Length   : u32
}

CXCursor :: struct #copy {
    kind  : CXCursorKind = CXCursorKind.Unknown
    xdata : i32          = 0
    data  : [3]^void     = default
}

CXType :: struct #copy {
    kind : CXTypeKind = CXTypeKind.Invalid
    data : [2]^void   = default
}

CXSourceLocation :: struct #copy {
  ptr_data : [2]^void = default
  int_data : u32      = default
}

// enums

CXChildVisitResult :: enum #copy #repr("C") #tag_type(i32) {
  /**
   * Terminates the cursor traversal.
   */
  Break
  /**
   * Continues the cursor traversal with the next sibling of
   * the cursor just visited, without visiting its children.
   */
  Continue
  /**
   * Recursively traverse the children of this cursor, using
   * the same visitor and client data.
   */
  Recurse
}

CXTranslationUnit_Flags :: enum #copy #repr("C") #tag_type(i32) {
  /**
   * Used to indicate that no special translation-unit options are
   * needed.
   */
  None = 0x0

  /**
   * Used to indicate that the parser should construct a "detailed"
   * preprocessing record, including all macro definitions and instantiations.
   *
   * Constructing a detailed preprocessing record requires more memory
   * and time to parse, since the information contained in the record
   * is usually not retained. However, it can be useful for
   * applications that require more detailed information about the
   * behavior of the preprocessor.
   */
  DetailedPreprocessingRecord = 0x01

  /**
   * Used to indicate that the translation unit is incomplete.
   *
   * When a translation unit is considered "incomplete", semantic
   * analysis that is typically performed at the end of the
   * translation unit will be suppressed. For example, this suppresses
   * the completion of tentative declarations in C and of
   * instantiation of implicitly-instantiation function templates in
   * C++. This option is typically used when parsing a header with the
   * intent of producing a precompiled header.
   */
  Incomplete = 0x02

  /**
   * Used to indicate that the translation unit should be built with an
   * implicit precompiled header for the preamble.
   *
   * An implicit precompiled header is used as an optimization when a
   * particular translation unit is likely to be reparsed many times
   * when the sources aren't changing that often. In this case, an
   * implicit precompiled header will be built containing all of the
   * initial includes at the top of the main file (what we refer to as
   * the "preamble" of the file). In subsequent parses, if the
   * preamble or the files in it have not changed, \c
   * clang_reparseTranslationUnit() will re-use the implicit
   * precompiled header to improve parsing performance.
   */
  PrecompiledPreamble = 0x04

  /**
   * Used to indicate that the translation unit should cache some
   * code-completion results with each reparse of the source file.
   *
   * Caching of code-completion results is a performance optimization that
   * introduces some overhead to reparsing but improves the performance of
   * code-completion operations.
   */
  CacheCompletionResults = 0x08

  /**
   * Used to indicate that the translation unit will be serialized with
   * \c clang_saveTranslationUnit.
   *
   * This option is typically used when parsing a header with the intent of
   * producing a precompiled header.
   */
  ForSerialization = 0x10

  /**
   * DEPRECATED: Enabled chained precompiled preambles in C++.
   *
   * Note: this is a *temporary* option that is available only while
   * we are testing C++ precompiled preamble support. It is deprecated.
   */
  CXXChainedPCH = 0x20

  /**
   * Used to indicate that function/method bodies should be skipped while
   * parsing.
   *
   * This option can be used to search for declarations/definitions while
   * ignoring the usages.
   */
  SkipFunctionBodies = 0x40

  /**
   * Used to indicate that brief documentation comments should be
   * included into the set of code completions returned from this translation
   * unit.
   */
  IncludeBriefCommentsInCodeCompletion = 0x80

  /**
   * Used to indicate that the precompiled preamble should be created on
   * the first parse. Otherwise it will be created on the first reparse. This
   * trades runtime on the first parse (serializing the preamble takes time) for
   * reduced runtime on the second parse (can now reuse the preamble).
   */
  CreatePreambleOnFirstParse = 0x100

  /**
   * Do not stop processing when fatal errors are encountered.
   *
   * When fatal errors are encountered while parsing a translation unit,
   * semantic analysis is typically stopped early when compiling code. A common
   * source for fatal errors are unresolvable include files. For the
   * purposes of an IDE, this is undesirable behavior and as much information
   * as possible should be reported. Use this flag to enable this behavior.
   */
  KeepGoing = 0x200

  /**
   * Sets the preprocessor in a mode for parsing a single file only.
   */
  SingleFileParse = 0x400

  /**
   * Used in combination with CXTranslationUnit_SkipFunctionBodies to
   * constrain the skipping of function bodies to the preamble.
   *
   * The function bodies of the main file are not skipped.
   */
  LimitSkipFunctionBodiesToPreamble = 0x800

  /**
   * Used to indicate that attributed types should be included in CXType.
   */
  IncludeAttributedTypes = 0x1000

  /**
   * Used to indicate that implicit attributes should be visited.
   */
  VisitImplicitAttributes = 0x2000

  /**
   * Used to indicate that non-errors from included files should be ignored.
   *
   * If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from
   * included files anymore. This speeds up clang_getDiagnosticSetFromTU() for
   * the case where these warnings are not of interest, as for an IDE for
   * example, which typically shows only the diagnostics in the main file.
   */
  IgnoreNonErrorsFromIncludedFiles = 0x4000
}

CXCursorKind :: enum #copy #repr("C") #tag_type(i32) {
  Unknown = 0

  /* Declarations */
  /**
   * A declaration whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed declarations have the same operations as any other kind
   * of declaration; one can extract their location information,
   * spelling, find their definitions, etc. However, the specific kind
   * of the declaration is not reported.
   */
  UnexposedDecl                 = 1
  /** A C or C++ struct. */
  StructDecl                    = 2
  /** A C or C++ union. */
  UnionDecl                     = 3
  /** A C++ class. */
  ClassDecl                     = 4
  /** An enumeration. */
  EnumDecl                      = 5
  /**
   * A field (in C) or non-static data member (in C++) in a
   * struct, union, or C++ class.
   */
  FieldDecl                     = 6
  /** An enumerator constant. */
  EnumConstantDecl              = 7
  /** A function. */
  FunctionDecl                  = 8
  /** A variable. */
  VarDecl                       = 9
  /** A function or method parameter. */
  ParmDecl                      = 10
  /** An Objective-C \@interface. */
  ObjCInterfaceDecl             = 11
  /** An Objective-C \@interface for a category. */
  ObjCCategoryDecl              = 12
  /** An Objective-C \@protocol declaration. */
  ObjCProtocolDecl              = 13
  /** An Objective-C \@property declaration. */
  ObjCPropertyDecl              = 14
  /** An Objective-C instance variable. */
  ObjCIvarDecl                  = 15
  /** An Objective-C instance method. */
  ObjCInstanceMethodDecl        = 16
  /** An Objective-C class method. */
  ObjCClassMethodDecl           = 17
  /** An Objective-C \@implementation. */
  ObjCImplementationDecl        = 18
  /** An Objective-C \@implementation for a category. */
  ObjCCategoryImplDecl          = 19
  /** A typedef. */
  TypedefDecl                   = 20
  /** A C++ class method. */
  CXXMethod                     = 21
  /** A C++ namespace. */
  Namespace                     = 22
  /** A linkage specification, e.g. 'extern "C"'. */
  LinkageSpec                   = 23
  /** A C++ constructor. */
  Constructor                   = 24
  /** A C++ destructor. */
  Destructor                    = 25
  /** A C++ conversion function. */
  ConversionFunction            = 26
  /** A C++ template type parameter. */
  TemplateTypeParameter         = 27
  /** A C++ non-type template parameter. */
  NonTypeTemplateParameter      = 28
  /** A C++ template template parameter. */
  TemplateTemplateParameter     = 29
  /** A C++ function template. */
  FunctionTemplate              = 30
  /** A C++ class template. */
  ClassTemplate                 = 31
  /** A C++ class template partial specialization. */
  ClassTemplatePartialSpecialization = 32
  /** A C++ namespace alias declaration. */
  NamespaceAlias                = 33
  /** A C++ using directive. */
  UsingDirective                = 34
  /** A C++ using declaration. */
  UsingDeclaration              = 35
  /** A C++ alias declaration */
  TypeAliasDecl                 = 36
  /** An Objective-C \@synthesize definition. */
  ObjCSynthesizeDecl            = 37
  /** An Objective-C \@dynamic definition. */
  ObjCDynamicDecl               = 38
  /** An access specifier. */
  CXXAccessSpecifier            = 39

  FirstDecl                     = UnexposedDecl
  LastDecl                      = CXXAccessSpecifier

  /* References */
  First&                     = 40 /* Decl references */
  ObjCSuperClass&            = 40
  ObjCProtocol&              = 41
  ObjCClass&                 = 42
  /**
   * A reference to a type declaration.
   *
   * A type reference occurs anywhere where a type is named but not
   * declared. For example, given:
   *
   * \code
   * typedef unsigned size_type;
   * size_type size;
   * \endcode
   *
   * The typedef is a declaration of size_type (TypedefDecl),
   * while the type of the variable "size" is referenced. The cursor
   * referenced by the type of size is the typedef for size_type.
   */
  Type&                      = 43
  CXXBaseSpecifier              = 44
  /**
   * A reference to a class template, function template, template
   * template parameter, or class template partial specialization.
   */
  Template&                  = 45
  /**
   * A reference to a namespace or namespace alias.
   */
  Namespace&                 = 46
  /**
   * A reference to a member of a struct, union, or class that occurs in
   * some non-expression context, e.g., a designated initializer.
   */
  Member&                    = 47
  /**
   * A reference to a labeled statement.
   *
   * This cursor kind is used to describe the jump to "start_over" in the
   * goto statement in the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   *
   *     goto start_over;
   * \endcode
   *
   * A label reference cursor refers to a label statement.
   */
  Label&                     = 48

  /**
   * A reference to a set of overloaded functions or function templates
   * that has not yet been resolved to a specific function or function template.
   *
   * An overloaded declaration reference cursor occurs in C++ templates where
   * a dependent name refers to a function. For example:
   *
   * \code
   * template<typename T> void swap(T^, T^);
   *
   * struct X { ... };
   * void swap(X^, X^);
   *
   * template<typename T>
   * void reverse(T* first, T* last) {
   *   while (first < last - 1) {
   *     swap(*first, *--last);
   *     ++first;
   *   }
   * }
   *
   * struct Y { };
   * void swap(Y^, Y^);
   * \endcode
   *
   * Here, the identifier "swap" is associated with an overloaded declaration
   * reference. In the template definition, "swap" refers to either of the two
   * "swap" functions declared above, so both results will be available. At
   * instantiation time, "swap" may also refer to other functions found via
   * argument-dependent lookup (e.g., the "swap" function at the end of the
   * example).
   *
   * The functions \c clang_getNumOverloadedDecls() and
   * \c clang_getOverloadedDecl() can be used to retrieve the definitions
   * referenced by this cursor.
   */
  OverloadedDecl&            = 49

  /**
   * A reference to a variable that occurs in some non-expression
   * context, e.g., a C++ lambda capture list.
   */
  Variable&                  = 50

  Last&                      = VariableRef

  /* Error conditions */
  FirstInvalid                  = 70
  InvalidFile                   = 70
  NoDeclFound                   = 71
  NotImplemented                = 72
  InvalidCode                   = 73
  LastInvalid                   = InvalidCode

  /* Expressions */
  FirstExpr                     = 100

  /**
   * An expression whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed expressions have the same operations as any other kind
   * of expression; one can extract their location information,
   * spelling, children, etc. However, the specific kind of the
   * expression is not reported.
   */
  UnexposedExpr                 = 100

  /**
   * An expression that refers to some value declaration, such
   * as a function, variable, or enumerator.
   */
  DeclRefExpr                   = 101

  /**
   * An expression that refers to a member of a struct, union,
   * class, Objective-C class, etc.
   */
  MemberRefExpr                 = 102

  /** An expression that calls a function. */
  CallExpr                      = 103

  /** An expression that sends a message to an Objective-C
   object or class. */
  ObjCMessageExpr               = 104

  /** An expression that represents a block literal. */
  BlockExpr                     = 105

  /** An integer literal.
   */
  IntegerLiteral                = 106

  /** A floating point number literal.
   */
  FloatingLiteral               = 107

  /** An imaginary number literal.
   */
  ImaginaryLiteral              = 108

  /** A string literal.
   */
  StringLiteral                 = 109

  /** A character literal.
   */
  CharacterLiteral              = 110

  /** A parenthesized expression, e.g. "(1)".
   *
   * This AST node is only formed if full location information is requested.
   */
  ParenExpr                     = 111

  /** This represents the unary-expression's (except sizeof and
   * alignof).
   */
  UnaryOperator                 = 112

  /** [C99 6.5.2.1] Array Subscripting.
   */
  ArraySubscriptExpr            = 113

  /** A builtin binary operation expression such as "x + y" or
   * "x <= y".
   */
  BinaryOperator                = 114

  /** Compound assignment such as "+=".
   */
  CompoundAssignOperator        = 115

  /** The ?: ternary operator.
   */
  ConditionalOperator           = 116

  /** An explicit cast in C (C99 6.5.4) or a C-style cast in C++
   * (C++ [expr.cast]), which uses the syntax (Type)expr.
   *
   * For example: (int)f.
   */
  CStyleCastExpr                = 117

  /** [C99 6.5.2.5]
   */
  CompoundLiteralExpr           = 118

  /** Describes an C or C++ initializer list.
   */
  InitListExpr                  = 119

  /** The GNU address of label extension, representing ^^label.
   */
  AddrLabelExpr                 = 120

  /** This is the GNU Statement Expression extension: ({int X=4; X;})
   */
  StmtExpr                      = 121

  /** Represents a C11 generic selection.
   */
  GenericSelectionExpr          = 122

  /** Implements the GNU __null extension, which is a name for a null
   * pointer constant that has integral type (e.g., int or long) and is the same
   * size and alignment as a pointer.
   *
   * The __null extension is typically only used by system headers, which define
   * NULL as __null in C++ rather than using 0 (which is an integer that may not
   * match the size of a pointer).
   */
  GNUNullExpr                   = 123

  /** C++'s static_cast<> expression.
   */
  CXXStaticCastExpr             = 124

  /** C++'s dynamic_cast<> expression.
   */
  CXXDynamicCastExpr            = 125

  /** C++'s reinterpret_cast<> expression.
   */
  CXXReinterpretCastExpr        = 126

  /** C++'s const_cast<> expression.
   */
  CXXConstCastExpr              = 127

  /** Represents an explicit C++ type conversion that uses "functional"
   * notion (C++ [expr.type.conv]).
   *
   * Example:
   * \code
   *   x = int(0.5);
   * \endcode
   */
  CXXFunctionalCastExpr         = 128

  /** A C++ typeid expression (C++ [expr.typeid]).
   */
  CXXTypeidExpr                 = 129

  /** [C++ 2.13.5] C++ Boolean Literal.
   */
  CXXBoolLiteralExpr            = 130

  /** [C++0x 2.14.7] C++ Pointer Literal.
   */
  CXXNullPtrLiteralExpr         = 131

  /** Represents the "this" expression in C++
   */
  CXXThisExpr                   = 132

  /** [C++ 15] C++ Throw Expression.
   *
   * This handles 'throw' and 'throw' assignment-expression. When
   * assignment-expression isn't present, Op will be null.
   */
  CXXThrowExpr                  = 133

  /** A new expression for memory allocation and constructor calls, e.g:
   * "new CXXNewExpr(foo)".
   */
  CXXNewExpr                    = 134

  /** A delete expression for memory deallocation and destructor calls,
   * e.g. "delete[] pArray".
   */
  CXXDeleteExpr                 = 135

  /** A unary expression. (noexcept, sizeof, or other traits)
   */
  UnaryExpr                     = 136

  /** An Objective-C string literal i.e. @"foo".
   */
  ObjCStringLiteral             = 137

  /** An Objective-C \@encode expression.
   */
  ObjCEncodeExpr                = 138

  /** An Objective-C \@selector expression.
   */
  ObjCSelectorExpr              = 139

  /** An Objective-C \@protocol expression.
   */
  ObjCProtocolExpr              = 140

  /** An Objective-C "bridged" cast expression, which casts between
   * Objective-C pointers and C pointers, transferring ownership in the process.
   *
   * \code
   *   NSString *str = (__bridge_transfer NSString *)CFCreateString();
   * \endcode
   */
  ObjCBridgedCastExpr           = 141

  /** Represents a C++0x pack expansion that produces a sequence of
   * expressions.
   *
   * A pack expansion expression contains a pattern (which itself is an
   * expression) followed by an ellipsis. For example:
   *
   * \code
   * template<typename F, typename ...Types>
   * void forward(F f, Types ^^...args) {
   *  f(static_cast<Types^^>(args)...);
   * }
   * \endcode
   */
  PackExpansionExpr             = 142

  /** Represents an expression that computes the length of a parameter
   * pack.
   *
   * \code
   * template<typename ...Types>
   * struct count {
   *   static const unsigned value = sizeof...(Types);
   * };
   * \endcode
   */
  SizeOfPackExpr                = 143

  /* Represents a C++ lambda expression that produces a local function
   * object.
   *
   * \code
   * void abssort(float *x, unsigned N) {
   *   std::sort(x, x + N,
   *             [](float a, float b) {
   *               return std::abs(a) < std::abs(b);
   *             });
   * }
   * \endcode
   */
  LambdaExpr                    = 144

  /** Objective-c Boolean Literal.
   */
  ObjCBoolLiteralExpr           = 145

  /** Represents the "self" expression in an Objective-C method.
   */
  ObjCSelfExpr                  = 146

  /** OpenMP 4.0 [2.4, Array Section].
   */
  OMPArraySectionExpr           = 147

  /** Represents an @available(...) check.
   */
  ObjCAvailabilityCheckExpr     = 148

  /**
   * Fixed point literal
   */
  FixedPointLiteral             = 149

  LastExpr                      = FixedPointLiteral

  /* Statements */
  FirstStmt                     = 200
  /**
   * A statement whose specific kind is not exposed via this
   * interface.
   *
   * Unexposed statements have the same operations as any other kind of
   * statement; one can extract their location information, spelling,
   * children, etc. However, the specific kind of the statement is not
   * reported.
   */
  UnexposedStmt                 = 200

  /** A labelled statement in a function.
   *
   * This cursor kind is used to describe the "start_over:" label statement in
   * the following example:
   *
   * \code
   *   start_over:
   *     ++counter;
   * \endcode
   *
   */
  LabelStmt                     = 201

  /** A group of statements like { stmt stmt }.
   *
   * This cursor kind is used to describe compound statements, e.g. function
   * bodies.
   */
  CompoundStmt                  = 202

  /** A case statement.
   */
  CaseStmt                      = 203

  /** A default statement.
   */
  DefaultStmt                   = 204

  /** An if statement
   */
  IfStmt                        = 205

  /** A switch statement.
   */
  SwitchStmt                    = 206

  /** A while statement.
   */
  WhileStmt                     = 207

  /** A do statement.
   */
  DoStmt                        = 208

  /** A for statement.
   */
  ForStmt                       = 209

  /** A goto statement.
   */
  GotoStmt                      = 210

  /** An indirect goto statement.
   */
  IndirectGotoStmt              = 211

  /** A continue statement.
   */
  ContinueStmt                  = 212

  /** A break statement.
   */
  BreakStmt                     = 213

  /** A return statement.
   */
  ReturnStmt                    = 214

  /** A GCC inline assembly statement extension.
   */
  GCCAsmStmt                    = 215
  AsmStmt                       = GCCAsmStmt

  /** Objective-C's overall \@try-\@catch-\@finally statement.
   */
  ObjCAtTryStmt                 = 216

  /** Objective-C's \@catch statement.
   */
  ObjCAtCatchStmt               = 217

  /** Objective-C's \@finally statement.
   */
  ObjCAtFinallyStmt             = 218

  /** Objective-C's \@throw statement.
   */
  ObjCAtThrowStmt               = 219

  /** Objective-C's \@synchronized statement.
   */
  ObjCAtSynchronizedStmt        = 220

  /** Objective-C's autorelease pool statement.
   */
  ObjCAutoreleasePoolStmt       = 221

  /** Objective-C's collection statement.
   */
  ObjCForCollectionStmt         = 222

  /** C++'s catch statement.
   */
  CXXCatchStmt                  = 223

  /** C++'s try statement.
   */
  CXXTryStmt                    = 224

  /** C++'s for (* : *) statement.
   */
  CXXForRangeStmt               = 225

  /** Windows Structured Exception Handling's try statement.
   */
  SEHTryStmt                    = 226

  /** Windows Structured Exception Handling's except statement.
   */
  SEHExceptStmt                 = 227

  /** Windows Structured Exception Handling's finally statement.
   */
  SEHFinallyStmt                = 228

  /** A MS inline assembly statement extension.
   */
  MSAsmStmt                     = 229

  /** The null statement ";": C99 6.8.3p3.
   *
   * This cursor kind is used to describe the null statement.
   */
  NullStmt                      = 230

  /** Adaptor class for mixing declarations with statements and
   * expressions.
   */
  DeclStmt                      = 231

  /** OpenMP parallel directive.
   */
  OMPParallelDirective          = 232

  /** OpenMP SIMD directive.
   */
  OMPSimdDirective              = 233

  /** OpenMP for directive.
   */
  OMPForDirective               = 234

  /** OpenMP sections directive.
   */
  OMPSectionsDirective          = 235

  /** OpenMP section directive.
   */
  OMPSectionDirective           = 236

  /** OpenMP single directive.
   */
  OMPSingleDirective            = 237

  /** OpenMP parallel for directive.
   */
  OMPParallelForDirective       = 238

  /** OpenMP parallel sections directive.
   */
  OMPParallelSectionsDirective  = 239

  /** OpenMP task directive.
   */
  OMPTaskDirective              = 240

  /** OpenMP master directive.
   */
  OMPMasterDirective            = 241

  /** OpenMP critical directive.
   */
  OMPCriticalDirective          = 242

  /** OpenMP taskyield directive.
   */
  OMPTaskyieldDirective         = 243

  /** OpenMP barrier directive.
   */
  OMPBarrierDirective           = 244

  /** OpenMP taskwait directive.
   */
  OMPTaskwaitDirective          = 245

  /** OpenMP flush directive.
   */
  OMPFlushDirective             = 246

  /** Windows Structured Exception Handling's leave statement.
   */
  SEHLeaveStmt                  = 247

  /** OpenMP ordered directive.
   */
  OMPOrderedDirective           = 248

  /** OpenMP atomic directive.
   */
  OMPAtomicDirective            = 249

  /** OpenMP for SIMD directive.
   */
  OMPForSimdDirective           = 250

  /** OpenMP parallel for SIMD directive.
   */
  OMPParallelForSimdDirective   = 251

  /** OpenMP target directive.
   */
  OMPTargetDirective            = 252

  /** OpenMP teams directive.
   */
  OMPTeamsDirective             = 253

  /** OpenMP taskgroup directive.
   */
  OMPTaskgroupDirective         = 254

  /** OpenMP cancellation point directive.
   */
  OMPCancellationPointDirective = 255

  /** OpenMP cancel directive.
   */
  OMPCancelDirective            = 256

  /** OpenMP target data directive.
   */
  OMPTargetDataDirective        = 257

  /** OpenMP taskloop directive.
   */
  OMPTaskLoopDirective          = 258

  /** OpenMP taskloop simd directive.
   */
  OMPTaskLoopSimdDirective      = 259

  /** OpenMP distribute directive.
   */
  OMPDistributeDirective        = 260

  /** OpenMP target enter data directive.
   */
  OMPTargetEnterDataDirective   = 261

  /** OpenMP target exit data directive.
   */
  OMPTargetExitDataDirective    = 262

  /** OpenMP target parallel directive.
   */
  OMPTargetParallelDirective    = 263

  /** OpenMP target parallel for directive.
   */
  OMPTargetParallelForDirective = 264

  /** OpenMP target update directive.
   */
  OMPTargetUpdateDirective      = 265

  /** OpenMP distribute parallel for directive.
   */
  OMPDistributeParallelForDirective = 266

  /** OpenMP distribute parallel for simd directive.
   */
  OMPDistributeParallelForSimdDirective = 267

  /** OpenMP distribute simd directive.
   */
  OMPDistributeSimdDirective = 268

  /** OpenMP target parallel for simd directive.
   */
  OMPTargetParallelForSimdDirective = 269

  /** OpenMP target simd directive.
   */
  OMPTargetSimdDirective = 270

  /** OpenMP teams distribute directive.
   */
  OMPTeamsDistributeDirective = 271

  /** OpenMP teams distribute simd directive.
   */
  OMPTeamsDistributeSimdDirective = 272

  /** OpenMP teams distribute parallel for simd directive.
   */
  OMPTeamsDistributeParallelForSimdDirective = 273

  /** OpenMP teams distribute parallel for directive.
   */
  OMPTeamsDistributeParallelForDirective = 274

  /** OpenMP target teams directive.
   */
  OMPTargetTeamsDirective = 275

  /** OpenMP target teams distribute directive.
   */
  OMPTargetTeamsDistributeDirective = 276

  /** OpenMP target teams distribute parallel for directive.
   */
  OMPTargetTeamsDistributeParallelForDirective = 277

  /** OpenMP target teams distribute parallel for simd directive.
   */
  OMPTargetTeamsDistributeParallelForSimdDirective = 278

  /** OpenMP target teams distribute simd directive.
   */
  OMPTargetTeamsDistributeSimdDirective = 279

  /** C++2a std::bit_cast expression.
   */
  BuiltinBitCastExpr = 280

  LastStmt = BuiltinBitCastExpr

  /**
   * Cursor that represents the translation unit itself.
   *
   * The translation unit cursor exists primarily to act as the root
   * cursor for traversing the contents of a translation unit.
   */
  TranslationUnit               = 300

  /* Attributes */
  FirstAttr                     = 400
  /**
   * An attribute whose specific kind is not exposed via this
   * interface.
   */
  UnexposedAttr                 = 400

  IBActionAttr                  = 401
  IBOutletAttr                  = 402
  IBOutletCollectionAttr        = 403
  CXXFinalAttr                  = 404
  CXXOverrideAttr               = 405
  AnnotateAttr                  = 406
  AsmLabelAttr                  = 407
  PackedAttr                    = 408
  PureAttr                      = 409
  ConstAttr                     = 410
  NoDuplicateAttr               = 411
  CUDAConstantAttr              = 412
  CUDADeviceAttr                = 413
  CUDAGlobalAttr                = 414
  CUDAHostAttr                  = 415
  CUDASharedAttr                = 416
  VisibilityAttr                = 417
  DLLExport                     = 418
  DLLImport                     = 419
  NSReturnsRetained             = 420
  NSReturnsNotRetained          = 421
  NSReturnsAutoreleased         = 422
  NSConsumesSelf                = 423
  NSConsumed                    = 424
  ObjCException                 = 425
  ObjCNSObject                  = 426
  ObjCIndependentClass          = 427
  ObjCPreciseLifetime           = 428
  ObjCReturnsInnerPointer       = 429
  ObjCRequiresSuper             = 430
  ObjCRootClass                 = 431
  ObjCSubclassingRestricted     = 432
  ObjCExplicitProtocolImpl      = 433
  ObjCDesignatedInitializer     = 434
  ObjCRuntimeVisible            = 435
  ObjCBoxable                   = 436
  FlagEnum                      = 437
  ConvergentAttr                = 438
  WarnUnusedAttr                = 439
  WarnUnusedResultAttr          = 440
  AlignedAttr                   = 441
  LastAttr                      = AlignedAttr

  /* Preprocessing */
  PreprocessingDirective        = 500
  MacroDefinition               = 501
  MacroExpansion                = 502
  MacroInstantiation            = MacroExpansion
  InclusionDirective            = 503
  FirstPreprocessing            = PreprocessingDirective
  LastPreprocessing             = InclusionDirective

  /* Extra Declarations */
  /**
   * A module import declaration.
   */
  ModuleImportDecl              = 600
  TypeAliasTemplateDecl         = 601
  /**
   * A static_assert or _Static_assert node
   */
  StaticAssert                  = 602
  /**
   * a friend declaration.
   */
  FriendDecl                    = 603
  FirstExtraDecl                = ModuleImportDecl
  LastExtraDecl                 = FriendDecl

  /**
   * A code completion overload candidate.
   */
  OverloadCandidate             = 700
}

/**
 * Describes the kind of type
 */
CXTypeKind :: enum #copy #repr("C") #tag_type(i32) {
  /**
   * Represents an invalid type (e.g., where no type is available).
   */
  Invalid                                        = 0

  /**
   * A type whose specific kind is not exposed via this
   * interface.
   */
  Unexposed                                      = 1

  /* Builtin types */
  Void                                           = 2
  Bool                                           = 3
  Char_U                                         = 4
  UChar                                          = 5
  Char16                                         = 6
  Char32                                         = 7
  UShort                                         = 8
  UInt                                           = 9
  ULong                                          = 10
  ULongLong                                      = 11
  UInt128                                        = 12
  Char_S                                         = 13
  SChar                                          = 14
  WChar                                          = 15
  Short                                          = 16
  Int                                            = 17
  Long                                           = 18
  LongLong                                       = 19
  Int128                                         = 20
  Float                                          = 21
  Double                                         = 22
  LongDouble                                     = 23
  NullPtr                                        = 24
  Overload                                       = 25
  Dependent                                      = 26
  ObjCId                                         = 27
  ObjCClass                                      = 28
  ObjCSel                                        = 29
  Float128                                       = 30
  Half                                           = 31
  Float16                                        = 32
  ShortAccum                                     = 33
  Accum                                          = 34
  LongAccum                                      = 35
  UShortAccum                                    = 36
  UAccum                                         = 37
  ULongAccum                                     = 38
  FirstBuiltin                                   = Void
  LastBuiltin                                    = ULongAccum

  Complex                                        = 100
  Pointer                                        = 101
  BlockPointer                                   = 102
  LValueReference                                = 103
  RValueReference                                = 104
  Record                                         = 105
  Enum                                           = 106
  Typedef                                        = 107
  ObjCInterface                                  = 108
  ObjCObjectPointer                              = 109
  FunctionNoProto                                = 110
  FunctionProto                                  = 111
  ConstantArray                                  = 112
  Vector                                         = 113
  IncompleteArray                                = 114
  VariableArray                                  = 115
  DependentSizedArray                            = 116
  MemberPointer                                  = 117
  Auto                                           = 118

  /**
   * Represents a type that was referred to using an elaborated type keyword.
   *
   * E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
   */
  Elaborated                                     = 119

  /* OpenCL PipeType. */
  Pipe                                           = 120

  /* OpenCL builtin types. */
  OCLImage1dRO                                   = 121
  OCLImage1dArrayRO                              = 122
  OCLImage1dBufferRO                             = 123
  OCLImage2dRO                                   = 124
  OCLImage2dArrayRO                              = 125
  OCLImage2dDepthRO                              = 126
  OCLImage2dArrayDepthRO                         = 127
  OCLImage2dMSAARO                               = 128
  OCLImage2dArrayMSAARO                          = 129
  OCLImage2dMSAADepthRO                          = 130
  OCLImage2dArrayMSAADepthRO                     = 131
  OCLImage3dRO                                   = 132
  OCLImage1dWO                                   = 133
  OCLImage1dArrayWO                              = 134
  OCLImage1dBufferWO                             = 135
  OCLImage2dWO                                   = 136
  OCLImage2dArrayWO                              = 137
  OCLImage2dDepthWO                              = 138
  OCLImage2dArrayDepthWO                         = 139
  OCLImage2dMSAAWO                               = 140
  OCLImage2dArrayMSAAWO                          = 141
  OCLImage2dMSAADepthWO                          = 142
  OCLImage2dArrayMSAADepthWO                     = 143
  OCLImage3dWO                                   = 144
  OCLImage1dRW                                   = 145
  OCLImage1dArrayRW                              = 146
  OCLImage1dBufferRW                             = 147
  OCLImage2dRW                                   = 148
  OCLImage2dArrayRW                              = 149
  OCLImage2dDepthRW                              = 150
  OCLImage2dArrayDepthRW                         = 151
  OCLImage2dMSAARW                               = 152
  OCLImage2dArrayMSAARW                          = 153
  OCLImage2dMSAADepthRW                          = 154
  OCLImage2dArrayMSAADepthRW                     = 155
  OCLImage3dRW                                   = 156
  OCLSampler                                     = 157
  OCLEvent                                       = 158
  OCLQueue                                       = 159
  OCLReserveID                                   = 160

  ObjCObject                                     = 161
  ObjCTypeParam                                  = 162
  Attributed                                     = 163

  OCLIntelSubgroupAVCMcePayload                  = 164
  OCLIntelSubgroupAVCImePayload                  = 165
  OCLIntelSubgroupAVCRefPayload                  = 166
  OCLIntelSubgroupAVCSicPayload                  = 167
  OCLIntelSubgroupAVCMceResult                   = 168
  OCLIntelSubgroupAVCImeResult                   = 169
  OCLIntelSubgroupAVCRefResult                   = 170
  OCLIntelSubgroupAVCSicResult                   = 171
  OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172
  OCLIntelSubgroupAVCImeResultDualRefStreamout   = 173
  OCLIntelSubgroupAVCImeSingleRefStreamin        = 174

  OCLIntelSubgroupAVCImeDualRefStreamin          = 175

  ExtVector                                      = 176
}