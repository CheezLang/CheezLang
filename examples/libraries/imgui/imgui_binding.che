#lib("./lib/Bindings.lib")
#lib("./lib/imgui.lib")

import std.alloca
use import std.io.stdio

use import glfw

#export_scope

Color32 :: (r: u8, g: u8, b: u8, a: u8 = 255) -> u32 {
    r_shift :: 0
    g_shift :: 8
    b_shift :: 16
    a_shift :: 24
    return @bin_or(
        @bin_lsl(u32(r), r_shift),
        @bin_lsl(u32(g), g_shift),
        @bin_lsl(u32(b), b_shift),
        @bin_lsl(u32(a), a_shift)
    )
}

__UNKNOWN_16 :: struct #copy {
    _: [16]u8 = default
}
__UNKNOWN_40 :: struct #copy {
    _: [40]u8 = default
}
va_list :: ^void
size_t :: u64

ImGuiDockContext :: struct {}

ImTextureID :: ^void
ImGuiID :: u32
ImWchar :: u16
ImGuiCol :: i32
ImGuiCond :: i32
ImGuiDataType :: i32
ImGuiDir :: i32
ImGuiKey :: i32
ImGuiNavInput :: i32
ImGuiMouseButton :: i32
ImGuiMouseCursor :: i32
ImGuiStyleVar :: i32
ImDrawCornerFlags :: i32
ImDrawListFlags :: i32
ImFontAtlasFlags :: i32
ImGuiBackendFlags :: i32
ImGuiColorEditFlags :: i32
ImGuiConfigFlags :: i32
ImGuiComboFlags :: i32
ImGuiDockNodeFlags :: i32
ImGuiDragDropFlags :: i32
ImGuiFocusedFlags :: i32
ImGuiHoveredFlags :: i32
ImGuiInputTextFlags :: i32
ImGuiSelectableFlags :: i32
ImGuiTabBarFlags :: i32
ImGuiTabItemFlags :: i32
ImGuiTreeNodeFlags :: i32
ImGuiViewportFlags :: i32
ImGuiWindowFlags :: i32
ImGuiInputTextCallback :: fn(^ImGuiInputTextCallbackData) -> i32
ImGuiSizeCallback :: fn(^ImGuiSizeCallbackData) -> void
ImS8 :: i8
ImU8 :: u8
ImS16 :: i16
ImU16 :: u16
ImS32 :: i32
ImU32 :: u32
ImS64 :: i64
ImU64 :: u64
ImGuiTextEditCallback :: ImGuiInputTextCallback
ImGuiTextEditCallbackData :: ImGuiInputTextCallbackData
ImDrawCallback :: fn(^ImDrawList, ^ImDrawCmd) -> void
ImDrawIdx :: u16
CustomRect :: ImFontAtlasCustomRect
GlyphRangesBuilder :: ImFontGlyphRangesBuilder
ImGuiDataAuthority :: i32
ImGuiLayoutType :: i32
ImGuiButtonFlags :: i32
ImGuiColumnsFlags :: i32
ImGuiDragFlags :: i32
ImGuiItemFlags :: i32
ImGuiItemStatusFlags :: i32
ImGuiNavHighlightFlags :: i32
ImGuiNavDirSourceFlags :: i32
ImGuiNavMoveFlags :: i32
ImGuiNextItemDataFlags :: i32
ImGuiNextWindowDataFlags :: i32
ImGuiSeparatorFlags :: i32
ImGuiSliderFlags :: i32
ImGuiTextFlags :: i32
StbUndoRecord :: struct #copy {}
StbUndoState :: struct #copy {}
STB_TexteditState :: struct #copy {}
StbTexteditRow :: struct #copy {}
ImFileHandle :: ^FILE
ImPoolIdx :: i32
STB_TEXTEDIT_STRING :: ImGuiInputTextState
STB_TEXTEDIT_CHARTYPE :: ImWchar
STB_TEXTEDIT_GETWIDTH_NEWLINE :: -1.0f
STB_TEXTEDIT_UNDOSTATECOUNT :: 99
STB_TEXTEDIT_UNDOCHARCOUNT :: 999
STB_TEXTEDIT_POSITIONTYPE :: i32
IMGUI_PAYLOAD_TYPE_WINDOW :: "_IMWINDOW"
IM_PI :: 3.14159265358979323846
IM_NEWLINE :: "`r`n"
IM_TABSIZE :: (4)
ImGuiWindowFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                      = 0x0
    NoTitleBar                = 0x1
    NoResize                  = 0x2
    NoMove                    = 0x4
    NoScrollbar               = 0x8
    NoScrollWithMouse         = 0x10
    NoCollapse                = 0x20
    AlwaysAutoResize          = 0x40
    NoBackground              = 0x80
    NoSavedSettings           = 0x100
    NoMouseInputs             = 0x200
    MenuBar                   = 0x400
    HorizontalScrollbar       = 0x800
    NoFocusOnAppearing        = 0x1000
    NoBringToFrontOnFocus     = 0x2000
    AlwaysVerticalScrollbar   = 0x4000
    AlwaysHorizontalScrollbar = 0x8000
    AlwaysUseWindowPadding    = 0x10000
    NoNavInputs               = 0x40000
    NoNavFocus                = 0x80000
    UnsavedDocument           = 0x100000
    NoDocking                 = 0x200000
    NoNav                     = 0xc0000
    NoDecoration              = 0x2b
    NoInputs                  = 0xc0200
    NavFlattened              = 0x800000
    ChildWindow               = 0x1000000
    Tooltip                   = 0x2000000
    Popup                     = 0x4000000
    Modal                     = 0x8000000
    ChildMenu                 = 0x10000000
    DockNodeHost              = 0x20000000
}
ImGuiInputTextFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                = 0x0
    CharsDecimal        = 0x1
    CharsHexadecimal    = 0x2
    CharsUppercase      = 0x4
    CharsNoBlank        = 0x8
    AutoSelectAll       = 0x10
    EnterReturnsTrue    = 0x20
    CallbackCompletion  = 0x40
    CallbackHistory     = 0x80
    CallbackAlways      = 0x100
    CallbackCharFilter  = 0x200
    AllowTabInput       = 0x400
    CtrlEnterForNewLine = 0x800
    NoHorizontalScroll  = 0x1000
    AlwaysInsertMode    = 0x2000
    ReadOnly            = 0x4000
    Password            = 0x8000
    NoUndoRedo          = 0x10000
    CharsScientific     = 0x20000
    CallbackResize      = 0x40000
    Multiline           = 0x100000
    NoMarkEdited        = 0x200000
}
ImGuiTreeNodeFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                 = 0x0
    Selected             = 0x1
    Framed               = 0x2
    AllowItemOverlap     = 0x4
    NoTreePushOnOpen     = 0x8
    NoAutoOpenOnLog      = 0x10
    DefaultOpen          = 0x20
    OpenOnDoubleClick    = 0x40
    OpenOnArrow          = 0x80
    Leaf                 = 0x100
    Bullet               = 0x200
    FramePadding         = 0x400
    SpanAvailWidth       = 0x800
    SpanFullWidth        = 0x1000
    NavLeftJumpsBackHere = 0x2000
    CollapsingHeader     = 0x1a
}
ImGuiSelectableFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None             = 0x0
    DontClosePopups  = 0x1
    SpanAllColumns   = 0x2
    AllowDoubleClick = 0x4
    Disabled         = 0x8
    AllowItemOverlap = 0x10
}
ImGuiComboFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None           = 0x0
    PopupAlignLeft = 0x1
    HeightSmall    = 0x2
    HeightRegular  = 0x4
    HeightLarge    = 0x8
    HeightLargest  = 0x10
    NoArrowButton  = 0x20
    NoPreview      = 0x40
    HeightMask_    = 0x1e
}
ImGuiTabBarFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                         = 0x0
    Reorderable                  = 0x1
    AutoSelectNewTabs            = 0x2
    TabListPopupButton           = 0x4
    NoCloseWithMiddleMouseButton = 0x8
    NoTabListScrollingButtons    = 0x10
    NoTooltip                    = 0x20
    FittingPolicyResizeDown      = 0x40
    FittingPolicyScroll          = 0x80
    FittingPolicyMask_           = 0xc0
    FittingPolicyDefault_        = 0x40
}
ImGuiTabItemFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                         = 0x0
    UnsavedDocument              = 0x1
    SetSelected                  = 0x2
    NoCloseWithMiddleMouseButton = 0x4
    NoPushId                     = 0x8
}
ImGuiFocusedFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                = 0x0
    ChildWindows        = 0x1
    RootWindow          = 0x2
    AnyWindow           = 0x4
    RootAndChildWindows = 0x3
}
ImGuiHoveredFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                         = 0x0
    ChildWindows                 = 0x1
    RootWindow                   = 0x2
    AnyWindow                    = 0x4
    AllowWhenBlockedByPopup      = 0x8
    AllowWhenBlockedByActiveItem = 0x20
    AllowWhenOverlapped          = 0x40
    AllowWhenDisabled            = 0x80
    RectOnly                     = 0x68
    RootAndChildWindows          = 0x3
}
ImGuiDockNodeFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                   = 0x0
    KeepAliveOnly          = 0x1
    NoDockingInCentralNode = 0x4
    PassthruCentralNode    = 0x8
    NoSplit                = 0x10
    NoResize               = 0x20
    AutoHideTabBar         = 0x40
}
ImGuiDragDropFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                     = 0x0
    SourceNoPreviewTooltip   = 0x1
    SourceNoDisableHover     = 0x2
    SourceNoHoldToOpenOthers = 0x4
    SourceAllowNullID        = 0x8
    SourceExtern             = 0x10
    SourceAutoExpirePayload  = 0x20
    AcceptBeforeDelivery     = 0x400
    AcceptNoDrawDefaultRect  = 0x800
    AcceptNoPreviewTooltip   = 0x1000
    AcceptPeekOnly           = 0xc00
}
ImGuiDataType_ :: enum #copy #repr("C") #tag_type(i32) {
    S8     = 0x0
    U8     = 0x1
    S16    = 0x2
    U16    = 0x3
    S32    = 0x4
    U32    = 0x5
    S64    = 0x6
    U64    = 0x7
    Float  = 0x8
    Double = 0x9
    COUNT  = 0xa
}
ImGuiDir_ :: enum #copy #repr("C") #tag_type(i32) {
    None  = -1
    Left  = 0x0
    Right = 0x1
    Up    = 0x2
    Down  = 0x3
    COUNT = 0x4
}
ImGuiKey_ :: enum #copy #repr("C") #tag_type(i32) {
    Tab         = 0x0
    LeftArrow   = 0x1
    RightArrow  = 0x2
    UpArrow     = 0x3
    DownArrow   = 0x4
    PageUp      = 0x5
    PageDown    = 0x6
    Home        = 0x7
    End         = 0x8
    Insert      = 0x9
    Delete      = 0xa
    Backspace   = 0xb
    Space       = 0xc
    Enter       = 0xd
    Escape      = 0xe
    KeyPadEnter = 0xf
    A           = 0x10
    C           = 0x11
    V           = 0x12
    X           = 0x13
    Y           = 0x14
    Z           = 0x15
    COUNT       = 0x16
}
ImGuiNavInput_ :: enum #copy #repr("C") #tag_type(i32) {
    Activate       = 0x0
    Cancel         = 0x1
    Input          = 0x2
    Menu           = 0x3
    DpadLeft       = 0x4
    DpadRight      = 0x5
    DpadUp         = 0x6
    DpadDown       = 0x7
    LStickLeft     = 0x8
    LStickRight    = 0x9
    LStickUp       = 0xa
    LStickDown     = 0xb
    FocusPrev      = 0xc
    FocusNext      = 0xd
    TweakSlow      = 0xe
    TweakFast      = 0xf
    KeyMenu_       = 0x10
    KeyLeft_       = 0x11
    KeyRight_      = 0x12
    KeyUp_         = 0x13
    KeyDown_       = 0x14
    COUNT          = 0x15
    InternalStart_ = 0x10
}
ImGuiConfigFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                    = 0x0
    NavEnableKeyboard       = 0x1
    NavEnableGamepad        = 0x2
    NavEnableSetMousePos    = 0x4
    NavNoCaptureKeyboard    = 0x8
    NoMouse                 = 0x10
    NoMouseCursorChange     = 0x20
    DockingEnable           = 0x40
    ViewportsEnable         = 0x400
    DpiEnableScaleViewports = 0x4000
    DpiEnableScaleFonts     = 0x8000
    IsSRGB                  = 0x100000
    
    IsTouchScreen           = 0x200000
}
ImGuiBackendFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                    = 0x0
    HasGamepad              = 0x1
    HasMouseCursors         = 0x2
    HasSetMousePos          = 0x4
    RendererHasVtxOffset    = 0x8
    PlatformHasViewports    = 0x400
    HasMouseHoveredViewport = 0x800
    RendererHasViewports    = 0x1000
}
ImGuiCol_ :: enum #copy #repr("C") #tag_type(i32) {
    Text                  = 0x0
    TextDisabled          = 0x1
    WindowBg              = 0x2
    ChildBg               = 0x3
    PopupBg               = 0x4
    Border                = 0x5
    BorderShadow          = 0x6
    FrameBg               = 0x7
    FrameBgHovered        = 0x8
    FrameBgActive         = 0x9
    TitleBg               = 0xa
    TitleBgActive         = 0xb
    TitleBgCollapsed      = 0xc
    MenuBarBg             = 0xd
    ScrollbarBg           = 0xe
    ScrollbarGrab         = 0xf
    ScrollbarGrabHovered  = 0x10
    ScrollbarGrabActive   = 0x11
    CheckMark             = 0x12
    SliderGrab            = 0x13
    SliderGrabActive      = 0x14
    Button                = 0x15
    ButtonHovered         = 0x16
    ButtonActive          = 0x17
    Header                = 0x18
    HeaderHovered         = 0x19
    HeaderActive          = 0x1a
    Separator             = 0x1b
    SeparatorHovered      = 0x1c
    SeparatorActive       = 0x1d
    ResizeGrip            = 0x1e
    ResizeGripHovered     = 0x1f
    ResizeGripActive      = 0x20
    Tab                   = 0x21
    TabHovered            = 0x22
    TabActive             = 0x23
    TabUnfocused          = 0x24
    TabUnfocusedActive    = 0x25
    DockingPreview        = 0x26
    DockingEmptyBg        = 0x27
    PlotLines             = 0x28
    PlotLinesHovered      = 0x29
    PlotHistogram         = 0x2a
    PlotHistogramHovered  = 0x2b
    TextSelectedBg        = 0x2c
    DragDropTarget        = 0x2d
    NavHighlight          = 0x2e
    NavWindowingHighlight = 0x2f
    NavWindowingDimBg     = 0x30
    ModalWindowDimBg      = 0x31
    COUNT                 = 0x32
    ModalWindowDarkening  = 0x31
}
ImGuiStyleVar_ :: enum #copy #repr("C") #tag_type(i32) {
    Alpha               = 0x0
    WindowPadding       = 0x1
    WindowRounding      = 0x2
    WindowBorderSize    = 0x3
    WindowMinSize       = 0x4
    WindowTitleAlign    = 0x5
    ChildRounding       = 0x6
    ChildBorderSize     = 0x7
    PopupRounding       = 0x8
    PopupBorderSize     = 0x9
    FramePadding        = 0xa
    FrameRounding       = 0xb
    FrameBorderSize     = 0xc
    ItemSpacing         = 0xd
    ItemInnerSpacing    = 0xe
    IndentSpacing       = 0xf
    ScrollbarSize       = 0x10
    ScrollbarRounding   = 0x11
    GrabMinSize         = 0x12
    GrabRounding        = 0x13
    TabRounding         = 0x14
    ButtonTextAlign     = 0x15
    SelectableTextAlign = 0x16
    COUNT               = 0x17
    Count_              = 0x17
}
ImGuiColorEditFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None             = 0x0
    NoAlpha          = 0x2
    NoPicker         = 0x4
    NoOptions        = 0x8
    NoSmallPreview   = 0x10
    NoInputs         = 0x20
    NoTooltip        = 0x40
    NoLabel          = 0x80
    NoSidePreview    = 0x100
    NoDragDrop       = 0x200
    AlphaBar         = 0x10000
    AlphaPreview     = 0x20000
    AlphaPreviewHalf = 0x40000
    HDR              = 0x80000
    DisplayRGB       = 0x100000
    DisplayHSV       = 0x200000
    DisplayHex       = 0x400000
    Uint8            = 0x800000
    Float            = 0x1000000
    PickerHueBar     = 0x2000000
    PickerHueWheel   = 0x4000000
    InputRGB         = 0x8000000
    InputHSV         = 0x10000000
    OptionsDefault   = 0xa900000
    DisplayMask      = 0x700000
    DataTypeMask     = 0x1800000
    PickerMask       = 0x6000000
    InputMask        = 0x18000000
    RGB              = 0x100000
    HSV              = 0x200000
    HEX              = 0x400000
}
ImGuiMouseButton_ :: enum #copy #repr("C") #tag_type(i32) {
    Left   = 0x0
    Right  = 0x1
    Middle = 0x2
    COUNT  = 0x5
}
ImGuiMouseCursor_ :: enum #copy #repr("C") #tag_type(i32) {
    None       = -1
    Arrow      = 0x0
    TextInput  = 0x1
    ResizeAll  = 0x2
    ResizeNS   = 0x3
    ResizeEW   = 0x4
    ResizeNESW = 0x5
    ResizeNWSE = 0x6
    Hand       = 0x7
    NotAllowed = 0x8
    COUNT      = 0x9
    Count_     = 0x9
}
ImGuiCond_ :: enum #copy #repr("C") #tag_type(i32) {
    Always       = 0x1
    Once         = 0x2
    FirstUseEver = 0x4
    Appearing    = 0x8
}
ImDrawCornerFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None     = 0x0
    TopLeft  = 0x1
    TopRight = 0x2
    BotLeft  = 0x4
    BotRight = 0x8
    Top      = 0x3
    Bot      = 0xc
    Left     = 0x5
    Right    = 0xa
    All      = 0xf
}
ImDrawListFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None             = 0x0
    AntiAliasedLines = 0x1
    AntiAliasedFill  = 0x2
    AllowVtxOffset   = 0x4
}
ImFontAtlasFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None               = 0x0
    NoPowerOfTwoHeight = 0x1
    NoMouseCursors     = 0x2
}
ImGuiViewportFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                = 0x0
    NoDecoration        = 0x1
    NoTaskBarIcon       = 0x2
    NoFocusOnAppearing  = 0x4
    NoFocusOnClick      = 0x8
    NoInputs            = 0x10
    NoRendererClear     = 0x20
    TopMost             = 0x40
    Minimized           = 0x80
    NoAutoMerge         = 0x100
    CanHostOtherWindows = 0x200
}
ImGuiButtonFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                  = 0x0
    Repeat                = 0x1
    PressedOnClickRelease = 0x2
    PressedOnClick        = 0x4
    PressedOnRelease      = 0x8
    PressedOnDoubleClick  = 0x10
    FlattenChildren       = 0x20
    AllowItemOverlap      = 0x40
    DontClosePopups       = 0x80
    Disabled              = 0x100
    AlignTextBaseLine     = 0x200
    NoKeyModifiers        = 0x400
    NoHoldingActiveID     = 0x800
    PressedOnDragDropHold = 0x1000
    NoNavFocus            = 0x2000
    NoHoveredOnNav        = 0x4000
}
ImGuiSliderFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None     = 0x0
    Vertical = 0x1
}
ImGuiDragFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None     = 0x0
    Vertical = 0x1
}
ImGuiColumnsFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                   = 0x0
    NoBorder               = 0x1
    NoResize               = 0x2
    NoPreserveWidths       = 0x4
    NoForceWithinWindow    = 0x8
    GrowParentContentsSize = 0x10
}
ImGuiSelectableFlagsPrivate_ :: enum #copy #repr("C") #tag_type(i32) {
    ImGuiSelectableFlags_NoHoldingActiveID   = 0x100000
    ImGuiSelectableFlags_PressedOnClick      = 0x200000
    ImGuiSelectableFlags_PressedOnRelease    = 0x400000
    ImGuiSelectableFlags_DrawFillAvailWidth  = 0x800000
    ImGuiSelectableFlags_DrawHoveredWhenHeld = 0x1000000
    ImGuiSelectableFlags_SetNavIdOnHover     = 0x2000000
}
ImGuiTreeNodeFlagsPrivate_ :: enum #copy #repr("C") #tag_type(i32) {
    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 0x100000
}
ImGuiSeparatorFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None           = 0x0
    Horizontal     = 0x1
    Vertical       = 0x2
    SpanAllColumns = 0x4
}
ImGuiItemFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                     = 0x0
    NoTabStop                = 0x1
    ButtonRepeat             = 0x2
    Disabled                 = 0x4
    NoNav                    = 0x8
    NoNavDefaultFocus        = 0x10
    SelectableDontClosePopup = 0x20
    MixedValue               = 0x40
    Default_                 = 0x0
}
ImGuiItemStatusFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None             = 0x0
    HoveredRect      = 0x1
    HasDisplayRect   = 0x2
    Edited           = 0x4
    ToggledSelection = 0x8
    ToggledOpen      = 0x10
    HasDeactivated   = 0x20
    Deactivated      = 0x40
}
ImGuiTextFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                       = 0x0
    NoWidthForLargeClippedText = 0x1
}
ImGuiLayoutType_ :: enum #copy #repr("C") #tag_type(i32) {
    Horizontal = 0x0
    Vertical   = 0x1
}
ImGuiLogType :: enum #copy #repr("C") #tag_type(i32) {
    None       = 0x0
    TTY        = 0x1
    File       = 0x2
    Buffer     = 0x3
    Clipboard  = 0x4
}
ImGuiAxis :: enum #copy #repr("C") #tag_type(i32) {
    None  = -1
    X     = 0x0
    Y     = 0x1
}
ImGuiPlotType :: enum #copy #repr("C") #tag_type(i32) {
    Lines      = 0x0
    Histogram  = 0x1
}
ImGuiInputSource :: enum #copy #repr("C") #tag_type(i32) {
    None         = 0x0
    Mouse        = 0x1
    Nav          = 0x2
    NavKeyboard  = 0x3
    NavGamepad   = 0x4
    COUNT        = 0x5
}
ImGuiInputReadMode :: enum #copy #repr("C") #tag_type(i32) {
    Down        = 0x0
    Pressed     = 0x1
    Released    = 0x2
    Repeat      = 0x3
    RepeatSlow  = 0x4
    RepeatFast  = 0x5
}
ImGuiNavHighlightFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None        = 0x0
    TypeDefault = 0x1
    TypeThin    = 0x2
    AlwaysDraw  = 0x4
    NoRounding  = 0x8
}
ImGuiNavDirSourceFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None      = 0x0
    Keyboard  = 0x1
    PadDPad   = 0x2
    PadLStick = 0x4
}
ImGuiNavMoveFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None                = 0x0
    LoopX               = 0x1
    LoopY               = 0x2
    WrapX               = 0x4
    WrapY               = 0x8
    AllowCurrentNavId   = 0x10
    AlsoScoreVisibleSet = 0x20
    ScrollToEdge        = 0x40
}
ImGuiNavForward :: enum #copy #repr("C") #tag_type(i32) {
    None           = 0x0
    ForwardQueued  = 0x1
    ForwardActive  = 0x2
}
ImGuiNavLayer :: enum #copy #repr("C") #tag_type(i32) {
    Main   = 0x0
    Menu   = 0x1
    COUNT  = 0x2
}
ImGuiPopupPositionPolicy :: enum #copy #repr("C") #tag_type(i32) {
    Default   = 0x0
    ComboBox  = 0x1
}
ImGuiNextWindowDataFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None              = 0x0
    HasPos            = 0x1
    HasSize           = 0x2
    HasContentSize    = 0x4
    HasCollapsed      = 0x8
    HasSizeConstraint = 0x10
    HasFocus          = 0x20
    HasBgAlpha        = 0x40
    HasViewport       = 0x80
    HasDock           = 0x100
    HasWindowClass    = 0x200
}
ImGuiNextItemDataFlags_ :: enum #copy #repr("C") #tag_type(i32) {
    None     = 0x0
    HasWidth = 0x1
    HasOpen  = 0x2
}
ImGuiDockNodeFlagsPrivate_ :: enum #copy #repr("C") #tag_type(i32) {
    ImGuiDockNodeFlags_DockSpace               = 0x400
    ImGuiDockNodeFlags_CentralNode             = 0x800
    ImGuiDockNodeFlags_NoTabBar                = 0x1000
    ImGuiDockNodeFlags_HiddenTabBar            = 0x2000
    ImGuiDockNodeFlags_NoWindowMenuButton      = 0x4000
    ImGuiDockNodeFlags_NoCloseButton           = 0x8000
    ImGuiDockNodeFlags_NoDocking               = 0x10000
    ImGuiDockNodeFlags_SharedFlagsInheritMask_ = -1
    ImGuiDockNodeFlags_LocalFlagsMask_         = 0x1fc70
    ImGuiDockNodeFlags_LocalFlagsTransferMask_ = 0x1f870
    ImGuiDockNodeFlags_SavedFlagsMask_         = 0x1fc20
}
ImGuiDataAuthority_ :: enum #copy #repr("C") #tag_type(i32) {
    Auto     = 0x0
    DockNode = 0x1
    Window   = 0x2
}
ImGuiDockNodeState :: enum #copy #repr("C") #tag_type(i32) {
    Unknown                                    = 0x0
    HostWindowHiddenBecauseSingleWindow        = 0x1
    HostWindowHiddenBecauseWindowsAreResizing  = 0x2
    HostWindowVisible                          = 0x3
}
ImGuiTabBarFlagsPrivate_ :: enum #copy #repr("C") #tag_type(i32) {
    ImGuiTabBarFlags_DockNode     = 0x100000
    ImGuiTabBarFlags_IsFocused    = 0x200000
    ImGuiTabBarFlags_SaveSettings = 0x400000
}
ImGuiTabItemFlagsPrivate_ :: enum #copy #repr("C") #tag_type(i32) {
    ImGuiTabItemFlags_NoCloseButton = 0x100000
    ImGuiTabItemFlags_Unsorted      = 0x200000
    ImGuiTabItemFlags_Preview       = 0x400000
}
ImVec2 :: struct #copy {
    x : f32 = default
    y : f32 = default
}
impl ImVec2 {
    new :: () -> ImVec2 {
        result : ImVec2 = default
        __c__ImVec2_new_2(^result)
        return result
    }
    new :: (__x: f32, __y: f32) -> ImVec2 {
        result : ImVec2 = default
        __c__ImVec2_new_3(^result, __x, __y)
        return result
    }
}
ImVec4 :: struct #copy {
    x : f32 = default
    y : f32 = default
    z : f32 = default
    w : f32 = default
}
impl ImVec4 {
    new :: () -> ImVec4 {
        result : ImVec4 = default
        __c__ImVec4_new_4(^result)
        return result
    }
    new :: (__x: f32, __y: f32, __z: f32, __w: f32) -> ImVec4 {
        result : ImVec4 = default
        __c__ImVec4_new_5(^result, __x, __y, __z, __w)
        return result
    }
}
ImNewDummy :: struct #copy {
}
ImGuiStyle :: struct #copy {
    Alpha : f32 = default
    WindowPadding : ImVec2 = default
    WindowRounding : f32 = default
    WindowBorderSize : f32 = default
    WindowMinSize : ImVec2 = default
    WindowTitleAlign : ImVec2 = default
    WindowMenuButtonPosition : ImGuiDir = default
    ChildRounding : f32 = default
    ChildBorderSize : f32 = default
    PopupRounding : f32 = default
    PopupBorderSize : f32 = default
    FramePadding : ImVec2 = default
    FrameRounding : f32 = default
    FrameBorderSize : f32 = default
    ItemSpacing : ImVec2 = default
    ItemInnerSpacing : ImVec2 = default
    TouchExtraPadding : ImVec2 = default
    IndentSpacing : f32 = default
    ColumnsMinSpacing : f32 = default
    ScrollbarSize : f32 = default
    ScrollbarRounding : f32 = default
    GrabMinSize : f32 = default
    GrabRounding : f32 = default
    TabRounding : f32 = default
    TabBorderSize : f32 = default
    ColorButtonPosition : ImGuiDir = default
    ButtonTextAlign : ImVec2 = default
    SelectableTextAlign : ImVec2 = default
    DisplayWindowPadding : ImVec2 = default
    DisplaySafeAreaPadding : ImVec2 = default
    MouseCursorScale : f32 = default
    AntiAliasedLines : bool = default
    AntiAliasedFill : bool = default
    CurveTessellationTol : f32 = default
    Colors : [50]ImVec4 = default
}
impl ImGuiStyle {
    new :: () -> ImGuiStyle {
        result : ImGuiStyle = default
        __c__ImGuiStyle_new_35(^result)
        return result
    }
    ScaleAllSizes :: (&Self, _scale_factor: f32) {
        __c__ImGuiStyle_ScaleAllSizes_36(^*self, _scale_factor)
    }
}
ImGuiIO :: struct #copy {
    ConfigFlags : ImGuiConfigFlags = default
    BackendFlags : ImGuiBackendFlags = default
    DisplaySize : ImVec2 = default
    DeltaTime : f32 = default
    IniSavingRate : f32 = default
    IniFilename : ^char8 = default
    LogFilename : ^char8 = default
    MouseDoubleClickTime : f32 = default
    MouseDoubleClickMaxDist : f32 = default
    MouseDragThreshold : f32 = default
    KeyMap : [22]i32 = default
    KeyRepeatDelay : f32 = default
    KeyRepeatRate : f32 = default
    UserData : ^void = default
    Fonts : ^ImFontAtlas = default
    FontGlobalScale : f32 = default
    FontAllowUserScaling : bool = default
    FontDefault : ^ImFont = default
    DisplayFramebufferScale : ImVec2 = default
    ConfigDockingNoSplit : bool = default
    ConfigDockingWithShift : bool = default
    ConfigDockingAlwaysTabBar : bool = default
    ConfigDockingTransparentPayload : bool = default
    ConfigViewportsNoAutoMerge : bool = default
    ConfigViewportsNoTaskBarIcon : bool = default
    ConfigViewportsNoDecoration : bool = default
    ConfigViewportsNoDefaultParent : bool = default
    MouseDrawCursor : bool = default
    ConfigMacOSXBehaviors : bool = default
    ConfigInputTextCursorBlink : bool = default
    ConfigWindowsResizeFromEdges : bool = default
    ConfigWindowsMoveFromTitleBarOnly : bool = default
    ConfigWindowsMemoryCompactTimer : f32 = default
    BackendPlatformName : ^char8 = default
    BackendRendererName : ^char8 = default
    BackendPlatformUserData : ^void = default
    BackendRendererUserData : ^void = default
    BackendLanguageUserData : ^void = default
    GetClipboardTextFn : fn(^void) -> ^char8 = default
    SetClipboardTextFn : fn(^void, ^char8) -> void = default
    ClipboardUserData : ^void = default
    RenderDrawListsFn : fn(^ImDrawData) -> void = default
    MousePos : ImVec2 = default
    MouseDown : [5]bool = default
    MouseWheel : f32 = default
    MouseWheelH : f32 = default
    MouseHoveredViewport : ImGuiID = default
    KeyCtrl : bool = default
    KeyShift : bool = default
    KeyAlt : bool = default
    KeySuper : bool = default
    KeysDown : [512]bool = default
    NavInputs : [21]f32 = default
    WantCaptureMouse : bool = default
    WantCaptureKeyboard : bool = default
    WantTextInput : bool = default
    WantSetMousePos : bool = default
    WantSaveIniSettings : bool = default
    NavActive : bool = default
    NavVisible : bool = default
    Framerate : f32 = default
    MetricsRenderVertices : i32 = default
    MetricsRenderIndices : i32 = default
    MetricsRenderWindows : i32 = default
    MetricsActiveWindows : i32 = default
    MetricsActiveAllocations : i32 = default
    MouseDelta : ImVec2 = default
    MousePosPrev : ImVec2 = default
    MouseClickedPos : [5]ImVec2 = default
    MouseClickedTime : [5]f64 = default
    MouseClicked : [5]bool = default
    MouseDoubleClicked : [5]bool = default
    MouseReleased : [5]bool = default
    MouseDownOwned : [5]bool = default
    MouseDownWasDoubleClick : [5]bool = default
    MouseDownDuration : [5]f32 = default
    MouseDownDurationPrev : [5]f32 = default
    MouseDragMaxDistanceAbs : [5]ImVec2 = default
    MouseDragMaxDistanceSqr : [5]f32 = default
    KeysDownDuration : [512]f32 = default
    KeysDownDurationPrev : [512]f32 = default
    NavInputsDownDuration : [21]f32 = default
    NavInputsDownDurationPrev : [21]f32 = default
    InputQueueCharacters : __UNKNOWN_16 = default
}
impl ImGuiIO {
    AddInputCharacter :: (&Self, _c: u32) {
        __c__ImGuiIO_AddInputCharacter_53(^*self, _c)
    }
    AddInputCharactersUTF8 :: (&Self, _str: ^char8) {
        __c__ImGuiIO_AddInputCharactersUTF8_54(^*self, _str)
    }
    ClearInputCharacters :: (&Self) {
        __c__ImGuiIO_ClearInputCharacters_55(^*self)
    }
    new :: () -> ImGuiIO {
        result : ImGuiIO = default
        __c__ImGuiIO_new_87(^result)
        return result
    }
}
ImGuiInputTextCallbackData :: struct #copy {
    EventFlag : ImGuiInputTextFlags = default
    Flags : ImGuiInputTextFlags = default
    UserData : ^void = default
    EventChar : ImWchar = default
    EventKey : ImGuiKey = default
    Buf : ^char8 = default
    BufTextLen : i32 = default
    BufSize : i32 = default
    BufDirty : bool = default
    CursorPos : i32 = default
    SelectionStart : i32 = default
    SelectionEnd : i32 = default
}
impl ImGuiInputTextCallbackData {
    new :: () -> ImGuiInputTextCallbackData {
        result : ImGuiInputTextCallbackData = default
        __c__ImGuiInputTextCallbackData_new_12(^result)
        return result
    }
    DeleteChars :: (&Self, _pos: i32, _bytes_count: i32) {
        __c__ImGuiInputTextCallbackData_DeleteChars_13(^*self, _pos, _bytes_count)
    }
    InsertChars :: (&Self, _pos: i32, _text: ^char8, _text_end: ^char8 = null) {
        __c__ImGuiInputTextCallbackData_InsertChars_14(^*self, _pos, _text, _text_end)
    }
    HasSelection :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiInputTextCallbackData_HasSelection_15(^*self, ^result)
        return result
    }
}
ImGuiSizeCallbackData :: struct #copy {
    UserData : ^void = default
    Pos : ImVec2 = default
    CurrentSize : ImVec2 = default
    DesiredSize : ImVec2 = default
}
ImGuiWindowClass :: struct #copy {
    ClassId : ImGuiID = default
    ParentViewportId : ImGuiID = default
    ViewportFlagsOverrideSet : ImGuiViewportFlags = default
    ViewportFlagsOverrideClear : ImGuiViewportFlags = default
    DockingAlwaysTabBar : bool = default
    DockingAllowUnclassed : bool = default
}
impl ImGuiWindowClass {
    new :: () -> ImGuiWindowClass {
        result : ImGuiWindowClass = default
        __c__ImGuiWindowClass_new_6(^result)
        return result
    }
}
ImGuiPayload :: struct #copy {
    Data : ^void = default
    DataSize : i32 = default
    SourceId : ImGuiID = default
    SourceParentId : ImGuiID = default
    DataFrameCount : i32 = default
    DataType : [33]char8 = default
    Preview : bool = default
    Delivery : bool = default
}
impl ImGuiPayload {
    new :: () -> ImGuiPayload {
        result : ImGuiPayload = default
        __c__ImGuiPayload_new_8(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImGuiPayload_Clear_9(^*self)
    }
    IsDataType :: (&Self, _type: ^char8) -> bool {
        result : bool = default
        __c__ImGuiPayload_IsDataType_10(^*self, ^result, _type)
        return result
    }
    IsPreview :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiPayload_IsPreview_11(^*self, ^result)
        return result
    }
    IsDelivery :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiPayload_IsDelivery_12(^*self, ^result)
        return result
    }
}
ImGuiOnceUponAFrame :: struct #copy {
    RefFrame : i32 = default
}
impl ImGuiOnceUponAFrame {
    new :: () -> ImGuiOnceUponAFrame {
        result : ImGuiOnceUponAFrame = default
        __c__ImGuiOnceUponAFrame_new_0(^result)
        return result
    }
}
ImGuiTextFilter :: struct #copy {
    InputBuf : [256]char8 = default
    Filters : __UNKNOWN_16 = default
    CountGrep : i32 = default
}
impl ImGuiTextFilter {
    new :: (_default_filter: ^char8 = "") -> ImGuiTextFilter {
        result : ImGuiTextFilter = default
        __c__ImGuiTextFilter_new_0(^result, _default_filter)
        return result
    }
    Draw :: (&Self, _label: ^char8 = "Filter (inc,-exc)", _width: f32 = 0.0f) -> bool {
        result : bool = default
        __c__ImGuiTextFilter_Draw_1(^*self, ^result, _label, _width)
        return result
    }
    PassFilter :: (&Self, _text: ^char8, _text_end: ^char8 = null) -> bool {
        result : bool = default
        __c__ImGuiTextFilter_PassFilter_2(^*self, ^result, _text, _text_end)
        return result
    }
    Build :: (&Self) {
        __c__ImGuiTextFilter_Build_3(^*self)
    }
    Clear :: (&Self) {
        __c__ImGuiTextFilter_Clear_4(^*self)
    }
    IsActive :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiTextFilter_IsActive_5(^*self, ^result)
        return result
    }
}
ImGuiTextRange :: struct #copy {
    b : ^char8 = default
    e : ^char8 = default
}
impl ImGuiTextRange {
    new :: () -> ImGuiTextRange {
        result : ImGuiTextRange = default
        __c__ImGuiTextRange_new_2(^result)
        return result
    }
    new :: (__b: ^char8, __e: ^char8) -> ImGuiTextRange {
        result : ImGuiTextRange = default
        __c__ImGuiTextRange_new_3(^result, __b, __e)
        return result
    }
    empty :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiTextRange_empty_4(^*self, ^result)
        return result
    }
    split :: (&Self, _separator: char8, _out: ^__UNKNOWN_16) {
        __c__ImGuiTextRange_split_5(^*self, _separator, _out)
    }
}
ImGuiTextBuffer :: struct #copy {
    Buf : __UNKNOWN_16 = default
}
impl ImGuiTextBuffer {
    new :: () -> ImGuiTextBuffer {
        result : ImGuiTextBuffer = default
        __c__ImGuiTextBuffer_new_2(^result)
        return result
    }
    begin :: (&Self) -> ^char8 {
        result : ^char8 = default
        __c__ImGuiTextBuffer_begin_4(^*self, ^result)
        return result
    }
    end :: (&Self) -> ^char8 {
        result : ^char8 = default
        __c__ImGuiTextBuffer_end_5(^*self, ^result)
        return result
    }
    size :: (&Self) -> i32 {
        result : i32 = default
        __c__ImGuiTextBuffer_size_6(^*self, ^result)
        return result
    }
    empty :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiTextBuffer_empty_7(^*self, ^result)
        return result
    }
    clear :: (&Self) {
        __c__ImGuiTextBuffer_clear_8(^*self)
    }
    reserve :: (&Self, _capacity: i32) {
        __c__ImGuiTextBuffer_reserve_9(^*self, _capacity)
    }
    c_str :: (&Self) -> ^char8 {
        result : ^char8 = default
        __c__ImGuiTextBuffer_c_str_10(^*self, ^result)
        return result
    }
    append :: (&Self, _str: ^char8, _str_end: ^char8 = null) {
        __c__ImGuiTextBuffer_append_11(^*self, _str, _str_end)
    }
    appendf :: (&Self, _fmt: ^char8) {
        __c__ImGuiTextBuffer_appendf_12(^*self, _fmt)
    }
    appendfv :: (&Self, _fmt: ^char8, _args: va_list) {
        __c__ImGuiTextBuffer_appendfv_13(^*self, _fmt, _args)
    }
}
ImGuiStorage :: struct #copy {
    Data : __UNKNOWN_16 = default
}
impl ImGuiStorage {
    Clear :: (&Self) {
        __c__ImGuiStorage_Clear_2(^*self)
    }
    GetInt :: (&Self, _key: ImGuiID, _default_val: i32 = 0) -> i32 {
        result : i32 = default
        __c__ImGuiStorage_GetInt_3(^*self, ^result, _key, _default_val)
        return result
    }
    SetInt :: (&Self, _key: ImGuiID, _val: i32) {
        __c__ImGuiStorage_SetInt_4(^*self, _key, _val)
    }
    GetBool :: (&Self, _key: ImGuiID, _default_val: bool = false) -> bool {
        result : bool = default
        __c__ImGuiStorage_GetBool_5(^*self, ^result, _key, _default_val)
        return result
    }
    SetBool :: (&Self, _key: ImGuiID, _val: bool) {
        __c__ImGuiStorage_SetBool_6(^*self, _key, _val)
    }
    GetFloat :: (&Self, _key: ImGuiID, _default_val: f32 = 0.0f) -> f32 {
        result : f32 = default
        __c__ImGuiStorage_GetFloat_7(^*self, ^result, _key, _default_val)
        return result
    }
    SetFloat :: (&Self, _key: ImGuiID, _val: f32) {
        __c__ImGuiStorage_SetFloat_8(^*self, _key, _val)
    }
    GetVoidPtr :: (&Self, _key: ImGuiID) -> ^void {
        result : ^void = default
        __c__ImGuiStorage_GetVoidPtr_9(^*self, ^result, _key)
        return result
    }
    SetVoidPtr :: (&Self, _key: ImGuiID, _val: ^void) {
        __c__ImGuiStorage_SetVoidPtr_10(^*self, _key, _val)
    }
    GetIntRef :: (&Self, _key: ImGuiID, _default_val: i32 = 0) -> ^i32 {
        result : ^i32 = default
        __c__ImGuiStorage_GetIntRef_11(^*self, ^result, _key, _default_val)
        return result
    }
    GetBoolRef :: (&Self, _key: ImGuiID, _default_val: bool = false) -> ^bool {
        result : ^bool = default
        __c__ImGuiStorage_GetBoolRef_12(^*self, ^result, _key, _default_val)
        return result
    }
    GetFloatRef :: (&Self, _key: ImGuiID, _default_val: f32 = 0.0f) -> ^f32 {
        result : ^f32 = default
        __c__ImGuiStorage_GetFloatRef_13(^*self, ^result, _key, _default_val)
        return result
    }
    GetVoidPtrRef :: (&Self, _key: ImGuiID, _default_val: ^void = null) -> ^^void {
        result : ^^void = default
        __c__ImGuiStorage_GetVoidPtrRef_14(^*self, ^result, _key, _default_val)
        return result
    }
    SetAllInt :: (&Self, _val: i32) {
        __c__ImGuiStorage_SetAllInt_15(^*self, _val)
    }
    BuildSortByKey :: (&Self) {
        __c__ImGuiStorage_BuildSortByKey_16(^*self)
    }
}
ImGuiStoragePair :: struct #copy {
    key : ImGuiID = default
}
impl ImGuiStoragePair {
    new :: (__key: ImGuiID, __val_i: i32) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_2(^result, __key, __val_i)
        return result
    }
    new :: (__key: ImGuiID, __val_f: f32) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_3(^result, __key, __val_f)
        return result
    }
    new :: (__key: ImGuiID, __val_p: ^void) -> ImGuiStoragePair {
        result : ImGuiStoragePair = default
        __c__ImGuiStoragePair_new_4(^result, __key, __val_p)
        return result
    }
}
ImGuiListClipper :: struct #copy {
    StartPosY : f32 = default
    ItemsHeight : f32 = default
    ItemsCount : i32 = default
    StepNo : i32 = default
    DisplayStart : i32 = default
    DisplayEnd : i32 = default
}
impl ImGuiListClipper {
    new :: (_items_count: i32 = -1, _items_height: f32 = -1.0f) -> ImGuiListClipper {
        result : ImGuiListClipper = default
        __c__ImGuiListClipper_new_6(^result, _items_count, _items_height)
        return result
    }
    Step :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiListClipper_Step_8(^*self, ^result)
        return result
    }
    Begin :: (&Self, _items_count: i32, _items_height: f32 = -1.0f) {
        __c__ImGuiListClipper_Begin_9(^*self, _items_count, _items_height)
    }
    End :: (&Self) {
        __c__ImGuiListClipper_End_10(^*self)
    }
}
impl Drop for ImGuiListClipper {
    drop :: (&Self) {
        __c__ImGuiListClipper_dtor(^*self)
    }
}
ImColor :: struct #copy {
    Value : ImVec4 = default
}
impl ImColor {
    new :: () -> ImColor {
        result : ImColor = default
        __c__ImColor_new_1(^result)
        return result
    }
    new :: (_r: i32, _g: i32, _b: i32, _a: i32 = 255) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_2(^result, _r, _g, _b, _a)
        return result
    }
    new :: (_rgba: ImU32) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_3(^result, _rgba)
        return result
    }
    new :: (_r: f32, _g: f32, _b: f32, _a: f32 = 1.0f) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_4(^result, _r, _g, _b, _a)
        return result
    }
    new :: (_col: &ImVec4) -> ImColor {
        result : ImColor = default
        __c__ImColor_new_5(^result, ^*_col)
        return result
    }
    SetHSV :: (&Self, _h: f32, _s: f32, _v: f32, _a: f32 = 1.0f) {
        __c__ImColor_SetHSV_8(^*self, _h, _s, _v, _a)
    }
    HSV :: (&Self, _h: f32, _s: f32, _v: f32, _a: f32 = 1.0f) -> ImColor {
        result : ImColor = default
        __c__ImColor_HSV_9(^*self, ^result, _h, _s, _v, _a)
        return result
    }
}
ImDrawCmd :: struct #copy {
    ElemCount : u32 = default
    ClipRect : ImVec4 = default
    TextureId : ImTextureID = default
    VtxOffset : u32 = default
    IdxOffset : u32 = default
    UserCallback : ImDrawCallback = default
    UserCallbackData : ^void = default
}
impl ImDrawCmd {
    new :: () -> ImDrawCmd {
        result : ImDrawCmd = default
        __c__ImDrawCmd_new_7(^result)
        return result
    }
}
ImDrawVert :: struct #copy {
    pos : ImVec2 = default
    uv : ImVec2 = default
    col : ImU32 = default
}
ImDrawChannel :: struct #copy {
    _CmdBuffer : __UNKNOWN_16 = default
    _IdxBuffer : __UNKNOWN_16 = default
}
ImDrawListSplitter :: struct #copy {
    _Current : i32 = default
    _Count : i32 = default
    _Channels : __UNKNOWN_16 = default
}
impl ImDrawListSplitter {
    new :: () -> ImDrawListSplitter {
        result : ImDrawListSplitter = default
        __c__ImDrawListSplitter_new_3(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImDrawListSplitter_Clear_5(^*self)
    }
    ClearFreeMemory :: (&Self) {
        __c__ImDrawListSplitter_ClearFreeMemory_6(^*self)
    }
    Split :: (&Self, _draw_list: ^ImDrawList, _count: i32) {
        __c__ImDrawListSplitter_Split_7(^*self, _draw_list, _count)
    }
    Merge :: (&Self, _draw_list: ^ImDrawList) {
        __c__ImDrawListSplitter_Merge_8(^*self, _draw_list)
    }
    SetCurrentChannel :: (&Self, _draw_list: ^ImDrawList, _channel_idx: i32) {
        __c__ImDrawListSplitter_SetCurrentChannel_9(^*self, _draw_list, _channel_idx)
    }
}
impl Drop for ImDrawListSplitter {
    drop :: (&Self) {
        __c__ImDrawListSplitter_dtor(^*self)
    }
}
ImDrawList :: struct #copy {
    CmdBuffer : __UNKNOWN_16 = default
    IdxBuffer : __UNKNOWN_16 = default
    VtxBuffer : __UNKNOWN_16 = default
    Flags : ImDrawListFlags = default
    _Data : ^ImDrawListSharedData = default
    _OwnerName : ^char8 = default
    _VtxCurrentOffset : u32 = default
    _VtxCurrentIdx : u32 = default
    _VtxWritePtr : ^ImDrawVert = default
    _IdxWritePtr : ^ImDrawIdx = default
    _ClipRectStack : __UNKNOWN_16 = default
    _TextureIdStack : __UNKNOWN_16 = default
    _Path : __UNKNOWN_16 = default
    _Splitter : ImDrawListSplitter = default
}
impl ImDrawList {
    new :: (_shared_data: ^ImDrawListSharedData) -> ImDrawList {
        result : ImDrawList = default
        __c__ImDrawList_new_14(^result, _shared_data)
        return result
    }
    PushClipRect :: (&Self, _clip_rect_min: ImVec2, _clip_rect_max: ImVec2, _intersect_with_current_clip_rect: bool = false) {
        __c__ImDrawList_PushClipRect_16(^*self, ^_clip_rect_min, ^_clip_rect_max, _intersect_with_current_clip_rect)
    }
    PushClipRectFullScreen :: (&Self) {
        __c__ImDrawList_PushClipRectFullScreen_17(^*self)
    }
    PopClipRect :: (&Self) {
        __c__ImDrawList_PopClipRect_18(^*self)
    }
    PushTextureID :: (&Self, _texture_id: ImTextureID) {
        __c__ImDrawList_PushTextureID_19(^*self, _texture_id)
    }
    PopTextureID :: (&Self) {
        __c__ImDrawList_PopTextureID_20(^*self)
    }
    GetClipRectMin :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImDrawList_GetClipRectMin_21(^*self, ^result)
        return result
    }
    GetClipRectMax :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImDrawList_GetClipRectMax_22(^*self, ^result)
        return result
    }
    AddLine :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _col: ImU32, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddLine_23(^*self, ^*_p1, ^*_p2, _col, _thickness)
    }
    AddRect :: (&Self, _p_min: &ImVec2, _p_max: &ImVec2, _col: ImU32, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddRect_24(^*self, ^*_p_min, ^*_p_max, _col, _rounding, _rounding_corners, _thickness)
    }
    AddRectFilled :: (&Self, _p_min: &ImVec2, _p_max: &ImVec2, _col: ImU32, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All) {
        __c__ImDrawList_AddRectFilled_25(^*self, ^*_p_min, ^*_p_max, _col, _rounding, _rounding_corners)
    }
    AddRectFilledMultiColor :: (&Self, _p_min: &ImVec2, _p_max: &ImVec2, _col_upr_left: ImU32, _col_upr_right: ImU32, _col_bot_right: ImU32, _col_bot_left: ImU32) {
        __c__ImDrawList_AddRectFilledMultiColor_26(^*self, ^*_p_min, ^*_p_max, _col_upr_left, _col_upr_right, _col_bot_right, _col_bot_left)
    }
    AddQuad :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _col: ImU32, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddQuad_27(^*self, ^*_p1, ^*_p2, ^*_p3, ^*_p4, _col, _thickness)
    }
    AddQuadFilled :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _col: ImU32) {
        __c__ImDrawList_AddQuadFilled_28(^*self, ^*_p1, ^*_p2, ^*_p3, ^*_p4, _col)
    }
    AddTriangle :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _col: ImU32, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddTriangle_29(^*self, ^*_p1, ^*_p2, ^*_p3, _col, _thickness)
    }
    AddTriangleFilled :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _col: ImU32) {
        __c__ImDrawList_AddTriangleFilled_30(^*self, ^*_p1, ^*_p2, ^*_p3, _col)
    }
    AddCircle :: (&Self, _center: &ImVec2, _radius: f32, _col: ImU32, _num_segments: i32 = 12, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddCircle_31(^*self, ^*_center, _radius, _col, _num_segments, _thickness)
    }
    AddCircleFilled :: (&Self, _center: &ImVec2, _radius: f32, _col: ImU32, _num_segments: i32 = 12) {
        __c__ImDrawList_AddCircleFilled_32(^*self, ^*_center, _radius, _col, _num_segments)
    }
    AddNgon :: (&Self, _center: &ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32 = 1.0f) {
        __c__ImDrawList_AddNgon_33(^*self, ^*_center, _radius, _col, _num_segments, _thickness)
    }
    AddNgonFilled :: (&Self, _center: &ImVec2, _radius: f32, _col: ImU32, _num_segments: i32) {
        __c__ImDrawList_AddNgonFilled_34(^*self, ^*_center, _radius, _col, _num_segments)
    }
    AddText :: (&Self, _pos: &ImVec2, _col: ImU32, _text: string) {
        __c__ImDrawList_AddText_35(^*self, ^*_pos, _col, cast _text.bytes.data, cast(^char8) int(_text.bytes.data) + _text.bytes.length)
    }
    AddText_2 :: (&Self, _font: ^ImFont, _font_size: f32, _pos: &ImVec2, _col: ImU32, _text: string, _wrap_width: f32 = 0.0f, _cpu_fine_clip_rect: ^ImVec4 = null) {
        __c__ImDrawList_AddText_36(^*self, _font, _font_size, ^*_pos, _col, cast _text.bytes.data, cast(^char8) int(_text.bytes.data) + _text.bytes.length, _wrap_width, _cpu_fine_clip_rect)
    }
    AddPolyline :: (&Self, _points: ^ImVec2, _num_points: i32, _col: ImU32, _closed: bool, _thickness: f32) {
        __c__ImDrawList_AddPolyline_37(^*self, _points, _num_points, _col, _closed, _thickness)
    }
    AddConvexPolyFilled :: (&Self, _points: ^ImVec2, _num_points: i32, _col: ImU32) {
        __c__ImDrawList_AddConvexPolyFilled_38(^*self, _points, _num_points, _col)
    }
    AddBezierCurve :: (&Self, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _col: ImU32, _thickness: f32, _num_segments: i32 = 0) {
        __c__ImDrawList_AddBezierCurve_39(^*self, ^*_p1, ^*_p2, ^*_p3, ^*_p4, _col, _thickness, _num_segments)
    }
    AddImage :: (&Self, _user_texture_id: ImTextureID, _p_min: &ImVec2, _p_max: &ImVec2, _uv_min: &ImVec2, _uv_max: &ImVec2, _col: ImU32) {
        __c__ImDrawList_AddImage_40(^*self, _user_texture_id, ^*_p_min, ^*_p_max, ^*_uv_min, ^*_uv_max, _col)
    }
    AddImageQuad :: (&Self, _user_texture_id: ImTextureID, _p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _uv1: &ImVec2, _uv2: &ImVec2, _uv3: &ImVec2, _uv4: &ImVec2, _col: ImU32) {
        __c__ImDrawList_AddImageQuad_41(^*self, _user_texture_id, ^*_p1, ^*_p2, ^*_p3, ^*_p4, ^*_uv1, ^*_uv2, ^*_uv3, ^*_uv4, _col)
    }
    AddImageRounded :: (&Self, _user_texture_id: ImTextureID, _p_min: &ImVec2, _p_max: &ImVec2, _uv_min: &ImVec2, _uv_max: &ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All) {
        __c__ImDrawList_AddImageRounded_42(^*self, _user_texture_id, ^*_p_min, ^*_p_max, ^*_uv_min, ^*_uv_max, _col, _rounding, _rounding_corners)
    }
    PathClear :: (&Self) {
        __c__ImDrawList_PathClear_43(^*self)
    }
    PathLineTo :: (&Self, _pos: &ImVec2) {
        __c__ImDrawList_PathLineTo_44(^*self, ^*_pos)
    }
    PathLineToMergeDuplicate :: (&Self, _pos: &ImVec2) {
        __c__ImDrawList_PathLineToMergeDuplicate_45(^*self, ^*_pos)
    }
    PathFillConvex :: (&Self, _col: ImU32) {
        __c__ImDrawList_PathFillConvex_46(^*self, _col)
    }
    PathStroke :: (&Self, _col: ImU32, _closed: bool, _thickness: f32 = 1.0f) {
        __c__ImDrawList_PathStroke_47(^*self, _col, _closed, _thickness)
    }
    PathArcTo :: (&Self, _center: &ImVec2, _radius: f32, _a_min: f32, _a_max: f32, _num_segments: i32 = 10) {
        __c__ImDrawList_PathArcTo_48(^*self, ^*_center, _radius, _a_min, _a_max, _num_segments)
    }
    PathArcToFast :: (&Self, _center: &ImVec2, _radius: f32, _a_min_of_12: i32, _a_max_of_12: i32) {
        __c__ImDrawList_PathArcToFast_49(^*self, ^*_center, _radius, _a_min_of_12, _a_max_of_12)
    }
    PathBezierCurveTo :: (&Self, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _num_segments: i32 = 0) {
        __c__ImDrawList_PathBezierCurveTo_50(^*self, ^*_p2, ^*_p3, ^*_p4, _num_segments)
    }
    PathRect :: (&Self, _rect_min: &ImVec2, _rect_max: &ImVec2, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All) {
        __c__ImDrawList_PathRect_51(^*self, ^*_rect_min, ^*_rect_max, _rounding, _rounding_corners)
    }
    AddCallback :: (&Self, _callback: ImDrawCallback, _callback_data: ^void) {
        __c__ImDrawList_AddCallback_52(^*self, _callback, _callback_data)
    }
    AddDrawCmd :: (&Self) {
        __c__ImDrawList_AddDrawCmd_53(^*self)
    }
    CloneOutput :: (&Self) -> ^ImDrawList {
        result : ^ImDrawList = default
        __c__ImDrawList_CloneOutput_54(^*self, ^result)
        return result
    }
    ChannelsSplit :: (&Self, _count: i32) {
        __c__ImDrawList_ChannelsSplit_55(^*self, _count)
    }
    ChannelsMerge :: (&Self) {
        __c__ImDrawList_ChannelsMerge_56(^*self)
    }
    ChannelsSetCurrent :: (&Self, _n: i32) {
        __c__ImDrawList_ChannelsSetCurrent_57(^*self, _n)
    }
    Clear :: (&Self) {
        __c__ImDrawList_Clear_58(^*self)
    }
    ClearFreeMemory :: (&Self) {
        __c__ImDrawList_ClearFreeMemory_59(^*self)
    }
    PrimReserve :: (&Self, _idx_count: i32, _vtx_count: i32) {
        __c__ImDrawList_PrimReserve_60(^*self, _idx_count, _vtx_count)
    }
    PrimUnreserve :: (&Self, _idx_count: i32, _vtx_count: i32) {
        __c__ImDrawList_PrimUnreserve_61(^*self, _idx_count, _vtx_count)
    }
    PrimRect :: (&Self, _a: &ImVec2, _b: &ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimRect_62(^*self, ^*_a, ^*_b, _col)
    }
    PrimRectUV :: (&Self, _a: &ImVec2, _b: &ImVec2, _uv_a: &ImVec2, _uv_b: &ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimRectUV_63(^*self, ^*_a, ^*_b, ^*_uv_a, ^*_uv_b, _col)
    }
    PrimQuadUV :: (&Self, _a: &ImVec2, _b: &ImVec2, _c: &ImVec2, _d: &ImVec2, _uv_a: &ImVec2, _uv_b: &ImVec2, _uv_c: &ImVec2, _uv_d: &ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimQuadUV_64(^*self, ^*_a, ^*_b, ^*_c, ^*_d, ^*_uv_a, ^*_uv_b, ^*_uv_c, ^*_uv_d, _col)
    }
    PrimWriteVtx :: (&Self, _pos: &ImVec2, _uv: &ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimWriteVtx_65(^*self, ^*_pos, ^*_uv, _col)
    }
    PrimWriteIdx :: (&Self, _idx: ImDrawIdx) {
        __c__ImDrawList_PrimWriteIdx_66(^*self, _idx)
    }
    PrimVtx :: (&Self, _pos: &ImVec2, _uv: &ImVec2, _col: ImU32) {
        __c__ImDrawList_PrimVtx_67(^*self, ^*_pos, ^*_uv, _col)
    }
    UpdateClipRect :: (&Self) {
        __c__ImDrawList_UpdateClipRect_68(^*self)
    }
    UpdateTextureID :: (&Self) {
        __c__ImDrawList_UpdateTextureID_69(^*self)
    }
}
impl Drop for ImDrawList {
    drop :: (&Self) {
        __c__ImDrawList_dtor(^*self)
    }
}
ImDrawData :: struct #copy {
    Valid : bool = default
    CmdLists : ^^ImDrawList = default
    CmdListsCount : i32 = default
    TotalIdxCount : i32 = default
    TotalVtxCount : i32 = default
    DisplayPos : ImVec2 = default
    DisplaySize : ImVec2 = default
    FramebufferScale : ImVec2 = default
    OwnerViewport : ^ImGuiViewport = default
}
impl ImDrawData {
    new :: () -> ImDrawData {
        result : ImDrawData = default
        __c__ImDrawData_new_9(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImDrawData_Clear_11(^*self)
    }
    DeIndexAllBuffers :: (&Self) {
        __c__ImDrawData_DeIndexAllBuffers_12(^*self)
    }
    ScaleClipRects :: (&Self, _fb_scale: &ImVec2) {
        __c__ImDrawData_ScaleClipRects_13(^*self, ^*_fb_scale)
    }
}
impl Drop for ImDrawData {
    drop :: (&Self) {
        __c__ImDrawData_dtor(^*self)
    }
}
ImFontConfig :: struct #copy {
    FontData : ^void = default
    FontDataSize : i32 = default
    FontDataOwnedByAtlas : bool = default
    FontNo : i32 = default
    SizePixels : f32 = default
    OversampleH : i32 = default
    OversampleV : i32 = default
    PixelSnapH : bool = default
    GlyphExtraSpacing : ImVec2 = default
    GlyphOffset : ImVec2 = default
    GlyphRanges : ^ImWchar = default
    GlyphMinAdvanceX : f32 = default
    GlyphMaxAdvanceX : f32 = default
    MergeMode : bool = default
    RasterizerFlags : u32 = default
    RasterizerMultiply : f32 = default
    EllipsisChar : ImWchar = default
    Name : [40]char8 = default
    DstFont : ^ImFont = default
}
impl ImFontConfig {
    new :: () -> ImFontConfig {
        result : ImFontConfig = default
        __c__ImFontConfig_new_19(^result)
        return result
    }
}
ImFontGlyph :: struct #copy {
    Codepoint : ImWchar = default
    AdvanceX : f32 = default
    X0 : f32 = default
    Y0 : f32 = default
    X1 : f32 = default
    Y1 : f32 = default
    U0 : f32 = default
    V0 : f32 = default
    U1 : f32 = default
    V1 : f32 = default
}
ImFontGlyphRangesBuilder :: struct #copy {
    UsedChars : __UNKNOWN_16 = default
}
impl ImFontGlyphRangesBuilder {
    new :: () -> ImFontGlyphRangesBuilder {
        result : ImFontGlyphRangesBuilder = default
        __c__ImFontGlyphRangesBuilder_new_1(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImFontGlyphRangesBuilder_Clear_2(^*self)
    }
    GetBit :: (&Self, _n: i32) -> bool {
        result : bool = default
        __c__ImFontGlyphRangesBuilder_GetBit_3(^*self, ^result, _n)
        return result
    }
    SetBit :: (&Self, _n: i32) {
        __c__ImFontGlyphRangesBuilder_SetBit_4(^*self, _n)
    }
    AddChar :: (&Self, _c: ImWchar) {
        __c__ImFontGlyphRangesBuilder_AddChar_5(^*self, _c)
    }
    AddText :: (&Self, _text: ^char8, _text_end: ^char8 = null) {
        __c__ImFontGlyphRangesBuilder_AddText_6(^*self, _text, _text_end)
    }
    AddRanges :: (&Self, _ranges: ^ImWchar) {
        __c__ImFontGlyphRangesBuilder_AddRanges_7(^*self, _ranges)
    }
    BuildRanges :: (&Self, _out_ranges: ^__UNKNOWN_16) {
        __c__ImFontGlyphRangesBuilder_BuildRanges_8(^*self, _out_ranges)
    }
}
ImFontAtlasCustomRect :: struct #copy {
    ID : u32 = default
    Width : u16 = default
    Height : u16 = default
    X : u16 = default
    Y : u16 = default
    GlyphAdvanceX : f32 = default
    GlyphOffset : ImVec2 = default
    Font : ^ImFont = default
}
impl ImFontAtlasCustomRect {
    new :: () -> ImFontAtlasCustomRect {
        result : ImFontAtlasCustomRect = default
        __c__ImFontAtlasCustomRect_new_8(^result)
        return result
    }
    IsPacked :: (&Self) -> bool {
        result : bool = default
        __c__ImFontAtlasCustomRect_IsPacked_9(^*self, ^result)
        return result
    }
}
ImFontAtlas :: struct #copy {
    Locked : bool = default
    Flags : ImFontAtlasFlags = default
    TexID : ImTextureID = default
    TexDesiredWidth : i32 = default
    TexGlyphPadding : i32 = default
    TexPixelsAlpha8 : ^u8 = default
    TexPixelsRGBA32 : ^u32 = default
    TexWidth : i32 = default
    TexHeight : i32 = default
    TexUvScale : ImVec2 = default
    TexUvWhitePixel : ImVec2 = default
    Fonts : __UNKNOWN_16 = default
    CustomRects : __UNKNOWN_16 = default
    ConfigData : __UNKNOWN_16 = default
    CustomRectIds : [1]i32 = default
}
impl ImFontAtlas {
    new :: () -> ImFontAtlas {
        result : ImFontAtlas = default
        __c__ImFontAtlas_new_0(^result)
        return result
    }
    AddFont :: (&Self, _font_cfg: ^ImFontConfig) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFont_2(^*self, ^result, _font_cfg)
        return result
    }
    AddFontDefault :: (&Self, _font_cfg: ^ImFontConfig = null) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFontDefault_3(^*self, ^result, _font_cfg)
        return result
    }
    AddFontFromFileTTF :: (&Self, _filename: ^char8, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFontFromFileTTF_4(^*self, ^result, _filename, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryTTF :: (&Self, _font_data: ^void, _font_size: i32, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryTTF_5(^*self, ^result, _font_data, _font_size, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryCompressedTTF :: (&Self, _compressed_font_data: ^void, _compressed_font_size: i32, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryCompressedTTF_6(^*self, ^result, _compressed_font_data, _compressed_font_size, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    AddFontFromMemoryCompressedBase85TTF :: (&Self, _compressed_font_data_base85: ^char8, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null) -> ^ImFont {
        result : ^ImFont = default
        __c__ImFontAtlas_AddFontFromMemoryCompressedBase85TTF_7(^*self, ^result, _compressed_font_data_base85, _size_pixels, _font_cfg, _glyph_ranges)
        return result
    }
    ClearInputData :: (&Self) {
        __c__ImFontAtlas_ClearInputData_8(^*self)
    }
    ClearTexData :: (&Self) {
        __c__ImFontAtlas_ClearTexData_9(^*self)
    }
    ClearFonts :: (&Self) {
        __c__ImFontAtlas_ClearFonts_10(^*self)
    }
    Clear :: (&Self) {
        __c__ImFontAtlas_Clear_11(^*self)
    }
    Build :: (&Self) -> bool {
        result : bool = default
        __c__ImFontAtlas_Build_12(^*self, ^result)
        return result
    }
    GetTexDataAsAlpha8 :: (&Self, _out_pixels: ^^u8, _out_width: ^i32, _out_height: ^i32, _out_bytes_per_pixel: ^i32 = null) {
        __c__ImFontAtlas_GetTexDataAsAlpha8_13(^*self, _out_pixels, _out_width, _out_height, _out_bytes_per_pixel)
    }
    GetTexDataAsRGBA32 :: (&Self, _out_pixels: ^^u8, _out_width: ^i32, _out_height: ^i32, _out_bytes_per_pixel: ^i32 = null) {
        __c__ImFontAtlas_GetTexDataAsRGBA32_14(^*self, _out_pixels, _out_width, _out_height, _out_bytes_per_pixel)
    }
    IsBuilt :: (&Self) -> bool {
        result : bool = default
        __c__ImFontAtlas_IsBuilt_15(^*self, ^result)
        return result
    }
    SetTexID :: (&Self, _id: ImTextureID) {
        __c__ImFontAtlas_SetTexID_16(^*self, _id)
    }
    GetGlyphRangesDefault :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesDefault_17(^*self, ^result)
        return result
    }
    GetGlyphRangesKorean :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesKorean_18(^*self, ^result)
        return result
    }
    GetGlyphRangesJapanese :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesJapanese_19(^*self, ^result)
        return result
    }
    GetGlyphRangesChineseFull :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesChineseFull_20(^*self, ^result)
        return result
    }
    GetGlyphRangesChineseSimplifiedCommon :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon_21(^*self, ^result)
        return result
    }
    GetGlyphRangesCyrillic :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesCyrillic_22(^*self, ^result)
        return result
    }
    GetGlyphRangesThai :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesThai_23(^*self, ^result)
        return result
    }
    GetGlyphRangesVietnamese :: (&Self) -> ^ImWchar {
        result : ^ImWchar = default
        __c__ImFontAtlas_GetGlyphRangesVietnamese_24(^*self, ^result)
        return result
    }
    AddCustomRectRegular :: (&Self, _id: u32, _width: i32, _height: i32) -> i32 {
        result : i32 = default
        __c__ImFontAtlas_AddCustomRectRegular_25(^*self, ^result, _id, _width, _height)
        return result
    }
    AddCustomRectFontGlyph :: (&Self, _font: ^ImFont, _id: ImWchar, _width: i32, _height: i32, _advance_x: f32, _offset: &ImVec2) -> i32 {
        result : i32 = default
        __c__ImFontAtlas_AddCustomRectFontGlyph_26(^*self, ^result, _font, _id, _width, _height, _advance_x, ^*_offset)
        return result
    }
    GetCustomRectByIndex :: (&Self, _index: i32) -> ^ImFontAtlasCustomRect {
        result : ^ImFontAtlasCustomRect = default
        __c__ImFontAtlas_GetCustomRectByIndex_27(^*self, ^result, _index)
        return result
    }
    CalcCustomRectUV :: (&Self, _rect: ^ImFontAtlasCustomRect, _out_uv_min: ^ImVec2, _out_uv_max: ^ImVec2) {
        __c__ImFontAtlas_CalcCustomRectUV_28(^*self, _rect, _out_uv_min, _out_uv_max)
    }
    GetMouseCursorTexData :: (&Self, _cursor: ImGuiMouseCursor, _out_offset: ^ImVec2, _out_size: ^ImVec2, _out_uv_border: ^ImVec2, _out_uv_fill: ^ImVec2) -> bool {
        result : bool = default
        __c__ImFontAtlas_GetMouseCursorTexData_29(^*self, ^result, _cursor, _out_offset, _out_size, _out_uv_border, _out_uv_fill)
        return result
    }
}
impl Drop for ImFontAtlas {
    drop :: (&Self) {
        __c__ImFontAtlas_dtor(^*self)
    }
}
ImFont :: struct #copy {
    IndexAdvanceX : __UNKNOWN_16 = default
    FallbackAdvanceX : f32 = default
    FontSize : f32 = default
    IndexLookup : __UNKNOWN_16 = default
    Glyphs : __UNKNOWN_16 = default
    FallbackGlyph : ^ImFontGlyph = default
    DisplayOffset : ImVec2 = default
    ContainerAtlas : ^ImFontAtlas = default
    ConfigData : ^ImFontConfig = default
    ConfigDataCount : i16 = default
    FallbackChar : ImWchar = default
    EllipsisChar : ImWchar = default
    Scale : f32 = default
    Ascent : f32 = default
    Descent : f32 = default
    MetricsTotalSurface : i32 = default
    DirtyLookupTables : bool = default
}
impl ImFont {
    new :: () -> ImFont {
        result : ImFont = default
        __c__ImFont_new_17(^result)
        return result
    }
    FindGlyph :: (&Self, _c: ImWchar) -> ^ImFontGlyph {
        result : ^ImFontGlyph = default
        __c__ImFont_FindGlyph_19(^*self, ^result, _c)
        return result
    }
    FindGlyphNoFallback :: (&Self, _c: ImWchar) -> ^ImFontGlyph {
        result : ^ImFontGlyph = default
        __c__ImFont_FindGlyphNoFallback_20(^*self, ^result, _c)
        return result
    }
    GetCharAdvance :: (&Self, _c: ImWchar) -> f32 {
        result : f32 = default
        __c__ImFont_GetCharAdvance_21(^*self, ^result, _c)
        return result
    }
    IsLoaded :: (&Self) -> bool {
        result : bool = default
        __c__ImFont_IsLoaded_22(^*self, ^result)
        return result
    }
    GetDebugName :: (&Self) -> ^char8 {
        result : ^char8 = default
        __c__ImFont_GetDebugName_23(^*self, ^result)
        return result
    }
    CalcTextSizeA :: (&Self, _size: f32, _max_width: f32, _wrap_width: f32, _text_begin: ^char8, _text_end: ^char8 = null, _remaining: ^^char8 = null) -> ImVec2 {
        result : ImVec2 = default
        __c__ImFont_CalcTextSizeA_24(^*self, ^result, _size, _max_width, _wrap_width, _text_begin, _text_end, _remaining)
        return result
    }
    CalcWordWrapPositionA :: (&Self, _scale: f32, _text: ^char8, _text_end: ^char8, _wrap_width: f32) -> ^char8 {
        result : ^char8 = default
        __c__ImFont_CalcWordWrapPositionA_25(^*self, ^result, _scale, _text, _text_end, _wrap_width)
        return result
    }
    RenderChar :: (&Self, _draw_list: ^ImDrawList, _size: f32, _pos: ImVec2, _col: ImU32, _c: ImWchar) {
        __c__ImFont_RenderChar_26(^*self, _draw_list, _size, ^_pos, _col, _c)
    }
    RenderText :: (&Self, _draw_list: ^ImDrawList, _size: f32, _pos: ImVec2, _col: ImU32, _clip_rect: &ImVec4, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32 = 0.0f, _cpu_fine_clip: bool = false) {
        __c__ImFont_RenderText_27(^*self, _draw_list, _size, ^_pos, _col, ^*_clip_rect, _text_begin, _text_end, _wrap_width, _cpu_fine_clip)
    }
    BuildLookupTable :: (&Self) {
        __c__ImFont_BuildLookupTable_28(^*self)
    }
    ClearOutputData :: (&Self) {
        __c__ImFont_ClearOutputData_29(^*self)
    }
    GrowIndex :: (&Self, _new_size: i32) {
        __c__ImFont_GrowIndex_30(^*self, _new_size)
    }
    AddGlyph :: (&Self, _c: ImWchar, _x0: f32, _y0: f32, _x1: f32, _y1: f32, _u0: f32, _v0: f32, _u1: f32, _v1: f32, _advance_x: f32) {
        __c__ImFont_AddGlyph_31(^*self, _c, _x0, _y0, _x1, _y1, _u0, _v0, _u1, _v1, _advance_x)
    }
    AddRemapChar :: (&Self, _dst: ImWchar, _src: ImWchar, _overwrite_dst: bool = true) {
        __c__ImFont_AddRemapChar_32(^*self, _dst, _src, _overwrite_dst)
    }
    SetFallbackChar :: (&Self, _c: ImWchar) {
        __c__ImFont_SetFallbackChar_33(^*self, _c)
    }
}
impl Drop for ImFont {
    drop :: (&Self) {
        __c__ImFont_dtor(^*self)
    }
}
ImGuiPlatformMonitor :: struct #copy {
    MainPos : ImVec2 = default
    MainSize : ImVec2 = default
    WorkPos : ImVec2 = default
    WorkSize : ImVec2 = default
    DpiScale : f32 = default
}
impl ImGuiPlatformMonitor {
    new :: () -> ImGuiPlatformMonitor {
        result : ImGuiPlatformMonitor = default
        __c__ImGuiPlatformMonitor_new_5(^result)
        return result
    }
}
ImGuiPlatformIO :: struct #copy {
    Platform_CreateWindow : fn(^ImGuiViewport) -> void = default
    Platform_DestroyWindow : fn(^ImGuiViewport) -> void = default
    Platform_ShowWindow : fn(^ImGuiViewport) -> void = default
    Platform_SetWindowPos : fn(^ImGuiViewport, ImVec2) -> void = default
    Platform_GetWindowPos : fn(^ImGuiViewport) -> ImVec2 = default
    Platform_SetWindowSize : fn(^ImGuiViewport, ImVec2) -> void = default
    Platform_GetWindowSize : fn(^ImGuiViewport) -> ImVec2 = default
    Platform_SetWindowFocus : fn(^ImGuiViewport) -> void = default
    Platform_GetWindowFocus : fn(^ImGuiViewport) -> bool = default
    Platform_GetWindowMinimized : fn(^ImGuiViewport) -> bool = default
    Platform_SetWindowTitle : fn(^ImGuiViewport, ^char8) -> void = default
    Platform_SetWindowAlpha : fn(^ImGuiViewport, f32) -> void = default
    Platform_UpdateWindow : fn(^ImGuiViewport) -> void = default
    Platform_RenderWindow : fn(^ImGuiViewport, ^void) -> void = default
    Platform_SwapBuffers : fn(^ImGuiViewport, ^void) -> void = default
    Platform_GetWindowDpiScale : fn(^ImGuiViewport) -> f32 = default
    Platform_OnChangedViewport : fn(^ImGuiViewport) -> void = default
    Platform_SetImeInputPos : fn(^ImGuiViewport, ImVec2) -> void = default
    Platform_CreateVkSurface : fn(^ImGuiViewport, ImU64, ^void, ^ImU64) -> i32 = default
    Renderer_CreateWindow : fn(^ImGuiViewport) -> void = default
    Renderer_DestroyWindow : fn(^ImGuiViewport) -> void = default
    Renderer_SetWindowSize : fn(^ImGuiViewport, ImVec2) -> void = default
    Renderer_RenderWindow : fn(^ImGuiViewport, ^void) -> void = default
    Renderer_SwapBuffers : fn(^ImGuiViewport, ^void) -> void = default
    Monitors : __UNKNOWN_16 = default
    MainViewport : ^ImGuiViewport = default
    Viewports : __UNKNOWN_16 = default
}
impl ImGuiPlatformIO {
    new :: () -> ImGuiPlatformIO {
        result : ImGuiPlatformIO = default
        __c__ImGuiPlatformIO_new_27(^result)
        return result
    }
}
ImGuiViewport :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiViewportFlags = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    DpiScale : f32 = default
    DrawData : ^ImDrawData = default
    ParentViewportId : ImGuiID = default
    RendererUserData : ^void = default
    PlatformUserData : ^void = default
    PlatformHandle : ^void = default
    PlatformHandleRaw : ^void = default
    PlatformRequestClose : bool = default
    PlatformRequestMove : bool = default
    PlatformRequestResize : bool = default
}
impl ImGuiViewport {
    new :: () -> ImGuiViewport {
        result : ImGuiViewport = default
        __c__ImGuiViewport_new_14(^result)
        return result
    }
}
impl Drop for ImGuiViewport {
    drop :: (&Self) {
        __c__ImGuiViewport_dtor(^*self)
    }
}
ImBoolVector :: struct #copy {
    Storage : __UNKNOWN_16 = default
}
impl ImBoolVector {
    new :: () -> ImBoolVector {
        result : ImBoolVector = default
        __c__ImBoolVector_new_1(^result)
        return result
    }
    Resize :: (&Self, _sz: i32) {
        __c__ImBoolVector_Resize_2(^*self, _sz)
    }
    Clear :: (&Self) {
        __c__ImBoolVector_Clear_3(^*self)
    }
    GetBit :: (&Self, _n: i32) -> bool {
        result : bool = default
        __c__ImBoolVector_GetBit_4(^*self, ^result, _n)
        return result
    }
    SetBit :: (&Self, _n: i32, _v: bool) {
        __c__ImBoolVector_SetBit_5(^*self, _n, _v)
    }
}
ImVec1 :: struct #copy {
    x : f32 = default
}
impl ImVec1 {
    new :: () -> ImVec1 {
        result : ImVec1 = default
        __c__ImVec1_new_1(^result)
        return result
    }
    new :: (__x: f32) -> ImVec1 {
        result : ImVec1 = default
        __c__ImVec1_new_2(^result, __x)
        return result
    }
}
ImVec2ih :: struct #copy {
    x : i16 = default
    y : i16 = default
}
impl ImVec2ih {
    new :: () -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_2(^result)
        return result
    }
    new :: (__x: i16, __y: i16) -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_3(^result, __x, __y)
        return result
    }
    new :: (_rhs: &ImVec2) -> ImVec2ih {
        result : ImVec2ih = default
        __c__ImVec2ih_new_4(^result, ^*_rhs)
        return result
    }
}
ImRect :: struct #copy {
    Min : ImVec2 = default
    Max : ImVec2 = default
}
impl ImRect {
    new :: () -> ImRect {
        result : ImRect = default
        __c__ImRect_new_2(^result)
        return result
    }
    new :: (_min: &ImVec2, _max: &ImVec2) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_3(^result, ^*_min, ^*_max)
        return result
    }
    new :: (_v: &ImVec4) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_4(^result, ^*_v)
        return result
    }
    new :: (_x1: f32, _y1: f32, _x2: f32, _y2: f32) -> ImRect {
        result : ImRect = default
        __c__ImRect_new_5(^result, _x1, _y1, _x2, _y2)
        return result
    }
    GetCenter :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetCenter_6(^*self, ^result)
        return result
    }
    GetSize :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetSize_7(^*self, ^result)
        return result
    }
    GetWidth :: (&Self) -> f32 {
        result : f32 = default
        __c__ImRect_GetWidth_8(^*self, ^result)
        return result
    }
    GetHeight :: (&Self) -> f32 {
        result : f32 = default
        __c__ImRect_GetHeight_9(^*self, ^result)
        return result
    }
    GetTL :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetTL_10(^*self, ^result)
        return result
    }
    GetTR :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetTR_11(^*self, ^result)
        return result
    }
    GetBL :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetBL_12(^*self, ^result)
        return result
    }
    GetBR :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImRect_GetBR_13(^*self, ^result)
        return result
    }
    Contains :: (&Self, _p: &ImVec2) -> bool {
        result : bool = default
        __c__ImRect_Contains_14(^*self, ^result, ^*_p)
        return result
    }
    Contains :: (&Self, _r: &ImRect) -> bool {
        result : bool = default
        __c__ImRect_Contains_15(^*self, ^result, ^*_r)
        return result
    }
    Overlaps :: (&Self, _r: &ImRect) -> bool {
        result : bool = default
        __c__ImRect_Overlaps_16(^*self, ^result, ^*_r)
        return result
    }
    Add :: (&Self, _p: &ImVec2) {
        __c__ImRect_Add_17(^*self, ^*_p)
    }
    Add :: (&Self, _r: &ImRect) {
        __c__ImRect_Add_18(^*self, ^*_r)
    }
    Expand :: (&Self, _amount: f32) {
        __c__ImRect_Expand_19(^*self, _amount)
    }
    Expand :: (&Self, _amount: &ImVec2) {
        __c__ImRect_Expand_20(^*self, ^*_amount)
    }
    Translate :: (&Self, _d: &ImVec2) {
        __c__ImRect_Translate_21(^*self, ^*_d)
    }
    TranslateX :: (&Self, _dx: f32) {
        __c__ImRect_TranslateX_22(^*self, _dx)
    }
    TranslateY :: (&Self, _dy: f32) {
        __c__ImRect_TranslateY_23(^*self, _dy)
    }
    ClipWith :: (&Self, _r: &ImRect) {
        __c__ImRect_ClipWith_24(^*self, ^*_r)
    }
    ClipWithFull :: (&Self, _r: &ImRect) {
        __c__ImRect_ClipWithFull_25(^*self, ^*_r)
    }
    Floor :: (&Self) {
        __c__ImRect_Floor_26(^*self)
    }
    IsInverted :: (&Self) -> bool {
        result : bool = default
        __c__ImRect_IsInverted_27(^*self, ^result)
        return result
    }
}
ImGuiDataTypeInfo :: struct #copy {
    Size : size_t = default
    PrintFmt : ^char8 = default
    ScanFmt : ^char8 = default
}
ImGuiColorMod :: struct #copy {
    Col : ImGuiCol = default
    BackupValue : ImVec4 = default
}
ImGuiStyleMod :: struct #copy {
    VarIdx : ImGuiStyleVar = default
}
impl ImGuiStyleMod {
    new :: (_idx: ImGuiStyleVar, _v: i32) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_2(^result, _idx, _v)
        return result
    }
    new :: (_idx: ImGuiStyleVar, _v: f32) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_3(^result, _idx, _v)
        return result
    }
    new :: (_idx: ImGuiStyleVar, _v: ImVec2) -> ImGuiStyleMod {
        result : ImGuiStyleMod = default
        __c__ImGuiStyleMod_new_4(^result, _idx, ^_v)
        return result
    }
}
ImGuiGroupData :: struct #copy {
    BackupCursorPos : ImVec2 = default
    BackupCursorMaxPos : ImVec2 = default
    BackupIndent : ImVec1 = default
    BackupGroupOffset : ImVec1 = default
    BackupCurrLineSize : ImVec2 = default
    BackupCurrLineTextBaseOffset : f32 = default
    BackupActiveIdIsAlive : ImGuiID = default
    BackupActiveIdPreviousFrameIsAlive : bool = default
    EmitItem : bool = default
}
ImGuiMenuColumns :: struct #copy {
    Spacing : f32 = default
    Width : f32 = default
    NextWidth : f32 = default
    Pos : [3]f32 = default
    NextWidths : [3]f32 = default
}
impl ImGuiMenuColumns {
    new :: () -> ImGuiMenuColumns {
        result : ImGuiMenuColumns = default
        __c__ImGuiMenuColumns_new_5(^result)
        return result
    }
    Update :: (&Self, _count: i32, _spacing: f32, _clear: bool) {
        __c__ImGuiMenuColumns_Update_6(^*self, _count, _spacing, _clear)
    }
    DeclColumns :: (&Self, _w0: f32, _w1: f32, _w2: f32) -> f32 {
        result : f32 = default
        __c__ImGuiMenuColumns_DeclColumns_7(^*self, ^result, _w0, _w1, _w2)
        return result
    }
    CalcExtraSpace :: (&Self, _avail_w: f32) -> f32 {
        result : f32 = default
        __c__ImGuiMenuColumns_CalcExtraSpace_8(^*self, ^result, _avail_w)
        return result
    }
}
ImGuiInputTextState :: struct #copy {
    ID : ImGuiID = default
    CurLenW : i32 = default
    CurLenA : i32 = default
    TextW : __UNKNOWN_16 = default
    TextA : __UNKNOWN_16 = default
    InitialTextA : __UNKNOWN_16 = default
    TextAIsValid : bool = default
    BufCapacityA : i32 = default
    ScrollX : f32 = default
    Stb : STB_TexteditState = default
    CursorAnim : f32 = default
    CursorFollow : bool = default
    SelectedAllMouseLock : bool = default
    UserFlags : ImGuiInputTextFlags = default
    UserCallback : ImGuiInputTextCallback = default
    UserCallbackData : ^void = default
}
impl ImGuiInputTextState {
    new :: () -> ImGuiInputTextState {
        result : ImGuiInputTextState = default
        __c__ImGuiInputTextState_new_16(^result)
        return result
    }
    ClearText :: (&Self) {
        __c__ImGuiInputTextState_ClearText_17(^*self)
    }
    ClearFreeMemory :: (&Self) {
        __c__ImGuiInputTextState_ClearFreeMemory_18(^*self)
    }
    GetUndoAvailCount :: (&Self) -> i32 {
        result : i32 = default
        __c__ImGuiInputTextState_GetUndoAvailCount_19(^*self, ^result)
        return result
    }
    GetRedoAvailCount :: (&Self) -> i32 {
        result : i32 = default
        __c__ImGuiInputTextState_GetRedoAvailCount_20(^*self, ^result)
        return result
    }
    OnKeyPressed :: (&Self, _key: i32) {
        __c__ImGuiInputTextState_OnKeyPressed_21(^*self, _key)
    }
    CursorAnimReset :: (&Self) {
        __c__ImGuiInputTextState_CursorAnimReset_22(^*self)
    }
    CursorClamp :: (&Self) {
        __c__ImGuiInputTextState_CursorClamp_23(^*self)
    }
    HasSelection :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiInputTextState_HasSelection_24(^*self, ^result)
        return result
    }
    ClearSelection :: (&Self) {
        __c__ImGuiInputTextState_ClearSelection_25(^*self)
    }
    SelectAll :: (&Self) {
        __c__ImGuiInputTextState_SelectAll_26(^*self)
    }
}
ImGuiWindowSettings :: struct #copy {
    ID : ImGuiID = default
    Pos : ImVec2ih = default
    Size : ImVec2ih = default
    ViewportPos : ImVec2ih = default
    ViewportId : ImGuiID = default
    DockId : ImGuiID = default
    ClassId : ImGuiID = default
    DockOrder : i16 = default
    Collapsed : bool = default
}
impl ImGuiWindowSettings {
    new :: () -> ImGuiWindowSettings {
        result : ImGuiWindowSettings = default
        __c__ImGuiWindowSettings_new_9(^result)
        return result
    }
    GetName :: (&Self) -> ^char8 {
        result : ^char8 = default
        __c__ImGuiWindowSettings_GetName_10(^*self, ^result)
        return result
    }
}
ImGuiSettingsHandler :: struct #copy {
    TypeName : ^char8 = default
    TypeHash : ImGuiID = default
    ReadOpenFn : fn(^ImGuiContext, ^ImGuiSettingsHandler, ^char8) -> ^void = default
    ReadLineFn : fn(^ImGuiContext, ^ImGuiSettingsHandler, ^void, ^char8) -> void = default
    WriteAllFn : fn(^ImGuiContext, ^ImGuiSettingsHandler, ^ImGuiTextBuffer) -> void = default
    UserData : ^void = default
}
impl ImGuiSettingsHandler {
    new :: () -> ImGuiSettingsHandler {
        result : ImGuiSettingsHandler = default
        __c__ImGuiSettingsHandler_new_6(^result)
        return result
    }
}
ImGuiPopupData :: struct #copy {
    PopupId : ImGuiID = default
    Window : ^ImGuiWindow = default
    SourceWindow : ^ImGuiWindow = default
    OpenFrameCount : i32 = default
    OpenParentId : ImGuiID = default
    OpenPopupPos : ImVec2 = default
    OpenMousePos : ImVec2 = default
}
impl ImGuiPopupData {
    new :: () -> ImGuiPopupData {
        result : ImGuiPopupData = default
        __c__ImGuiPopupData_new_7(^result)
        return result
    }
}
ImGuiColumnData :: struct #copy {
    OffsetNorm : f32 = default
    OffsetNormBeforeResize : f32 = default
    Flags : ImGuiColumnsFlags = default
    ClipRect : ImRect = default
}
impl ImGuiColumnData {
    new :: () -> ImGuiColumnData {
        result : ImGuiColumnData = default
        __c__ImGuiColumnData_new_4(^result)
        return result
    }
}
ImGuiColumns :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiColumnsFlags = default
    IsFirstFrame : bool = default
    IsBeingResized : bool = default
    Current : i32 = default
    Count : i32 = default
    OffMinX : f32 = default
    OffMaxX : f32 = default
    LineMinY : f32 = default
    LineMaxY : f32 = default
    HostCursorPosY : f32 = default
    HostCursorMaxPosX : f32 = default
    HostClipRect : ImRect = default
    HostWorkRect : ImRect = default
    Columns : __UNKNOWN_16 = default
}
impl ImGuiColumns {
    new :: () -> ImGuiColumns {
        result : ImGuiColumns = default
        __c__ImGuiColumns_new_15(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImGuiColumns_Clear_16(^*self)
    }
}
ImDrawListSharedData :: struct #copy {
    TexUvWhitePixel : ImVec2 = default
    Font : ^ImFont = default
    FontSize : f32 = default
    CurveTessellationTol : f32 = default
    ClipRectFullscreen : ImVec4 = default
    InitialFlags : ImDrawListFlags = default
    CircleVtx12 : [12]ImVec2 = default
}
impl ImDrawListSharedData {
    new :: () -> ImDrawListSharedData {
        result : ImDrawListSharedData = default
        __c__ImDrawListSharedData_new_7(^result)
        return result
    }
}
ImDrawDataBuilder :: struct #copy {
    Layers : [2]__UNKNOWN_16 = default
}
impl ImDrawDataBuilder {
    Clear :: (&Self) {
        __c__ImDrawDataBuilder_Clear_1(^*self)
    }
    ClearFreeMemory :: (&Self) {
        __c__ImDrawDataBuilder_ClearFreeMemory_2(^*self)
    }
    FlattenIntoSingleLayer :: (&Self) {
        __c__ImDrawDataBuilder_FlattenIntoSingleLayer_3(^*self)
    }
}
ImGuiViewportP :: struct #copy {
    Idx : i32 = default
    LastFrameActive : i32 = default
    LastFrameDrawLists : [2]i32 = default
    LastFrontMostStampCount : i32 = default
    LastNameHash : ImGuiID = default
    LastPos : ImVec2 = default
    Alpha : f32 = default
    LastAlpha : f32 = default
    PlatformMonitor : i16 = default
    PlatformWindowCreated : bool = default
    Window : ^ImGuiWindow = default
    DrawLists : [2]^ImDrawList = default
    DrawDataP : ImDrawData = default
    DrawDataBuilder : ImDrawDataBuilder = default
    LastPlatformPos : ImVec2 = default
    LastPlatformSize : ImVec2 = default
    LastRendererSize : ImVec2 = default
}
impl ImGuiViewportP {
    new :: () -> ImGuiViewportP {
        result : ImGuiViewportP = default
        __c__ImGuiViewportP_new_18(^result)
        return result
    }
    GetRect :: (&Self) -> ImRect {
        result : ImRect = default
        __c__ImGuiViewportP_GetRect_20(^*self, ^result)
        return result
    }
    GetCenter :: (&Self) -> ImVec2 {
        result : ImVec2 = default
        __c__ImGuiViewportP_GetCenter_21(^*self, ^result)
        return result
    }
    ClearRequestFlags :: (&Self) {
        __c__ImGuiViewportP_ClearRequestFlags_22(^*self)
    }
}
impl Drop for ImGuiViewportP {
    drop :: (&Self) {
        __c__ImGuiViewportP_dtor(^*self)
    }
}
ImGuiNavMoveResult :: struct #copy {
    ID : ImGuiID = default
    SelectScopeId : ImGuiID = default
    Window : ^ImGuiWindow = default
    DistBox : f32 = default
    DistCenter : f32 = default
    DistAxial : f32 = default
    RectRel : ImRect = default
}
impl ImGuiNavMoveResult {
    new :: () -> ImGuiNavMoveResult {
        result : ImGuiNavMoveResult = default
        __c__ImGuiNavMoveResult_new_7(^result)
        return result
    }
    Clear :: (&Self) {
        __c__ImGuiNavMoveResult_Clear_8(^*self)
    }
}
ImGuiNextWindowData :: struct #copy {
    Flags : ImGuiNextWindowDataFlags = default
    PosCond : ImGuiCond = default
    SizeCond : ImGuiCond = default
    CollapsedCond : ImGuiCond = default
    DockCond : ImGuiCond = default
    PosVal : ImVec2 = default
    PosPivotVal : ImVec2 = default
    SizeVal : ImVec2 = default
    ContentSizeVal : ImVec2 = default
    PosUndock : bool = default
    CollapsedVal : bool = default
    SizeConstraintRect : ImRect = default
    SizeCallback : ImGuiSizeCallback = default
    SizeCallbackUserData : ^void = default
    BgAlphaVal : f32 = default
    ViewportId : ImGuiID = default
    DockId : ImGuiID = default
    WindowClass : ImGuiWindowClass = default
    MenuBarOffsetMinVal : ImVec2 = default
}
impl ImGuiNextWindowData {
    new :: () -> ImGuiNextWindowData {
        result : ImGuiNextWindowData = default
        __c__ImGuiNextWindowData_new_19(^result)
        return result
    }
    ClearFlags :: (&Self) {
        __c__ImGuiNextWindowData_ClearFlags_20(^*self)
    }
}
ImGuiNextItemData :: struct #copy {
    Flags : ImGuiNextItemDataFlags = default
    Width : f32 = default
    OpenVal : bool = default
    OpenCond : ImGuiCond = default
}
impl ImGuiNextItemData {
    new :: () -> ImGuiNextItemData {
        result : ImGuiNextItemData = default
        __c__ImGuiNextItemData_new_4(^result)
        return result
    }
    ClearFlags :: (&Self) {
        __c__ImGuiNextItemData_ClearFlags_5(^*self)
    }
}
ImGuiShrinkWidthItem :: struct #copy {
    Index : i32 = default
    Width : f32 = default
}
ImGuiPtrOrIndex :: struct #copy {
    Ptr : ^void = default
    Index : i32 = default
}
impl ImGuiPtrOrIndex {
    new :: (_ptr: ^void) -> ImGuiPtrOrIndex {
        result : ImGuiPtrOrIndex = default
        __c__ImGuiPtrOrIndex_new_2(^result, _ptr)
        return result
    }
    new :: (_index: i32) -> ImGuiPtrOrIndex {
        result : ImGuiPtrOrIndex = default
        __c__ImGuiPtrOrIndex_new_3(^result, _index)
        return result
    }
}
ImGuiDockNode :: struct #copy {
    ID : ImGuiID = default
    SharedFlags : ImGuiDockNodeFlags = default
    LocalFlags : ImGuiDockNodeFlags = default
    ParentNode : ^ImGuiDockNode = default
    ChildNodes : [2]^ImGuiDockNode = default
    Windows : __UNKNOWN_16 = default
    TabBar : ^ImGuiTabBar = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    SizeRef : ImVec2 = default
    SplitAxis : i32 = default
    WindowClass : ImGuiWindowClass = default
    State : ImGuiDockNodeState = ImGuiDockNodeState.Unknown
    HostWindow : ^ImGuiWindow = default
    VisibleWindow : ^ImGuiWindow = default
    CentralNode : ^ImGuiDockNode = default
    OnlyNodeWithWindows : ^ImGuiDockNode = default
    LastFrameAlive : i32 = default
    LastFrameActive : i32 = default
    LastFrameFocused : i32 = default
    LastFocusedNodeID : ImGuiID = default
    SelectedTabID : ImGuiID = default
    WantCloseTabID : ImGuiID = default
    AuthorityForPos : ImGuiDataAuthority = default
    AuthorityForSize : ImGuiDataAuthority = default
    AuthorityForViewport : ImGuiDataAuthority = default
    IsVisible : bool = default
    IsFocused : bool = default
    HasCloseButton : bool = default
    HasWindowMenuButton : bool = default
    EnableCloseButton : bool = default
    WantCloseAll : bool = default
    WantLockSizeOnce : bool = default
    WantMouseMove : bool = default
    WantHiddenTabBarUpdate : bool = default
    WantHiddenTabBarToggle : bool = default
    MarkedForPosSizeWrite : bool = default
}
impl ImGuiDockNode {
    new :: (_id: ImGuiID) -> ImGuiDockNode {
        result : ImGuiDockNode = default
        __c__ImGuiDockNode_new_37(^result, _id)
        return result
    }
    IsRootNode :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsRootNode_39(^*self, ^result)
        return result
    }
    IsDockSpace :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsDockSpace_40(^*self, ^result)
        return result
    }
    IsFloatingNode :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsFloatingNode_41(^*self, ^result)
        return result
    }
    IsCentralNode :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsCentralNode_42(^*self, ^result)
        return result
    }
    IsHiddenTabBar :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsHiddenTabBar_43(^*self, ^result)
        return result
    }
    IsNoTabBar :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsNoTabBar_44(^*self, ^result)
        return result
    }
    IsSplitNode :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsSplitNode_45(^*self, ^result)
        return result
    }
    IsLeafNode :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsLeafNode_46(^*self, ^result)
        return result
    }
    IsEmpty :: (&Self) -> bool {
        result : bool = default
        __c__ImGuiDockNode_IsEmpty_47(^*self, ^result)
        return result
    }
    GetMergedFlags :: (&Self) -> ImGuiDockNodeFlags {
        result : ImGuiDockNodeFlags = default
        __c__ImGuiDockNode_GetMergedFlags_48(^*self, ^result)
        return result
    }
    Rect :: (&Self) -> ImRect {
        result : ImRect = default
        __c__ImGuiDockNode_Rect_49(^*self, ^result)
        return result
    }
}
impl Drop for ImGuiDockNode {
    drop :: (&Self) {
        __c__ImGuiDockNode_dtor(^*self)
    }
}
ImGuiContext :: struct #copy {
    Initialized : bool = default
    FontAtlasOwnedByContext : bool = default
    IO : ImGuiIO = default
    PlatformIO : ImGuiPlatformIO = default
    Style : ImGuiStyle = default
    ConfigFlagsCurrFrame : ImGuiConfigFlags = default
    ConfigFlagsLastFrame : ImGuiConfigFlags = default
    Font : ^ImFont = default
    FontSize : f32 = default
    FontBaseSize : f32 = default
    DrawListSharedData : ImDrawListSharedData = default
    Time : f64 = default
    FrameCount : i32 = default
    FrameCountEnded : i32 = default
    FrameCountPlatformEnded : i32 = default
    FrameCountRendered : i32 = default
    WithinFrameScope : bool = default
    WithinFrameScopeWithImplicitWindow : bool = default
    WithinEndChild : bool = default
    Windows : __UNKNOWN_16 = default
    WindowsFocusOrder : __UNKNOWN_16 = default
    WindowsSortBuffer : __UNKNOWN_16 = default
    CurrentWindowStack : __UNKNOWN_16 = default
    WindowsById : ImGuiStorage = default
    WindowsActiveCount : i32 = default
    CurrentWindow : ^ImGuiWindow = default
    HoveredWindow : ^ImGuiWindow = default
    HoveredRootWindow : ^ImGuiWindow = default
    HoveredWindowUnderMovingWindow : ^ImGuiWindow = default
    MovingWindow : ^ImGuiWindow = default
    WheelingWindow : ^ImGuiWindow = default
    WheelingWindowRefMousePos : ImVec2 = default
    WheelingWindowTimer : f32 = default
    HoveredId : ImGuiID = default
    HoveredIdAllowOverlap : bool = default
    HoveredIdPreviousFrame : ImGuiID = default
    HoveredIdTimer : f32 = default
    HoveredIdNotActiveTimer : f32 = default
    ActiveId : ImGuiID = default
    ActiveIdIsAlive : ImGuiID = default
    ActiveIdTimer : f32 = default
    ActiveIdIsJustActivated : bool = default
    ActiveIdAllowOverlap : bool = default
    ActiveIdHasBeenPressedBefore : bool = default
    ActiveIdHasBeenEditedBefore : bool = default
    ActiveIdHasBeenEditedThisFrame : bool = default
    ActiveIdUsingNavDirMask : ImU32 = default
    ActiveIdUsingNavInputMask : ImU32 = default
    ActiveIdUsingKeyInputMask : ImU64 = default
    ActiveIdClickOffset : ImVec2 = default
    ActiveIdWindow : ^ImGuiWindow = default
    ActiveIdSource : ImGuiInputSource = ImGuiInputSource.None
    ActiveIdPreviousFrame : ImGuiID = default
    ActiveIdPreviousFrameIsAlive : bool = default
    ActiveIdPreviousFrameHasBeenEditedBefore : bool = default
    ActiveIdPreviousFrameWindow : ^ImGuiWindow = default
    LastActiveId : ImGuiID = default
    LastActiveIdTimer : f32 = default
    NextWindowData : ImGuiNextWindowData = default
    NextItemData : ImGuiNextItemData = default
    ColorModifiers : __UNKNOWN_16 = default
    StyleModifiers : __UNKNOWN_16 = default
    FontStack : __UNKNOWN_16 = default
    OpenPopupStack : __UNKNOWN_16 = default
    BeginPopupStack : __UNKNOWN_16 = default
    Viewports : __UNKNOWN_16 = default
    CurrentDpiScale : f32 = default
    CurrentViewport : ^ImGuiViewportP = default
    MouseViewport : ^ImGuiViewportP = default
    MouseLastHoveredViewport : ^ImGuiViewportP = default
    PlatformLastFocusedViewport : ImGuiID = default
    ViewportFrontMostStampCount : i32 = default
    NavWindow : ^ImGuiWindow = default
    NavId : ImGuiID = default
    NavActivateId : ImGuiID = default
    NavActivateDownId : ImGuiID = default
    NavActivatePressedId : ImGuiID = default
    NavInputId : ImGuiID = default
    NavJustTabbedId : ImGuiID = default
    NavJustMovedToId : ImGuiID = default
    NavJustMovedToMultiSelectScopeId : ImGuiID = default
    NavNextActivateId : ImGuiID = default
    NavInputSource : ImGuiInputSource = ImGuiInputSource.None
    NavScoringRectScreen : ImRect = default
    NavScoringCount : i32 = default
    NavWindowingTarget : ^ImGuiWindow = default
    NavWindowingTargetAnim : ^ImGuiWindow = default
    NavWindowingList : ^ImGuiWindow = default
    NavWindowingTimer : f32 = default
    NavWindowingHighlightAlpha : f32 = default
    NavWindowingToggleLayer : bool = default
    NavLayer : ImGuiNavLayer = ImGuiNavLayer.Main
    NavIdTabCounter : i32 = default
    NavIdIsAlive : bool = default
    NavMousePosDirty : bool = default
    NavDisableHighlight : bool = default
    NavDisableMouseHover : bool = default
    NavAnyRequest : bool = default
    NavInitRequest : bool = default
    NavInitRequestFromMove : bool = default
    NavInitResultId : ImGuiID = default
    NavInitResultRectRel : ImRect = default
    NavMoveFromClampedRefRect : bool = default
    NavMoveRequest : bool = default
    NavMoveRequestFlags : ImGuiNavMoveFlags = default
    NavMoveRequestForward : ImGuiNavForward = ImGuiNavForward.None
    NavMoveDir : ImGuiDir = default
    NavMoveDirLast : ImGuiDir = default
    NavMoveClipDir : ImGuiDir = default
    NavMoveResultLocal : ImGuiNavMoveResult = default
    NavMoveResultLocalVisibleSet : ImGuiNavMoveResult = default
    NavMoveResultOther : ImGuiNavMoveResult = default
    FocusRequestCurrWindow : ^ImGuiWindow = default
    FocusRequestNextWindow : ^ImGuiWindow = default
    FocusRequestCurrCounterAll : i32 = default
    FocusRequestCurrCounterTab : i32 = default
    FocusRequestNextCounterAll : i32 = default
    FocusRequestNextCounterTab : i32 = default
    FocusTabPressed : bool = default
    DimBgRatio : f32 = default
    MouseCursor : ImGuiMouseCursor = default
    DragDropActive : bool = default
    DragDropWithinSourceOrTarget : bool = default
    DragDropSourceFlags : ImGuiDragDropFlags = default
    DragDropSourceFrameCount : i32 = default
    DragDropMouseButton : i32 = default
    DragDropPayload : ImGuiPayload = default
    DragDropTargetRect : ImRect = default
    DragDropTargetId : ImGuiID = default
    DragDropAcceptFlags : ImGuiDragDropFlags = default
    DragDropAcceptIdCurrRectSurface : f32 = default
    DragDropAcceptIdCurr : ImGuiID = default
    DragDropAcceptIdPrev : ImGuiID = default
    DragDropAcceptFrameCount : i32 = default
    DragDropPayloadBufHeap : __UNKNOWN_16 = default
    DragDropPayloadBufLocal : [16]u8 = default
    CurrentTabBar : ^ImGuiTabBar = default
    TabBars : __UNKNOWN_40 = default
    CurrentTabBarStack : __UNKNOWN_16 = default
    ShrinkWidthBuffer : __UNKNOWN_16 = default
    LastValidMousePos : ImVec2 = default
    InputTextState : ImGuiInputTextState = default
    InputTextPasswordFont : ImFont = default
    TempInputTextId : ImGuiID = default
    ColorEditOptions : ImGuiColorEditFlags = default
    ColorEditLastHue : f32 = default
    ColorEditLastColor : [3]f32 = default
    ColorPickerRef : ImVec4 = default
    DragCurrentAccumDirty : bool = default
    DragCurrentAccum : f32 = default
    DragSpeedDefaultRatio : f32 = default
    ScrollbarClickDeltaToGrabCenter : f32 = default
    TooltipOverrideCount : i32 = default
    PrivateClipboard : __UNKNOWN_16 = default
    MultiSelectScopeId : ImGuiID = default
    PlatformImePos : ImVec2 = default
    PlatformImeLastPos : ImVec2 = default
    PlatformImePosViewport : ^ImGuiViewportP = default
    DockContext : ^ImGuiDockContext = default
    SettingsLoaded : bool = default
    SettingsDirtyTimer : f32 = default
    SettingsIniData : ImGuiTextBuffer = default
    SettingsHandlers : __UNKNOWN_16 = default
    SettingsWindows : __UNKNOWN_16 = default
    LogEnabled : bool = default
    LogType : ImGuiLogType = ImGuiLogType.None
    LogFile : ImFileHandle = default
    LogBuffer : ImGuiTextBuffer = default
    LogLinePosY : f32 = default
    LogLineFirstItem : bool = default
    LogDepthRef : i32 = default
    LogDepthToExpand : i32 = default
    LogDepthToExpandDefault : i32 = default
    DebugItemPickerActive : bool = default
    DebugItemPickerBreakID : ImGuiID = default
    FramerateSecPerFrame : [120]f32 = default
    FramerateSecPerFrameIdx : i32 = default
    FramerateSecPerFrameAccum : f32 = default
    WantCaptureMouseNextFrame : i32 = default
    WantCaptureKeyboardNextFrame : i32 = default
    WantTextInputNextFrame : i32 = default
    TempBuffer : [3073]char8 = default
}
impl ImGuiContext {
    new :: (_shared_font_atlas: ^ImFontAtlas) -> ImGuiContext {
        result : ImGuiContext = default
        __c__ImGuiContext_new_182(^result, _shared_font_atlas)
        return result
    }
}
ImGuiWindowTempData :: struct #copy {
    CursorPos : ImVec2 = default
    CursorPosPrevLine : ImVec2 = default
    CursorStartPos : ImVec2 = default
    CursorMaxPos : ImVec2 = default
    CurrLineSize : ImVec2 = default
    PrevLineSize : ImVec2 = default
    CurrLineTextBaseOffset : f32 = default
    PrevLineTextBaseOffset : f32 = default
    TreeDepth : i32 = default
    TreeMayJumpToParentOnPopMask : ImU32 = default
    LastItemId : ImGuiID = default
    LastItemStatusFlags : ImGuiItemStatusFlags = default
    LastItemRect : ImRect = default
    LastItemDisplayRect : ImRect = default
    NavLayerCurrent : ImGuiNavLayer = ImGuiNavLayer.Main
    NavLayerCurrentMask : i32 = default
    NavLayerActiveMask : i32 = default
    NavLayerActiveMaskNext : i32 = default
    NavHideHighlightOneFrame : bool = default
    NavHasScroll : bool = default
    MenuBarAppending : bool = default
    MenuBarOffset : ImVec2 = default
    ChildWindows : __UNKNOWN_16 = default
    StateStorage : ^ImGuiStorage = default
    LayoutType : ImGuiLayoutType = default
    ParentLayoutType : ImGuiLayoutType = default
    FocusCounterAll : i32 = default
    FocusCounterTab : i32 = default
    ItemFlags : ImGuiItemFlags = default
    ItemWidth : f32 = default
    TextWrapPos : f32 = default
    ItemFlagsStack : __UNKNOWN_16 = default
    ItemWidthStack : __UNKNOWN_16 = default
    TextWrapPosStack : __UNKNOWN_16 = default
    GroupStack : __UNKNOWN_16 = default
    StackSizesBackup : [6]i16 = default
    Indent : ImVec1 = default
    GroupOffset : ImVec1 = default
    ColumnsOffset : ImVec1 = default
    CurrentColumns : ^ImGuiColumns = default
}
impl ImGuiWindowTempData {
    new :: () -> ImGuiWindowTempData {
        result : ImGuiWindowTempData = default
        __c__ImGuiWindowTempData_new_40(^result)
        return result
    }
}
ImGuiWindow :: struct #copy {
    Name : ^char8 = default
    ID : ImGuiID = default
    Flags : ImGuiWindowFlags = default
    FlagsPreviousFrame : ImGuiWindowFlags = default
    WindowClass : ImGuiWindowClass = default
    Viewport : ^ImGuiViewportP = default
    ViewportId : ImGuiID = default
    ViewportPos : ImVec2 = default
    ViewportAllowPlatformMonitorExtend : i32 = default
    Pos : ImVec2 = default
    Size : ImVec2 = default
    SizeFull : ImVec2 = default
    ContentSize : ImVec2 = default
    ContentSizeExplicit : ImVec2 = default
    WindowPadding : ImVec2 = default
    WindowRounding : f32 = default
    WindowBorderSize : f32 = default
    NameBufLen : i32 = default
    MoveId : ImGuiID = default
    ChildId : ImGuiID = default
    Scroll : ImVec2 = default
    ScrollMax : ImVec2 = default
    ScrollTarget : ImVec2 = default
    ScrollTargetCenterRatio : ImVec2 = default
    ScrollbarSizes : ImVec2 = default
    ScrollbarX : bool = default
    ScrollbarY : bool = default
    ViewportOwned : bool = default
    Active : bool = default
    WasActive : bool = default
    WriteAccessed : bool = default
    Collapsed : bool = default
    WantCollapseToggle : bool = default
    SkipItems : bool = default
    Appearing : bool = default
    Hidden : bool = default
    IsFallbackWindow : bool = default
    HasCloseButton : bool = default
    ResizeBorderHeld : i8 = default
    BeginCount : i16 = default
    BeginOrderWithinParent : i16 = default
    BeginOrderWithinContext : i16 = default
    PopupId : ImGuiID = default
    AutoFitFramesX : ImS8 = default
    AutoFitFramesY : ImS8 = default
    AutoFitChildAxises : ImS8 = default
    AutoFitOnlyGrows : bool = default
    AutoPosLastDirection : ImGuiDir = default
    HiddenFramesCanSkipItems : i32 = default
    HiddenFramesCannotSkipItems : i32 = default
    SetWindowPosAllowFlags : ImGuiCond = default
    SetWindowSizeAllowFlags : ImGuiCond = default
    SetWindowCollapsedAllowFlags : ImGuiCond = default
    SetWindowDockAllowFlags : ImGuiCond = default
    SetWindowPosVal : ImVec2 = default
    SetWindowPosPivot : ImVec2 = default
    IDStack : __UNKNOWN_16 = default
    DC : ImGuiWindowTempData = default
    OuterRectClipped : ImRect = default
    InnerRect : ImRect = default
    InnerClipRect : ImRect = default
    WorkRect : ImRect = default
    ClipRect : ImRect = default
    ContentRegionRect : ImRect = default
    HitTestHoleSize : ImVec2ih = default
    HitTestHoleOffset : ImVec2ih = default
    LastFrameActive : i32 = default
    LastFrameJustFocused : i32 = default
    LastTimeActive : f32 = default
    ItemWidthDefault : f32 = default
    MenuColumns : ImGuiMenuColumns = default
    StateStorage : ImGuiStorage = default
    ColumnsStorage : __UNKNOWN_16 = default
    FontWindowScale : f32 = default
    FontDpiScale : f32 = default
    SettingsOffset : i32 = default
    DrawList : ^ImDrawList = default
    DrawListInst : ImDrawList = default
    ParentWindow : ^ImGuiWindow = default
    RootWindow : ^ImGuiWindow = default
    RootWindowDockStop : ^ImGuiWindow = default
    RootWindowForTitleBarHighlight : ^ImGuiWindow = default
    RootWindowForNav : ^ImGuiWindow = default
    NavLastChildNavWindow : ^ImGuiWindow = default
    NavLastIds : [2]ImGuiID = default
    NavRectRel : [2]ImRect = default
    MemoryCompacted : bool = default
    MemoryDrawListIdxCapacity : i32 = default
    MemoryDrawListVtxCapacity : i32 = default
    DockNode : ^ImGuiDockNode = default
    DockNodeAsHost : ^ImGuiDockNode = default
    DockId : ImGuiID = default
    DockTabItemStatusFlags : ImGuiItemStatusFlags = default
    DockTabItemRect : ImRect = default
    DockOrder : i16 = default
    DockIsActive : bool = default
    DockTabIsVisible : bool = default
    DockTabWantClose : bool = default
}
impl ImGuiWindow {
    new :: (_context: ^ImGuiContext, _name: ^char8) -> ImGuiWindow {
        result : ImGuiWindow = default
        __c__ImGuiWindow_new_99(^result, _context, _name)
        return result
    }
    GetID :: (&Self, _str: ^char8, _str_end: ^char8 = null) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetID_101(^*self, ^result, _str, _str_end)
        return result
    }
    GetID :: (&Self, _ptr: ^void) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetID_102(^*self, ^result, _ptr)
        return result
    }
    GetID :: (&Self, _n: i32) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetID_103(^*self, ^result, _n)
        return result
    }
    GetIDNoKeepAlive :: (&Self, _str: ^char8, _str_end: ^char8 = null) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_104(^*self, ^result, _str, _str_end)
        return result
    }
    GetIDNoKeepAlive :: (&Self, _ptr: ^void) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_105(^*self, ^result, _ptr)
        return result
    }
    GetIDNoKeepAlive :: (&Self, _n: i32) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetIDNoKeepAlive_106(^*self, ^result, _n)
        return result
    }
    GetIDFromRectangle :: (&Self, _r_abs: &ImRect) -> ImGuiID {
        result : ImGuiID = default
        __c__ImGuiWindow_GetIDFromRectangle_107(^*self, ^result, ^*_r_abs)
        return result
    }
    Rect :: (&Self) -> ImRect {
        result : ImRect = default
        __c__ImGuiWindow_Rect_108(^*self, ^result)
        return result
    }
    CalcFontSize :: (&Self) -> f32 {
        result : f32 = default
        __c__ImGuiWindow_CalcFontSize_109(^*self, ^result)
        return result
    }
    TitleBarHeight :: (&Self) -> f32 {
        result : f32 = default
        __c__ImGuiWindow_TitleBarHeight_110(^*self, ^result)
        return result
    }
    TitleBarRect :: (&Self) -> ImRect {
        result : ImRect = default
        __c__ImGuiWindow_TitleBarRect_111(^*self, ^result)
        return result
    }
    MenuBarHeight :: (&Self) -> f32 {
        result : f32 = default
        __c__ImGuiWindow_MenuBarHeight_112(^*self, ^result)
        return result
    }
    MenuBarRect :: (&Self) -> ImRect {
        result : ImRect = default
        __c__ImGuiWindow_MenuBarRect_113(^*self, ^result)
        return result
    }
}
impl Drop for ImGuiWindow {
    drop :: (&Self) {
        __c__ImGuiWindow_dtor(^*self)
    }
}
ImGuiItemHoveredDataBackup :: struct #copy {
    LastItemId : ImGuiID = default
    LastItemStatusFlags : ImGuiItemStatusFlags = default
    LastItemRect : ImRect = default
    LastItemDisplayRect : ImRect = default
}
impl ImGuiItemHoveredDataBackup {
    new :: () -> ImGuiItemHoveredDataBackup {
        result : ImGuiItemHoveredDataBackup = default
        __c__ImGuiItemHoveredDataBackup_new_4(^result)
        return result
    }
    Backup :: (&Self) {
        __c__ImGuiItemHoveredDataBackup_Backup_5(^*self)
    }
    Restore :: (&Self) {
        __c__ImGuiItemHoveredDataBackup_Restore_6(^*self)
    }
}
ImGuiTabItem :: struct #copy {
    ID : ImGuiID = default
    Flags : ImGuiTabItemFlags = default
    Window : ^ImGuiWindow = default
    LastFrameVisible : i32 = default
    LastFrameSelected : i32 = default
    NameOffset : i32 = default
    Offset : f32 = default
    Width : f32 = default
    ContentWidth : f32 = default
}
impl ImGuiTabItem {
    new :: () -> ImGuiTabItem {
        result : ImGuiTabItem = default
        __c__ImGuiTabItem_new_9(^result)
        return result
    }
}
ImGuiTabBar :: struct #copy {
    Tabs : __UNKNOWN_16 = default
    ID : ImGuiID = default
    SelectedTabId : ImGuiID = default
    NextSelectedTabId : ImGuiID = default
    VisibleTabId : ImGuiID = default
    CurrFrameVisible : i32 = default
    PrevFrameVisible : i32 = default
    BarRect : ImRect = default
    LastTabContentHeight : f32 = default
    OffsetMax : f32 = default
    OffsetMaxIdeal : f32 = default
    OffsetNextTab : f32 = default
    ScrollingAnim : f32 = default
    ScrollingTarget : f32 = default
    ScrollingTargetDistToVisibility : f32 = default
    ScrollingSpeed : f32 = default
    Flags : ImGuiTabBarFlags = default
    ReorderRequestTabId : ImGuiID = default
    ReorderRequestDir : ImS8 = default
    WantLayout : bool = default
    VisibleTabWasSubmitted : bool = default
    LastTabItemIdx : i16 = default
    FramePadding : ImVec2 = default
    TabsNames : ImGuiTextBuffer = default
}
impl ImGuiTabBar {
    new :: () -> ImGuiTabBar {
        result : ImGuiTabBar = default
        __c__ImGuiTabBar_new_24(^result)
        return result
    }
    GetTabOrder :: (&Self, _tab: ^ImGuiTabItem) -> i32 {
        result : i32 = default
        __c__ImGuiTabBar_GetTabOrder_25(^*self, ^result, _tab)
        return result
    }
    GetTabName :: (&Self, _tab: ^ImGuiTabItem) -> ^char8 {
        result : ^char8 = default
        __c__ImGuiTabBar_GetTabName_26(^*self, ^result, _tab)
        return result
    }
}
CreateContext :: (_shared_font_atlas: ^ImFontAtlas = null) -> ^ImGuiContext {
    result : ^ImGuiContext = default
    __c__CreateContext(^result, _shared_font_atlas)
    return result
}
DestroyContext :: (_ctx: ^ImGuiContext = null) {
    __c__DestroyContext(_ctx)
}
GetCurrentContext :: () -> ^ImGuiContext {
    result : ^ImGuiContext = default
    __c__GetCurrentContext(^result)
    return result
}
SetCurrentContext :: (_ctx: ^ImGuiContext) {
    __c__SetCurrentContext(_ctx)
}
DebugCheckVersionAndDataLayout :: (_version_str: ^char8, _sz_io: size_t, _sz_style: size_t, _sz_vec2: size_t, _sz_vec4: size_t, _sz_drawvert: size_t, _sz_drawidx: size_t) -> bool {
    result : bool = default
    __c__DebugCheckVersionAndDataLayout(^result, _version_str, _sz_io, _sz_style, _sz_vec2, _sz_vec4, _sz_drawvert, _sz_drawidx)
    return result
}
GetIO :: () -> &mut ImGuiIO {
    result : ^ImGuiIO = default
    __c__GetIO(^result)
    return &mut *result
}
GetStyle :: () -> &mut ImGuiStyle {
    result : ^ImGuiStyle = default
    __c__GetStyle(^result)
    return &mut *result
}
NewFrame :: () {
    __c__NewFrame()
}
EndFrame :: () {
    __c__EndFrame()
}
Render :: () {
    __c__Render()
}
GetDrawData :: () -> ^ImDrawData {
    result : ^ImDrawData = default
    __c__GetDrawData(^result)
    return result
}
ShowDemoWindow :: (_p_open: ^bool = null) {
    __c__ShowDemoWindow(_p_open)
}
ShowAboutWindow :: (_p_open: ^bool = null) {
    __c__ShowAboutWindow(_p_open)
}
ShowMetricsWindow :: (_p_open: ^bool = null) {
    __c__ShowMetricsWindow(_p_open)
}
ShowStyleEditor :: (_ref: ^ImGuiStyle = null) {
    __c__ShowStyleEditor(_ref)
}
ShowStyleSelector :: (_label: ^char8) -> bool {
    result : bool = default
    __c__ShowStyleSelector(^result, _label)
    return result
}
ShowFontSelector :: (_label: ^char8) {
    __c__ShowFontSelector(_label)
}
ShowUserGuide :: () {
    __c__ShowUserGuide()
}
GetVersion :: () -> ^char8 {
    result : ^char8 = default
    __c__GetVersion(^result)
    return result
}
StyleColorsDark :: (_dst: ^ImGuiStyle = null) {
    __c__StyleColorsDark(_dst)
}
StyleColorsClassic :: (_dst: ^ImGuiStyle = null) {
    __c__StyleColorsClassic(_dst)
}
StyleColorsLight :: (_dst: ^ImGuiStyle = null) {
    __c__StyleColorsLight(_dst)
}
Begin :: (_name: ^char8, _p_open: ^bool = null, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__Begin(^result, _name, _p_open, _flags)
    return result
}
End :: () {
    __c__End()
}
BeginChildStr :: (_str_id: ^char8, _size: &ImVec2, _border: bool = false, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__BeginChild(^result, _str_id, ^*_size, _border, _flags)
    return result
}
BeginChildInt :: (_id: ImGuiID, _size: &ImVec2, _border: bool = false, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__BeginChild_2(^result, _id, ^*_size, _border, _flags)
    return result
}
EndChild :: () {
    __c__EndChild()
}
IsWindowAppearing :: () -> bool {
    result : bool = default
    __c__IsWindowAppearing(^result)
    return result
}
IsWindowCollapsed :: () -> bool {
    result : bool = default
    __c__IsWindowCollapsed(^result)
    return result
}
IsWindowFocused :: (_flags: ImGuiFocusedFlags = 0) -> bool {
    result : bool = default
    __c__IsWindowFocused(^result, _flags)
    return result
}
IsWindowHovered :: (_flags: ImGuiHoveredFlags = 0) -> bool {
    result : bool = default
    __c__IsWindowHovered(^result, _flags)
    return result
}
GetWindowDrawList :: () -> ^ImDrawList {
    result : ^ImDrawList = default
    __c__GetWindowDrawList(^result)
    return result
}
GetWindowDpiScale :: () -> f32 {
    result : f32 = default
    __c__GetWindowDpiScale(^result)
    return result
}
GetWindowViewport :: () -> ^ImGuiViewport {
    result : ^ImGuiViewport = default
    __c__GetWindowViewport(^result)
    return result
}
GetWindowPos :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetWindowPos(^result)
    return result
}
GetWindowSize :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetWindowSize(^result)
    return result
}
GetWindowWidth :: () -> f32 {
    result : f32 = default
    __c__GetWindowWidth(^result)
    return result
}
GetWindowHeight :: () -> f32 {
    result : f32 = default
    __c__GetWindowHeight(^result)
    return result
}
SetNextWindowPos :: (_pos: &ImVec2, _cond: ImGuiCond = 0, _pivot: &ImVec2) {
    __c__SetNextWindowPos(^*_pos, _cond, ^*_pivot)
}
SetNextWindowSize :: (_size: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetNextWindowSize(^*_size, _cond)
}
SetNextWindowSizeConstraints :: (_size_min: &ImVec2, _size_max: &ImVec2, _custom_callback: ImGuiSizeCallback = null, _custom_callback_data: ^void = null) {
    __c__SetNextWindowSizeConstraints(^*_size_min, ^*_size_max, _custom_callback, _custom_callback_data)
}
SetNextWindowContentSize :: (_size: &ImVec2) {
    __c__SetNextWindowContentSize(^*_size)
}
SetNextWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond = 0) {
    __c__SetNextWindowCollapsed(_collapsed, _cond)
}
SetNextWindowFocus :: () {
    __c__SetNextWindowFocus()
}
SetNextWindowBgAlpha :: (_alpha: f32) {
    __c__SetNextWindowBgAlpha(_alpha)
}
SetNextWindowViewport :: (_viewport_id: ImGuiID) {
    __c__SetNextWindowViewport(_viewport_id)
}
SetWindowPos :: (_pos: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowPos(^*_pos, _cond)
}
SetWindowSize :: (_size: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowSize(^*_size, _cond)
}
SetWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond = 0) {
    __c__SetWindowCollapsed(_collapsed, _cond)
}
SetWindowFocus :: () {
    __c__SetWindowFocus()
}
SetWindowFontScale :: (_scale: f32) {
    __c__SetWindowFontScale(_scale)
}
SetWindowPos_2 :: (_name: ^char8, _pos: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowPos_2(_name, ^*_pos, _cond)
}
SetWindowSize_2 :: (_name: ^char8, _size: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowSize_2(_name, ^*_size, _cond)
}
SetWindowCollapsed_2 :: (_name: ^char8, _collapsed: bool, _cond: ImGuiCond = 0) {
    __c__SetWindowCollapsed_2(_name, _collapsed, _cond)
}
SetWindowFocus_2 :: (_name: ^char8) {
    __c__SetWindowFocus_2(_name)
}
GetContentRegionMax :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetContentRegionMax(^result)
    return result
}
GetContentRegionAvail :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetContentRegionAvail(^result)
    return result
}
GetWindowContentRegionMin :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetWindowContentRegionMin(^result)
    return result
}
GetWindowContentRegionMax :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetWindowContentRegionMax(^result)
    return result
}
GetWindowContentRegionWidth :: () -> f32 {
    result : f32 = default
    __c__GetWindowContentRegionWidth(^result)
    return result
}
GetScrollX :: () -> f32 {
    result : f32 = default
    __c__GetScrollX(^result)
    return result
}
GetScrollY :: () -> f32 {
    result : f32 = default
    __c__GetScrollY(^result)
    return result
}
GetScrollMaxX :: () -> f32 {
    result : f32 = default
    __c__GetScrollMaxX(^result)
    return result
}
GetScrollMaxY :: () -> f32 {
    result : f32 = default
    __c__GetScrollMaxY(^result)
    return result
}
SetScrollX :: (_scroll_x: f32) {
    __c__SetScrollX(_scroll_x)
}
SetScrollY :: (_scroll_y: f32) {
    __c__SetScrollY(_scroll_y)
}
SetScrollHereX :: (_center_x_ratio: f32 = 0.5f) {
    __c__SetScrollHereX(_center_x_ratio)
}
SetScrollHereY :: (_center_y_ratio: f32 = 0.5f) {
    __c__SetScrollHereY(_center_y_ratio)
}
SetScrollFromPosX :: (_local_x: f32, _center_x_ratio: f32 = 0.5f) {
    __c__SetScrollFromPosX(_local_x, _center_x_ratio)
}
SetScrollFromPosY :: (_local_y: f32, _center_y_ratio: f32 = 0.5f) {
    __c__SetScrollFromPosY(_local_y, _center_y_ratio)
}
PushFont :: (_font: ^ImFont) {
    __c__PushFont(_font)
}
PopFont :: () {
    __c__PopFont()
}
PushStyleColorInt :: (_idx: ImGuiCol, _col: ImU32) {
    __c__PushStyleColor(_idx, _col)
}
PushStyleColorVec :: (_idx: ImGuiCol, _col: &ImVec4) {
    __c__PushStyleColor_2(_idx, ^*_col)
}
PopStyleColor :: (_count: i32 = 1) {
    __c__PopStyleColor(_count)
}
PushStyleVar :: (_idx: ImGuiStyleVar, _val: f32) {
    __c__PushStyleVar(_idx, _val)
}
PushStyleVarVec :: (_idx: ImGuiStyleVar, _val: &ImVec2) {
    __c__PushStyleVar_2(_idx, ^*_val)
}
PopStyleVar :: (_count: i32 = 1) {
    __c__PopStyleVar(_count)
}
GetStyleColorVec4 :: (_idx: ImGuiCol) -> &ImVec4 {
    result : ^ImVec4 = default
    __c__GetStyleColorVec4(^result, _idx)
    return &*result
}
GetFont :: () -> ^ImFont {
    result : ^ImFont = default
    __c__GetFont(^result)
    return result
}
GetFontSize :: () -> f32 {
    result : f32 = default
    __c__GetFontSize(^result)
    return result
}
GetFontTexUvWhitePixel :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetFontTexUvWhitePixel(^result)
    return result
}
GetColorU32 :: (_idx: ImGuiCol, _alpha_mul: f32 = 1.0f) -> ImU32 {
    result : ImU32 = default
    __c__GetColorU32(^result, _idx, _alpha_mul)
    return result
}
GetColorU32_2 :: (_col: &ImVec4) -> ImU32 {
    result : ImU32 = default
    __c__GetColorU32_2(^result, ^*_col)
    return result
}
GetColorU32_3 :: (_col: ImU32) -> ImU32 {
    result : ImU32 = default
    __c__GetColorU32_3(^result, _col)
    return result
}
PushItemWidth :: (_item_width: f32) {
    __c__PushItemWidth(_item_width)
}
PopItemWidth :: () {
    __c__PopItemWidth()
}
SetNextItemWidth :: (_item_width: f32) {
    __c__SetNextItemWidth(_item_width)
}
CalcItemWidth :: () -> f32 {
    result : f32 = default
    __c__CalcItemWidth(^result)
    return result
}
PushTextWrapPos :: (_wrap_local_pos_x: f32 = 0.0f) {
    __c__PushTextWrapPos(_wrap_local_pos_x)
}
PopTextWrapPos :: () {
    __c__PopTextWrapPos()
}
PushAllowKeyboardFocus :: (_allow_keyboard_focus: bool) {
    __c__PushAllowKeyboardFocus(_allow_keyboard_focus)
}
PopAllowKeyboardFocus :: () {
    __c__PopAllowKeyboardFocus()
}
PushButtonRepeat :: (_repeat: bool) {
    __c__PushButtonRepeat(_repeat)
}
PopButtonRepeat :: () {
    __c__PopButtonRepeat()
}
Separator :: () {
    __c__Separator()
}
SameLine :: (_offset_from_start_x: f32 = 0.0f, _spacing: f32 = -1.0f) {
    __c__SameLine(_offset_from_start_x, _spacing)
}
NewLine :: () {
    __c__NewLine()
}
Spacing :: () {
    __c__Spacing()
}
Dummy :: (_size: &ImVec2) {
    __c__Dummy(^*_size)
}
Indent :: (_indent_w: f32 = 0.0f) {
    __c__Indent(_indent_w)
}
Unindent :: (_indent_w: f32 = 0.0f) {
    __c__Unindent(_indent_w)
}
BeginGroup :: () {
    __c__BeginGroup()
}
EndGroup :: () {
    __c__EndGroup()
}
GetCursorPos :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetCursorPos(^result)
    return result
}
GetCursorPosX :: () -> f32 {
    result : f32 = default
    __c__GetCursorPosX(^result)
    return result
}
GetCursorPosY :: () -> f32 {
    result : f32 = default
    __c__GetCursorPosY(^result)
    return result
}
SetCursorPos :: (_local_pos: &ImVec2) {
    __c__SetCursorPos(^*_local_pos)
}
SetCursorPosX :: (_local_x: f32) {
    __c__SetCursorPosX(_local_x)
}
SetCursorPosY :: (_local_y: f32) {
    __c__SetCursorPosY(_local_y)
}
GetCursorStartPos :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetCursorStartPos(^result)
    return result
}
GetCursorScreenPos :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetCursorScreenPos(^result)
    return result
}
SetCursorScreenPos :: (_pos: &ImVec2) {
    __c__SetCursorScreenPos(^*_pos)
}
AlignTextToFramePadding :: () {
    __c__AlignTextToFramePadding()
}
GetTextLineHeight :: () -> f32 {
    result : f32 = default
    __c__GetTextLineHeight(^result)
    return result
}
GetTextLineHeightWithSpacing :: () -> f32 {
    result : f32 = default
    __c__GetTextLineHeightWithSpacing(^result)
    return result
}
GetFrameHeight :: () -> f32 {
    result : f32 = default
    __c__GetFrameHeight(^result)
    return result
}
GetFrameHeightWithSpacing :: () -> f32 {
    result : f32 = default
    __c__GetFrameHeightWithSpacing(^result)
    return result
}
PushID :: (_str_id: ^char8) {
    __c__PushID(_str_id)
}
PushID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8) {
    __c__PushID_2(_str_id_begin, _str_id_end)
}
PushIDPtr :: (_ptr_id: ^void) {
    __c__PushID_3(_ptr_id)
}
PushIDInt :: (_int_id: i32) {
    __c__PushID_4(_int_id)
}
PopID :: () {
    __c__PopID()
}
GetID :: (_str_id: ^char8) -> ImGuiID {
    result : ImGuiID = default
    __c__GetID(^result, _str_id)
    return result
}
GetID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8) -> ImGuiID {
    result : ImGuiID = default
    __c__GetID_2(^result, _str_id_begin, _str_id_end)
    return result
}
GetID_3 :: (_ptr_id: ^void) -> ImGuiID {
    result : ImGuiID = default
    __c__GetID_3(^result, _ptr_id)
    return result
}
TextUnformatted :: (_text: ^char8, _text_end: ^char8 = null) {
    __c__TextUnformatted(_text, _text_end)
}
Text :: (_fmt: ^char8) {
    __c__Text(_fmt)
}
TextV :: (_fmt: ^char8, _args: va_list) {
    __c__TextV(_fmt, _args)
}
TextColored :: (_col: &ImVec4, _fmt: ^char8) {
    __c__TextColored(^*_col, _fmt)
}
TextColoredV :: (_col: &ImVec4, _fmt: ^char8, _args: va_list) {
    __c__TextColoredV(^*_col, _fmt, _args)
}
TextDisabled :: (_fmt: ^char8) {
    __c__TextDisabled(_fmt)
}
TextDisabledV :: (_fmt: ^char8, _args: va_list) {
    __c__TextDisabledV(_fmt, _args)
}
TextWrapped :: (_fmt: ^char8) {
    __c__TextWrapped(_fmt)
}
TextWrappedV :: (_fmt: ^char8, _args: va_list) {
    __c__TextWrappedV(_fmt, _args)
}
LabelText :: (_label: ^char8, _fmt: ^char8) {
    __c__LabelText(_label, _fmt)
}
LabelTextV :: (_label: ^char8, _fmt: ^char8, _args: va_list) {
    __c__LabelTextV(_label, _fmt, _args)
}
BulletText :: (_fmt: ^char8) {
    __c__BulletText(_fmt)
}
BulletTextV :: (_fmt: ^char8, _args: va_list) {
    __c__BulletTextV(_fmt, _args)
}
Button :: (_label: ^char8, _size: &ImVec2) -> bool {
    result : bool = default
    __c__Button(^result, _label, ^*_size)
    return result
}
SmallButton :: (_label: ^char8) -> bool {
    result : bool = default
    __c__SmallButton(^result, _label)
    return result
}
InvisibleButton :: (_str_id: ^char8, _size: &ImVec2) -> bool {
    result : bool = default
    __c__InvisibleButton(^result, _str_id, ^*_size)
    return result
}
ArrowButton :: (_str_id: ^char8, _dir: ImGuiDir) -> bool {
    result : bool = default
    __c__ArrowButton(^result, _str_id, _dir)
    return result
}
Image :: (_user_texture_id: ImTextureID, _size: &ImVec2, _uv0: &ImVec2, _uv1: &ImVec2, _tint_col: &ImVec4, _border_col: &ImVec4) {
    __c__Image(_user_texture_id, ^*_size, ^*_uv0, ^*_uv1, ^*_tint_col, ^*_border_col)
}
ImageButton :: (_user_texture_id: ImTextureID, _size: &ImVec2, _uv0: &ImVec2, _uv1: &ImVec2, _frame_padding: i32 = -1, _bg_col: &ImVec4, _tint_col: &ImVec4) -> bool {
    result : bool = default
    __c__ImageButton(^result, _user_texture_id, ^*_size, ^*_uv0, ^*_uv1, _frame_padding, ^*_bg_col, ^*_tint_col)
    return result
}
Checkbox :: (_label: ^char8, _v: ^bool) -> bool {
    result : bool = default
    __c__Checkbox(^result, _label, _v)
    return result
}
CheckboxFlags :: (_label: ^char8, _flags: ^u32, _flags_value: u32) -> bool {
    result : bool = default
    __c__CheckboxFlags(^result, _label, _flags, _flags_value)
    return result
}
RadioButton :: (_label: ^char8, _active: bool) -> bool {
    result : bool = default
    __c__RadioButton(^result, _label, _active)
    return result
}
RadioButton_2 :: (_label: ^char8, _v: ^i32, _v_button: i32) -> bool {
    result : bool = default
    __c__RadioButton_2(^result, _label, _v, _v_button)
    return result
}
ProgressBar :: (_fraction: f32, _size_arg: &ImVec2, _overlay: ^char8 = null) {
    __c__ProgressBar(_fraction, ^*_size_arg, _overlay)
}
Bullet :: () {
    __c__Bullet()
}
BeginCombo :: (_label: ^char8, _preview_value: ^char8, _flags: ImGuiComboFlags = 0) -> bool {
    result : bool = default
    __c__BeginCombo(^result, _label, _preview_value, _flags)
    return result
}
EndCombo :: () {
    __c__EndCombo()
}
Combo :: (_label: ^char8, _current_item: ^i32, _items: ^^char8, _items_count: i32, _popup_max_height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__Combo(^result, _label, _current_item, _items, _items_count, _popup_max_height_in_items)
    return result
}
Combo_2 :: (_label: ^char8, _current_item: ^i32, _items_separated_by_zeros: ^char8, _popup_max_height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__Combo_2(^result, _label, _current_item, _items_separated_by_zeros, _popup_max_height_in_items)
    return result
}
Combo_3 :: (_label: ^char8, _current_item: ^i32, _items_getter: fn(^void, i32, ^^char8) -> bool, _data: ^void, _items_count: i32, _popup_max_height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__Combo_3(^result, _label, _current_item, _items_getter, _data, _items_count, _popup_max_height_in_items)
    return result
}
DragFloat :: (_label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragFloat(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _power)
    return result
}
DragFloat2 :: (_label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragFloat2(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _power)
    return result
}
DragFloat3 :: (_label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragFloat3(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _power)
    return result
}
DragFloat4 :: (_label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragFloat4(^result, _label, _v, _v_speed, _v_min, _v_max, _format, _power)
    return result
}
DragFloatRange2 :: (_label: ^char8, _v_current_min: ^f32, _v_current_max: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _format_max: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragFloatRange2(^result, _label, _v_current_min, _v_current_max, _v_speed, _v_min, _v_max, _format, _format_max, _power)
    return result
}
DragInt :: (_label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__DragInt(^result, _label, _v, _v_speed, _v_min, _v_max, _format)
    return result
}
DragInt2 :: (_label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__DragInt2(^result, _label, _v, _v_speed, _v_min, _v_max, _format)
    return result
}
DragInt3 :: (_label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__DragInt3(^result, _label, _v, _v_speed, _v_min, _v_max, _format)
    return result
}
DragInt4 :: (_label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__DragInt4(^result, _label, _v, _v_speed, _v_min, _v_max, _format)
    return result
}
DragIntRange2 :: (_label: ^char8, _v_current_min: ^i32, _v_current_max: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d", _format_max: ^char8 = null) -> bool {
    result : bool = default
    __c__DragIntRange2(^result, _label, _v_current_min, _v_current_max, _v_speed, _v_min, _v_max, _format, _format_max)
    return result
}
DragScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _v_speed: f32, _p_min: ^void = null, _p_max: ^void = null, _format: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragScalar(^result, _label, _data_type, _p_data, _v_speed, _p_min, _p_max, _format, _power)
    return result
}
DragScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _v_speed: f32, _p_min: ^void = null, _p_max: ^void = null, _format: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__DragScalarN(^result, _label, _data_type, _p_data, _components, _v_speed, _p_min, _p_max, _format, _power)
    return result
}
SliderFloat :: (_label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderFloat(^result, _label, _v, _v_min, _v_max, _format, _power)
    return result
}
SliderFloat2 :: (_label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderFloat2(^result, _label, _v, _v_min, _v_max, _format, _power)
    return result
}
SliderFloat3 :: (_label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderFloat3(^result, _label, _v, _v_min, _v_max, _format, _power)
    return result
}
SliderFloat4 :: (_label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderFloat4(^result, _label, _v, _v_min, _v_max, _format, _power)
    return result
}
SliderAngle :: (_label: ^char8, _v_rad: ^f32, _v_degrees_min: f32 = -360.0f, _v_degrees_max: f32 = 360.0f, _format: ^char8 = "%.0f deg") -> bool {
    result : bool = default
    __c__SliderAngle(^result, _label, _v_rad, _v_degrees_min, _v_degrees_max, _format)
    return result
}
SliderInt :: (_label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__SliderInt(^result, _label, _v, _v_min, _v_max, _format)
    return result
}
SliderInt2 :: (_label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__SliderInt2(^result, _label, _v, _v_min, _v_max, _format)
    return result
}
SliderInt3 :: (_label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__SliderInt3(^result, _label, _v, _v_min, _v_max, _format)
    return result
}
SliderInt4 :: (_label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__SliderInt4(^result, _label, _v, _v_min, _v_max, _format)
    return result
}
SliderScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderScalar(^result, _label, _data_type, _p_data, _p_min, _p_max, _format, _power)
    return result
}
SliderScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__SliderScalarN(^result, _label, _data_type, _p_data, _components, _p_min, _p_max, _format, _power)
    return result
}
VSliderFloat :: (_label: ^char8, _size: &ImVec2, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__VSliderFloat(^result, _label, ^*_size, _v, _v_min, _v_max, _format, _power)
    return result
}
VSliderInt :: (_label: ^char8, _size: &ImVec2, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d") -> bool {
    result : bool = default
    __c__VSliderInt(^result, _label, ^*_size, _v, _v_min, _v_max, _format)
    return result
}
VSliderScalar :: (_label: ^char8, _size: &ImVec2, _data_type: ImGuiDataType, _p_data: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f) -> bool {
    result : bool = default
    __c__VSliderScalar(^result, _label, ^*_size, _data_type, _p_data, _p_min, _p_max, _format, _power)
    return result
}
InputText :: (_label: ^char8, _buf: ^char8, _buf_size: size_t, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null) -> bool {
    result : bool = default
    __c__InputText(^result, _label, _buf, _buf_size, _flags, _callback, _user_data)
    return result
}
InputTextMultiline :: (_label: ^char8, _buf: ^char8, _buf_size: size_t, _size: &ImVec2, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null) -> bool {
    result : bool = default
    __c__InputTextMultiline(^result, _label, _buf, _buf_size, ^*_size, _flags, _callback, _user_data)
    return result
}
InputTextWithHint :: (_label: ^char8, _hint: ^char8, _buf: ^char8, _buf_size: size_t, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null) -> bool {
    result : bool = default
    __c__InputTextWithHint(^result, _label, _hint, _buf, _buf_size, _flags, _callback, _user_data)
    return result
}
InputFloat :: (_label: ^char8, _v: ^f32, _step: f32 = 0.0f, _step_fast: f32 = 0.0f, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat(^result, _label, _v, _step, _step_fast, _format, _flags)
    return result
}
InputFloat2 :: (_label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat2(^result, _label, _v, _format, _flags)
    return result
}
InputFloat3 :: (_label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat3(^result, _label, _v, _format, _flags)
    return result
}
InputFloat4 :: (_label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat4(^result, _label, _v, _format, _flags)
    return result
}
InputInt :: (_label: ^char8, _v: ^i32, _step: i32 = 1, _step_fast: i32 = 100, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputInt(^result, _label, _v, _step, _step_fast, _flags)
    return result
}
InputInt2 :: (_label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputInt2(^result, _label, _v, _flags)
    return result
}
InputInt3 :: (_label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputInt3(^result, _label, _v, _flags)
    return result
}
InputInt4 :: (_label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputInt4(^result, _label, _v, _flags)
    return result
}
InputDouble :: (_label: ^char8, _v: ^f64, _step: f64 = 0.0, _step_fast: f64 = 0.0, _format: ^char8 = "%.6f", _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputDouble(^result, _label, _v, _step, _step_fast, _format, _flags)
    return result
}
InputScalar :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _p_step: ^void = null, _p_step_fast: ^void = null, _format: ^char8 = null, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputScalar(^result, _label, _data_type, _p_data, _p_step, _p_step_fast, _format, _flags)
    return result
}
InputScalarN :: (_label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _p_step: ^void = null, _p_step_fast: ^void = null, _format: ^char8 = null, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputScalarN(^result, _label, _data_type, _p_data, _components, _p_step, _p_step_fast, _format, _flags)
    return result
}
ColorEdit3 :: (_label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0) -> bool {
    result : bool = default
    __c__ColorEdit3(^result, _label, _col, _flags)
    return result
}
ColorEdit4 :: (_label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0) -> bool {
    result : bool = default
    __c__ColorEdit4(^result, _label, _col, _flags)
    return result
}
ColorPicker3 :: (_label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0) -> bool {
    result : bool = default
    __c__ColorPicker3(^result, _label, _col, _flags)
    return result
}
ColorPicker4 :: (_label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0, _ref_col: ^f32 = null) -> bool {
    result : bool = default
    __c__ColorPicker4(^result, _label, _col, _flags, _ref_col)
    return result
}
ColorButton :: (_desc_id: ^char8, _col: &ImVec4, _flags: ImGuiColorEditFlags = 0, _size: ImVec2) -> bool {
    result : bool = default
    __c__ColorButton(^result, _desc_id, ^*_col, _flags, ^_size)
    return result
}
SetColorEditOptions :: (_flags: ImGuiColorEditFlags) {
    __c__SetColorEditOptions(_flags)
}
TreeNode :: (_label: ^char8) -> bool {
    result : bool = default
    __c__TreeNode(^result, _label)
    return result
}
TreeNode_2 :: (_str_id: ^char8, _fmt: ^char8) -> bool {
    result : bool = default
    __c__TreeNode_2(^result, _str_id, _fmt)
    return result
}
TreeNode_3 :: (_ptr_id: ^void, _fmt: ^char8) -> bool {
    result : bool = default
    __c__TreeNode_3(^result, _ptr_id, _fmt)
    return result
}
TreeNodeV :: (_str_id: ^char8, _fmt: ^char8, _args: va_list) -> bool {
    result : bool = default
    __c__TreeNodeV(^result, _str_id, _fmt, _args)
    return result
}
TreeNodeV_2 :: (_ptr_id: ^void, _fmt: ^char8, _args: va_list) -> bool {
    result : bool = default
    __c__TreeNodeV_2(^result, _ptr_id, _fmt, _args)
    return result
}
TreeNodeEx :: (_label: ^char8, _flags: ImGuiTreeNodeFlags = 0) -> bool {
    result : bool = default
    __c__TreeNodeEx(^result, _label, _flags)
    return result
}
TreeNodeEx_2 :: (_str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8) -> bool {
    result : bool = default
    __c__TreeNodeEx_2(^result, _str_id, _flags, _fmt)
    return result
}
TreeNodeEx_3 :: (_ptr_id: ^void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8) -> bool {
    result : bool = default
    __c__TreeNodeEx_3(^result, _ptr_id, _flags, _fmt)
    return result
}
TreeNodeExV :: (_str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list) -> bool {
    result : bool = default
    __c__TreeNodeExV(^result, _str_id, _flags, _fmt, _args)
    return result
}
TreeNodeExV_2 :: (_ptr_id: ^void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list) -> bool {
    result : bool = default
    __c__TreeNodeExV_2(^result, _ptr_id, _flags, _fmt, _args)
    return result
}
TreePush :: (_str_id: ^char8) {
    __c__TreePush(_str_id)
}
TreePush_2 :: (_ptr_id: ^void = null) {
    __c__TreePush_2(_ptr_id)
}
TreePop :: () {
    __c__TreePop()
}
GetTreeNodeToLabelSpacing :: () -> f32 {
    result : f32 = default
    __c__GetTreeNodeToLabelSpacing(^result)
    return result
}
CollapsingHeader :: (_label: ^char8, _flags: ImGuiTreeNodeFlags = 0) -> bool {
    result : bool = default
    __c__CollapsingHeader(^result, _label, _flags)
    return result
}
CollapsingHeader_2 :: (_label: ^char8, _p_open: ^bool, _flags: ImGuiTreeNodeFlags = 0) -> bool {
    result : bool = default
    __c__CollapsingHeader_2(^result, _label, _p_open, _flags)
    return result
}
SetNextItemOpen :: (_is_open: bool, _cond: ImGuiCond = 0) {
    __c__SetNextItemOpen(_is_open, _cond)
}
Selectable :: (_label: ^char8, _selected: bool = false, _flags: ImGuiSelectableFlags = 0, _size: &ImVec2) -> bool {
    result : bool = default
    __c__Selectable(^result, _label, _selected, _flags, ^*_size)
    return result
}
Selectable_2 :: (_label: ^char8, _p_selected: ^bool, _flags: ImGuiSelectableFlags = 0, _size: &ImVec2) -> bool {
    result : bool = default
    __c__Selectable_2(^result, _label, _p_selected, _flags, ^*_size)
    return result
}
ListBox :: (_label: ^char8, _current_item: ^i32, _items: ^^char8, _items_count: i32, _height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__ListBox(^result, _label, _current_item, _items, _items_count, _height_in_items)
    return result
}
ListBoxFnPtr :: (_label: ^char8, _current_item: ^i32, _items_getter: fn(^void, i32, ^mut ^char8) -> bool, _data: ^void, _items_count: i32, _height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__ListBox_2(^result, _label, _current_item, _items_getter, _data, _items_count, _height_in_items)
    return result
}
ListBoxHeader :: (_label: ^char8, _size: &ImVec2) -> bool {
    result : bool = default
    __c__ListBoxHeader(^result, _label, ^*_size)
    return result
}
ListBoxHeader_2 :: (_label: ^char8, _items_count: i32, _height_in_items: i32 = -1) -> bool {
    result : bool = default
    __c__ListBoxHeader_2(^result, _label, _items_count, _height_in_items)
    return result
}
ListBoxFooter :: () {
    __c__ListBoxFooter()
}
PlotLines :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ImVec2, _stride: i32) {
    __c__PlotLines(_label, _values, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^_graph_size, _stride)
}
PlotLines_2 :: (_label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ImVec2) {
    __c__PlotLines_2(_label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^_graph_size)
}
PlotHistogram :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ImVec2, _stride: i32) {
    __c__PlotHistogram(_label, _values, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^_graph_size, _stride)
}
PlotHistogram_2 :: (_label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ImVec2) {
    __c__PlotHistogram_2(_label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^_graph_size)
}
Value :: (_prefix: ^char8, _b: bool) {
    __c__Value(_prefix, _b)
}
Value_2 :: (_prefix: ^char8, _v: i32) {
    __c__Value_2(_prefix, _v)
}
Value_3 :: (_prefix: ^char8, _v: u32) {
    __c__Value_3(_prefix, _v)
}
Value_4 :: (_prefix: ^char8, _v: f32, _float_format: ^char8 = null) {
    __c__Value_4(_prefix, _v, _float_format)
}
BeginMenuBar :: () -> bool {
    result : bool = default
    __c__BeginMenuBar(^result)
    return result
}
EndMenuBar :: () {
    __c__EndMenuBar()
}
BeginMainMenuBar :: () -> bool {
    result : bool = default
    __c__BeginMainMenuBar(^result)
    return result
}
EndMainMenuBar :: () {
    __c__EndMainMenuBar()
}
BeginMenu :: (_label: ^char8, _enabled: bool = true) -> bool {
    result : bool = default
    __c__BeginMenu(^result, _label, _enabled)
    return result
}
EndMenu :: () {
    __c__EndMenu()
}
MenuItem :: (_label: ^char8, _shortcut: ^char8 = null, _selected: bool = false, _enabled: bool = true) -> bool {
    result : bool = default
    __c__MenuItem(^result, _label, _shortcut, _selected, _enabled)
    return result
}
MenuItem_2 :: (_label: ^char8, _shortcut: ^char8, _p_selected: ^bool, _enabled: bool = true) -> bool {
    result : bool = default
    __c__MenuItem_2(^result, _label, _shortcut, _p_selected, _enabled)
    return result
}
BeginTooltip :: () {
    __c__BeginTooltip()
}
EndTooltip :: () {
    __c__EndTooltip()
}
SetTooltip :: (_fmt: ^char8) {
    __c__SetTooltip(_fmt)
}
SetTooltipV :: (_fmt: ^char8, _args: va_list) {
    __c__SetTooltipV(_fmt, _args)
}
OpenPopup :: (_str_id: ^char8) {
    __c__OpenPopup(_str_id)
}
BeginPopup :: (_str_id: ^char8, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__BeginPopup(^result, _str_id, _flags)
    return result
}
BeginPopupContextItem :: (_str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1) -> bool {
    result : bool = default
    __c__BeginPopupContextItem(^result, _str_id, _mouse_button)
    return result
}
BeginPopupContextWindow :: (_str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1, _also_over_items: bool = true) -> bool {
    result : bool = default
    __c__BeginPopupContextWindow(^result, _str_id, _mouse_button, _also_over_items)
    return result
}
BeginPopupContextVoid :: (_str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1) -> bool {
    result : bool = default
    __c__BeginPopupContextVoid(^result, _str_id, _mouse_button)
    return result
}
BeginPopupModal :: (_name: ^char8, _p_open: ^bool = null, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__BeginPopupModal(^result, _name, _p_open, _flags)
    return result
}
EndPopup :: () {
    __c__EndPopup()
}
OpenPopupOnItemClick :: (_str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1) -> bool {
    result : bool = default
    __c__OpenPopupOnItemClick(^result, _str_id, _mouse_button)
    return result
}
IsPopupOpen :: (_str_id: ^char8) -> bool {
    result : bool = default
    __c__IsPopupOpen(^result, _str_id)
    return result
}
CloseCurrentPopup :: () {
    __c__CloseCurrentPopup()
}
Columns :: (_count: i32 = 1, _id: ^char8 = null, _border: bool = true) {
    __c__Columns(_count, _id, _border)
}
NextColumn :: () {
    __c__NextColumn()
}
GetColumnIndex :: () -> i32 {
    result : i32 = default
    __c__GetColumnIndex(^result)
    return result
}
GetColumnWidth :: (_column_index: i32 = -1) -> f32 {
    result : f32 = default
    __c__GetColumnWidth(^result, _column_index)
    return result
}
SetColumnWidth :: (_column_index: i32, _width: f32) {
    __c__SetColumnWidth(_column_index, _width)
}
GetColumnOffset :: (_column_index: i32 = -1) -> f32 {
    result : f32 = default
    __c__GetColumnOffset(^result, _column_index)
    return result
}
SetColumnOffset :: (_column_index: i32, _offset_x: f32) {
    __c__SetColumnOffset(_column_index, _offset_x)
}
GetColumnsCount :: () -> i32 {
    result : i32 = default
    __c__GetColumnsCount(^result)
    return result
}
BeginTabBar :: (_str_id: ^char8, _flags: ImGuiTabBarFlags = 0) -> bool {
    result : bool = default
    __c__BeginTabBar(^result, _str_id, _flags)
    return result
}
EndTabBar :: () {
    __c__EndTabBar()
}
BeginTabItem :: (_label: ^char8, _p_open: ^bool = null, _flags: ImGuiTabItemFlags = 0) -> bool {
    result : bool = default
    __c__BeginTabItem(^result, _label, _p_open, _flags)
    return result
}
EndTabItem :: () {
    __c__EndTabItem()
}
SetTabItemClosed :: (_tab_or_docked_window_label: ^char8) {
    __c__SetTabItemClosed(_tab_or_docked_window_label)
}
DockSpace :: (_id: ImGuiID, _size: &ImVec2, _flags: ImGuiDockNodeFlags = 0, _window_class: ^ImGuiWindowClass = null) {
    __c__DockSpace(_id, ^*_size, _flags, _window_class)
}
DockSpaceOverViewport :: (_viewport: ^ImGuiViewport = null, _flags: ImGuiDockNodeFlags = 0, _window_class: ^ImGuiWindowClass = null) -> ImGuiID {
    result : ImGuiID = default
    __c__DockSpaceOverViewport(^result, _viewport, _flags, _window_class)
    return result
}
SetNextWindowDockID :: (_dock_id: ImGuiID, _cond: ImGuiCond = 0) {
    __c__SetNextWindowDockID(_dock_id, _cond)
}
SetNextWindowClass :: (_window_class: ^ImGuiWindowClass) {
    __c__SetNextWindowClass(_window_class)
}
GetWindowDockID :: () -> ImGuiID {
    result : ImGuiID = default
    __c__GetWindowDockID(^result)
    return result
}
IsWindowDocked :: () -> bool {
    result : bool = default
    __c__IsWindowDocked(^result)
    return result
}
LogToTTY :: (_auto_open_depth: i32 = -1) {
    __c__LogToTTY(_auto_open_depth)
}
LogToFile :: (_auto_open_depth: i32 = -1, _filename: ^char8 = null) {
    __c__LogToFile(_auto_open_depth, _filename)
}
LogToClipboard :: (_auto_open_depth: i32 = -1) {
    __c__LogToClipboard(_auto_open_depth)
}
LogFinish :: () {
    __c__LogFinish()
}
LogButtons :: () {
    __c__LogButtons()
}
LogText :: (_fmt: ^char8) {
    __c__LogText(_fmt)
}
BeginDragDropSource :: (_flags: ImGuiDragDropFlags = 0) -> bool {
    result : bool = default
    __c__BeginDragDropSource(^result, _flags)
    return result
}
SetDragDropPayload :: (_type: ^char8, _data: ^void, _sz: size_t, _cond: ImGuiCond = 0) -> bool {
    result : bool = default
    __c__SetDragDropPayload(^result, _type, _data, _sz, _cond)
    return result
}
EndDragDropSource :: () {
    __c__EndDragDropSource()
}
BeginDragDropTarget :: () -> bool {
    result : bool = default
    __c__BeginDragDropTarget(^result)
    return result
}
AcceptDragDropPayload :: (_type: ^char8, _flags: ImGuiDragDropFlags = 0) -> ^ImGuiPayload {
    result : ^ImGuiPayload = default
    __c__AcceptDragDropPayload(^result, _type, _flags)
    return result
}
EndDragDropTarget :: () {
    __c__EndDragDropTarget()
}
GetDragDropPayload :: () -> ^ImGuiPayload {
    result : ^ImGuiPayload = default
    __c__GetDragDropPayload(^result)
    return result
}
PushClipRect :: (_clip_rect_min: &ImVec2, _clip_rect_max: &ImVec2, _intersect_with_current_clip_rect: bool) {
    __c__PushClipRect(^*_clip_rect_min, ^*_clip_rect_max, _intersect_with_current_clip_rect)
}
PopClipRect :: () {
    __c__PopClipRect()
}
SetItemDefaultFocus :: () {
    __c__SetItemDefaultFocus()
}
SetKeyboardFocusHere :: (_offset: i32 = 0) {
    __c__SetKeyboardFocusHere(_offset)
}
IsItemHovered :: (_flags: ImGuiHoveredFlags = 0) -> bool {
    result : bool = default
    __c__IsItemHovered(^result, _flags)
    return result
}
IsItemActive :: () -> bool {
    result : bool = default
    __c__IsItemActive(^result)
    return result
}
IsItemFocused :: () -> bool {
    result : bool = default
    __c__IsItemFocused(^result)
    return result
}
IsItemClicked :: (_mouse_button: ImGuiMouseButton = 0) -> bool {
    result : bool = default
    __c__IsItemClicked(^result, _mouse_button)
    return result
}
IsItemVisible :: () -> bool {
    result : bool = default
    __c__IsItemVisible(^result)
    return result
}
IsItemEdited :: () -> bool {
    result : bool = default
    __c__IsItemEdited(^result)
    return result
}
IsItemActivated :: () -> bool {
    result : bool = default
    __c__IsItemActivated(^result)
    return result
}
IsItemDeactivated :: () -> bool {
    result : bool = default
    __c__IsItemDeactivated(^result)
    return result
}
IsItemDeactivatedAfterEdit :: () -> bool {
    result : bool = default
    __c__IsItemDeactivatedAfterEdit(^result)
    return result
}
IsItemToggledOpen :: () -> bool {
    result : bool = default
    __c__IsItemToggledOpen(^result)
    return result
}
IsAnyItemHovered :: () -> bool {
    result : bool = default
    __c__IsAnyItemHovered(^result)
    return result
}
IsAnyItemActive :: () -> bool {
    result : bool = default
    __c__IsAnyItemActive(^result)
    return result
}
IsAnyItemFocused :: () -> bool {
    result : bool = default
    __c__IsAnyItemFocused(^result)
    return result
}
GetItemRectMin :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetItemRectMin(^result)
    return result
}
GetItemRectMax :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetItemRectMax(^result)
    return result
}
GetItemRectSize :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetItemRectSize(^result)
    return result
}
SetItemAllowOverlap :: () {
    __c__SetItemAllowOverlap()
}
IsRectVisible :: (_size: &ImVec2) -> bool {
    result : bool = default
    __c__IsRectVisible(^result, ^*_size)
    return result
}
IsRectVisible_2 :: (_rect_min: &ImVec2, _rect_max: &ImVec2) -> bool {
    result : bool = default
    __c__IsRectVisible_2(^result, ^*_rect_min, ^*_rect_max)
    return result
}
GetTime :: () -> f64 {
    result : f64 = default
    __c__GetTime(^result)
    return result
}
GetFrameCount :: () -> i32 {
    result : i32 = default
    __c__GetFrameCount(^result)
    return result
}
GetBackgroundDrawList :: () -> ^ImDrawList {
    result : ^ImDrawList = default
    __c__GetBackgroundDrawList(^result)
    return result
}
GetForegroundDrawList :: () -> ^ImDrawList {
    result : ^ImDrawList = default
    __c__GetForegroundDrawList(^result)
    return result
}
GetBackgroundDrawList_2 :: (_viewport: ^ImGuiViewport) -> ^ImDrawList {
    result : ^ImDrawList = default
    __c__GetBackgroundDrawList_2(^result, _viewport)
    return result
}
GetForegroundDrawList_2 :: (_viewport: ^ImGuiViewport) -> ^ImDrawList {
    result : ^ImDrawList = default
    __c__GetForegroundDrawList_2(^result, _viewport)
    return result
}
GetDrawListSharedData :: () -> ^ImDrawListSharedData {
    result : ^ImDrawListSharedData = default
    __c__GetDrawListSharedData(^result)
    return result
}
GetStyleColorName :: (_idx: ImGuiCol) -> ^char8 {
    result : ^char8 = default
    __c__GetStyleColorName(^result, _idx)
    return result
}
SetStateStorage :: (_storage: ^ImGuiStorage) {
    __c__SetStateStorage(_storage)
}
GetStateStorage :: () -> ^ImGuiStorage {
    result : ^ImGuiStorage = default
    __c__GetStateStorage(^result)
    return result
}
CalcTextSize :: (_text: ^char8, _text_end: ^char8 = null, _hide_text_after_double_hash: bool = false, _wrap_width: f32 = -1.0f) -> ImVec2 {
    result : ImVec2 = default
    __c__CalcTextSize(^result, _text, _text_end, _hide_text_after_double_hash, _wrap_width)
    return result
}
CalcListClipping :: (_items_count: i32, _items_height: f32, _out_items_display_start: ^i32, _out_items_display_end: ^i32) {
    __c__CalcListClipping(_items_count, _items_height, _out_items_display_start, _out_items_display_end)
}
BeginChildFrame :: (_id: ImGuiID, _size: &ImVec2, _flags: ImGuiWindowFlags = 0) -> bool {
    result : bool = default
    __c__BeginChildFrame(^result, _id, ^*_size, _flags)
    return result
}
EndChildFrame :: () {
    __c__EndChildFrame()
}
ColorConvertU32ToFloat4 :: (_in: ImU32) -> ImVec4 {
    result : ImVec4 = default
    __c__ColorConvertU32ToFloat4(^result, _in)
    return result
}
ColorConvertFloat4ToU32 :: (_in: &ImVec4) -> ImU32 {
    result : ImU32 = default
    __c__ColorConvertFloat4ToU32(^result, ^*_in)
    return result
}
ColorConvertRGBtoHSV :: (_r: f32, _g: f32, _b: f32, _out_h: &f32, _out_s: &f32, _out_v: &f32) {
    __c__ColorConvertRGBtoHSV(_r, _g, _b, ^*_out_h, ^*_out_s, ^*_out_v)
}
ColorConvertHSVtoRGB :: (_h: f32, _s: f32, _v: f32, _out_r: &f32, _out_g: &f32, _out_b: &f32) {
    __c__ColorConvertHSVtoRGB(_h, _s, _v, ^*_out_r, ^*_out_g, ^*_out_b)
}
GetKeyIndex :: (_imgui_key: ImGuiKey) -> i32 {
    result : i32 = default
    __c__GetKeyIndex(^result, _imgui_key)
    return result
}
IsKeyDown :: (_user_key_index: i32) -> bool {
    result : bool = default
    __c__IsKeyDown(^result, _user_key_index)
    return result
}
IsKeyPressed :: (_user_key_index: i32, _repeat: bool = true) -> bool {
    result : bool = default
    __c__IsKeyPressed(^result, _user_key_index, _repeat)
    return result
}
IsKeyReleased :: (_user_key_index: i32) -> bool {
    result : bool = default
    __c__IsKeyReleased(^result, _user_key_index)
    return result
}
GetKeyPressedAmount :: (_key_index: i32, _repeat_delay: f32, _rate: f32) -> i32 {
    result : i32 = default
    __c__GetKeyPressedAmount(^result, _key_index, _repeat_delay, _rate)
    return result
}
CaptureKeyboardFromApp :: (_want_capture_keyboard_value: bool = true) {
    __c__CaptureKeyboardFromApp(_want_capture_keyboard_value)
}
IsMouseDown :: (_button: ImGuiMouseButton) -> bool {
    result : bool = default
    __c__IsMouseDown(^result, _button)
    return result
}
IsMouseClicked :: (_button: ImGuiMouseButton, _repeat: bool = false) -> bool {
    result : bool = default
    __c__IsMouseClicked(^result, _button, _repeat)
    return result
}
IsMouseReleased :: (_button: ImGuiMouseButton) -> bool {
    result : bool = default
    __c__IsMouseReleased(^result, _button)
    return result
}
IsMouseDoubleClicked :: (_button: ImGuiMouseButton) -> bool {
    result : bool = default
    __c__IsMouseDoubleClicked(^result, _button)
    return result
}
IsMouseHoveringRect :: (_r_min: &ImVec2, _r_max: &ImVec2, _clip: bool = true) -> bool {
    result : bool = default
    __c__IsMouseHoveringRect(^result, ^*_r_min, ^*_r_max, _clip)
    return result
}
IsMousePosValid :: (_mouse_pos: ^ImVec2 = null) -> bool {
    result : bool = default
    __c__IsMousePosValid(^result, _mouse_pos)
    return result
}
IsAnyMouseDown :: () -> bool {
    result : bool = default
    __c__IsAnyMouseDown(^result)
    return result
}
GetMousePos :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetMousePos(^result)
    return result
}
GetMousePosOnOpeningCurrentPopup :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetMousePosOnOpeningCurrentPopup(^result)
    return result
}
IsMouseDragging :: (_button: ImGuiMouseButton, _lock_threshold: f32 = -1.0f) -> bool {
    result : bool = default
    __c__IsMouseDragging(^result, _button, _lock_threshold)
    return result
}
GetMouseDragDelta :: (_button: ImGuiMouseButton = 0, _lock_threshold: f32 = -1.0f) -> ImVec2 {
    result : ImVec2 = default
    __c__GetMouseDragDelta(^result, _button, _lock_threshold)
    return result
}
ResetMouseDragDelta :: (_button: ImGuiMouseButton = 0) {
    __c__ResetMouseDragDelta(_button)
}
GetMouseCursor :: () -> ImGuiMouseCursor {
    result : ImGuiMouseCursor = default
    __c__GetMouseCursor(^result)
    return result
}
SetMouseCursor :: (_cursor_type: ImGuiMouseCursor) {
    __c__SetMouseCursor(_cursor_type)
}
CaptureMouseFromApp :: (_want_capture_mouse_value: bool = true) {
    __c__CaptureMouseFromApp(_want_capture_mouse_value)
}
GetClipboardText :: () -> ^char8 {
    result : ^char8 = default
    __c__GetClipboardText(^result)
    return result
}
SetClipboardText :: (_text: ^char8) {
    __c__SetClipboardText(_text)
}
LoadIniSettingsFromDisk :: (_ini_filename: ^char8) {
    __c__LoadIniSettingsFromDisk(_ini_filename)
}
LoadIniSettingsFromMemory :: (_ini_data: ^char8, _ini_size: size_t = 0) {
    __c__LoadIniSettingsFromMemory(_ini_data, _ini_size)
}
SaveIniSettingsToDisk :: (_ini_filename: ^char8) {
    __c__SaveIniSettingsToDisk(_ini_filename)
}
SaveIniSettingsToMemory :: (_out_ini_size: ^size_t = null) -> ^char8 {
    result : ^char8 = default
    __c__SaveIniSettingsToMemory(^result, _out_ini_size)
    return result
}
SetAllocatorFunctions :: (_alloc_func: fn(size_t, ^void) -> ^void, _free_func: fn(^void, ^void) -> void, _user_data: ^void = null) {
    __c__SetAllocatorFunctions(_alloc_func, _free_func, _user_data)
}
MemAlloc :: (_size: size_t) -> ^void {
    result : ^void = default
    __c__MemAlloc(^result, _size)
    return result
}
MemFree :: (_ptr: ^void) {
    __c__MemFree(_ptr)
}
GetPlatformIO :: () -> &ImGuiPlatformIO {
    result : ^ImGuiPlatformIO = default
    __c__GetPlatformIO(^result)
    return &*result
}
GetMainViewport :: () -> ^ImGuiViewport {
    result : ^ImGuiViewport = default
    __c__GetMainViewport(^result)
    return result
}
UpdatePlatformWindows :: () {
    __c__UpdatePlatformWindows()
}
RenderPlatformWindowsDefault :: (_platform_arg: ^void = null, _renderer_arg: ^void = null) {
    __c__RenderPlatformWindowsDefault(_platform_arg, _renderer_arg)
}
DestroyPlatformWindows :: () {
    __c__DestroyPlatformWindows()
}
FindViewportByID :: (_id: ImGuiID) -> ^ImGuiViewport {
    result : ^ImGuiViewport = default
    __c__FindViewportByID(^result, _id)
    return result
}
FindViewportByPlatformHandle :: (_platform_handle: ^void) -> ^ImGuiViewport {
    result : ^ImGuiViewport = default
    __c__FindViewportByPlatformHandle(^result, _platform_handle)
    return result
}
InputFloat_2 :: (_label: ^char8, _v: ^f32, _step: f32, _step_fast: f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat_2(^result, _label, _v, _step, _step_fast, _decimal_precision, _flags)
    return result
}
InputFloat2_2 :: (_label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat2_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
InputFloat3_2 :: (_label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat3_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
InputFloat4_2 :: (_label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0) -> bool {
    result : bool = default
    __c__InputFloat4_2(^result, _label, _v, _decimal_precision, _flags)
    return result
}
ImHashData :: (_data: ^void, _data_size: size_t, _seed: ImU32 = 0) -> ImU32 {
    result : ImU32 = default
    __c__ImHashData(^result, _data, _data_size, _seed)
    return result
}
ImHashStr :: (_data: ^char8, _data_size: size_t = 0, _seed: ImU32 = 0) -> ImU32 {
    result : ImU32 = default
    __c__ImHashStr(^result, _data, _data_size, _seed)
    return result
}
ImStricmp :: (_str1: ^char8, _str2: ^char8) -> i32 {
    result : i32 = default
    __c__ImStricmp(^result, _str1, _str2)
    return result
}
ImStrnicmp :: (_str1: ^char8, _str2: ^char8, _count: size_t) -> i32 {
    result : i32 = default
    __c__ImStrnicmp(^result, _str1, _str2, _count)
    return result
}
ImStrncpy :: (_dst: ^char8, _src: ^char8, _count: size_t) {
    __c__ImStrncpy(_dst, _src, _count)
}
ImStrdup :: (_str: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStrdup(^result, _str)
    return result
}
ImStrdupcpy :: (_dst: ^char8, _p_dst_size: ^size_t, _str: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStrdupcpy(^result, _dst, _p_dst_size, _str)
    return result
}
ImStrchrRange :: (_str_begin: ^char8, _str_end: ^char8, _c: char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStrchrRange(^result, _str_begin, _str_end, _c)
    return result
}
ImStrlenW :: (_str: ^ImWchar) -> i32 {
    result : i32 = default
    __c__ImStrlenW(^result, _str)
    return result
}
ImStreolRange :: (_str: ^char8, _str_end: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStreolRange(^result, _str, _str_end)
    return result
}
ImStrbolW :: (_buf_mid_line: ^ImWchar, _buf_begin: ^ImWchar) -> ^ImWchar {
    result : ^ImWchar = default
    __c__ImStrbolW(^result, _buf_mid_line, _buf_begin)
    return result
}
ImStristr :: (_haystack: ^char8, _haystack_end: ^char8, _needle: ^char8, _needle_end: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStristr(^result, _haystack, _haystack_end, _needle, _needle_end)
    return result
}
ImStrTrimBlanks :: (_str: ^char8) {
    __c__ImStrTrimBlanks(_str)
}
ImStrSkipBlank :: (_str: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImStrSkipBlank(^result, _str)
    return result
}
ImFormatString :: (_buf: ^char8, _buf_size: size_t, _fmt: ^char8) -> i32 {
    result : i32 = default
    __c__ImFormatString(^result, _buf, _buf_size, _fmt)
    return result
}
ImFormatStringV :: (_buf: ^char8, _buf_size: size_t, _fmt: ^char8, _args: va_list) -> i32 {
    result : i32 = default
    __c__ImFormatStringV(^result, _buf, _buf_size, _fmt, _args)
    return result
}
ImParseFormatFindStart :: (_format: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImParseFormatFindStart(^result, _format)
    return result
}
ImParseFormatFindEnd :: (_format: ^char8) -> ^char8 {
    result : ^char8 = default
    __c__ImParseFormatFindEnd(^result, _format)
    return result
}
ImParseFormatTrimDecorations :: (_format: ^char8, _buf: ^char8, _buf_size: size_t) -> ^char8 {
    result : ^char8 = default
    __c__ImParseFormatTrimDecorations(^result, _format, _buf, _buf_size)
    return result
}
ImParseFormatPrecision :: (_format: ^char8, _default_value: i32) -> i32 {
    result : i32 = default
    __c__ImParseFormatPrecision(^result, _format, _default_value)
    return result
}
ImTextStrToUtf8 :: (_buf: ^char8, _buf_size: i32, _in_text: ^ImWchar, _in_text_end: ^ImWchar) -> i32 {
    result : i32 = default
    __c__ImTextStrToUtf8(^result, _buf, _buf_size, _in_text, _in_text_end)
    return result
}
ImTextCharFromUtf8 :: (_out_char: ^u32, _in_text: ^char8, _in_text_end: ^char8) -> i32 {
    result : i32 = default
    __c__ImTextCharFromUtf8(^result, _out_char, _in_text, _in_text_end)
    return result
}
ImTextStrFromUtf8 :: (_buf: ^ImWchar, _buf_size: i32, _in_text: ^char8, _in_text_end: ^char8, _in_remaining: ^^char8 = null) -> i32 {
    result : i32 = default
    __c__ImTextStrFromUtf8(^result, _buf, _buf_size, _in_text, _in_text_end, _in_remaining)
    return result
}
ImTextCountCharsFromUtf8 :: (_in_text: ^char8, _in_text_end: ^char8) -> i32 {
    result : i32 = default
    __c__ImTextCountCharsFromUtf8(^result, _in_text, _in_text_end)
    return result
}
ImTextCountUtf8BytesFromChar :: (_in_text: ^char8, _in_text_end: ^char8) -> i32 {
    result : i32 = default
    __c__ImTextCountUtf8BytesFromChar(^result, _in_text, _in_text_end)
    return result
}
ImTextCountUtf8BytesFromStr :: (_in_text: ^ImWchar, _in_text_end: ^ImWchar) -> i32 {
    result : i32 = default
    __c__ImTextCountUtf8BytesFromStr(^result, _in_text, _in_text_end)
    return result
}
ImFileOpen :: (_filename: ^char8, _mode: ^char8) -> ImFileHandle {
    result : ImFileHandle = default
    __c__ImFileOpen(^result, _filename, _mode)
    return result
}
ImFileClose :: (_file: ImFileHandle) -> bool {
    result : bool = default
    __c__ImFileClose(^result, _file)
    return result
}
ImFileGetSize :: (_file: ImFileHandle) -> ImU64 {
    result : ImU64 = default
    __c__ImFileGetSize(^result, _file)
    return result
}
ImFileRead :: (_data: ^void, _size: ImU64, _count: ImU64, _file: ImFileHandle) -> ImU64 {
    result : ImU64 = default
    __c__ImFileRead(^result, _data, _size, _count, _file)
    return result
}
ImFileWrite :: (_data: ^void, _size: ImU64, _count: ImU64, _file: ImFileHandle) -> ImU64 {
    result : ImU64 = default
    __c__ImFileWrite(^result, _data, _size, _count, _file)
    return result
}
ImFileLoadToMemory :: (_filename: ^char8, _mode: ^char8, _out_file_size: ^size_t = null, _padding_bytes: i32 = 0) -> ^void {
    result : ^void = default
    __c__ImFileLoadToMemory(^result, _filename, _mode, _out_file_size, _padding_bytes)
    return result
}
ImBezierCalc :: (_p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _t: f32) -> ImVec2 {
    result : ImVec2 = default
    __c__ImBezierCalc(^result, ^*_p1, ^*_p2, ^*_p3, ^*_p4, _t)
    return result
}
ImBezierClosestPoint :: (_p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _p: &ImVec2, _num_segments: i32) -> ImVec2 {
    result : ImVec2 = default
    __c__ImBezierClosestPoint(^result, ^*_p1, ^*_p2, ^*_p3, ^*_p4, ^*_p, _num_segments)
    return result
}
ImBezierClosestPointCasteljau :: (_p1: &ImVec2, _p2: &ImVec2, _p3: &ImVec2, _p4: &ImVec2, _p: &ImVec2, _tess_tol: f32) -> ImVec2 {
    result : ImVec2 = default
    __c__ImBezierClosestPointCasteljau(^result, ^*_p1, ^*_p2, ^*_p3, ^*_p4, ^*_p, _tess_tol)
    return result
}
ImLineClosestPoint :: (_a: &ImVec2, _b: &ImVec2, _p: &ImVec2) -> ImVec2 {
    result : ImVec2 = default
    __c__ImLineClosestPoint(^result, ^*_a, ^*_b, ^*_p)
    return result
}
ImTriangleContainsPoint :: (_a: &ImVec2, _b: &ImVec2, _c: &ImVec2, _p: &ImVec2) -> bool {
    result : bool = default
    __c__ImTriangleContainsPoint(^result, ^*_a, ^*_b, ^*_c, ^*_p)
    return result
}
ImTriangleClosestPoint :: (_a: &ImVec2, _b: &ImVec2, _c: &ImVec2, _p: &ImVec2) -> ImVec2 {
    result : ImVec2 = default
    __c__ImTriangleClosestPoint(^result, ^*_a, ^*_b, ^*_c, ^*_p)
    return result
}
ImTriangleBarycentricCoords :: (_a: &ImVec2, _b: &ImVec2, _c: &ImVec2, _p: &ImVec2, _out_u: &f32, _out_v: &f32, _out_w: &f32) {
    __c__ImTriangleBarycentricCoords(^*_a, ^*_b, ^*_c, ^*_p, ^*_out_u, ^*_out_v, ^*_out_w)
}
ImGetDirQuadrantFromDelta :: (_dx: f32, _dy: f32) -> ImGuiDir {
    result : ImGuiDir = default
    __c__ImGetDirQuadrantFromDelta(^result, _dx, _dy)
    return result
}
FindWindowByID :: (_id: ImGuiID) -> ^ImGuiWindow {
    result : ^ImGuiWindow = default
    __c__FindWindowByID(^result, _id)
    return result
}
FindWindowByName :: (_name: ^char8) -> ^ImGuiWindow {
    result : ^ImGuiWindow = default
    __c__FindWindowByName(^result, _name)
    return result
}
FocusWindow :: (_window: ^ImGuiWindow) {
    __c__FocusWindow(_window)
}
FocusTopMostWindowUnderOne :: (_under_this_window: ^ImGuiWindow, _ignore_window: ^ImGuiWindow) {
    __c__FocusTopMostWindowUnderOne(_under_this_window, _ignore_window)
}
BringWindowToFocusFront :: (_window: ^ImGuiWindow) {
    __c__BringWindowToFocusFront(_window)
}
BringWindowToDisplayFront :: (_window: ^ImGuiWindow) {
    __c__BringWindowToDisplayFront(_window)
}
BringWindowToDisplayBack :: (_window: ^ImGuiWindow) {
    __c__BringWindowToDisplayBack(_window)
}
UpdateWindowParentAndRootLinks :: (_window: ^ImGuiWindow, _flags: ImGuiWindowFlags, _parent_window: ^ImGuiWindow) {
    __c__UpdateWindowParentAndRootLinks(_window, _flags, _parent_window)
}
CalcWindowExpectedSize :: (_window: ^ImGuiWindow) -> ImVec2 {
    result : ImVec2 = default
    __c__CalcWindowExpectedSize(^result, _window)
    return result
}
IsWindowChildOf :: (_window: ^ImGuiWindow, _potential_parent: ^ImGuiWindow) -> bool {
    result : bool = default
    __c__IsWindowChildOf(^result, _window, _potential_parent)
    return result
}
IsWindowNavFocusable :: (_window: ^ImGuiWindow) -> bool {
    result : bool = default
    __c__IsWindowNavFocusable(^result, _window)
    return result
}
GetWindowAllowedExtentRect :: (_window: ^ImGuiWindow) -> ImRect {
    result : ImRect = default
    __c__GetWindowAllowedExtentRect(^result, _window)
    return result
}
SetWindowPos_3 :: (_window: ^ImGuiWindow, _pos: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowPos_3(_window, ^*_pos, _cond)
}
SetWindowSize_3 :: (_window: ^ImGuiWindow, _size: &ImVec2, _cond: ImGuiCond = 0) {
    __c__SetWindowSize_3(_window, ^*_size, _cond)
}
SetWindowCollapsed_3 :: (_window: ^ImGuiWindow, _collapsed: bool, _cond: ImGuiCond = 0) {
    __c__SetWindowCollapsed_3(_window, _collapsed, _cond)
}
GcCompactTransientWindowBuffers :: (_window: ^ImGuiWindow) {
    __c__GcCompactTransientWindowBuffers(_window)
}
GcAwakeTransientWindowBuffers :: (_window: ^ImGuiWindow) {
    __c__GcAwakeTransientWindowBuffers(_window)
}
SetCurrentFont :: (_font: ^ImFont) {
    __c__SetCurrentFont(_font)
}
Initialize :: (_context: ^ImGuiContext) {
    __c__Initialize(_context)
}
Shutdown :: (_context: ^ImGuiContext) {
    __c__Shutdown(_context)
}
UpdateHoveredWindowAndCaptureFlags :: () {
    __c__UpdateHoveredWindowAndCaptureFlags()
}
StartMouseMovingWindow :: (_window: ^ImGuiWindow) {
    __c__StartMouseMovingWindow(_window)
}
StartMouseMovingWindowOrNode :: (_window: ^ImGuiWindow, _node: ^ImGuiDockNode, _undock_floating_node: bool) {
    __c__StartMouseMovingWindowOrNode(_window, _node, _undock_floating_node)
}
UpdateMouseMovingWindowNewFrame :: () {
    __c__UpdateMouseMovingWindowNewFrame()
}
UpdateMouseMovingWindowEndFrame :: () {
    __c__UpdateMouseMovingWindowEndFrame()
}
TranslateWindowsInViewport :: (_viewport: ^ImGuiViewportP, _old_pos: &ImVec2, _new_pos: &ImVec2) {
    __c__TranslateWindowsInViewport(_viewport, ^*_old_pos, ^*_new_pos)
}
ScaleWindowsInViewport :: (_viewport: ^ImGuiViewportP, _scale: f32) {
    __c__ScaleWindowsInViewport(_viewport, _scale)
}
DestroyPlatformWindow :: (_viewport: ^ImGuiViewportP) {
    __c__DestroyPlatformWindow(_viewport)
}
ShowViewportThumbnails :: () {
    __c__ShowViewportThumbnails()
}
MarkIniSettingsDirty :: () {
    __c__MarkIniSettingsDirty()
}
MarkIniSettingsDirty_2 :: (_window: ^ImGuiWindow) {
    __c__MarkIniSettingsDirty_2(_window)
}
CreateNewWindowSettings :: (_name: ^char8) -> ^ImGuiWindowSettings {
    result : ^ImGuiWindowSettings = default
    __c__CreateNewWindowSettings(^result, _name)
    return result
}
FindWindowSettings :: (_id: ImGuiID) -> ^ImGuiWindowSettings {
    result : ^ImGuiWindowSettings = default
    __c__FindWindowSettings(^result, _id)
    return result
}
FindOrCreateWindowSettings :: (_name: ^char8) -> ^ImGuiWindowSettings {
    result : ^ImGuiWindowSettings = default
    __c__FindOrCreateWindowSettings(^result, _name)
    return result
}
FindSettingsHandler :: (_type_name: ^char8) -> ^ImGuiSettingsHandler {
    result : ^ImGuiSettingsHandler = default
    __c__FindSettingsHandler(^result, _type_name)
    return result
}
SetScrollX_2 :: (_window: ^ImGuiWindow, _new_scroll_x: f32) {
    __c__SetScrollX_2(_window, _new_scroll_x)
}
SetScrollY_2 :: (_window: ^ImGuiWindow, _new_scroll_y: f32) {
    __c__SetScrollY_2(_window, _new_scroll_y)
}
SetScrollFromPosX_2 :: (_window: ^ImGuiWindow, _local_x: f32, _center_x_ratio: f32 = 0.5f) {
    __c__SetScrollFromPosX_2(_window, _local_x, _center_x_ratio)
}
SetScrollFromPosY_2 :: (_window: ^ImGuiWindow, _local_y: f32, _center_y_ratio: f32 = 0.5f) {
    __c__SetScrollFromPosY_2(_window, _local_y, _center_y_ratio)
}
ScrollToBringRectIntoView :: (_window: ^ImGuiWindow, _item_rect: &ImRect) -> ImVec2 {
    result : ImVec2 = default
    __c__ScrollToBringRectIntoView(^result, _window, ^*_item_rect)
    return result
}
SetActiveID :: (_id: ImGuiID, _window: ^ImGuiWindow) {
    __c__SetActiveID(_id, _window)
}
SetFocusID :: (_id: ImGuiID, _window: ^ImGuiWindow) {
    __c__SetFocusID(_id, _window)
}
ClearActiveID :: () {
    __c__ClearActiveID()
}
GetHoveredID :: () -> ImGuiID {
    result : ImGuiID = default
    __c__GetHoveredID(^result)
    return result
}
SetHoveredID :: (_id: ImGuiID) {
    __c__SetHoveredID(_id)
}
KeepAliveID :: (_id: ImGuiID) {
    __c__KeepAliveID(_id)
}
MarkItemEdited :: (_id: ImGuiID) {
    __c__MarkItemEdited(_id)
}
PushOverrideID :: (_id: ImGuiID) {
    __c__PushOverrideID(_id)
}
ItemSize :: (_size: &ImVec2, _text_baseline_y: f32 = -1.0f) {
    __c__ItemSize(^*_size, _text_baseline_y)
}
ItemSize_2 :: (_bb: &ImRect, _text_baseline_y: f32 = -1.0f) {
    __c__ItemSize_2(^*_bb, _text_baseline_y)
}
ItemAdd :: (_bb: &ImRect, _id: ImGuiID, _nav_bb: ^ImRect = null) -> bool {
    result : bool = default
    __c__ItemAdd(^result, ^*_bb, _id, _nav_bb)
    return result
}
ItemHoverable :: (_bb: &ImRect, _id: ImGuiID) -> bool {
    result : bool = default
    __c__ItemHoverable(^result, ^*_bb, _id)
    return result
}
IsClippedEx :: (_bb: &ImRect, _id: ImGuiID, _clip_even_when_logged: bool) -> bool {
    result : bool = default
    __c__IsClippedEx(^result, ^*_bb, _id, _clip_even_when_logged)
    return result
}
FocusableItemRegister :: (_window: ^ImGuiWindow, _id: ImGuiID) -> bool {
    result : bool = default
    __c__FocusableItemRegister(^result, _window, _id)
    return result
}
FocusableItemUnregister :: (_window: ^ImGuiWindow) {
    __c__FocusableItemUnregister(_window)
}
CalcItemSize :: (_size: ImVec2, _default_w: f32, _default_h: f32) -> ImVec2 {
    result : ImVec2 = default
    __c__CalcItemSize(^result, ^_size, _default_w, _default_h)
    return result
}
CalcWrapWidthForPos :: (_pos: &ImVec2, _wrap_pos_x: f32) -> f32 {
    result : f32 = default
    __c__CalcWrapWidthForPos(^result, ^*_pos, _wrap_pos_x)
    return result
}
PushMultiItemsWidths :: (_components: i32, _width_full: f32) {
    __c__PushMultiItemsWidths(_components, _width_full)
}
PushItemFlag :: (_option: ImGuiItemFlags, _enabled: bool) {
    __c__PushItemFlag(_option, _enabled)
}
PopItemFlag :: () {
    __c__PopItemFlag()
}
IsItemToggledSelection :: () -> bool {
    result : bool = default
    __c__IsItemToggledSelection(^result)
    return result
}
GetContentRegionMaxAbs :: () -> ImVec2 {
    result : ImVec2 = default
    __c__GetContentRegionMaxAbs(^result)
    return result
}
ShrinkWidths :: (_items: ^ImGuiShrinkWidthItem, _count: i32, _width_excess: f32) {
    __c__ShrinkWidths(_items, _count, _width_excess)
}
LogBegin :: (_type: ImGuiLogType, _auto_open_depth: i32) {
    __c__LogBegin(_type, _auto_open_depth)
}
LogToBuffer :: (_auto_open_depth: i32 = -1) {
    __c__LogToBuffer(_auto_open_depth)
}
OpenPopupEx :: (_id: ImGuiID) {
    __c__OpenPopupEx(_id)
}
ClosePopupToLevel :: (_remaining: i32, _restore_focus_to_window_under_popup: bool) {
    __c__ClosePopupToLevel(_remaining, _restore_focus_to_window_under_popup)
}
ClosePopupsOverWindow :: (_ref_window: ^ImGuiWindow, _restore_focus_to_window_under_popup: bool) {
    __c__ClosePopupsOverWindow(_ref_window, _restore_focus_to_window_under_popup)
}
IsPopupOpen_2 :: (_id: ImGuiID) -> bool {
    result : bool = default
    __c__IsPopupOpen_2(^result, _id)
    return result
}
BeginPopupEx :: (_id: ImGuiID, _extra_flags: ImGuiWindowFlags) -> bool {
    result : bool = default
    __c__BeginPopupEx(^result, _id, _extra_flags)
    return result
}
BeginTooltipEx :: (_extra_flags: ImGuiWindowFlags, _override_previous_tooltip: bool = true) {
    __c__BeginTooltipEx(_extra_flags, _override_previous_tooltip)
}
GetTopMostPopupModal :: () -> ^ImGuiWindow {
    result : ^ImGuiWindow = default
    __c__GetTopMostPopupModal(^result)
    return result
}
FindBestWindowPosForPopup :: (_window: ^ImGuiWindow) -> ImVec2 {
    result : ImVec2 = default
    __c__FindBestWindowPosForPopup(^result, _window)
    return result
}
FindBestWindowPosForPopupEx :: (_ref_pos: &ImVec2, _size: &ImVec2, _last_dir: ^ImGuiDir, _r_outer: &ImRect, _r_avoid: &ImRect, _policy: ImGuiPopupPositionPolicy = ImGuiPopupPositionPolicy.Default) -> ImVec2 {
    result : ImVec2 = default
    __c__FindBestWindowPosForPopupEx(^result, ^*_ref_pos, ^*_size, _last_dir, ^*_r_outer, ^*_r_avoid, _policy)
    return result
}
NavInitWindow :: (_window: ^ImGuiWindow, _force_reinit: bool) {
    __c__NavInitWindow(_window, _force_reinit)
}
NavMoveRequestButNoResultYet :: () -> bool {
    result : bool = default
    __c__NavMoveRequestButNoResultYet(^result)
    return result
}
NavMoveRequestCancel :: () {
    __c__NavMoveRequestCancel()
}
NavMoveRequestForward :: (_move_dir: ImGuiDir, _clip_dir: ImGuiDir, _bb_rel: &ImRect, _move_flags: ImGuiNavMoveFlags) {
    __c__NavMoveRequestForward(_move_dir, _clip_dir, ^*_bb_rel, _move_flags)
}
NavMoveRequestTryWrapping :: (_window: ^ImGuiWindow, _move_flags: ImGuiNavMoveFlags) {
    __c__NavMoveRequestTryWrapping(_window, _move_flags)
}
GetNavInputAmount :: (_n: ImGuiNavInput, _mode: ImGuiInputReadMode) -> f32 {
    result : f32 = default
    __c__GetNavInputAmount(^result, _n, _mode)
    return result
}
GetNavInputAmount2d :: (_dir_sources: ImGuiNavDirSourceFlags, _mode: ImGuiInputReadMode, _slow_factor: f32 = 0.0f, _fast_factor: f32 = 0.0f) -> ImVec2 {
    result : ImVec2 = default
    __c__GetNavInputAmount2d(^result, _dir_sources, _mode, _slow_factor, _fast_factor)
    return result
}
CalcTypematicRepeatAmount :: (_t0: f32, _t1: f32, _repeat_delay: f32, _repeat_rate: f32) -> i32 {
    result : i32 = default
    __c__CalcTypematicRepeatAmount(^result, _t0, _t1, _repeat_delay, _repeat_rate)
    return result
}
ActivateItem :: (_id: ImGuiID) {
    __c__ActivateItem(_id)
}
SetNavID :: (_id: ImGuiID, _nav_layer: i32) {
    __c__SetNavID(_id, _nav_layer)
}
SetNavIDWithRectRel :: (_id: ImGuiID, _nav_layer: i32, _rect_rel: &ImRect) {
    __c__SetNavIDWithRectRel(_id, _nav_layer, ^*_rect_rel)
}
IsMouseDragPastThreshold :: (_button: ImGuiMouseButton, _lock_threshold: f32 = -1.0f) -> bool {
    result : bool = default
    __c__IsMouseDragPastThreshold(^result, _button, _lock_threshold)
    return result
}
DockContextInitialize :: (_ctx: ^ImGuiContext) {
    __c__DockContextInitialize(_ctx)
}
DockContextShutdown :: (_ctx: ^ImGuiContext) {
    __c__DockContextShutdown(_ctx)
}
DockContextOnLoadSettings :: (_ctx: ^ImGuiContext) {
    __c__DockContextOnLoadSettings(_ctx)
}
DockContextRebuildNodes :: (_ctx: ^ImGuiContext) {
    __c__DockContextRebuildNodes(_ctx)
}
DockContextUpdateUndocking :: (_ctx: ^ImGuiContext) {
    __c__DockContextUpdateUndocking(_ctx)
}
DockContextUpdateDocking :: (_ctx: ^ImGuiContext) {
    __c__DockContextUpdateDocking(_ctx)
}
DockContextGenNodeID :: (_ctx: ^ImGuiContext) -> ImGuiID {
    result : ImGuiID = default
    __c__DockContextGenNodeID(^result, _ctx)
    return result
}
DockContextQueueDock :: (_ctx: ^ImGuiContext, _target: ^ImGuiWindow, _target_node: ^ImGuiDockNode, _payload: ^ImGuiWindow, _split_dir: ImGuiDir, _split_ratio: f32, _split_outer: bool) {
    __c__DockContextQueueDock(_ctx, _target, _target_node, _payload, _split_dir, _split_ratio, _split_outer)
}
DockContextQueueUndockWindow :: (_ctx: ^ImGuiContext, _window: ^ImGuiWindow) {
    __c__DockContextQueueUndockWindow(_ctx, _window)
}
DockContextQueueUndockNode :: (_ctx: ^ImGuiContext, _node: ^ImGuiDockNode) {
    __c__DockContextQueueUndockNode(_ctx, _node)
}
DockContextCalcDropPosForDocking :: (_target: ^ImGuiWindow, _target_node: ^ImGuiDockNode, _payload: ^ImGuiWindow, _split_dir: ImGuiDir, _split_outer: bool, _out_pos: ^ImVec2) -> bool {
    result : bool = default
    __c__DockContextCalcDropPosForDocking(^result, _target, _target_node, _payload, _split_dir, _split_outer, _out_pos)
    return result
}
GetWindowAlwaysWantOwnTabBar :: (_window: ^ImGuiWindow) -> bool {
    result : bool = default
    __c__GetWindowAlwaysWantOwnTabBar(^result, _window)
    return result
}
BeginDocked :: (_window: ^ImGuiWindow, _p_open: ^bool) {
    __c__BeginDocked(_window, _p_open)
}
BeginDockableDragDropSource :: (_window: ^ImGuiWindow) {
    __c__BeginDockableDragDropSource(_window)
}
BeginDockableDragDropTarget :: (_window: ^ImGuiWindow) {
    __c__BeginDockableDragDropTarget(_window)
}
SetWindowDock :: (_window: ^ImGuiWindow, _dock_id: ImGuiID, _cond: ImGuiCond) {
    __c__SetWindowDock(_window, _dock_id, _cond)
}
DockBuilderDockWindow :: (_window_name: ^char8, _node_id: ImGuiID) {
    __c__DockBuilderDockWindow(_window_name, _node_id)
}
DockBuilderGetNode :: (_node_id: ImGuiID) -> ^ImGuiDockNode {
    result : ^ImGuiDockNode = default
    __c__DockBuilderGetNode(^result, _node_id)
    return result
}
DockBuilderAddNode :: (_node_id: ImGuiID = 0, _flags: ImGuiDockNodeFlags = 0) -> ImGuiID {
    result : ImGuiID = default
    __c__DockBuilderAddNode(^result, _node_id, _flags)
    return result
}
DockBuilderRemoveNode :: (_node_id: ImGuiID) {
    __c__DockBuilderRemoveNode(_node_id)
}
DockBuilderRemoveNodeDockedWindows :: (_node_id: ImGuiID, _clear_persistent_docking_references: bool = true) {
    __c__DockBuilderRemoveNodeDockedWindows(_node_id, _clear_persistent_docking_references)
}
DockBuilderRemoveNodeChildNodes :: (_node_id: ImGuiID) {
    __c__DockBuilderRemoveNodeChildNodes(_node_id)
}
DockBuilderSetNodePos :: (_node_id: ImGuiID, _pos: ImVec2) {
    __c__DockBuilderSetNodePos(_node_id, ^_pos)
}
DockBuilderSetNodeSize :: (_node_id: ImGuiID, _size: ImVec2) {
    __c__DockBuilderSetNodeSize(_node_id, ^_size)
}
DockBuilderSplitNode :: (_node_id: ImGuiID, _split_dir: ImGuiDir, _size_ratio_for_node_at_dir: f32, _out_id_at_dir: ^ImGuiID, _out_id_at_opposite_dir: ^ImGuiID) -> ImGuiID {
    result : ImGuiID = default
    __c__DockBuilderSplitNode(^result, _node_id, _split_dir, _size_ratio_for_node_at_dir, _out_id_at_dir, _out_id_at_opposite_dir)
    return result
}
DockBuilderCopyDockSpace :: (_src_dockspace_id: ImGuiID, _dst_dockspace_id: ImGuiID, _in_window_remap_pairs: ^__UNKNOWN_16) {
    __c__DockBuilderCopyDockSpace(_src_dockspace_id, _dst_dockspace_id, _in_window_remap_pairs)
}
DockBuilderCopyNode :: (_src_node_id: ImGuiID, _dst_node_id: ImGuiID, _out_node_remap_pairs: ^__UNKNOWN_16) {
    __c__DockBuilderCopyNode(_src_node_id, _dst_node_id, _out_node_remap_pairs)
}
DockBuilderCopyWindowSettings :: (_src_name: ^char8, _dst_name: ^char8) {
    __c__DockBuilderCopyWindowSettings(_src_name, _dst_name)
}
DockBuilderFinish :: (_node_id: ImGuiID) {
    __c__DockBuilderFinish(_node_id)
}
BeginDragDropTargetCustom :: (_bb: &ImRect, _id: ImGuiID) -> bool {
    result : bool = default
    __c__BeginDragDropTargetCustom(^result, ^*_bb, _id)
    return result
}
ClearDragDrop :: () {
    __c__ClearDragDrop()
}
IsDragDropPayloadBeingAccepted :: () -> bool {
    result : bool = default
    __c__IsDragDropPayloadBeingAccepted(^result)
    return result
}
BeginColumns :: (_str_id: ^char8, _count: i32, _flags: ImGuiColumnsFlags = 0) {
    __c__BeginColumns(_str_id, _count, _flags)
}
EndColumns :: () {
    __c__EndColumns()
}
PushColumnClipRect :: (_column_index: i32) {
    __c__PushColumnClipRect(_column_index)
}
PushColumnsBackground :: () {
    __c__PushColumnsBackground()
}
PopColumnsBackground :: () {
    __c__PopColumnsBackground()
}
GetColumnsID :: (_str_id: ^char8, _count: i32) -> ImGuiID {
    result : ImGuiID = default
    __c__GetColumnsID(^result, _str_id, _count)
    return result
}
FindOrCreateColumns :: (_window: ^ImGuiWindow, _id: ImGuiID) -> ^ImGuiColumns {
    result : ^ImGuiColumns = default
    __c__FindOrCreateColumns(^result, _window, _id)
    return result
}
GetColumnOffsetFromNorm :: (_columns: ^ImGuiColumns, _offset_norm: f32) -> f32 {
    result : f32 = default
    __c__GetColumnOffsetFromNorm(^result, _columns, _offset_norm)
    return result
}
GetColumnNormFromOffset :: (_columns: ^ImGuiColumns, _offset: f32) -> f32 {
    result : f32 = default
    __c__GetColumnNormFromOffset(^result, _columns, _offset)
    return result
}
BeginTabBarEx :: (_tab_bar: ^ImGuiTabBar, _bb: &ImRect, _flags: ImGuiTabBarFlags, _dock_node: ^ImGuiDockNode) -> bool {
    result : bool = default
    __c__BeginTabBarEx(^result, _tab_bar, ^*_bb, _flags, _dock_node)
    return result
}
TabBarFindTabByID :: (_tab_bar: ^ImGuiTabBar, _tab_id: ImGuiID) -> ^ImGuiTabItem {
    result : ^ImGuiTabItem = default
    __c__TabBarFindTabByID(^result, _tab_bar, _tab_id)
    return result
}
TabBarFindMostRecentlySelectedTabForActiveWindow :: (_tab_bar: ^ImGuiTabBar) -> ^ImGuiTabItem {
    result : ^ImGuiTabItem = default
    __c__TabBarFindMostRecentlySelectedTabForActiveWindow(^result, _tab_bar)
    return result
}
TabBarAddTab :: (_tab_bar: ^ImGuiTabBar, _tab_flags: ImGuiTabItemFlags, _window: ^ImGuiWindow) {
    __c__TabBarAddTab(_tab_bar, _tab_flags, _window)
}
TabBarRemoveTab :: (_tab_bar: ^ImGuiTabBar, _tab_id: ImGuiID) {
    __c__TabBarRemoveTab(_tab_bar, _tab_id)
}
TabBarCloseTab :: (_tab_bar: ^ImGuiTabBar, _tab: ^ImGuiTabItem) {
    __c__TabBarCloseTab(_tab_bar, _tab)
}
TabBarQueueChangeTabOrder :: (_tab_bar: ^ImGuiTabBar, _tab: ^ImGuiTabItem, _dir: i32) {
    __c__TabBarQueueChangeTabOrder(_tab_bar, _tab, _dir)
}
TabItemEx :: (_tab_bar: ^ImGuiTabBar, _label: ^char8, _p_open: ^bool, _flags: ImGuiTabItemFlags, _docked_window: ^ImGuiWindow) -> bool {
    result : bool = default
    __c__TabItemEx(^result, _tab_bar, _label, _p_open, _flags, _docked_window)
    return result
}
TabItemCalcSize :: (_label: ^char8, _has_close_button: bool) -> ImVec2 {
    result : ImVec2 = default
    __c__TabItemCalcSize(^result, _label, _has_close_button)
    return result
}
TabItemBackground :: (_draw_list: ^ImDrawList, _bb: &ImRect, _flags: ImGuiTabItemFlags, _col: ImU32) {
    __c__TabItemBackground(_draw_list, ^*_bb, _flags, _col)
}
TabItemLabelAndCloseButton :: (_draw_list: ^ImDrawList, _bb: &ImRect, _flags: ImGuiTabItemFlags, _frame_padding: ImVec2, _label: ^char8, _tab_id: ImGuiID, _close_button_id: ImGuiID) -> bool {
    result : bool = default
    __c__TabItemLabelAndCloseButton(^result, _draw_list, ^*_bb, _flags, ^_frame_padding, _label, _tab_id, _close_button_id)
    return result
}
RenderText :: (_pos: ImVec2, _text: ^char8, _text_end: ^char8 = null, _hide_text_after_hash: bool = true) {
    __c__RenderText(^_pos, _text, _text_end, _hide_text_after_hash)
}
RenderTextWrapped :: (_pos: ImVec2, _text: ^char8, _text_end: ^char8, _wrap_width: f32) {
    __c__RenderTextWrapped(^_pos, _text, _text_end, _wrap_width)
}
RenderTextClipped :: (_pos_min: &ImVec2, _pos_max: &ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2, _align: &ImVec2, _clip_rect: ^ImRect = null) {
    __c__RenderTextClipped(^*_pos_min, ^*_pos_max, _text, _text_end, _text_size_if_known, ^*_align, _clip_rect)
}
RenderTextClippedEx :: (_draw_list: ^ImDrawList, _pos_min: &ImVec2, _pos_max: &ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2, _align: &ImVec2, _clip_rect: ^ImRect = null) {
    __c__RenderTextClippedEx(_draw_list, ^*_pos_min, ^*_pos_max, _text, _text_end, _text_size_if_known, ^*_align, _clip_rect)
}
RenderTextEllipsis :: (_draw_list: ^ImDrawList, _pos_min: &ImVec2, _pos_max: &ImVec2, _clip_max_x: f32, _ellipsis_max_x: f32, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2) {
    __c__RenderTextEllipsis(_draw_list, ^*_pos_min, ^*_pos_max, _clip_max_x, _ellipsis_max_x, _text, _text_end, _text_size_if_known)
}
RenderFrame :: (_p_min: ImVec2, _p_max: ImVec2, _fill_col: ImU32, _border: bool = true, _rounding: f32 = 0.0f) {
    __c__RenderFrame(^_p_min, ^_p_max, _fill_col, _border, _rounding)
}
RenderFrameBorder :: (_p_min: ImVec2, _p_max: ImVec2, _rounding: f32 = 0.0f) {
    __c__RenderFrameBorder(^_p_min, ^_p_max, _rounding)
}
RenderColorRectWithAlphaCheckerboard :: (_p_min: ImVec2, _p_max: ImVec2, _fill_col: ImU32, _grid_step: f32, _grid_off: ImVec2, _rounding: f32 = 0.0f, _rounding_corners_flags: i32 = @bin_not(0)) {
    __c__RenderColorRectWithAlphaCheckerboard(^_p_min, ^_p_max, _fill_col, _grid_step, ^_grid_off, _rounding, _rounding_corners_flags)
}
RenderCheckMark :: (_pos: ImVec2, _col: ImU32, _sz: f32) {
    __c__RenderCheckMark(^_pos, _col, _sz)
}
RenderNavHighlight :: (_bb: &ImRect, _id: ImGuiID, _flags: ImGuiNavHighlightFlags = ImGuiNavHighlightFlags_.TypeDefault) {
    __c__RenderNavHighlight(^*_bb, _id, _flags)
}
RenderMouseCursor :: (_pos: ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor = ImGuiMouseCursor_.Arrow) {
    __c__RenderMouseCursor(^_pos, _scale, _mouse_cursor)
}
FindRenderedTextEnd :: (_text: ^char8, _text_end: ^char8 = null) -> ^char8 {
    result : ^char8 = default
    __c__FindRenderedTextEnd(^result, _text, _text_end)
    return result
}
LogRenderedText :: (_ref_pos: ^ImVec2, _text: ^char8, _text_end: ^char8 = null) {
    __c__LogRenderedText(_ref_pos, _text, _text_end)
}
RenderArrow :: (_draw_list: ^ImDrawList, _pos: ImVec2, _col: ImU32, _dir: ImGuiDir, _scale: f32 = 1.0f) {
    __c__RenderArrow(_draw_list, ^_pos, _col, _dir, _scale)
}
RenderBullet :: (_draw_list: ^ImDrawList, _pos: ImVec2, _col: ImU32) {
    __c__RenderBullet(_draw_list, ^_pos, _col)
}
RenderMouseCursor_2 :: (_draw_list: ^ImDrawList, _pos: ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor, _col_fill: ImU32, _col_border: ImU32, _col_shadow: ImU32) {
    __c__RenderMouseCursor_2(_draw_list, ^_pos, _scale, _mouse_cursor, _col_fill, _col_border, _col_shadow)
}
RenderArrowPointingAt :: (_draw_list: ^ImDrawList, _pos: ImVec2, _half_sz: ImVec2, _direction: ImGuiDir, _col: ImU32) {
    __c__RenderArrowPointingAt(_draw_list, ^_pos, ^_half_sz, _direction, _col)
}
RenderArrowDockMenu :: (_draw_list: ^ImDrawList, _p_min: ImVec2, _sz: f32, _col: ImU32) {
    __c__RenderArrowDockMenu(_draw_list, ^_p_min, _sz, _col)
}
RenderRectFilledRangeH :: (_draw_list: ^ImDrawList, _rect: &ImRect, _col: ImU32, _x_start_norm: f32, _x_end_norm: f32, _rounding: f32) {
    __c__RenderRectFilledRangeH(_draw_list, ^*_rect, _col, _x_start_norm, _x_end_norm, _rounding)
}
RenderRectFilledWithHole :: (_draw_list: ^ImDrawList, _outer: ImRect, _inner: ImRect, _col: ImU32, _rounding: f32) {
    __c__RenderRectFilledWithHole(_draw_list, ^_outer, ^_inner, _col, _rounding)
}
TextEx :: (_text: ^char8, _text_end: ^char8 = null, _flags: ImGuiTextFlags = 0) {
    __c__TextEx(_text, _text_end, _flags)
}
ButtonEx :: (_label: ^char8, _size_arg: &ImVec2, _flags: ImGuiButtonFlags = 0) -> bool {
    result : bool = default
    __c__ButtonEx(^result, _label, ^*_size_arg, _flags)
    return result
}
CloseButton :: (_id: ImGuiID, _pos: &ImVec2) -> bool {
    result : bool = default
    __c__CloseButton(^result, _id, ^*_pos)
    return result
}
CollapseButton :: (_id: ImGuiID, _pos: &ImVec2, _dock_node: ^ImGuiDockNode) -> bool {
    result : bool = default
    __c__CollapseButton(^result, _id, ^*_pos, _dock_node)
    return result
}
ArrowButtonEx :: (_str_id: ^char8, _dir: ImGuiDir, _size_arg: ImVec2, _flags: ImGuiButtonFlags) -> bool {
    result : bool = default
    __c__ArrowButtonEx(^result, _str_id, _dir, ^_size_arg, _flags)
    return result
}
Scrollbar :: (_axis: ImGuiAxis) {
    __c__Scrollbar(_axis)
}
ScrollbarEx :: (_bb: &ImRect, _id: ImGuiID, _axis: ImGuiAxis, _p_scroll_v: ^f32, _avail_v: f32, _contents_v: f32, _rounding_corners: ImDrawCornerFlags) -> bool {
    result : bool = default
    __c__ScrollbarEx(^result, ^*_bb, _id, _axis, _p_scroll_v, _avail_v, _contents_v, _rounding_corners)
    return result
}
GetWindowScrollbarID :: (_window: ^ImGuiWindow, _axis: ImGuiAxis) -> ImGuiID {
    result : ImGuiID = default
    __c__GetWindowScrollbarID(^result, _window, _axis)
    return result
}
GetWindowResizeID :: (_window: ^ImGuiWindow, _n: i32) -> ImGuiID {
    result : ImGuiID = default
    __c__GetWindowResizeID(^result, _window, _n)
    return result
}
SeparatorEx :: (_flags: ImGuiSeparatorFlags) {
    __c__SeparatorEx(_flags)
}
ButtonBehavior :: (_bb: &ImRect, _id: ImGuiID, _out_hovered: ^bool, _out_held: ^bool, _flags: ImGuiButtonFlags = 0) -> bool {
    result : bool = default
    __c__ButtonBehavior(^result, ^*_bb, _id, _out_hovered, _out_held, _flags)
    return result
}
DragBehavior :: (_id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^void, _v_speed: f32, _p_min: ^void, _p_max: ^void, _format: ^char8, _power: f32, _flags: ImGuiDragFlags) -> bool {
    result : bool = default
    __c__DragBehavior(^result, _id, _data_type, _p_v, _v_speed, _p_min, _p_max, _format, _power, _flags)
    return result
}
SliderBehavior :: (_bb: &ImRect, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8, _power: f32, _flags: ImGuiSliderFlags, _out_grab_bb: ^ImRect) -> bool {
    result : bool = default
    __c__SliderBehavior(^result, ^*_bb, _id, _data_type, _p_v, _p_min, _p_max, _format, _power, _flags, _out_grab_bb)
    return result
}
SplitterBehavior :: (_bb: &ImRect, _id: ImGuiID, _axis: ImGuiAxis, _size1: ^f32, _size2: ^f32, _min_size1: f32, _min_size2: f32, _hover_extend: f32 = 0.0f, _hover_visibility_delay: f32 = 0.0f) -> bool {
    result : bool = default
    __c__SplitterBehavior(^result, ^*_bb, _id, _axis, _size1, _size2, _min_size1, _min_size2, _hover_extend, _hover_visibility_delay)
    return result
}
TreeNodeBehavior :: (_id: ImGuiID, _flags: ImGuiTreeNodeFlags, _label: ^char8, _label_end: ^char8 = null) -> bool {
    result : bool = default
    __c__TreeNodeBehavior(^result, _id, _flags, _label, _label_end)
    return result
}
TreeNodeBehaviorIsOpen :: (_id: ImGuiID, _flags: ImGuiTreeNodeFlags = 0) -> bool {
    result : bool = default
    __c__TreeNodeBehaviorIsOpen(^result, _id, _flags)
    return result
}
TreePushOverrideID :: (_id: ImGuiID) {
    __c__TreePushOverrideID(_id)
}
DataTypeGetInfo :: (_data_type: ImGuiDataType) -> ^ImGuiDataTypeInfo {
    result : ^ImGuiDataTypeInfo = default
    __c__DataTypeGetInfo(^result, _data_type)
    return result
}
DataTypeFormatString :: (_buf: ^char8, _buf_size: i32, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8) -> i32 {
    result : i32 = default
    __c__DataTypeFormatString(^result, _buf, _buf_size, _data_type, _p_data, _format)
    return result
}
DataTypeApplyOp :: (_data_type: ImGuiDataType, _op: i32, _output: ^void, _arg_1: ^void, _arg_2: ^void) {
    __c__DataTypeApplyOp(_data_type, _op, _output, _arg_1, _arg_2)
}
DataTypeApplyOpFromText :: (_buf: ^char8, _initial_value_buf: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8) -> bool {
    result : bool = default
    __c__DataTypeApplyOpFromText(^result, _buf, _initial_value_buf, _data_type, _p_data, _format)
    return result
}
InputTextEx :: (_label: ^char8, _hint: ^char8, _buf: ^char8, _buf_size: i32, _size_arg: &ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null) -> bool {
    result : bool = default
    __c__InputTextEx(^result, _label, _hint, _buf, _buf_size, ^*_size_arg, _flags, _callback, _user_data)
    return result
}
TempInputTextScalar :: (_bb: &ImRect, _id: ImGuiID, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8) -> bool {
    result : bool = default
    __c__TempInputTextScalar(^result, ^*_bb, _id, _label, _data_type, _p_data, _format)
    return result
}
ColorTooltip :: (_text: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorTooltip(_text, _col, _flags)
}
ColorEditOptionsPopup :: (_col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorEditOptionsPopup(_col, _flags)
}
ColorPickerOptionsPopup :: (_ref_col: ^f32, _flags: ImGuiColorEditFlags) {
    __c__ColorPickerOptionsPopup(_ref_col, _flags)
}
PlotEx :: (_plot_type: ImGuiPlotType, _label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _frame_size: ImVec2) {
    __c__PlotEx(_plot_type, _label, _values_getter, _data, _values_count, _values_offset, _overlay_text, _scale_min, _scale_max, ^_frame_size)
}
ShadeVertsLinearColorGradientKeepAlpha :: (_draw_list: ^ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _gradient_p0: ImVec2, _gradient_p1: ImVec2, _col0: ImU32, _col1: ImU32) {
    __c__ShadeVertsLinearColorGradientKeepAlpha(_draw_list, _vert_start_idx, _vert_end_idx, ^_gradient_p0, ^_gradient_p1, _col0, _col1)
}
ShadeVertsLinearUV :: (_draw_list: ^ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _a: &ImVec2, _b: &ImVec2, _uv_a: &ImVec2, _uv_b: &ImVec2, _clamp: bool) {
    __c__ShadeVertsLinearUV(_draw_list, _vert_start_idx, _vert_end_idx, ^*_a, ^*_b, ^*_uv_a, ^*_uv_b, _clamp)
}
ImFontAtlasBuildWithStbTruetype :: (_atlas: ^ImFontAtlas) -> bool {
    result : bool = default
    __c__ImFontAtlasBuildWithStbTruetype(^result, _atlas)
    return result
}
ImFontAtlasBuildRegisterDefaultCustomRects :: (_atlas: ^ImFontAtlas) {
    __c__ImFontAtlasBuildRegisterDefaultCustomRects(_atlas)
}
ImFontAtlasBuildSetupFont :: (_atlas: ^ImFontAtlas, _font: ^ImFont, _font_config: ^ImFontConfig, _ascent: f32, _descent: f32) {
    __c__ImFontAtlasBuildSetupFont(_atlas, _font, _font_config, _ascent, _descent)
}
ImFontAtlasBuildPackCustomRects :: (_atlas: ^ImFontAtlas, _stbrp_context_opaque: ^void) {
    __c__ImFontAtlasBuildPackCustomRects(_atlas, _stbrp_context_opaque)
}
ImFontAtlasBuildFinish :: (_atlas: ^ImFontAtlas) {
    __c__ImFontAtlasBuildFinish(_atlas)
}
ImFontAtlasBuildMultiplyCalcLookupTable :: (_out_table: ^u8, _in_multiply_factor: f32) {
    __c__ImFontAtlasBuildMultiplyCalcLookupTable(_out_table, _in_multiply_factor)
}
ImFontAtlasBuildMultiplyRectAlpha8 :: (_table: ^u8, _pixels: ^u8, _x: i32, _y: i32, _w: i32, _h: i32, _stride: i32) {
    __c__ImFontAtlasBuildMultiplyRectAlpha8(_table, _pixels, _x, _y, _w, _h, _stride)
}
ImGui_ImplOpenGL3_Init :: (_glsl_version: ^char8 = null) -> bool {
    result : bool = default
    __c__ImGui_ImplOpenGL3_Init(^result, _glsl_version)
    return result
}
ImGui_ImplOpenGL3_Shutdown :: () {
    __c__ImGui_ImplOpenGL3_Shutdown()
}
ImGui_ImplOpenGL3_NewFrame :: () {
    __c__ImGui_ImplOpenGL3_NewFrame()
}
ImGui_ImplOpenGL3_RenderDrawData :: (_draw_data: ^ImDrawData) {
    __c__ImGui_ImplOpenGL3_RenderDrawData(_draw_data)
}
ImGui_ImplOpenGL3_CreateFontsTexture :: () -> bool {
    result : bool = default
    __c__ImGui_ImplOpenGL3_CreateFontsTexture(^result)
    return result
}
ImGui_ImplOpenGL3_DestroyFontsTexture :: () {
    __c__ImGui_ImplOpenGL3_DestroyFontsTexture()
}
ImGui_ImplOpenGL3_CreateDeviceObjects :: () -> bool {
    result : bool = default
    __c__ImGui_ImplOpenGL3_CreateDeviceObjects(^result)
    return result
}
ImGui_ImplOpenGL3_DestroyDeviceObjects :: () {
    __c__ImGui_ImplOpenGL3_DestroyDeviceObjects()
}
ImGui_ImplGlfw_InitForOpenGL :: (_window: ^GLFWwindow, _install_callbacks: bool) -> bool {
    result : bool = default
    __c__ImGui_ImplGlfw_InitForOpenGL(^result, _window, _install_callbacks)
    return result
}
ImGui_ImplGlfw_InitForVulkan :: (_window: ^GLFWwindow, _install_callbacks: bool) -> bool {
    result : bool = default
    __c__ImGui_ImplGlfw_InitForVulkan(^result, _window, _install_callbacks)
    return result
}
ImGui_ImplGlfw_Shutdown :: () {
    __c__ImGui_ImplGlfw_Shutdown()
}
ImGui_ImplGlfw_NewFrame :: () {
    __c__ImGui_ImplGlfw_NewFrame()
}
ImGui_ImplGlfw_MouseButtonCallback :: (_window: ^GLFWwindow, _button: i32, _action: i32, _mods: i32) {
    __c__ImGui_ImplGlfw_MouseButtonCallback(_window, _button, _action, _mods)
}
ImGui_ImplGlfw_ScrollCallback :: (_window: ^GLFWwindow, _xoffset: f64, _yoffset: f64) {
    __c__ImGui_ImplGlfw_ScrollCallback(_window, _xoffset, _yoffset)
}
ImGui_ImplGlfw_KeyCallback :: (_window: ^GLFWwindow, _key: i32, _scancode: i32, _action: i32, _mods: i32) {
    __c__ImGui_ImplGlfw_KeyCallback(_window, _key, _scancode, _action, _mods)
}
ImGui_ImplGlfw_CharCallback :: (_window: ^GLFWwindow, _c: u32) {
    __c__ImGui_ImplGlfw_CharCallback(_window, _c)
}
EmptyString : [1]char8 #extern
GImGui : ^ImGuiContext #extern

// ==========================================================
// ==========================================================
// ==========================================================

#file_scope

__c__ImVec2_new_2 :: (self: ^ImVec2);
__c__ImVec2_new_3 :: (self: ^ImVec2, __x: f32, __y: f32);
__c__ImVec4_new_4 :: (self: ^ImVec4);
__c__ImVec4_new_5 :: (self: ^ImVec4, __x: f32, __y: f32, __z: f32, __w: f32);
__c__ImGuiStyle_new_35 :: (self: ^ImGuiStyle);
__c__ImGuiStyle_ScaleAllSizes_36 :: (self: ^ImGuiStyle, _scale_factor: f32);
__c__ImGuiIO_AddInputCharacter_53 :: (self: ^ImGuiIO, _c: u32);
__c__ImGuiIO_AddInputCharactersUTF8_54 :: (self: ^ImGuiIO, _str: ^char8);
__c__ImGuiIO_ClearInputCharacters_55 :: (self: ^ImGuiIO);
__c__ImGuiIO_new_87 :: (self: ^ImGuiIO);
__c__ImGuiInputTextCallbackData_new_12 :: (self: ^ImGuiInputTextCallbackData);
__c__ImGuiInputTextCallbackData_DeleteChars_13 :: (self: ^ImGuiInputTextCallbackData, _pos: i32, _bytes_count: i32);
__c__ImGuiInputTextCallbackData_InsertChars_14 :: (self: ^ImGuiInputTextCallbackData, _pos: i32, _text: ^char8, _text_end: ^char8 = null);
__c__ImGuiInputTextCallbackData_HasSelection_15 :: (self: ^ImGuiInputTextCallbackData, ret: ^bool);
__c__ImGuiWindowClass_new_6 :: (self: ^ImGuiWindowClass);
__c__ImGuiPayload_new_8 :: (self: ^ImGuiPayload);
__c__ImGuiPayload_Clear_9 :: (self: ^ImGuiPayload);
__c__ImGuiPayload_IsDataType_10 :: (self: ^ImGuiPayload, ret: ^bool, _type: ^char8);
__c__ImGuiPayload_IsPreview_11 :: (self: ^ImGuiPayload, ret: ^bool);
__c__ImGuiPayload_IsDelivery_12 :: (self: ^ImGuiPayload, ret: ^bool);
__c__ImGuiOnceUponAFrame_new_0 :: (self: ^ImGuiOnceUponAFrame);
__c__ImGuiTextFilter_new_0 :: (self: ^ImGuiTextFilter, _default_filter: ^char8 = "");
__c__ImGuiTextFilter_Draw_1 :: (self: ^ImGuiTextFilter, ret: ^bool, _label: ^char8 = "Filter (inc,-exc)", _width: f32 = 0.0f);
__c__ImGuiTextFilter_PassFilter_2 :: (self: ^ImGuiTextFilter, ret: ^bool, _text: ^char8, _text_end: ^char8 = null);
__c__ImGuiTextFilter_Build_3 :: (self: ^ImGuiTextFilter);
__c__ImGuiTextFilter_Clear_4 :: (self: ^ImGuiTextFilter);
__c__ImGuiTextFilter_IsActive_5 :: (self: ^ImGuiTextFilter, ret: ^bool);
__c__ImGuiTextRange_new_2 :: (self: ^ImGuiTextRange);
__c__ImGuiTextRange_new_3 :: (self: ^ImGuiTextRange, __b: ^char8, __e: ^char8);
__c__ImGuiTextRange_empty_4 :: (self: ^ImGuiTextRange, ret: ^bool);
__c__ImGuiTextRange_split_5 :: (self: ^ImGuiTextRange, _separator: char8, _out: ^__UNKNOWN_16);
__c__ImGuiTextBuffer_new_2 :: (self: ^ImGuiTextBuffer);
__c__ImGuiTextBuffer_begin_4 :: (self: ^ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_end_5 :: (self: ^ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_size_6 :: (self: ^ImGuiTextBuffer, ret: ^i32);
__c__ImGuiTextBuffer_empty_7 :: (self: ^ImGuiTextBuffer, ret: ^bool);
__c__ImGuiTextBuffer_clear_8 :: (self: ^ImGuiTextBuffer);
__c__ImGuiTextBuffer_reserve_9 :: (self: ^ImGuiTextBuffer, _capacity: i32);
__c__ImGuiTextBuffer_c_str_10 :: (self: ^ImGuiTextBuffer, ret: ^^char8);
__c__ImGuiTextBuffer_append_11 :: (self: ^ImGuiTextBuffer, _str: ^char8, _str_end: ^char8 = null);
__c__ImGuiTextBuffer_appendf_12 :: (self: ^ImGuiTextBuffer, _fmt: ^char8);
__c__ImGuiTextBuffer_appendfv_13 :: (self: ^ImGuiTextBuffer, _fmt: ^char8, _args: va_list);
__c__ImGuiStorage_Clear_2 :: (self: ^ImGuiStorage);
__c__ImGuiStorage_GetInt_3 :: (self: ^ImGuiStorage, ret: ^i32, _key: ImGuiID, _default_val: i32 = 0);
__c__ImGuiStorage_SetInt_4 :: (self: ^ImGuiStorage, _key: ImGuiID, _val: i32);
__c__ImGuiStorage_GetBool_5 :: (self: ^ImGuiStorage, ret: ^bool, _key: ImGuiID, _default_val: bool = false);
__c__ImGuiStorage_SetBool_6 :: (self: ^ImGuiStorage, _key: ImGuiID, _val: bool);
__c__ImGuiStorage_GetFloat_7 :: (self: ^ImGuiStorage, ret: ^f32, _key: ImGuiID, _default_val: f32 = 0.0f);
__c__ImGuiStorage_SetFloat_8 :: (self: ^ImGuiStorage, _key: ImGuiID, _val: f32);
__c__ImGuiStorage_GetVoidPtr_9 :: (self: ^ImGuiStorage, ret: ^^void, _key: ImGuiID);
__c__ImGuiStorage_SetVoidPtr_10 :: (self: ^ImGuiStorage, _key: ImGuiID, _val: ^void);
__c__ImGuiStorage_GetIntRef_11 :: (self: ^ImGuiStorage, ret: ^^i32, _key: ImGuiID, _default_val: i32 = 0);
__c__ImGuiStorage_GetBoolRef_12 :: (self: ^ImGuiStorage, ret: ^^bool, _key: ImGuiID, _default_val: bool = false);
__c__ImGuiStorage_GetFloatRef_13 :: (self: ^ImGuiStorage, ret: ^^f32, _key: ImGuiID, _default_val: f32 = 0.0f);
__c__ImGuiStorage_GetVoidPtrRef_14 :: (self: ^ImGuiStorage, ret: ^^^void, _key: ImGuiID, _default_val: ^void = null);
__c__ImGuiStorage_SetAllInt_15 :: (self: ^ImGuiStorage, _val: i32);
__c__ImGuiStorage_BuildSortByKey_16 :: (self: ^ImGuiStorage);
__c__ImGuiStoragePair_new_2 :: (self: ^ImGuiStoragePair, __key: ImGuiID, __val_i: i32);
__c__ImGuiStoragePair_new_3 :: (self: ^ImGuiStoragePair, __key: ImGuiID, __val_f: f32);
__c__ImGuiStoragePair_new_4 :: (self: ^ImGuiStoragePair, __key: ImGuiID, __val_p: ^void);
__c__ImGuiListClipper_new_6 :: (self: ^ImGuiListClipper, _items_count: i32 = -1, _items_height: f32 = -1.0f);
__c__ImGuiListClipper_dtor :: (self: ^ImGuiListClipper);
__c__ImGuiListClipper_Step_8 :: (self: ^ImGuiListClipper, ret: ^bool);
__c__ImGuiListClipper_Begin_9 :: (self: ^ImGuiListClipper, _items_count: i32, _items_height: f32 = -1.0f);
__c__ImGuiListClipper_End_10 :: (self: ^ImGuiListClipper);
__c__ImColor_new_1 :: (self: ^ImColor);
__c__ImColor_new_2 :: (self: ^ImColor, _r: i32, _g: i32, _b: i32, _a: i32 = 255);
__c__ImColor_new_3 :: (self: ^ImColor, _rgba: ImU32);
__c__ImColor_new_4 :: (self: ^ImColor, _r: f32, _g: f32, _b: f32, _a: f32 = 1.0f);
__c__ImColor_new_5 :: (self: ^ImColor, _col: ^ImVec4);
__c__ImColor_SetHSV_8 :: (self: ^ImColor, _h: f32, _s: f32, _v: f32, _a: f32 = 1.0f);
__c__ImColor_HSV_9 :: (self: ^ImColor, ret: ^ImColor, _h: f32, _s: f32, _v: f32, _a: f32 = 1.0f);
__c__ImDrawCmd_new_7 :: (self: ^ImDrawCmd);
__c__ImDrawListSplitter_new_3 :: (self: ^ImDrawListSplitter);
__c__ImDrawListSplitter_dtor :: (self: ^ImDrawListSplitter);
__c__ImDrawListSplitter_Clear_5 :: (self: ^ImDrawListSplitter);
__c__ImDrawListSplitter_ClearFreeMemory_6 :: (self: ^ImDrawListSplitter);
__c__ImDrawListSplitter_Split_7 :: (self: ^ImDrawListSplitter, _draw_list: ^ImDrawList, _count: i32);
__c__ImDrawListSplitter_Merge_8 :: (self: ^ImDrawListSplitter, _draw_list: ^ImDrawList);
__c__ImDrawListSplitter_SetCurrentChannel_9 :: (self: ^ImDrawListSplitter, _draw_list: ^ImDrawList, _channel_idx: i32);
__c__ImDrawList_new_14 :: (self: ^ImDrawList, _shared_data: ^ImDrawListSharedData);
__c__ImDrawList_dtor :: (self: ^ImDrawList);
__c__ImDrawList_PushClipRect_16 :: (self: ^ImDrawList, _clip_rect_min: ^ImVec2, _clip_rect_max: ^ImVec2, _intersect_with_current_clip_rect: bool = false);
__c__ImDrawList_PushClipRectFullScreen_17 :: (self: ^ImDrawList);
__c__ImDrawList_PopClipRect_18 :: (self: ^ImDrawList);
__c__ImDrawList_PushTextureID_19 :: (self: ^ImDrawList, _texture_id: ImTextureID);
__c__ImDrawList_PopTextureID_20 :: (self: ^ImDrawList);
__c__ImDrawList_GetClipRectMin_21 :: (self: ^ImDrawList, ret: ^ImVec2);
__c__ImDrawList_GetClipRectMax_22 :: (self: ^ImDrawList, ret: ^ImVec2);
__c__ImDrawList_AddLine_23 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _col: ImU32, _thickness: f32 = 1.0f);
__c__ImDrawList_AddRect_24 :: (self: ^ImDrawList, _p_min: ^ImVec2, _p_max: ^ImVec2, _col: ImU32, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All, _thickness: f32 = 1.0f);
__c__ImDrawList_AddRectFilled_25 :: (self: ^ImDrawList, _p_min: ^ImVec2, _p_max: ^ImVec2, _col: ImU32, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All);
__c__ImDrawList_AddRectFilledMultiColor_26 :: (self: ^ImDrawList, _p_min: ^ImVec2, _p_max: ^ImVec2, _col_upr_left: ImU32, _col_upr_right: ImU32, _col_bot_right: ImU32, _col_bot_left: ImU32);
__c__ImDrawList_AddQuad_27 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _col: ImU32, _thickness: f32 = 1.0f);
__c__ImDrawList_AddQuadFilled_28 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _col: ImU32);
__c__ImDrawList_AddTriangle_29 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _col: ImU32, _thickness: f32 = 1.0f);
__c__ImDrawList_AddTriangleFilled_30 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _col: ImU32);
__c__ImDrawList_AddCircle_31 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _col: ImU32, _num_segments: i32 = 12, _thickness: f32 = 1.0f);
__c__ImDrawList_AddCircleFilled_32 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _col: ImU32, _num_segments: i32 = 12);
__c__ImDrawList_AddNgon_33 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _col: ImU32, _num_segments: i32, _thickness: f32 = 1.0f);
__c__ImDrawList_AddNgonFilled_34 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _col: ImU32, _num_segments: i32);
__c__ImDrawList_AddText_35 :: (self: ^ImDrawList, _pos: ^ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8 = null);
__c__ImDrawList_AddText_36 :: (self: ^ImDrawList, _font: ^ImFont, _font_size: f32, _pos: ^ImVec2, _col: ImU32, _text_begin: ^char8, _text_end: ^char8 = null, _wrap_width: f32 = 0.0f, _cpu_fine_clip_rect: ^ImVec4 = null);
__c__ImDrawList_AddPolyline_37 :: (self: ^ImDrawList, _points: ^ImVec2, _num_points: i32, _col: ImU32, _closed: bool, _thickness: f32);
__c__ImDrawList_AddConvexPolyFilled_38 :: (self: ^ImDrawList, _points: ^ImVec2, _num_points: i32, _col: ImU32);
__c__ImDrawList_AddBezierCurve_39 :: (self: ^ImDrawList, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _col: ImU32, _thickness: f32, _num_segments: i32 = 0);
__c__ImDrawList_AddImage_40 :: (self: ^ImDrawList, _user_texture_id: ImTextureID, _p_min: ^ImVec2, _p_max: ^ImVec2, _uv_min: ^ImVec2, _uv_max: ^ImVec2, _col: ImU32);
__c__ImDrawList_AddImageQuad_41 :: (self: ^ImDrawList, _user_texture_id: ImTextureID, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _uv1: ^ImVec2, _uv2: ^ImVec2, _uv3: ^ImVec2, _uv4: ^ImVec2, _col: ImU32);
__c__ImDrawList_AddImageRounded_42 :: (self: ^ImDrawList, _user_texture_id: ImTextureID, _p_min: ^ImVec2, _p_max: ^ImVec2, _uv_min: ^ImVec2, _uv_max: ^ImVec2, _col: ImU32, _rounding: f32, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All);
__c__ImDrawList_PathClear_43 :: (self: ^ImDrawList);
__c__ImDrawList_PathLineTo_44 :: (self: ^ImDrawList, _pos: ^ImVec2);
__c__ImDrawList_PathLineToMergeDuplicate_45 :: (self: ^ImDrawList, _pos: ^ImVec2);
__c__ImDrawList_PathFillConvex_46 :: (self: ^ImDrawList, _col: ImU32);
__c__ImDrawList_PathStroke_47 :: (self: ^ImDrawList, _col: ImU32, _closed: bool, _thickness: f32 = 1.0f);
__c__ImDrawList_PathArcTo_48 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _a_min: f32, _a_max: f32, _num_segments: i32 = 10);
__c__ImDrawList_PathArcToFast_49 :: (self: ^ImDrawList, _center: ^ImVec2, _radius: f32, _a_min_of_12: i32, _a_max_of_12: i32);
__c__ImDrawList_PathBezierCurveTo_50 :: (self: ^ImDrawList, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _num_segments: i32 = 0);
__c__ImDrawList_PathRect_51 :: (self: ^ImDrawList, _rect_min: ^ImVec2, _rect_max: ^ImVec2, _rounding: f32 = 0.0f, _rounding_corners: ImDrawCornerFlags = ImDrawCornerFlags_.All);
__c__ImDrawList_AddCallback_52 :: (self: ^ImDrawList, _callback: ImDrawCallback, _callback_data: ^void);
__c__ImDrawList_AddDrawCmd_53 :: (self: ^ImDrawList);
__c__ImDrawList_CloneOutput_54 :: (self: ^ImDrawList, ret: ^^ImDrawList);
__c__ImDrawList_ChannelsSplit_55 :: (self: ^ImDrawList, _count: i32);
__c__ImDrawList_ChannelsMerge_56 :: (self: ^ImDrawList);
__c__ImDrawList_ChannelsSetCurrent_57 :: (self: ^ImDrawList, _n: i32);
__c__ImDrawList_Clear_58 :: (self: ^ImDrawList);
__c__ImDrawList_ClearFreeMemory_59 :: (self: ^ImDrawList);
__c__ImDrawList_PrimReserve_60 :: (self: ^ImDrawList, _idx_count: i32, _vtx_count: i32);
__c__ImDrawList_PrimUnreserve_61 :: (self: ^ImDrawList, _idx_count: i32, _vtx_count: i32);
__c__ImDrawList_PrimRect_62 :: (self: ^ImDrawList, _a: ^ImVec2, _b: ^ImVec2, _col: ImU32);
__c__ImDrawList_PrimRectUV_63 :: (self: ^ImDrawList, _a: ^ImVec2, _b: ^ImVec2, _uv_a: ^ImVec2, _uv_b: ^ImVec2, _col: ImU32);
__c__ImDrawList_PrimQuadUV_64 :: (self: ^ImDrawList, _a: ^ImVec2, _b: ^ImVec2, _c: ^ImVec2, _d: ^ImVec2, _uv_a: ^ImVec2, _uv_b: ^ImVec2, _uv_c: ^ImVec2, _uv_d: ^ImVec2, _col: ImU32);
__c__ImDrawList_PrimWriteVtx_65 :: (self: ^ImDrawList, _pos: ^ImVec2, _uv: ^ImVec2, _col: ImU32);
__c__ImDrawList_PrimWriteIdx_66 :: (self: ^ImDrawList, _idx: ImDrawIdx);
__c__ImDrawList_PrimVtx_67 :: (self: ^ImDrawList, _pos: ^ImVec2, _uv: ^ImVec2, _col: ImU32);
__c__ImDrawList_UpdateClipRect_68 :: (self: ^ImDrawList);
__c__ImDrawList_UpdateTextureID_69 :: (self: ^ImDrawList);
__c__ImDrawData_new_9 :: (self: ^ImDrawData);
__c__ImDrawData_dtor :: (self: ^ImDrawData);
__c__ImDrawData_Clear_11 :: (self: ^ImDrawData);
__c__ImDrawData_DeIndexAllBuffers_12 :: (self: ^ImDrawData);
__c__ImDrawData_ScaleClipRects_13 :: (self: ^ImDrawData, _fb_scale: ^ImVec2);
__c__ImFontConfig_new_19 :: (self: ^ImFontConfig);
__c__ImFontGlyphRangesBuilder_new_1 :: (self: ^ImFontGlyphRangesBuilder);
__c__ImFontGlyphRangesBuilder_Clear_2 :: (self: ^ImFontGlyphRangesBuilder);
__c__ImFontGlyphRangesBuilder_GetBit_3 :: (self: ^ImFontGlyphRangesBuilder, ret: ^bool, _n: i32);
__c__ImFontGlyphRangesBuilder_SetBit_4 :: (self: ^ImFontGlyphRangesBuilder, _n: i32);
__c__ImFontGlyphRangesBuilder_AddChar_5 :: (self: ^ImFontGlyphRangesBuilder, _c: ImWchar);
__c__ImFontGlyphRangesBuilder_AddText_6 :: (self: ^ImFontGlyphRangesBuilder, _text: ^char8, _text_end: ^char8 = null);
__c__ImFontGlyphRangesBuilder_AddRanges_7 :: (self: ^ImFontGlyphRangesBuilder, _ranges: ^ImWchar);
__c__ImFontGlyphRangesBuilder_BuildRanges_8 :: (self: ^ImFontGlyphRangesBuilder, _out_ranges: ^__UNKNOWN_16);
__c__ImFontAtlasCustomRect_new_8 :: (self: ^ImFontAtlasCustomRect);
__c__ImFontAtlasCustomRect_IsPacked_9 :: (self: ^ImFontAtlasCustomRect, ret: ^bool);
__c__ImFontAtlas_new_0 :: (self: ^ImFontAtlas);
__c__ImFontAtlas_dtor :: (self: ^ImFontAtlas);
__c__ImFontAtlas_AddFont_2 :: (self: ^ImFontAtlas, ret: ^^ImFont, _font_cfg: ^ImFontConfig);
__c__ImFontAtlas_AddFontDefault_3 :: (self: ^ImFontAtlas, ret: ^^ImFont, _font_cfg: ^ImFontConfig = null);
__c__ImFontAtlas_AddFontFromFileTTF_4 :: (self: ^ImFontAtlas, ret: ^^ImFont, _filename: ^char8, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null);
__c__ImFontAtlas_AddFontFromMemoryTTF_5 :: (self: ^ImFontAtlas, ret: ^^ImFont, _font_data: ^void, _font_size: i32, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null);
__c__ImFontAtlas_AddFontFromMemoryCompressedTTF_6 :: (self: ^ImFontAtlas, ret: ^^ImFont, _compressed_font_data: ^void, _compressed_font_size: i32, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null);
__c__ImFontAtlas_AddFontFromMemoryCompressedBase85TTF_7 :: (self: ^ImFontAtlas, ret: ^^ImFont, _compressed_font_data_base85: ^char8, _size_pixels: f32, _font_cfg: ^ImFontConfig = null, _glyph_ranges: ^ImWchar = null);
__c__ImFontAtlas_ClearInputData_8 :: (self: ^ImFontAtlas);
__c__ImFontAtlas_ClearTexData_9 :: (self: ^ImFontAtlas);
__c__ImFontAtlas_ClearFonts_10 :: (self: ^ImFontAtlas);
__c__ImFontAtlas_Clear_11 :: (self: ^ImFontAtlas);
__c__ImFontAtlas_Build_12 :: (self: ^ImFontAtlas, ret: ^bool);
__c__ImFontAtlas_GetTexDataAsAlpha8_13 :: (self: ^ImFontAtlas, _out_pixels: ^^u8, _out_width: ^i32, _out_height: ^i32, _out_bytes_per_pixel: ^i32 = null);
__c__ImFontAtlas_GetTexDataAsRGBA32_14 :: (self: ^ImFontAtlas, _out_pixels: ^^u8, _out_width: ^i32, _out_height: ^i32, _out_bytes_per_pixel: ^i32 = null);
__c__ImFontAtlas_IsBuilt_15 :: (self: ^ImFontAtlas, ret: ^bool);
__c__ImFontAtlas_SetTexID_16 :: (self: ^ImFontAtlas, _id: ImTextureID);
__c__ImFontAtlas_GetGlyphRangesDefault_17 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesKorean_18 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesJapanese_19 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesChineseFull_20 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon_21 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesCyrillic_22 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesThai_23 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_GetGlyphRangesVietnamese_24 :: (self: ^ImFontAtlas, ret: ^^ImWchar);
__c__ImFontAtlas_AddCustomRectRegular_25 :: (self: ^ImFontAtlas, ret: ^i32, _id: u32, _width: i32, _height: i32);
__c__ImFontAtlas_AddCustomRectFontGlyph_26 :: (self: ^ImFontAtlas, ret: ^i32, _font: ^ImFont, _id: ImWchar, _width: i32, _height: i32, _advance_x: f32, _offset: ^ImVec2);
__c__ImFontAtlas_GetCustomRectByIndex_27 :: (self: ^ImFontAtlas, ret: ^^ImFontAtlasCustomRect, _index: i32);
__c__ImFontAtlas_CalcCustomRectUV_28 :: (self: ^ImFontAtlas, _rect: ^ImFontAtlasCustomRect, _out_uv_min: ^ImVec2, _out_uv_max: ^ImVec2);
__c__ImFontAtlas_GetMouseCursorTexData_29 :: (self: ^ImFontAtlas, ret: ^bool, _cursor: ImGuiMouseCursor, _out_offset: ^ImVec2, _out_size: ^ImVec2, _out_uv_border: ^ImVec2, _out_uv_fill: ^ImVec2);
__c__ImFont_new_17 :: (self: ^ImFont);
__c__ImFont_dtor :: (self: ^ImFont);
__c__ImFont_FindGlyph_19 :: (self: ^ImFont, ret: ^^ImFontGlyph, _c: ImWchar);
__c__ImFont_FindGlyphNoFallback_20 :: (self: ^ImFont, ret: ^^ImFontGlyph, _c: ImWchar);
__c__ImFont_GetCharAdvance_21 :: (self: ^ImFont, ret: ^f32, _c: ImWchar);
__c__ImFont_IsLoaded_22 :: (self: ^ImFont, ret: ^bool);
__c__ImFont_GetDebugName_23 :: (self: ^ImFont, ret: ^^char8);
__c__ImFont_CalcTextSizeA_24 :: (self: ^ImFont, ret: ^ImVec2, _size: f32, _max_width: f32, _wrap_width: f32, _text_begin: ^char8, _text_end: ^char8 = null, _remaining: ^^char8 = null);
__c__ImFont_CalcWordWrapPositionA_25 :: (self: ^ImFont, ret: ^^char8, _scale: f32, _text: ^char8, _text_end: ^char8, _wrap_width: f32);
__c__ImFont_RenderChar_26 :: (self: ^ImFont, _draw_list: ^ImDrawList, _size: f32, _pos: ^ImVec2, _col: ImU32, _c: ImWchar);
__c__ImFont_RenderText_27 :: (self: ^ImFont, _draw_list: ^ImDrawList, _size: f32, _pos: ^ImVec2, _col: ImU32, _clip_rect: ^ImVec4, _text_begin: ^char8, _text_end: ^char8, _wrap_width: f32 = 0.0f, _cpu_fine_clip: bool = false);
__c__ImFont_BuildLookupTable_28 :: (self: ^ImFont);
__c__ImFont_ClearOutputData_29 :: (self: ^ImFont);
__c__ImFont_GrowIndex_30 :: (self: ^ImFont, _new_size: i32);
__c__ImFont_AddGlyph_31 :: (self: ^ImFont, _c: ImWchar, _x0: f32, _y0: f32, _x1: f32, _y1: f32, _u0: f32, _v0: f32, _u1: f32, _v1: f32, _advance_x: f32);
__c__ImFont_AddRemapChar_32 :: (self: ^ImFont, _dst: ImWchar, _src: ImWchar, _overwrite_dst: bool = true);
__c__ImFont_SetFallbackChar_33 :: (self: ^ImFont, _c: ImWchar);
__c__ImGuiPlatformMonitor_new_5 :: (self: ^ImGuiPlatformMonitor);
__c__ImGuiPlatformIO_new_27 :: (self: ^ImGuiPlatformIO);
__c__ImGuiViewport_new_14 :: (self: ^ImGuiViewport);
__c__ImGuiViewport_dtor :: (self: ^ImGuiViewport);
__c__ImBoolVector_new_1 :: (self: ^ImBoolVector);
__c__ImBoolVector_Resize_2 :: (self: ^ImBoolVector, _sz: i32);
__c__ImBoolVector_Clear_3 :: (self: ^ImBoolVector);
__c__ImBoolVector_GetBit_4 :: (self: ^ImBoolVector, ret: ^bool, _n: i32);
__c__ImBoolVector_SetBit_5 :: (self: ^ImBoolVector, _n: i32, _v: bool);
__c__ImVec1_new_1 :: (self: ^ImVec1);
__c__ImVec1_new_2 :: (self: ^ImVec1, __x: f32);
__c__ImVec2ih_new_2 :: (self: ^ImVec2ih);
__c__ImVec2ih_new_3 :: (self: ^ImVec2ih, __x: i16, __y: i16);
__c__ImVec2ih_new_4 :: (self: ^ImVec2ih, _rhs: ^ImVec2);
__c__ImRect_new_2 :: (self: ^ImRect);
__c__ImRect_new_3 :: (self: ^ImRect, _min: ^ImVec2, _max: ^ImVec2);
__c__ImRect_new_4 :: (self: ^ImRect, _v: ^ImVec4);
__c__ImRect_new_5 :: (self: ^ImRect, _x1: f32, _y1: f32, _x2: f32, _y2: f32);
__c__ImRect_GetCenter_6 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_GetSize_7 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_GetWidth_8 :: (self: ^ImRect, ret: ^f32);
__c__ImRect_GetHeight_9 :: (self: ^ImRect, ret: ^f32);
__c__ImRect_GetTL_10 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_GetTR_11 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_GetBL_12 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_GetBR_13 :: (self: ^ImRect, ret: ^ImVec2);
__c__ImRect_Contains_14 :: (self: ^ImRect, ret: ^bool, _p: ^ImVec2);
__c__ImRect_Contains_15 :: (self: ^ImRect, ret: ^bool, _r: ^ImRect);
__c__ImRect_Overlaps_16 :: (self: ^ImRect, ret: ^bool, _r: ^ImRect);
__c__ImRect_Add_17 :: (self: ^ImRect, _p: ^ImVec2);
__c__ImRect_Add_18 :: (self: ^ImRect, _r: ^ImRect);
__c__ImRect_Expand_19 :: (self: ^ImRect, _amount: f32);
__c__ImRect_Expand_20 :: (self: ^ImRect, _amount: ^ImVec2);
__c__ImRect_Translate_21 :: (self: ^ImRect, _d: ^ImVec2);
__c__ImRect_TranslateX_22 :: (self: ^ImRect, _dx: f32);
__c__ImRect_TranslateY_23 :: (self: ^ImRect, _dy: f32);
__c__ImRect_ClipWith_24 :: (self: ^ImRect, _r: ^ImRect);
__c__ImRect_ClipWithFull_25 :: (self: ^ImRect, _r: ^ImRect);
__c__ImRect_Floor_26 :: (self: ^ImRect);
__c__ImRect_IsInverted_27 :: (self: ^ImRect, ret: ^bool);
__c__ImGuiStyleMod_new_2 :: (self: ^ImGuiStyleMod, _idx: ImGuiStyleVar, _v: i32);
__c__ImGuiStyleMod_new_3 :: (self: ^ImGuiStyleMod, _idx: ImGuiStyleVar, _v: f32);
__c__ImGuiStyleMod_new_4 :: (self: ^ImGuiStyleMod, _idx: ImGuiStyleVar, _v: ^ImVec2);
__c__ImGuiMenuColumns_new_5 :: (self: ^ImGuiMenuColumns);
__c__ImGuiMenuColumns_Update_6 :: (self: ^ImGuiMenuColumns, _count: i32, _spacing: f32, _clear: bool);
__c__ImGuiMenuColumns_DeclColumns_7 :: (self: ^ImGuiMenuColumns, ret: ^f32, _w0: f32, _w1: f32, _w2: f32);
__c__ImGuiMenuColumns_CalcExtraSpace_8 :: (self: ^ImGuiMenuColumns, ret: ^f32, _avail_w: f32);
__c__ImGuiInputTextState_new_16 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_ClearText_17 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_ClearFreeMemory_18 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_GetUndoAvailCount_19 :: (self: ^ImGuiInputTextState, ret: ^i32);
__c__ImGuiInputTextState_GetRedoAvailCount_20 :: (self: ^ImGuiInputTextState, ret: ^i32);
__c__ImGuiInputTextState_OnKeyPressed_21 :: (self: ^ImGuiInputTextState, _key: i32);
__c__ImGuiInputTextState_CursorAnimReset_22 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_CursorClamp_23 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_HasSelection_24 :: (self: ^ImGuiInputTextState, ret: ^bool);
__c__ImGuiInputTextState_ClearSelection_25 :: (self: ^ImGuiInputTextState);
__c__ImGuiInputTextState_SelectAll_26 :: (self: ^ImGuiInputTextState);
__c__ImGuiWindowSettings_new_9 :: (self: ^ImGuiWindowSettings);
__c__ImGuiWindowSettings_GetName_10 :: (self: ^ImGuiWindowSettings, ret: ^^char8);
__c__ImGuiSettingsHandler_new_6 :: (self: ^ImGuiSettingsHandler);
__c__ImGuiPopupData_new_7 :: (self: ^ImGuiPopupData);
__c__ImGuiColumnData_new_4 :: (self: ^ImGuiColumnData);
__c__ImGuiColumns_new_15 :: (self: ^ImGuiColumns);
__c__ImGuiColumns_Clear_16 :: (self: ^ImGuiColumns);
__c__ImDrawListSharedData_new_7 :: (self: ^ImDrawListSharedData);
__c__ImDrawDataBuilder_Clear_1 :: (self: ^ImDrawDataBuilder);
__c__ImDrawDataBuilder_ClearFreeMemory_2 :: (self: ^ImDrawDataBuilder);
__c__ImDrawDataBuilder_FlattenIntoSingleLayer_3 :: (self: ^ImDrawDataBuilder);
__c__ImGuiViewportP_new_18 :: (self: ^ImGuiViewportP);
__c__ImGuiViewportP_dtor :: (self: ^ImGuiViewportP);
__c__ImGuiViewportP_GetRect_20 :: (self: ^ImGuiViewportP, ret: ^ImRect);
__c__ImGuiViewportP_GetCenter_21 :: (self: ^ImGuiViewportP, ret: ^ImVec2);
__c__ImGuiViewportP_ClearRequestFlags_22 :: (self: ^ImGuiViewportP);
__c__ImGuiNavMoveResult_new_7 :: (self: ^ImGuiNavMoveResult);
__c__ImGuiNavMoveResult_Clear_8 :: (self: ^ImGuiNavMoveResult);
__c__ImGuiNextWindowData_new_19 :: (self: ^ImGuiNextWindowData);
__c__ImGuiNextWindowData_ClearFlags_20 :: (self: ^ImGuiNextWindowData);
__c__ImGuiNextItemData_new_4 :: (self: ^ImGuiNextItemData);
__c__ImGuiNextItemData_ClearFlags_5 :: (self: ^ImGuiNextItemData);
__c__ImGuiPtrOrIndex_new_2 :: (self: ^ImGuiPtrOrIndex, _ptr: ^void);
__c__ImGuiPtrOrIndex_new_3 :: (self: ^ImGuiPtrOrIndex, _index: i32);
__c__ImGuiDockNode_new_37 :: (self: ^ImGuiDockNode, _id: ImGuiID);
__c__ImGuiDockNode_dtor :: (self: ^ImGuiDockNode);
__c__ImGuiDockNode_IsRootNode_39 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsDockSpace_40 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsFloatingNode_41 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsCentralNode_42 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsHiddenTabBar_43 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsNoTabBar_44 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsSplitNode_45 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsLeafNode_46 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_IsEmpty_47 :: (self: ^ImGuiDockNode, ret: ^bool);
__c__ImGuiDockNode_GetMergedFlags_48 :: (self: ^ImGuiDockNode, ret: ^ImGuiDockNodeFlags);
__c__ImGuiDockNode_Rect_49 :: (self: ^ImGuiDockNode, ret: ^ImRect);
__c__ImGuiContext_new_182 :: (self: ^ImGuiContext, _shared_font_atlas: ^ImFontAtlas);
__c__ImGuiWindowTempData_new_40 :: (self: ^ImGuiWindowTempData);
__c__ImGuiWindow_new_99 :: (self: ^ImGuiWindow, _context: ^ImGuiContext, _name: ^char8);
__c__ImGuiWindow_dtor :: (self: ^ImGuiWindow);
__c__ImGuiWindow_GetID_101 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _str: ^char8, _str_end: ^char8 = null);
__c__ImGuiWindow_GetID_102 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _ptr: ^void);
__c__ImGuiWindow_GetID_103 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _n: i32);
__c__ImGuiWindow_GetIDNoKeepAlive_104 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _str: ^char8, _str_end: ^char8 = null);
__c__ImGuiWindow_GetIDNoKeepAlive_105 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _ptr: ^void);
__c__ImGuiWindow_GetIDNoKeepAlive_106 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _n: i32);
__c__ImGuiWindow_GetIDFromRectangle_107 :: (self: ^ImGuiWindow, ret: ^ImGuiID, _r_abs: ^ImRect);
__c__ImGuiWindow_Rect_108 :: (self: ^ImGuiWindow, ret: ^ImRect);
__c__ImGuiWindow_CalcFontSize_109 :: (self: ^ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_TitleBarHeight_110 :: (self: ^ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_TitleBarRect_111 :: (self: ^ImGuiWindow, ret: ^ImRect);
__c__ImGuiWindow_MenuBarHeight_112 :: (self: ^ImGuiWindow, ret: ^f32);
__c__ImGuiWindow_MenuBarRect_113 :: (self: ^ImGuiWindow, ret: ^ImRect);
__c__ImGuiItemHoveredDataBackup_new_4 :: (self: ^ImGuiItemHoveredDataBackup);
__c__ImGuiItemHoveredDataBackup_Backup_5 :: (self: ^ImGuiItemHoveredDataBackup);
__c__ImGuiItemHoveredDataBackup_Restore_6 :: (self: ^ImGuiItemHoveredDataBackup);
__c__ImGuiTabItem_new_9 :: (self: ^ImGuiTabItem);
__c__ImGuiTabBar_new_24 :: (self: ^ImGuiTabBar);
__c__ImGuiTabBar_GetTabOrder_25 :: (self: ^ImGuiTabBar, ret: ^i32, _tab: ^ImGuiTabItem);
__c__ImGuiTabBar_GetTabName_26 :: (self: ^ImGuiTabBar, ret: ^^char8, _tab: ^ImGuiTabItem);
__c__CreateContext :: (ret: ^^ImGuiContext, _shared_font_atlas: ^ImFontAtlas = null);
__c__DestroyContext :: (_ctx: ^ImGuiContext = null);
__c__GetCurrentContext :: (ret: ^^ImGuiContext);
__c__SetCurrentContext :: (_ctx: ^ImGuiContext);
__c__DebugCheckVersionAndDataLayout :: (ret: ^bool, _version_str: ^char8, _sz_io: size_t, _sz_style: size_t, _sz_vec2: size_t, _sz_vec4: size_t, _sz_drawvert: size_t, _sz_drawidx: size_t);
__c__GetIO :: (ret: ^^ImGuiIO);
__c__GetStyle :: (ret: ^^ImGuiStyle);
__c__NewFrame :: ();
__c__EndFrame :: ();
__c__Render :: ();
__c__GetDrawData :: (ret: ^^ImDrawData);
__c__ShowDemoWindow :: (_p_open: ^bool = null);
__c__ShowAboutWindow :: (_p_open: ^bool = null);
__c__ShowMetricsWindow :: (_p_open: ^bool = null);
__c__ShowStyleEditor :: (_ref: ^ImGuiStyle = null);
__c__ShowStyleSelector :: (ret: ^bool, _label: ^char8);
__c__ShowFontSelector :: (_label: ^char8);
__c__ShowUserGuide :: ();
__c__GetVersion :: (ret: ^^char8);
__c__StyleColorsDark :: (_dst: ^ImGuiStyle = null);
__c__StyleColorsClassic :: (_dst: ^ImGuiStyle = null);
__c__StyleColorsLight :: (_dst: ^ImGuiStyle = null);
__c__Begin :: (ret: ^bool, _name: ^char8, _p_open: ^bool = null, _flags: ImGuiWindowFlags = 0);
__c__End :: ();
__c__BeginChild :: (ret: ^bool, _str_id: ^char8, _size: ^ImVec2, _border: bool = false, _flags: ImGuiWindowFlags = 0);
__c__BeginChild_2 :: (ret: ^bool, _id: ImGuiID, _size: ^ImVec2, _border: bool = false, _flags: ImGuiWindowFlags = 0);
__c__EndChild :: ();
__c__IsWindowAppearing :: (ret: ^bool);
__c__IsWindowCollapsed :: (ret: ^bool);
__c__IsWindowFocused :: (ret: ^bool, _flags: ImGuiFocusedFlags = 0);
__c__IsWindowHovered :: (ret: ^bool, _flags: ImGuiHoveredFlags = 0);
__c__GetWindowDrawList :: (ret: ^^ImDrawList);
__c__GetWindowDpiScale :: (ret: ^f32);
__c__GetWindowViewport :: (ret: ^^ImGuiViewport);
__c__GetWindowPos :: (ret: ^ImVec2);
__c__GetWindowSize :: (ret: ^ImVec2);
__c__GetWindowWidth :: (ret: ^f32);
__c__GetWindowHeight :: (ret: ^f32);
__c__SetNextWindowPos :: (_pos: ^ImVec2, _cond: ImGuiCond = 0, _pivot: ^ImVec2);
__c__SetNextWindowSize :: (_size: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetNextWindowSizeConstraints :: (_size_min: ^ImVec2, _size_max: ^ImVec2, _custom_callback: ImGuiSizeCallback = null, _custom_callback_data: ^void = null);
__c__SetNextWindowContentSize :: (_size: ^ImVec2);
__c__SetNextWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond = 0);
__c__SetNextWindowFocus :: ();
__c__SetNextWindowBgAlpha :: (_alpha: f32);
__c__SetNextWindowViewport :: (_viewport_id: ImGuiID);
__c__SetWindowPos :: (_pos: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowSize :: (_size: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowCollapsed :: (_collapsed: bool, _cond: ImGuiCond = 0);
__c__SetWindowFocus :: ();
__c__SetWindowFontScale :: (_scale: f32);
__c__SetWindowPos_2 :: (_name: ^char8, _pos: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowSize_2 :: (_name: ^char8, _size: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowCollapsed_2 :: (_name: ^char8, _collapsed: bool, _cond: ImGuiCond = 0);
__c__SetWindowFocus_2 :: (_name: ^char8);
__c__GetContentRegionMax :: (ret: ^ImVec2);
__c__GetContentRegionAvail :: (ret: ^ImVec2);
__c__GetWindowContentRegionMin :: (ret: ^ImVec2);
__c__GetWindowContentRegionMax :: (ret: ^ImVec2);
__c__GetWindowContentRegionWidth :: (ret: ^f32);
__c__GetScrollX :: (ret: ^f32);
__c__GetScrollY :: (ret: ^f32);
__c__GetScrollMaxX :: (ret: ^f32);
__c__GetScrollMaxY :: (ret: ^f32);
__c__SetScrollX :: (_scroll_x: f32);
__c__SetScrollY :: (_scroll_y: f32);
__c__SetScrollHereX :: (_center_x_ratio: f32 = 0.5f);
__c__SetScrollHereY :: (_center_y_ratio: f32 = 0.5f);
__c__SetScrollFromPosX :: (_local_x: f32, _center_x_ratio: f32 = 0.5f);
__c__SetScrollFromPosY :: (_local_y: f32, _center_y_ratio: f32 = 0.5f);
__c__PushFont :: (_font: ^ImFont);
__c__PopFont :: ();
__c__PushStyleColor :: (_idx: ImGuiCol, _col: ImU32);
__c__PushStyleColor_2 :: (_idx: ImGuiCol, _col: ^ImVec4);
__c__PopStyleColor :: (_count: i32 = 1);
__c__PushStyleVar :: (_idx: ImGuiStyleVar, _val: f32);
__c__PushStyleVar_2 :: (_idx: ImGuiStyleVar, _val: ^ImVec2);
__c__PopStyleVar :: (_count: i32 = 1);
__c__GetStyleColorVec4 :: (ret: ^^ImVec4, _idx: ImGuiCol);
__c__GetFont :: (ret: ^^ImFont);
__c__GetFontSize :: (ret: ^f32);
__c__GetFontTexUvWhitePixel :: (ret: ^ImVec2);
__c__GetColorU32 :: (ret: ^ImU32, _idx: ImGuiCol, _alpha_mul: f32 = 1.0f);
__c__GetColorU32_2 :: (ret: ^ImU32, _col: ^ImVec4);
__c__GetColorU32_3 :: (ret: ^ImU32, _col: ImU32);
__c__PushItemWidth :: (_item_width: f32);
__c__PopItemWidth :: ();
__c__SetNextItemWidth :: (_item_width: f32);
__c__CalcItemWidth :: (ret: ^f32);
__c__PushTextWrapPos :: (_wrap_local_pos_x: f32 = 0.0f);
__c__PopTextWrapPos :: ();
__c__PushAllowKeyboardFocus :: (_allow_keyboard_focus: bool);
__c__PopAllowKeyboardFocus :: ();
__c__PushButtonRepeat :: (_repeat: bool);
__c__PopButtonRepeat :: ();
__c__Separator :: ();
__c__SameLine :: (_offset_from_start_x: f32 = 0.0f, _spacing: f32 = -1.0f);
__c__NewLine :: ();
__c__Spacing :: ();
__c__Dummy :: (_size: ^ImVec2);
__c__Indent :: (_indent_w: f32 = 0.0f);
__c__Unindent :: (_indent_w: f32 = 0.0f);
__c__BeginGroup :: ();
__c__EndGroup :: ();
__c__GetCursorPos :: (ret: ^ImVec2);
__c__GetCursorPosX :: (ret: ^f32);
__c__GetCursorPosY :: (ret: ^f32);
__c__SetCursorPos :: (_local_pos: ^ImVec2);
__c__SetCursorPosX :: (_local_x: f32);
__c__SetCursorPosY :: (_local_y: f32);
__c__GetCursorStartPos :: (ret: ^ImVec2);
__c__GetCursorScreenPos :: (ret: ^ImVec2);
__c__SetCursorScreenPos :: (_pos: ^ImVec2);
__c__AlignTextToFramePadding :: ();
__c__GetTextLineHeight :: (ret: ^f32);
__c__GetTextLineHeightWithSpacing :: (ret: ^f32);
__c__GetFrameHeight :: (ret: ^f32);
__c__GetFrameHeightWithSpacing :: (ret: ^f32);
__c__PushID :: (_str_id: ^char8);
__c__PushID_2 :: (_str_id_begin: ^char8, _str_id_end: ^char8);
__c__PushID_3 :: (_ptr_id: ^void);
__c__PushID_4 :: (_int_id: i32);
__c__PopID :: ();
__c__GetID :: (ret: ^ImGuiID, _str_id: ^char8);
__c__GetID_2 :: (ret: ^ImGuiID, _str_id_begin: ^char8, _str_id_end: ^char8);
__c__GetID_3 :: (ret: ^ImGuiID, _ptr_id: ^void);
__c__TextUnformatted :: (_text: ^char8, _text_end: ^char8 = null);
__c__Text :: (_fmt: ^char8);
__c__TextV :: (_fmt: ^char8, _args: va_list);
__c__TextColored :: (_col: ^ImVec4, _fmt: ^char8);
__c__TextColoredV :: (_col: ^ImVec4, _fmt: ^char8, _args: va_list);
__c__TextDisabled :: (_fmt: ^char8);
__c__TextDisabledV :: (_fmt: ^char8, _args: va_list);
__c__TextWrapped :: (_fmt: ^char8);
__c__TextWrappedV :: (_fmt: ^char8, _args: va_list);
__c__LabelText :: (_label: ^char8, _fmt: ^char8);
__c__LabelTextV :: (_label: ^char8, _fmt: ^char8, _args: va_list);
__c__BulletText :: (_fmt: ^char8);
__c__BulletTextV :: (_fmt: ^char8, _args: va_list);
__c__Button :: (ret: ^bool, _label: ^char8, _size: ^ImVec2);
__c__SmallButton :: (ret: ^bool, _label: ^char8);
__c__InvisibleButton :: (ret: ^bool, _str_id: ^char8, _size: ^ImVec2);
__c__ArrowButton :: (ret: ^bool, _str_id: ^char8, _dir: ImGuiDir);
__c__Image :: (_user_texture_id: ImTextureID, _size: ^ImVec2, _uv0: ^ImVec2, _uv1: ^ImVec2, _tint_col: ^ImVec4, _border_col: ^ImVec4);
__c__ImageButton :: (ret: ^bool, _user_texture_id: ImTextureID, _size: ^ImVec2, _uv0: ^ImVec2, _uv1: ^ImVec2, _frame_padding: i32 = -1, _bg_col: ^ImVec4, _tint_col: ^ImVec4);
__c__Checkbox :: (ret: ^bool, _label: ^char8, _v: ^bool);
__c__CheckboxFlags :: (ret: ^bool, _label: ^char8, _flags: ^u32, _flags_value: u32);
__c__RadioButton :: (ret: ^bool, _label: ^char8, _active: bool);
__c__RadioButton_2 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_button: i32);
__c__ProgressBar :: (_fraction: f32, _size_arg: ^ImVec2, _overlay: ^char8 = null);
__c__Bullet :: ();
__c__BeginCombo :: (ret: ^bool, _label: ^char8, _preview_value: ^char8, _flags: ImGuiComboFlags = 0);
__c__EndCombo :: ();
__c__Combo :: (ret: ^bool, _label: ^char8, _current_item: ^i32, _items: ^^char8, _items_count: i32, _popup_max_height_in_items: i32 = -1);
__c__Combo_2 :: (ret: ^bool, _label: ^char8, _current_item: ^i32, _items_separated_by_zeros: ^char8, _popup_max_height_in_items: i32 = -1);
__c__Combo_3 :: (ret: ^bool, _label: ^char8, _current_item: ^i32, _items_getter: fn(^void, i32, ^^char8) -> bool, _data: ^void, _items_count: i32, _popup_max_height_in_items: i32 = -1);
__c__DragFloat :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__DragFloat2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__DragFloat3 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__DragFloat4 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__DragFloatRange2 :: (ret: ^bool, _label: ^char8, _v_current_min: ^f32, _v_current_max: ^f32, _v_speed: f32 = 1.0f, _v_min: f32 = 0.0f, _v_max: f32 = 0.0f, _format: ^char8 = "%.3f", _format_max: ^char8 = null, _power: f32 = 1.0f);
__c__DragInt :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d");
__c__DragInt2 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d");
__c__DragInt3 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d");
__c__DragInt4 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d");
__c__DragIntRange2 :: (ret: ^bool, _label: ^char8, _v_current_min: ^i32, _v_current_max: ^i32, _v_speed: f32 = 1.0f, _v_min: i32 = 0, _v_max: i32 = 0, _format: ^char8 = "%d", _format_max: ^char8 = null);
__c__DragScalar :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _v_speed: f32, _p_min: ^void = null, _p_max: ^void = null, _format: ^char8 = null, _power: f32 = 1.0f);
__c__DragScalarN :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _v_speed: f32, _p_min: ^void = null, _p_max: ^void = null, _format: ^char8 = null, _power: f32 = 1.0f);
__c__SliderFloat :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__SliderFloat2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__SliderFloat3 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__SliderFloat4 :: (ret: ^bool, _label: ^char8, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__SliderAngle :: (ret: ^bool, _label: ^char8, _v_rad: ^f32, _v_degrees_min: f32 = -360.0f, _v_degrees_max: f32 = 360.0f, _format: ^char8 = "%.0f deg");
__c__SliderInt :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d");
__c__SliderInt2 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d");
__c__SliderInt3 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d");
__c__SliderInt4 :: (ret: ^bool, _label: ^char8, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d");
__c__SliderScalar :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f);
__c__SliderScalarN :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f);
__c__VSliderFloat :: (ret: ^bool, _label: ^char8, _size: ^ImVec2, _v: ^f32, _v_min: f32, _v_max: f32, _format: ^char8 = "%.3f", _power: f32 = 1.0f);
__c__VSliderInt :: (ret: ^bool, _label: ^char8, _size: ^ImVec2, _v: ^i32, _v_min: i32, _v_max: i32, _format: ^char8 = "%d");
__c__VSliderScalar :: (ret: ^bool, _label: ^char8, _size: ^ImVec2, _data_type: ImGuiDataType, _p_data: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8 = null, _power: f32 = 1.0f);
__c__InputText :: (ret: ^bool, _label: ^char8, _buf: ^char8, _buf_size: size_t, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null);
__c__InputTextMultiline :: (ret: ^bool, _label: ^char8, _buf: ^char8, _buf_size: size_t, _size: ^ImVec2, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null);
__c__InputTextWithHint :: (ret: ^bool, _label: ^char8, _hint: ^char8, _buf: ^char8, _buf_size: size_t, _flags: ImGuiInputTextFlags = 0, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null);
__c__InputFloat :: (ret: ^bool, _label: ^char8, _v: ^f32, _step: f32 = 0.0f, _step_fast: f32 = 0.0f, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0);
__c__InputFloat2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0);
__c__InputFloat3 :: (ret: ^bool, _label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0);
__c__InputFloat4 :: (ret: ^bool, _label: ^char8, _v: ^f32, _format: ^char8 = "%.3f", _flags: ImGuiInputTextFlags = 0);
__c__InputInt :: (ret: ^bool, _label: ^char8, _v: ^i32, _step: i32 = 1, _step_fast: i32 = 100, _flags: ImGuiInputTextFlags = 0);
__c__InputInt2 :: (ret: ^bool, _label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0);
__c__InputInt3 :: (ret: ^bool, _label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0);
__c__InputInt4 :: (ret: ^bool, _label: ^char8, _v: ^i32, _flags: ImGuiInputTextFlags = 0);
__c__InputDouble :: (ret: ^bool, _label: ^char8, _v: ^f64, _step: f64 = 0.0, _step_fast: f64 = 0.0, _format: ^char8 = "%.6f", _flags: ImGuiInputTextFlags = 0);
__c__InputScalar :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _p_step: ^void = null, _p_step_fast: ^void = null, _format: ^char8 = null, _flags: ImGuiInputTextFlags = 0);
__c__InputScalarN :: (ret: ^bool, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _components: i32, _p_step: ^void = null, _p_step_fast: ^void = null, _format: ^char8 = null, _flags: ImGuiInputTextFlags = 0);
__c__ColorEdit3 :: (ret: ^bool, _label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0);
__c__ColorEdit4 :: (ret: ^bool, _label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0);
__c__ColorPicker3 :: (ret: ^bool, _label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0);
__c__ColorPicker4 :: (ret: ^bool, _label: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags = 0, _ref_col: ^f32 = null);
__c__ColorButton :: (ret: ^bool, _desc_id: ^char8, _col: ^ImVec4, _flags: ImGuiColorEditFlags = 0, _size: ^ImVec2);
__c__SetColorEditOptions :: (_flags: ImGuiColorEditFlags);
__c__TreeNode :: (ret: ^bool, _label: ^char8);
__c__TreeNode_2 :: (ret: ^bool, _str_id: ^char8, _fmt: ^char8);
__c__TreeNode_3 :: (ret: ^bool, _ptr_id: ^void, _fmt: ^char8);
__c__TreeNodeV :: (ret: ^bool, _str_id: ^char8, _fmt: ^char8, _args: va_list);
__c__TreeNodeV_2 :: (ret: ^bool, _ptr_id: ^void, _fmt: ^char8, _args: va_list);
__c__TreeNodeEx :: (ret: ^bool, _label: ^char8, _flags: ImGuiTreeNodeFlags = 0);
__c__TreeNodeEx_2 :: (ret: ^bool, _str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8);
__c__TreeNodeEx_3 :: (ret: ^bool, _ptr_id: ^void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8);
__c__TreeNodeExV :: (ret: ^bool, _str_id: ^char8, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list);
__c__TreeNodeExV_2 :: (ret: ^bool, _ptr_id: ^void, _flags: ImGuiTreeNodeFlags, _fmt: ^char8, _args: va_list);
__c__TreePush :: (_str_id: ^char8);
__c__TreePush_2 :: (_ptr_id: ^void = null);
__c__TreePop :: ();
__c__GetTreeNodeToLabelSpacing :: (ret: ^f32);
__c__CollapsingHeader :: (ret: ^bool, _label: ^char8, _flags: ImGuiTreeNodeFlags = 0);
__c__CollapsingHeader_2 :: (ret: ^bool, _label: ^char8, _p_open: ^bool, _flags: ImGuiTreeNodeFlags = 0);
__c__SetNextItemOpen :: (_is_open: bool, _cond: ImGuiCond = 0);
__c__Selectable :: (ret: ^bool, _label: ^char8, _selected: bool = false, _flags: ImGuiSelectableFlags = 0, _size: ^ImVec2);
__c__Selectable_2 :: (ret: ^bool, _label: ^char8, _p_selected: ^bool, _flags: ImGuiSelectableFlags = 0, _size: ^ImVec2);
__c__ListBox :: (ret: ^bool, _label: ^char8, _current_item: ^i32, _items: ^^char8, _items_count: i32, _height_in_items: i32 = -1);
__c__ListBox_2 :: (ret: ^bool, _label: ^char8, _current_item: ^i32, _items_getter: fn(^void, i32, ^mut ^char8) -> bool, _data: ^void, _items_count: i32, _height_in_items: i32 = -1);
__c__ListBoxHeader :: (ret: ^bool, _label: ^char8, _size: ^ImVec2);
__c__ListBoxHeader_2 :: (ret: ^bool, _label: ^char8, _items_count: i32, _height_in_items: i32 = -1);
__c__ListBoxFooter :: ();
__c__PlotLines :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ^ImVec2, _stride: i32);
__c__PlotLines_2 :: (_label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ^ImVec2);
__c__PlotHistogram :: (_label: ^char8, _values: ^f32, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ^ImVec2, _stride: i32);
__c__PlotHistogram_2 :: (_label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32 = 0, _overlay_text: ^char8 = null, _scale_min: f32 = f32.max, _scale_max: f32 = f32.max, _graph_size: ^ImVec2);
__c__Value :: (_prefix: ^char8, _b: bool);
__c__Value_2 :: (_prefix: ^char8, _v: i32);
__c__Value_3 :: (_prefix: ^char8, _v: u32);
__c__Value_4 :: (_prefix: ^char8, _v: f32, _float_format: ^char8 = null);
__c__BeginMenuBar :: (ret: ^bool);
__c__EndMenuBar :: ();
__c__BeginMainMenuBar :: (ret: ^bool);
__c__EndMainMenuBar :: ();
__c__BeginMenu :: (ret: ^bool, _label: ^char8, _enabled: bool = true);
__c__EndMenu :: ();
__c__MenuItem :: (ret: ^bool, _label: ^char8, _shortcut: ^char8 = null, _selected: bool = false, _enabled: bool = true);
__c__MenuItem_2 :: (ret: ^bool, _label: ^char8, _shortcut: ^char8, _p_selected: ^bool, _enabled: bool = true);
__c__BeginTooltip :: ();
__c__EndTooltip :: ();
__c__SetTooltip :: (_fmt: ^char8);
__c__SetTooltipV :: (_fmt: ^char8, _args: va_list);
__c__OpenPopup :: (_str_id: ^char8);
__c__BeginPopup :: (ret: ^bool, _str_id: ^char8, _flags: ImGuiWindowFlags = 0);
__c__BeginPopupContextItem :: (ret: ^bool, _str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1);
__c__BeginPopupContextWindow :: (ret: ^bool, _str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1, _also_over_items: bool = true);
__c__BeginPopupContextVoid :: (ret: ^bool, _str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1);
__c__BeginPopupModal :: (ret: ^bool, _name: ^char8, _p_open: ^bool = null, _flags: ImGuiWindowFlags = 0);
__c__EndPopup :: ();
__c__OpenPopupOnItemClick :: (ret: ^bool, _str_id: ^char8 = null, _mouse_button: ImGuiMouseButton = 1);
__c__IsPopupOpen :: (ret: ^bool, _str_id: ^char8);
__c__CloseCurrentPopup :: ();
__c__Columns :: (_count: i32 = 1, _id: ^char8 = null, _border: bool = true);
__c__NextColumn :: ();
__c__GetColumnIndex :: (ret: ^i32);
__c__GetColumnWidth :: (ret: ^f32, _column_index: i32 = -1);
__c__SetColumnWidth :: (_column_index: i32, _width: f32);
__c__GetColumnOffset :: (ret: ^f32, _column_index: i32 = -1);
__c__SetColumnOffset :: (_column_index: i32, _offset_x: f32);
__c__GetColumnsCount :: (ret: ^i32);
__c__BeginTabBar :: (ret: ^bool, _str_id: ^char8, _flags: ImGuiTabBarFlags = 0);
__c__EndTabBar :: ();
__c__BeginTabItem :: (ret: ^bool, _label: ^char8, _p_open: ^bool = null, _flags: ImGuiTabItemFlags = 0);
__c__EndTabItem :: ();
__c__SetTabItemClosed :: (_tab_or_docked_window_label: ^char8);
__c__DockSpace :: (_id: ImGuiID, _size: ^ImVec2, _flags: ImGuiDockNodeFlags = 0, _window_class: ^ImGuiWindowClass = null);
__c__DockSpaceOverViewport :: (ret: ^ImGuiID, _viewport: ^ImGuiViewport = null, _flags: ImGuiDockNodeFlags = 0, _window_class: ^ImGuiWindowClass = null);
__c__SetNextWindowDockID :: (_dock_id: ImGuiID, _cond: ImGuiCond = 0);
__c__SetNextWindowClass :: (_window_class: ^ImGuiWindowClass);
__c__GetWindowDockID :: (ret: ^ImGuiID);
__c__IsWindowDocked :: (ret: ^bool);
__c__LogToTTY :: (_auto_open_depth: i32 = -1);
__c__LogToFile :: (_auto_open_depth: i32 = -1, _filename: ^char8 = null);
__c__LogToClipboard :: (_auto_open_depth: i32 = -1);
__c__LogFinish :: ();
__c__LogButtons :: ();
__c__LogText :: (_fmt: ^char8);
__c__BeginDragDropSource :: (ret: ^bool, _flags: ImGuiDragDropFlags = 0);
__c__SetDragDropPayload :: (ret: ^bool, _type: ^char8, _data: ^void, _sz: size_t, _cond: ImGuiCond = 0);
__c__EndDragDropSource :: ();
__c__BeginDragDropTarget :: (ret: ^bool);
__c__AcceptDragDropPayload :: (ret: ^^ImGuiPayload, _type: ^char8, _flags: ImGuiDragDropFlags = 0);
__c__EndDragDropTarget :: ();
__c__GetDragDropPayload :: (ret: ^^ImGuiPayload);
__c__PushClipRect :: (_clip_rect_min: ^ImVec2, _clip_rect_max: ^ImVec2, _intersect_with_current_clip_rect: bool);
__c__PopClipRect :: ();
__c__SetItemDefaultFocus :: ();
__c__SetKeyboardFocusHere :: (_offset: i32 = 0);
__c__IsItemHovered :: (ret: ^bool, _flags: ImGuiHoveredFlags = 0);
__c__IsItemActive :: (ret: ^bool);
__c__IsItemFocused :: (ret: ^bool);
__c__IsItemClicked :: (ret: ^bool, _mouse_button: ImGuiMouseButton = 0);
__c__IsItemVisible :: (ret: ^bool);
__c__IsItemEdited :: (ret: ^bool);
__c__IsItemActivated :: (ret: ^bool);
__c__IsItemDeactivated :: (ret: ^bool);
__c__IsItemDeactivatedAfterEdit :: (ret: ^bool);
__c__IsItemToggledOpen :: (ret: ^bool);
__c__IsAnyItemHovered :: (ret: ^bool);
__c__IsAnyItemActive :: (ret: ^bool);
__c__IsAnyItemFocused :: (ret: ^bool);
__c__GetItemRectMin :: (ret: ^ImVec2);
__c__GetItemRectMax :: (ret: ^ImVec2);
__c__GetItemRectSize :: (ret: ^ImVec2);
__c__SetItemAllowOverlap :: ();
__c__IsRectVisible :: (ret: ^bool, _size: ^ImVec2);
__c__IsRectVisible_2 :: (ret: ^bool, _rect_min: ^ImVec2, _rect_max: ^ImVec2);
__c__GetTime :: (ret: ^f64);
__c__GetFrameCount :: (ret: ^i32);
__c__GetBackgroundDrawList :: (ret: ^^ImDrawList);
__c__GetForegroundDrawList :: (ret: ^^ImDrawList);
__c__GetBackgroundDrawList_2 :: (ret: ^^ImDrawList, _viewport: ^ImGuiViewport);
__c__GetForegroundDrawList_2 :: (ret: ^^ImDrawList, _viewport: ^ImGuiViewport);
__c__GetDrawListSharedData :: (ret: ^^ImDrawListSharedData);
__c__GetStyleColorName :: (ret: ^^char8, _idx: ImGuiCol);
__c__SetStateStorage :: (_storage: ^ImGuiStorage);
__c__GetStateStorage :: (ret: ^^ImGuiStorage);
__c__CalcTextSize :: (ret: ^ImVec2, _text: ^char8, _text_end: ^char8 = null, _hide_text_after_double_hash: bool = false, _wrap_width: f32 = -1.0f);
__c__CalcListClipping :: (_items_count: i32, _items_height: f32, _out_items_display_start: ^i32, _out_items_display_end: ^i32);
__c__BeginChildFrame :: (ret: ^bool, _id: ImGuiID, _size: ^ImVec2, _flags: ImGuiWindowFlags = 0);
__c__EndChildFrame :: ();
__c__ColorConvertU32ToFloat4 :: (ret: ^ImVec4, _in: ImU32);
__c__ColorConvertFloat4ToU32 :: (ret: ^ImU32, _in: ^ImVec4);
__c__ColorConvertRGBtoHSV :: (_r: f32, _g: f32, _b: f32, _out_h: ^f32, _out_s: ^f32, _out_v: ^f32);
__c__ColorConvertHSVtoRGB :: (_h: f32, _s: f32, _v: f32, _out_r: ^f32, _out_g: ^f32, _out_b: ^f32);
__c__GetKeyIndex :: (ret: ^i32, _imgui_key: ImGuiKey);
__c__IsKeyDown :: (ret: ^bool, _user_key_index: i32);
__c__IsKeyPressed :: (ret: ^bool, _user_key_index: i32, _repeat: bool = true);
__c__IsKeyReleased :: (ret: ^bool, _user_key_index: i32);
__c__GetKeyPressedAmount :: (ret: ^i32, _key_index: i32, _repeat_delay: f32, _rate: f32);
__c__CaptureKeyboardFromApp :: (_want_capture_keyboard_value: bool = true);
__c__IsMouseDown :: (ret: ^bool, _button: ImGuiMouseButton);
__c__IsMouseClicked :: (ret: ^bool, _button: ImGuiMouseButton, _repeat: bool = false);
__c__IsMouseReleased :: (ret: ^bool, _button: ImGuiMouseButton);
__c__IsMouseDoubleClicked :: (ret: ^bool, _button: ImGuiMouseButton);
__c__IsMouseHoveringRect :: (ret: ^bool, _r_min: ^ImVec2, _r_max: ^ImVec2, _clip: bool = true);
__c__IsMousePosValid :: (ret: ^bool, _mouse_pos: ^ImVec2 = null);
__c__IsAnyMouseDown :: (ret: ^bool);
__c__GetMousePos :: (ret: ^ImVec2);
__c__GetMousePosOnOpeningCurrentPopup :: (ret: ^ImVec2);
__c__IsMouseDragging :: (ret: ^bool, _button: ImGuiMouseButton, _lock_threshold: f32 = -1.0f);
__c__GetMouseDragDelta :: (ret: ^ImVec2, _button: ImGuiMouseButton = 0, _lock_threshold: f32 = -1.0f);
__c__ResetMouseDragDelta :: (_button: ImGuiMouseButton = 0);
__c__GetMouseCursor :: (ret: ^ImGuiMouseCursor);
__c__SetMouseCursor :: (_cursor_type: ImGuiMouseCursor);
__c__CaptureMouseFromApp :: (_want_capture_mouse_value: bool = true);
__c__GetClipboardText :: (ret: ^^char8);
__c__SetClipboardText :: (_text: ^char8);
__c__LoadIniSettingsFromDisk :: (_ini_filename: ^char8);
__c__LoadIniSettingsFromMemory :: (_ini_data: ^char8, _ini_size: size_t = 0);
__c__SaveIniSettingsToDisk :: (_ini_filename: ^char8);
__c__SaveIniSettingsToMemory :: (ret: ^^char8, _out_ini_size: ^size_t = null);
__c__SetAllocatorFunctions :: (_alloc_func: fn(size_t, ^void) -> ^void, _free_func: fn(^void, ^void) -> void, _user_data: ^void = null);
__c__MemAlloc :: (ret: ^^void, _size: size_t);
__c__MemFree :: (_ptr: ^void);
__c__GetPlatformIO :: (ret: ^^ImGuiPlatformIO);
__c__GetMainViewport :: (ret: ^^ImGuiViewport);
__c__UpdatePlatformWindows :: ();
__c__RenderPlatformWindowsDefault :: (_platform_arg: ^void = null, _renderer_arg: ^void = null);
__c__DestroyPlatformWindows :: ();
__c__FindViewportByID :: (ret: ^^ImGuiViewport, _id: ImGuiID);
__c__FindViewportByPlatformHandle :: (ret: ^^ImGuiViewport, _platform_handle: ^void);
__c__InputFloat_2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _step: f32, _step_fast: f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0);
__c__InputFloat2_2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0);
__c__InputFloat3_2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0);
__c__InputFloat4_2 :: (ret: ^bool, _label: ^char8, _v: ^f32, _decimal_precision: i32, _flags: ImGuiInputTextFlags = 0);
__c__ImHashData :: (ret: ^ImU32, _data: ^void, _data_size: size_t, _seed: ImU32 = 0);
__c__ImHashStr :: (ret: ^ImU32, _data: ^char8, _data_size: size_t = 0, _seed: ImU32 = 0);
__c__ImStricmp :: (ret: ^i32, _str1: ^char8, _str2: ^char8);
__c__ImStrnicmp :: (ret: ^i32, _str1: ^char8, _str2: ^char8, _count: size_t);
__c__ImStrncpy :: (_dst: ^char8, _src: ^char8, _count: size_t);
__c__ImStrdup :: (ret: ^^char8, _str: ^char8);
__c__ImStrdupcpy :: (ret: ^^char8, _dst: ^char8, _p_dst_size: ^size_t, _str: ^char8);
__c__ImStrchrRange :: (ret: ^^char8, _str_begin: ^char8, _str_end: ^char8, _c: char8);
__c__ImStrlenW :: (ret: ^i32, _str: ^ImWchar);
__c__ImStreolRange :: (ret: ^^char8, _str: ^char8, _str_end: ^char8);
__c__ImStrbolW :: (ret: ^^ImWchar, _buf_mid_line: ^ImWchar, _buf_begin: ^ImWchar);
__c__ImStristr :: (ret: ^^char8, _haystack: ^char8, _haystack_end: ^char8, _needle: ^char8, _needle_end: ^char8);
__c__ImStrTrimBlanks :: (_str: ^char8);
__c__ImStrSkipBlank :: (ret: ^^char8, _str: ^char8);
__c__ImFormatString :: (ret: ^i32, _buf: ^char8, _buf_size: size_t, _fmt: ^char8);
__c__ImFormatStringV :: (ret: ^i32, _buf: ^char8, _buf_size: size_t, _fmt: ^char8, _args: va_list);
__c__ImParseFormatFindStart :: (ret: ^^char8, _format: ^char8);
__c__ImParseFormatFindEnd :: (ret: ^^char8, _format: ^char8);
__c__ImParseFormatTrimDecorations :: (ret: ^^char8, _format: ^char8, _buf: ^char8, _buf_size: size_t);
__c__ImParseFormatPrecision :: (ret: ^i32, _format: ^char8, _default_value: i32);
__c__ImTextStrToUtf8 :: (ret: ^i32, _buf: ^char8, _buf_size: i32, _in_text: ^ImWchar, _in_text_end: ^ImWchar);
__c__ImTextCharFromUtf8 :: (ret: ^i32, _out_char: ^u32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextStrFromUtf8 :: (ret: ^i32, _buf: ^ImWchar, _buf_size: i32, _in_text: ^char8, _in_text_end: ^char8, _in_remaining: ^^char8 = null);
__c__ImTextCountCharsFromUtf8 :: (ret: ^i32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextCountUtf8BytesFromChar :: (ret: ^i32, _in_text: ^char8, _in_text_end: ^char8);
__c__ImTextCountUtf8BytesFromStr :: (ret: ^i32, _in_text: ^ImWchar, _in_text_end: ^ImWchar);
__c__ImFileOpen :: (ret: ^ImFileHandle, _filename: ^char8, _mode: ^char8);
__c__ImFileClose :: (ret: ^bool, _file: ImFileHandle);
__c__ImFileGetSize :: (ret: ^ImU64, _file: ImFileHandle);
__c__ImFileRead :: (ret: ^ImU64, _data: ^void, _size: ImU64, _count: ImU64, _file: ImFileHandle);
__c__ImFileWrite :: (ret: ^ImU64, _data: ^void, _size: ImU64, _count: ImU64, _file: ImFileHandle);
__c__ImFileLoadToMemory :: (ret: ^^void, _filename: ^char8, _mode: ^char8, _out_file_size: ^size_t = null, _padding_bytes: i32 = 0);
__c__ImBezierCalc :: (ret: ^ImVec2, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _t: f32);
__c__ImBezierClosestPoint :: (ret: ^ImVec2, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _p: ^ImVec2, _num_segments: i32);
__c__ImBezierClosestPointCasteljau :: (ret: ^ImVec2, _p1: ^ImVec2, _p2: ^ImVec2, _p3: ^ImVec2, _p4: ^ImVec2, _p: ^ImVec2, _tess_tol: f32);
__c__ImLineClosestPoint :: (ret: ^ImVec2, _a: ^ImVec2, _b: ^ImVec2, _p: ^ImVec2);
__c__ImTriangleContainsPoint :: (ret: ^bool, _a: ^ImVec2, _b: ^ImVec2, _c: ^ImVec2, _p: ^ImVec2);
__c__ImTriangleClosestPoint :: (ret: ^ImVec2, _a: ^ImVec2, _b: ^ImVec2, _c: ^ImVec2, _p: ^ImVec2);
__c__ImTriangleBarycentricCoords :: (_a: ^ImVec2, _b: ^ImVec2, _c: ^ImVec2, _p: ^ImVec2, _out_u: ^f32, _out_v: ^f32, _out_w: ^f32);
__c__ImGetDirQuadrantFromDelta :: (ret: ^ImGuiDir, _dx: f32, _dy: f32);
__c__FindWindowByID :: (ret: ^^ImGuiWindow, _id: ImGuiID);
__c__FindWindowByName :: (ret: ^^ImGuiWindow, _name: ^char8);
__c__FocusWindow :: (_window: ^ImGuiWindow);
__c__FocusTopMostWindowUnderOne :: (_under_this_window: ^ImGuiWindow, _ignore_window: ^ImGuiWindow);
__c__BringWindowToFocusFront :: (_window: ^ImGuiWindow);
__c__BringWindowToDisplayFront :: (_window: ^ImGuiWindow);
__c__BringWindowToDisplayBack :: (_window: ^ImGuiWindow);
__c__UpdateWindowParentAndRootLinks :: (_window: ^ImGuiWindow, _flags: ImGuiWindowFlags, _parent_window: ^ImGuiWindow);
__c__CalcWindowExpectedSize :: (ret: ^ImVec2, _window: ^ImGuiWindow);
__c__IsWindowChildOf :: (ret: ^bool, _window: ^ImGuiWindow, _potential_parent: ^ImGuiWindow);
__c__IsWindowNavFocusable :: (ret: ^bool, _window: ^ImGuiWindow);
__c__GetWindowAllowedExtentRect :: (ret: ^ImRect, _window: ^ImGuiWindow);
__c__SetWindowPos_3 :: (_window: ^ImGuiWindow, _pos: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowSize_3 :: (_window: ^ImGuiWindow, _size: ^ImVec2, _cond: ImGuiCond = 0);
__c__SetWindowCollapsed_3 :: (_window: ^ImGuiWindow, _collapsed: bool, _cond: ImGuiCond = 0);
__c__GcCompactTransientWindowBuffers :: (_window: ^ImGuiWindow);
__c__GcAwakeTransientWindowBuffers :: (_window: ^ImGuiWindow);
__c__SetCurrentFont :: (_font: ^ImFont);
__c__Initialize :: (_context: ^ImGuiContext);
__c__Shutdown :: (_context: ^ImGuiContext);
__c__UpdateHoveredWindowAndCaptureFlags :: ();
__c__StartMouseMovingWindow :: (_window: ^ImGuiWindow);
__c__StartMouseMovingWindowOrNode :: (_window: ^ImGuiWindow, _node: ^ImGuiDockNode, _undock_floating_node: bool);
__c__UpdateMouseMovingWindowNewFrame :: ();
__c__UpdateMouseMovingWindowEndFrame :: ();
__c__TranslateWindowsInViewport :: (_viewport: ^ImGuiViewportP, _old_pos: ^ImVec2, _new_pos: ^ImVec2);
__c__ScaleWindowsInViewport :: (_viewport: ^ImGuiViewportP, _scale: f32);
__c__DestroyPlatformWindow :: (_viewport: ^ImGuiViewportP);
__c__ShowViewportThumbnails :: ();
__c__MarkIniSettingsDirty :: ();
__c__MarkIniSettingsDirty_2 :: (_window: ^ImGuiWindow);
__c__CreateNewWindowSettings :: (ret: ^^ImGuiWindowSettings, _name: ^char8);
__c__FindWindowSettings :: (ret: ^^ImGuiWindowSettings, _id: ImGuiID);
__c__FindOrCreateWindowSettings :: (ret: ^^ImGuiWindowSettings, _name: ^char8);
__c__FindSettingsHandler :: (ret: ^^ImGuiSettingsHandler, _type_name: ^char8);
__c__SetScrollX_2 :: (_window: ^ImGuiWindow, _new_scroll_x: f32);
__c__SetScrollY_2 :: (_window: ^ImGuiWindow, _new_scroll_y: f32);
__c__SetScrollFromPosX_2 :: (_window: ^ImGuiWindow, _local_x: f32, _center_x_ratio: f32 = 0.5f);
__c__SetScrollFromPosY_2 :: (_window: ^ImGuiWindow, _local_y: f32, _center_y_ratio: f32 = 0.5f);
__c__ScrollToBringRectIntoView :: (ret: ^ImVec2, _window: ^ImGuiWindow, _item_rect: ^ImRect);
__c__SetActiveID :: (_id: ImGuiID, _window: ^ImGuiWindow);
__c__SetFocusID :: (_id: ImGuiID, _window: ^ImGuiWindow);
__c__ClearActiveID :: ();
__c__GetHoveredID :: (ret: ^ImGuiID);
__c__SetHoveredID :: (_id: ImGuiID);
__c__KeepAliveID :: (_id: ImGuiID);
__c__MarkItemEdited :: (_id: ImGuiID);
__c__PushOverrideID :: (_id: ImGuiID);
__c__ItemSize :: (_size: ^ImVec2, _text_baseline_y: f32 = -1.0f);
__c__ItemSize_2 :: (_bb: ^ImRect, _text_baseline_y: f32 = -1.0f);
__c__ItemAdd :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _nav_bb: ^ImRect = null);
__c__ItemHoverable :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID);
__c__IsClippedEx :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _clip_even_when_logged: bool);
__c__FocusableItemRegister :: (ret: ^bool, _window: ^ImGuiWindow, _id: ImGuiID);
__c__FocusableItemUnregister :: (_window: ^ImGuiWindow);
__c__CalcItemSize :: (ret: ^ImVec2, _size: ^ImVec2, _default_w: f32, _default_h: f32);
__c__CalcWrapWidthForPos :: (ret: ^f32, _pos: ^ImVec2, _wrap_pos_x: f32);
__c__PushMultiItemsWidths :: (_components: i32, _width_full: f32);
__c__PushItemFlag :: (_option: ImGuiItemFlags, _enabled: bool);
__c__PopItemFlag :: ();
__c__IsItemToggledSelection :: (ret: ^bool);
__c__GetContentRegionMaxAbs :: (ret: ^ImVec2);
__c__ShrinkWidths :: (_items: ^ImGuiShrinkWidthItem, _count: i32, _width_excess: f32);
__c__LogBegin :: (_type: ImGuiLogType, _auto_open_depth: i32);
__c__LogToBuffer :: (_auto_open_depth: i32 = -1);
__c__OpenPopupEx :: (_id: ImGuiID);
__c__ClosePopupToLevel :: (_remaining: i32, _restore_focus_to_window_under_popup: bool);
__c__ClosePopupsOverWindow :: (_ref_window: ^ImGuiWindow, _restore_focus_to_window_under_popup: bool);
__c__IsPopupOpen_2 :: (ret: ^bool, _id: ImGuiID);
__c__BeginPopupEx :: (ret: ^bool, _id: ImGuiID, _extra_flags: ImGuiWindowFlags);
__c__BeginTooltipEx :: (_extra_flags: ImGuiWindowFlags, _override_previous_tooltip: bool = true);
__c__GetTopMostPopupModal :: (ret: ^^ImGuiWindow);
__c__FindBestWindowPosForPopup :: (ret: ^ImVec2, _window: ^ImGuiWindow);
__c__FindBestWindowPosForPopupEx :: (ret: ^ImVec2, _ref_pos: ^ImVec2, _size: ^ImVec2, _last_dir: ^ImGuiDir, _r_outer: ^ImRect, _r_avoid: ^ImRect, _policy: ImGuiPopupPositionPolicy = ImGuiPopupPositionPolicy.Default);
__c__NavInitWindow :: (_window: ^ImGuiWindow, _force_reinit: bool);
__c__NavMoveRequestButNoResultYet :: (ret: ^bool);
__c__NavMoveRequestCancel :: ();
__c__NavMoveRequestForward :: (_move_dir: ImGuiDir, _clip_dir: ImGuiDir, _bb_rel: ^ImRect, _move_flags: ImGuiNavMoveFlags);
__c__NavMoveRequestTryWrapping :: (_window: ^ImGuiWindow, _move_flags: ImGuiNavMoveFlags);
__c__GetNavInputAmount :: (ret: ^f32, _n: ImGuiNavInput, _mode: ImGuiInputReadMode);
__c__GetNavInputAmount2d :: (ret: ^ImVec2, _dir_sources: ImGuiNavDirSourceFlags, _mode: ImGuiInputReadMode, _slow_factor: f32 = 0.0f, _fast_factor: f32 = 0.0f);
__c__CalcTypematicRepeatAmount :: (ret: ^i32, _t0: f32, _t1: f32, _repeat_delay: f32, _repeat_rate: f32);
__c__ActivateItem :: (_id: ImGuiID);
__c__SetNavID :: (_id: ImGuiID, _nav_layer: i32);
__c__SetNavIDWithRectRel :: (_id: ImGuiID, _nav_layer: i32, _rect_rel: ^ImRect);
__c__IsMouseDragPastThreshold :: (ret: ^bool, _button: ImGuiMouseButton, _lock_threshold: f32 = -1.0f);
__c__DockContextInitialize :: (_ctx: ^ImGuiContext);
__c__DockContextShutdown :: (_ctx: ^ImGuiContext);
__c__DockContextOnLoadSettings :: (_ctx: ^ImGuiContext);
__c__DockContextRebuildNodes :: (_ctx: ^ImGuiContext);
__c__DockContextUpdateUndocking :: (_ctx: ^ImGuiContext);
__c__DockContextUpdateDocking :: (_ctx: ^ImGuiContext);
__c__DockContextGenNodeID :: (ret: ^ImGuiID, _ctx: ^ImGuiContext);
__c__DockContextQueueDock :: (_ctx: ^ImGuiContext, _target: ^ImGuiWindow, _target_node: ^ImGuiDockNode, _payload: ^ImGuiWindow, _split_dir: ImGuiDir, _split_ratio: f32, _split_outer: bool);
__c__DockContextQueueUndockWindow :: (_ctx: ^ImGuiContext, _window: ^ImGuiWindow);
__c__DockContextQueueUndockNode :: (_ctx: ^ImGuiContext, _node: ^ImGuiDockNode);
__c__DockContextCalcDropPosForDocking :: (ret: ^bool, _target: ^ImGuiWindow, _target_node: ^ImGuiDockNode, _payload: ^ImGuiWindow, _split_dir: ImGuiDir, _split_outer: bool, _out_pos: ^ImVec2);
__c__GetWindowAlwaysWantOwnTabBar :: (ret: ^bool, _window: ^ImGuiWindow);
__c__BeginDocked :: (_window: ^ImGuiWindow, _p_open: ^bool);
__c__BeginDockableDragDropSource :: (_window: ^ImGuiWindow);
__c__BeginDockableDragDropTarget :: (_window: ^ImGuiWindow);
__c__SetWindowDock :: (_window: ^ImGuiWindow, _dock_id: ImGuiID, _cond: ImGuiCond);
__c__DockBuilderDockWindow :: (_window_name: ^char8, _node_id: ImGuiID);
__c__DockBuilderGetNode :: (ret: ^^ImGuiDockNode, _node_id: ImGuiID);
__c__DockBuilderAddNode :: (ret: ^ImGuiID, _node_id: ImGuiID = 0, _flags: ImGuiDockNodeFlags = 0);
__c__DockBuilderRemoveNode :: (_node_id: ImGuiID);
__c__DockBuilderRemoveNodeDockedWindows :: (_node_id: ImGuiID, _clear_persistent_docking_references: bool = true);
__c__DockBuilderRemoveNodeChildNodes :: (_node_id: ImGuiID);
__c__DockBuilderSetNodePos :: (_node_id: ImGuiID, _pos: ^ImVec2);
__c__DockBuilderSetNodeSize :: (_node_id: ImGuiID, _size: ^ImVec2);
__c__DockBuilderSplitNode :: (ret: ^ImGuiID, _node_id: ImGuiID, _split_dir: ImGuiDir, _size_ratio_for_node_at_dir: f32, _out_id_at_dir: ^ImGuiID, _out_id_at_opposite_dir: ^ImGuiID);
__c__DockBuilderCopyDockSpace :: (_src_dockspace_id: ImGuiID, _dst_dockspace_id: ImGuiID, _in_window_remap_pairs: ^__UNKNOWN_16);
__c__DockBuilderCopyNode :: (_src_node_id: ImGuiID, _dst_node_id: ImGuiID, _out_node_remap_pairs: ^__UNKNOWN_16);
__c__DockBuilderCopyWindowSettings :: (_src_name: ^char8, _dst_name: ^char8);
__c__DockBuilderFinish :: (_node_id: ImGuiID);
__c__BeginDragDropTargetCustom :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID);
__c__ClearDragDrop :: ();
__c__IsDragDropPayloadBeingAccepted :: (ret: ^bool);
__c__BeginColumns :: (_str_id: ^char8, _count: i32, _flags: ImGuiColumnsFlags = 0);
__c__EndColumns :: ();
__c__PushColumnClipRect :: (_column_index: i32);
__c__PushColumnsBackground :: ();
__c__PopColumnsBackground :: ();
__c__GetColumnsID :: (ret: ^ImGuiID, _str_id: ^char8, _count: i32);
__c__FindOrCreateColumns :: (ret: ^^ImGuiColumns, _window: ^ImGuiWindow, _id: ImGuiID);
__c__GetColumnOffsetFromNorm :: (ret: ^f32, _columns: ^ImGuiColumns, _offset_norm: f32);
__c__GetColumnNormFromOffset :: (ret: ^f32, _columns: ^ImGuiColumns, _offset: f32);
__c__BeginTabBarEx :: (ret: ^bool, _tab_bar: ^ImGuiTabBar, _bb: ^ImRect, _flags: ImGuiTabBarFlags, _dock_node: ^ImGuiDockNode);
__c__TabBarFindTabByID :: (ret: ^^ImGuiTabItem, _tab_bar: ^ImGuiTabBar, _tab_id: ImGuiID);
__c__TabBarFindMostRecentlySelectedTabForActiveWindow :: (ret: ^^ImGuiTabItem, _tab_bar: ^ImGuiTabBar);
__c__TabBarAddTab :: (_tab_bar: ^ImGuiTabBar, _tab_flags: ImGuiTabItemFlags, _window: ^ImGuiWindow);
__c__TabBarRemoveTab :: (_tab_bar: ^ImGuiTabBar, _tab_id: ImGuiID);
__c__TabBarCloseTab :: (_tab_bar: ^ImGuiTabBar, _tab: ^ImGuiTabItem);
__c__TabBarQueueChangeTabOrder :: (_tab_bar: ^ImGuiTabBar, _tab: ^ImGuiTabItem, _dir: i32);
__c__TabItemEx :: (ret: ^bool, _tab_bar: ^ImGuiTabBar, _label: ^char8, _p_open: ^bool, _flags: ImGuiTabItemFlags, _docked_window: ^ImGuiWindow);
__c__TabItemCalcSize :: (ret: ^ImVec2, _label: ^char8, _has_close_button: bool);
__c__TabItemBackground :: (_draw_list: ^ImDrawList, _bb: ^ImRect, _flags: ImGuiTabItemFlags, _col: ImU32);
__c__TabItemLabelAndCloseButton :: (ret: ^bool, _draw_list: ^ImDrawList, _bb: ^ImRect, _flags: ImGuiTabItemFlags, _frame_padding: ^ImVec2, _label: ^char8, _tab_id: ImGuiID, _close_button_id: ImGuiID);
__c__RenderText :: (_pos: ^ImVec2, _text: ^char8, _text_end: ^char8 = null, _hide_text_after_hash: bool = true);
__c__RenderTextWrapped :: (_pos: ^ImVec2, _text: ^char8, _text_end: ^char8, _wrap_width: f32);
__c__RenderTextClipped :: (_pos_min: ^ImVec2, _pos_max: ^ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2, _align: ^ImVec2, _clip_rect: ^ImRect = null);
__c__RenderTextClippedEx :: (_draw_list: ^ImDrawList, _pos_min: ^ImVec2, _pos_max: ^ImVec2, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2, _align: ^ImVec2, _clip_rect: ^ImRect = null);
__c__RenderTextEllipsis :: (_draw_list: ^ImDrawList, _pos_min: ^ImVec2, _pos_max: ^ImVec2, _clip_max_x: f32, _ellipsis_max_x: f32, _text: ^char8, _text_end: ^char8, _text_size_if_known: ^ImVec2);
__c__RenderFrame :: (_p_min: ^ImVec2, _p_max: ^ImVec2, _fill_col: ImU32, _border: bool = true, _rounding: f32 = 0.0f);
__c__RenderFrameBorder :: (_p_min: ^ImVec2, _p_max: ^ImVec2, _rounding: f32 = 0.0f);
__c__RenderColorRectWithAlphaCheckerboard :: (_p_min: ^ImVec2, _p_max: ^ImVec2, _fill_col: ImU32, _grid_step: f32, _grid_off: ^ImVec2, _rounding: f32 = 0.0f, _rounding_corners_flags: i32 = @bin_not(0));
__c__RenderCheckMark :: (_pos: ^ImVec2, _col: ImU32, _sz: f32);
__c__RenderNavHighlight :: (_bb: ^ImRect, _id: ImGuiID, _flags: ImGuiNavHighlightFlags = ImGuiNavHighlightFlags_.TypeDefault);
__c__RenderMouseCursor :: (_pos: ^ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor = ImGuiMouseCursor_.Arrow);
__c__FindRenderedTextEnd :: (ret: ^^char8, _text: ^char8, _text_end: ^char8 = null);
__c__LogRenderedText :: (_ref_pos: ^ImVec2, _text: ^char8, _text_end: ^char8 = null);
__c__RenderArrow :: (_draw_list: ^ImDrawList, _pos: ^ImVec2, _col: ImU32, _dir: ImGuiDir, _scale: f32 = 1.0f);
__c__RenderBullet :: (_draw_list: ^ImDrawList, _pos: ^ImVec2, _col: ImU32);
__c__RenderMouseCursor_2 :: (_draw_list: ^ImDrawList, _pos: ^ImVec2, _scale: f32, _mouse_cursor: ImGuiMouseCursor, _col_fill: ImU32, _col_border: ImU32, _col_shadow: ImU32);
__c__RenderArrowPointingAt :: (_draw_list: ^ImDrawList, _pos: ^ImVec2, _half_sz: ^ImVec2, _direction: ImGuiDir, _col: ImU32);
__c__RenderArrowDockMenu :: (_draw_list: ^ImDrawList, _p_min: ^ImVec2, _sz: f32, _col: ImU32);
__c__RenderRectFilledRangeH :: (_draw_list: ^ImDrawList, _rect: ^ImRect, _col: ImU32, _x_start_norm: f32, _x_end_norm: f32, _rounding: f32);
__c__RenderRectFilledWithHole :: (_draw_list: ^ImDrawList, _outer: ^ImRect, _inner: ^ImRect, _col: ImU32, _rounding: f32);
__c__TextEx :: (_text: ^char8, _text_end: ^char8 = null, _flags: ImGuiTextFlags = 0);
__c__ButtonEx :: (ret: ^bool, _label: ^char8, _size_arg: ^ImVec2, _flags: ImGuiButtonFlags = 0);
__c__CloseButton :: (ret: ^bool, _id: ImGuiID, _pos: ^ImVec2);
__c__CollapseButton :: (ret: ^bool, _id: ImGuiID, _pos: ^ImVec2, _dock_node: ^ImGuiDockNode);
__c__ArrowButtonEx :: (ret: ^bool, _str_id: ^char8, _dir: ImGuiDir, _size_arg: ^ImVec2, _flags: ImGuiButtonFlags);
__c__Scrollbar :: (_axis: ImGuiAxis);
__c__ScrollbarEx :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _axis: ImGuiAxis, _p_scroll_v: ^f32, _avail_v: f32, _contents_v: f32, _rounding_corners: ImDrawCornerFlags);
__c__GetWindowScrollbarID :: (ret: ^ImGuiID, _window: ^ImGuiWindow, _axis: ImGuiAxis);
__c__GetWindowResizeID :: (ret: ^ImGuiID, _window: ^ImGuiWindow, _n: i32);
__c__SeparatorEx :: (_flags: ImGuiSeparatorFlags);
__c__ButtonBehavior :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _out_hovered: ^bool, _out_held: ^bool, _flags: ImGuiButtonFlags = 0);
__c__DragBehavior :: (ret: ^bool, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^void, _v_speed: f32, _p_min: ^void, _p_max: ^void, _format: ^char8, _power: f32, _flags: ImGuiDragFlags);
__c__SliderBehavior :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _data_type: ImGuiDataType, _p_v: ^void, _p_min: ^void, _p_max: ^void, _format: ^char8, _power: f32, _flags: ImGuiSliderFlags, _out_grab_bb: ^ImRect);
__c__SplitterBehavior :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _axis: ImGuiAxis, _size1: ^f32, _size2: ^f32, _min_size1: f32, _min_size2: f32, _hover_extend: f32 = 0.0f, _hover_visibility_delay: f32 = 0.0f);
__c__TreeNodeBehavior :: (ret: ^bool, _id: ImGuiID, _flags: ImGuiTreeNodeFlags, _label: ^char8, _label_end: ^char8 = null);
__c__TreeNodeBehaviorIsOpen :: (ret: ^bool, _id: ImGuiID, _flags: ImGuiTreeNodeFlags = 0);
__c__TreePushOverrideID :: (_id: ImGuiID);
__c__DataTypeGetInfo :: (ret: ^^ImGuiDataTypeInfo, _data_type: ImGuiDataType);
__c__DataTypeFormatString :: (ret: ^i32, _buf: ^char8, _buf_size: i32, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8);
__c__DataTypeApplyOp :: (_data_type: ImGuiDataType, _op: i32, _output: ^void, _arg_1: ^void, _arg_2: ^void);
__c__DataTypeApplyOpFromText :: (ret: ^bool, _buf: ^char8, _initial_value_buf: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8);
__c__InputTextEx :: (ret: ^bool, _label: ^char8, _hint: ^char8, _buf: ^char8, _buf_size: i32, _size_arg: ^ImVec2, _flags: ImGuiInputTextFlags, _callback: ImGuiInputTextCallback = null, _user_data: ^void = null);
__c__TempInputTextScalar :: (ret: ^bool, _bb: ^ImRect, _id: ImGuiID, _label: ^char8, _data_type: ImGuiDataType, _p_data: ^void, _format: ^char8);
__c__ColorTooltip :: (_text: ^char8, _col: ^f32, _flags: ImGuiColorEditFlags);
__c__ColorEditOptionsPopup :: (_col: ^f32, _flags: ImGuiColorEditFlags);
__c__ColorPickerOptionsPopup :: (_ref_col: ^f32, _flags: ImGuiColorEditFlags);
__c__PlotEx :: (_plot_type: ImGuiPlotType, _label: ^char8, _values_getter: fn(^void, i32) -> f32, _data: ^void, _values_count: i32, _values_offset: i32, _overlay_text: ^char8, _scale_min: f32, _scale_max: f32, _frame_size: ^ImVec2);
__c__ShadeVertsLinearColorGradientKeepAlpha :: (_draw_list: ^ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _gradient_p0: ^ImVec2, _gradient_p1: ^ImVec2, _col0: ImU32, _col1: ImU32);
__c__ShadeVertsLinearUV :: (_draw_list: ^ImDrawList, _vert_start_idx: i32, _vert_end_idx: i32, _a: ^ImVec2, _b: ^ImVec2, _uv_a: ^ImVec2, _uv_b: ^ImVec2, _clamp: bool);
__c__ImFontAtlasBuildWithStbTruetype :: (ret: ^bool, _atlas: ^ImFontAtlas);
__c__ImFontAtlasBuildRegisterDefaultCustomRects :: (_atlas: ^ImFontAtlas);
__c__ImFontAtlasBuildSetupFont :: (_atlas: ^ImFontAtlas, _font: ^ImFont, _font_config: ^ImFontConfig, _ascent: f32, _descent: f32);
__c__ImFontAtlasBuildPackCustomRects :: (_atlas: ^ImFontAtlas, _stbrp_context_opaque: ^void);
__c__ImFontAtlasBuildFinish :: (_atlas: ^ImFontAtlas);
__c__ImFontAtlasBuildMultiplyCalcLookupTable :: (_out_table: ^u8, _in_multiply_factor: f32);
__c__ImFontAtlasBuildMultiplyRectAlpha8 :: (_table: ^u8, _pixels: ^u8, _x: i32, _y: i32, _w: i32, _h: i32, _stride: i32);
__c__ImGui_ImplOpenGL3_Init :: (ret: ^bool, _glsl_version: ^char8 = null);
__c__ImGui_ImplOpenGL3_Shutdown :: ();
__c__ImGui_ImplOpenGL3_NewFrame :: ();
__c__ImGui_ImplOpenGL3_RenderDrawData :: (_draw_data: ^ImDrawData);
__c__ImGui_ImplOpenGL3_CreateFontsTexture :: (ret: ^bool);
__c__ImGui_ImplOpenGL3_DestroyFontsTexture :: ();
__c__ImGui_ImplOpenGL3_CreateDeviceObjects :: (ret: ^bool);
__c__ImGui_ImplOpenGL3_DestroyDeviceObjects :: ();
__c__ImGui_ImplGlfw_InitForOpenGL :: (ret: ^bool, _window: ^GLFWwindow, _install_callbacks: bool);
__c__ImGui_ImplGlfw_InitForVulkan :: (ret: ^bool, _window: ^GLFWwindow, _install_callbacks: bool);
__c__ImGui_ImplGlfw_Shutdown :: ();
__c__ImGui_ImplGlfw_NewFrame :: ();
__c__ImGui_ImplGlfw_MouseButtonCallback :: (_window: ^GLFWwindow, _button: i32, _action: i32, _mods: i32);
__c__ImGui_ImplGlfw_ScrollCallback :: (_window: ^GLFWwindow, _xoffset: f64, _yoffset: f64);
__c__ImGui_ImplGlfw_KeyCallback :: (_window: ^GLFWwindow, _key: i32, _scancode: i32, _action: i32, _mods: i32);
__c__ImGui_ImplGlfw_CharCallback :: (_window: ^GLFWwindow, _c: u32);
