use import std.map

fmt :: import std.fmt
io  :: import std.io

use import ast
use import types
use import value
use import compiler

#export_scope

Scope :: struct {
    parent      : ^Scope
    constant    := false
    symbols     := Map[string, Symbol].new()
}

impl Scope {
    debug_log :: (&Self, msg: string, args: []^any = []) {
        // if const DEBUG_JOBS {
        //     str := fmt.format(msg, args)
        //     io.formatln("[{}] [Scope] {}", [Fiber.user_data(FiberContext).thread, str])
        // } 
    }

    define_value :: (&Self, name: string, typ: ^TypeInfo, val: Value) -> Result[(), ()] {
        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Val(typ, val)

        return Ok()
    }

    define_function :: (&Self, name: string, func: &AstFunction) -> Result[(), ()] {
        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Func(^func)

        return Ok()
    }

    define_decl :: (&Self, name: string, decl: &AstDecl) -> Result[(), ()] {
        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Decl(^decl)

        return Ok()
    }

    define_const_decl :: (&Self, name: string, decl: &AstConstDecl) -> Result[(), ()] {
        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.ConstDecl(^decl)

        return Ok()
    }

    define_native_function :: (&Self, name: string, wrapper: ^NativeFunctionWrapper) -> Result[(), ()] {
        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.NativeFunc(wrapper)

        return Ok()
    }

    get_symbol :: (&Self, name: string) -> Symbol {
        if parent == null {
            wait_until(symbols.contains(name), {
                return Symbol.NotFound
            })
            return symbols.at(name)
        }

        return match symbols.get(name) {
            Some($sym)  -> sym
            None        -> {
                sym := parent.get_symbol(name)
                if constant {
                    match &sym {
                        .Decl(_) -> {
                            return .Poison
                        }
                    }
                }
                return sym
            }
        }
    }
}

Symbol :: enum #copy {
    NotFound
    Poison
    Decl        : ^AstDecl
    ConstDecl   : ^AstConstDecl
    Val         : (typ: ^TypeInfo, value: Value)
    Func        : ^AstFunction
    NativeFunc  : ^NativeFunctionWrapper
}

#file_scope
