use import std.map
use import std.thread

fmt :: import std.fmt
io  :: import std.io

use import logging.logger

use import ast
use import types
use import value
use import compiler

#export_scope

Scope :: struct {
    parent      : ^Scope
    symbols     := Map[string, Symbol].new()
    mutex       := Option[Mutex].None

    // if true, this scope is for code executed at compile time
    // and thus can only access constant values from parent scopes
    constant    := false
}

impl Scope {
    debug_log :: (&Self, msg: string, args: []^any = []) {
        // if const DEBUG_JOBS {
        //     str := fmt.format(msg, args)
        //     io.formatln("[{}] [Scope] {}", [Fiber.user_data(FiberContext).thread, str])
        // } 
    }

    lock :: (&Self) {
        match &mutex {
            Some($m) -> {
                // g_logger.log("scope lock")
                m.lock()
            }
        }
    }

    release :: (&Self) {
        match &mutex {
            Some($m) -> {
                // g_logger.log("scope release")
                m.release()
            }
        }
    }

    define_value :: (&Self, name: string, typ: ^TypeInfo, val: Value) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Val(typ, val)

        return Ok()
    }

    define_function :: (&Self, name: string, func: &AstFunction) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Func(^*func)

        return Ok()
    }

    define_decl :: (&Self, name: string, decl: &AstDecl) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.Decl(^*decl)

        return Ok()
    }

    define_const_decl :: (&Self, name: string, decl: &AstConstDecl) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.ConstDecl(^*decl)

        return Ok()
    }

    define_native_function :: (&Self, name: string, wrapper: ^NativeFunctionWrapper) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = Symbol.NativeFunc(wrapper)

        return Ok()
    }

    define_symbol :: (&Self, name: string, symbol: Symbol) -> Result[(), ()] {
        self.lock()
        defer self.release()

        if symbols.contains(name) {
            return Err()
        }

        symbols[name] = symbol

        return Ok()
    }

    get_symbol :: (&Self, name: string, only_public: bool = false) -> Symbol {
        if parent == null {
            self.lock()
            defer self.release()

            wait_until(symbols.contains(name), {
                return Symbol.NotFound
            }, self.release(), self.lock())
            result := symbols.at(name)

            if only_public {
                match result {
                    .Decl($decl) if !(*decl).public -> {
                        return .Private(*decl)
                    }
                    .ConstDecl($decl) if !(*decl).public -> {
                        return .Private(*decl)
                    }
                }
            }

            return *result
        }

        @assert(self.mutex == .None)

        return match symbols.get(name) {
            Some($sym)  -> *sym
            None        -> {
                sym := parent.get_symbol(name)

                // if its a constant scope, you can't access variables from outside
                // @todo: actually you should be able to still access global variables
                if constant {
                    match &sym {
                        .Decl(_) -> {
                            return .Poison
                        }
                    }
                }

                return sym
            }
        }
    }
}

Symbol :: enum #copy {
    Poison
    NotFound
    Private         : ^AstNode
    Decl            : ^AstDecl
    ConstDecl       : ^AstConstDecl
    Val             : (typ: ^TypeInfo, value: Value)
    Func            : ^AstFunction
    NativeFunc      : ^NativeFunctionWrapper
    NativeFunc2     : NativeFunctionWrapper2
    StructMember    : ^TypeInfoStructMember
}

#file_scope
