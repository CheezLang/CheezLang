mem :: import std.mem.allocator
util :: import std.util

use import ast
use import compiler
use import interpreter

#export_scope

Value :: enum #copy {
    None
    Poison
    Function    : ^AstFunction
    Poly        : ^AstPoly
    Bool        : bool
    Int         : int
    Float       : f64
    String      : string
    NativeFunc  : ^NativeFunctionWrapper
    NativeFunc2 : (wrapper: NativeFunctionWrapper2, func: fn())
    Type        : ^TypeInfo
    Module      : ^SourceFile
}

NativeFunction :: Fn(^Interpreter)

NativeFunctionWrapper2 :: fn(fn(), ^Interpreter)

NativeFunctionWrapper :: struct {
    function            : NativeFunction
    function_type       : ^TypeInfoFunction
    arg_slots           : int
    parameter_indices   : []int
}

impl NativeFunctionWrapper {
    new :: (func: NativeFunction, $T: type) -> ^NativeFunctionWrapper {
        ti := cast(^TypeInfoFunction) @type_info(T)
        raw := mem.alloc_raw(u8, cast @sizeof(NativeFunctionWrapper) + ti.param_types.length * @sizeof(int))

        indices : []int = cast(^int) util.pointer_add(raw, @sizeof(NativeFunctionWrapper))
        indices.length = ti.param_types.length
        wrapper := cast(^NativeFunctionWrapper) raw

        slot_index := 0
        for(reverse=true) typ in ti.param_types {
            slot_index -= (typ.size + 7) / 8
            *indices[it_index_rev] = slot_index
        }

        *wrapper = NativeFunctionWrapper(
            function            = func
            function_type       = ti
            arg_slots           = -slot_index
            parameter_indices   = indices
        )
        return wrapper
    }

    slots_for_type :: (ti: ^TypeInfoFunction) -> int {
        slots := 0
        for(reverse=true) typ in ti.param_types {
            slots += (typ.size + 7) / 8
        }
        return slots
    }
}
