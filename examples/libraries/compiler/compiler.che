use import std.array
use import std.fiber
use import std.map
use import std.mem.std_heap_allocator
use import std.os.windows_constants
use import std.os.windows_functions
use import std.os.windows_types
use import std.rc
use import std.ring_queue
use import std.string
use import std.thread
use import std.time

mem :: import std.mem.allocator
C   :: import std.c
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import ast_dumper
use import bytecode_generator
use import config
use import error_handler
use import interpreter
use import jobs
use import lexer
use import parser
use import scope
use import string_database
use import value

enable_profiler :: false

#export_scope


wait_until :: (cond: Code) #macro {
    fiber_context := Fiber.user_data(FiberContext)
    fiber_context.job.progressed = true

    loop {
        if @insert(cond) then break
        if const DEBUG_WAIT then g_logger.log("[{}] [{}] suspending on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        Fiber.yield()
        if const DEBUG_WAIT then g_logger.log("[{}] [{}] resuming on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        fiber_context.job.progressed = false
    }
    if const DEBUG_WAIT then g_logger.log("[{}] [{}] done on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
    fiber_context.job.progressed = true
}

compile_files :: (files: []String) {
    g_logger.log("compile files: {}", [files])
    // Fiber.init()

    console_error_handler := ConsoleErrorHandler.new(null)

    compiler := Compiler.new(1, ^console_error_handler)
    compiler.get().global_scope.define_native_function("print", cast(NativeFunction) (interp, arg_count) => {
        frame := interp.top_frame()
        for 0..arg_count {
            val := frame.get_arg(it_index)
            g_logger.log("native print: {}", [val])
        }
    })

    for(by_ref=true) file : files {
        compiler.get().add_job(LoadFileJob.new(file.clone()))
    }

    start := get_time_milliseconds()
    compiler.get().start_compilation()
    compiler.get().wait_until_done()
    end := get_time_milliseconds()
    dur := end - start
    g_logger.log("Compilation took {} ms", [dur])
}

FiberContext :: struct {
    fiber   : ^Fiber
    interp  : ^Interpreter
    job     : ^CompilationJob = null
    thread  : int = -1
}

Compiler :: struct {
    jobs            := RingQueue[^CompilationJob].new()

    fibers          := Array[^FiberContext].create(1024)
    waiting_fibers  := RingQueue[^FiberContext].new()
    paused_fibers   := RingQueue[^FiberContext].new()
    any_progress    := false

    mutex           : Mutex
    threads         : Array[Thread]
    active_threads  := 0

    error_handler   : ^ErrorHandler
    string_database : StringDatabase

    global_scope    : ^Scope = null
    all_nodes       := Array[^AstNode].create()

    code_runner     : Rc[CodeRunner]

    // filename -> filecontent
    // contains all source files loaded during compilation
    sources         := Map[string, String].new()

    // allocators
    scope_allocator : ^mem.Allocator
    ast_allocator   : ^mem.Allocator
    bc_allocator    : ^mem.Allocator
}

impl Drop for Compiler {
    drop :: (&Self) {
        // for f : fibers {
        //     Memory.drop(f.fiber)
        // }
    }
}

impl TextProvider for Compiler {
    get_text :: (&Self, filename: string) -> string {
        return match self.sources.get(filename) {
            Some($content) -> content.slice()
            None -> @assert(false)
        }
    }
}

impl Compiler {
    new :: (thread_count: int, error_handler: ^ErrorHandler) -> Rc[Compiler] {
        scope_allocator     := mem.alloc(StdHeapAllocator)
        ast_allocator       := mem.alloc(StdHeapAllocator)
        bc_allocator        := mem.alloc(StdHeapAllocator)
        <<scope_allocator   = StdHeapAllocator()
        <<ast_allocator     = StdHeapAllocator()
        <<bc_allocator      = StdHeapAllocator()
        comp := Rc[Compiler].new(Compiler(
            mutex           = Mutex.new()
            threads         = Array[Thread].create()

            error_handler   = error_handler
            string_database = StringDatabase.new()

            code_runner     = Rc[CodeRunner].new(NormalCodeRunner())

            ast_allocator   = ast_allocator
            bc_allocator    = bc_allocator
            scope_allocator = scope_allocator
        ))
        comp.get().error_handler.text_provider = ^comp.get()
        comp.get().global_scope = comp.get().new_scope()
        for 0..thread_count {
            comp.get().threads.add(Thread.new(cast comp.get().thread_func))
        }
        return comp
    }

    lock :: (&Self) {
        if threads.get_length() > 1 then mutex.lock()
    }

    release :: (&Self) {
        if threads.get_length() > 1 then mutex.release()
    }

    add_job :: (&Self, job: $T) {
        ptr := mem.alloc(T)
        <<ptr = job
        ptr.compiler = ^self
        jobs.push(ptr)
    }

    run_job :: (&Self, context: ^FiberContext) {
        context.job.execute(self)
    }

    new_scope :: (&Self, parent: ^Scope = null) -> ^Scope {
        scope := mem.alloc(Scope, scope_allocator)
        <<scope = Scope(
            parent = parent
        )
        return scope
    }
}

impl Compiler {
    start_compilation :: (&Self) {
        for threads {
            it.start()
        }
    }

    wait_until_done :: (&Self) {
        handles := mem.alloc_raw(HANDLE, cast threads.get_length())

        for threads {
            handles[it_index] = it.data.handle
        }
        WaitForMultipleObjects(cast threads.get_length(), handles, 1, INFINITE)

        if paused_fibers.count() > 0 {
            error_handler.report_error("Failed to compile. {} fibers are still waiting", [paused_fibers.count()])
        }

        g_logger.log("[compiler] finished compilation with {} fibers", [fibers.get_length()])
    }

    find_free_fiber :: (&Self) -> ^FiberContext {
        for f : fibers {
            if f.job == null and f.thread == -1 {
                return f
            }
        }
        {
            new_fiber := mem.alloc(FiberContext)
            <<new_fiber = FiberContext(
                fiber   = Fiber.new(cast(Fn(^FiberContext)) self.fiber_func, new_fiber)
                interp  = Interpreter.new()
            )
            fibers.add(new_fiber)
            return new_fiber
        }
    }

    fiber_func :: (&Self, fiber_context: ^FiberContext) {
        while true {
            while fiber_context.job == null {
                Fiber.yield()
            }

            fiber_context.job.progressed = false
            self.run_job(fiber_context)
            fiber_context.job.done = true
            fiber_context.job = null
        }
    }

    thread_func :: (&Self) {
        Fiber.init()
        thread_id := Thread.current().id

        current_fiber : ^FiberContext = null
        while true #label main_loop {
            {
                self.lock()
                defer self.release()

                active_threads -= 1

                // if fiber made progress or finished, move all stuff from q2 to q
                if current_fiber != null {
                    current_fiber.thread = -1

                    // done or progressed
                    if current_fiber.job == null or current_fiber.job.progressed {
                        any_progress = true
                        while self.paused_fibers.count() > 0 {
                            self.waiting_fibers.push(self.paused_fibers.pop())
                        }
                        any_progress = false
                    }

                    if current_fiber.job != null {
                        self.paused_fibers.push(current_fiber)
                    }

                    current_fiber = null
                }

                // no waiting fibers
                if self.waiting_fibers.count() == 0 {
                    if self.jobs.count() > 0 {
                        job := self.jobs.pop()
                        fiber := self.find_free_fiber()
                        fiber.job = job
                        self.waiting_fibers.push(fiber)

                    /*
                    } else if self.paused_fibers.count() > 0 {
                        if self.active_threads > 0 then continue

                        // if all fibers are paused and we didn't make any progress
                        // then we're done
                        if !any_progress then break main_loop
                        self.waiting_fibers.push(self.paused_fibers.pop())
                    // */

                    } else {
                        if self.active_threads > 0 then continue
                        break main_loop
                    }
                }

                current_fiber = self.waiting_fibers.pop()
                current_fiber.thread = thread_id
                active_threads += 1
            }

            current_fiber.fiber.resume()
        }
    }
}
