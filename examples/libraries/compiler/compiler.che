use import std.array
use import std.fiber
use import std.map
use import std.mem.arena_allocator
use import std.mem.bump_allocator
use import std.mem.std_heap_allocator
use import std.os.windows_constants
use import std.os.windows_functions
use import std.os.windows_types
use import std.printable
use import std.rc
use import std.ring_queue
use import std.string
use import std.thread
use import std.time

mem :: import std.mem.allocator
C   :: import std.c
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import ast_dumper
use import bytecode_generator
use import config
use import error_handler
use import interpreter
use import jobs
use import lexer
use import parser
use import scope
use import string_database
use import value

enable_profiler :: false

#export_scope


wait_until :: (cond: Code, on_error: Code, on_yield: Code = {}, on_resume: Code = {}) #macro {
    fiber_context := Fiber.user_data(FiberContext)
    fiber_context.job.progressed = true

    loop {
        if @insert(cond) then break
        if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] suspending on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        @insert(on_yield)
        Fiber.yield()
        @insert(on_resume)
        if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] resuming on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        fiber_context.job.progressed = false

        if fiber_context.job.cancelled {
            @insert(on_error)
            loop Fiber.yield()
        }
    }
    if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] done on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
    fiber_context.job.progressed = true
}

compile_files :: (files: []String, thread_count: int) {
    console_error_handler := ConsoleErrorHandler.new(null)

    g_logger.log("compile files: {}", [files])

    if thread_count < 1 or thread_count > 32 {
        console_error_handler.report_error("Invalid thread_count: {}", [thread_count])
        return
    }

    compiler := Compiler.new(thread_count, ^console_error_handler)
    compiler.get().global_scope.define_native_function("print_string", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, string)])
        io.set_console_color(.White, .Black)
    }, fn(string)))
    compiler.get().global_scope.define_native_function("print_int", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, int)])
        io.set_console_color(.White, .Black)
    }, fn(int)))
    compiler.get().global_scope.define_native_function("print_float", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, f64)])
        io.set_console_color(.White, .Black)
    }, fn(f64)))
    compiler.get().global_scope.define_native_function("print_array", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, [3]int)])
        io.set_console_color(.White, .Black)
    }, fn([3]int)))
    compiler.get().global_scope.define_native_function("print", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, ^any)])
        io.set_console_color(.White, .Black)
    }, fn(^any)))

    compiler.get().global_scope.define_native_function("debugbreak", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {},
        fn())
    )

    for(by_ref=true) file : files {
        compiler.get().add_job(LoadFileJob.new(file.clone()))
    }

    start := get_time_milliseconds()
    compiler.get().start_compilation()
    compiler.get().wait_until_done()
    end := get_time_milliseconds()
    dur := end - start
    g_logger.log("[Compiler] Compilation took {} ms", [dur])
}

FiberContext :: struct {
    fiber   : ^Fiber
    interp  : ^Interpreter
    job     : ^CompilationJob = null
    thread  : int = -1
}

Compiler :: struct {
    jobs            := RingQueue[^CompilationJob].new()

    fibers          := Array[^FiberContext].create(1024)
    ready_fibers    := RingQueue[^FiberContext].new()
    waiting_fibers  := RingQueue[^FiberContext].new()
    any_progress    := false

    mutex           : Mutex
    threads         : Array[Thread]
    active_threads  := 0

    error_handler   : ^ErrorHandler
    string_database : StringDatabase

    global_scope    : ^Scope = null
    all_nodes       := Array[^AstNode].create()

    code_runner     : Rc[CodeRunner]

    // filename -> filecontent
    // contains all source files loaded during compilation
    sources         := Map[string, String].new()
    next_ast_id     := 1

    // allocators
    ast_allocator   : ^mem.Allocator
    bc_allocator    : ^mem.Allocator
    job_allocator   : ^mem.Allocator
    scope_allocator : ^mem.Allocator
    type_allocator  : ^mem.Allocator
}

impl Drop for Compiler {
    drop :: (&Self) {
        // for f : fibers {
        //     Memory.drop(f.fiber)
        // }
    }
}

impl TextProvider for Compiler {
    get_text :: (&Self, filename: string) -> string {
        // for s : self.sources {
        //     g_logger.log("{}", [s.name])
        // }
        return match self.sources.get(filename) {
            Some($content) -> content.slice()
            None -> @assert(false)
        }
    }
}

impl Compiler {
    new :: (thread_count: int, error_handler: ^ErrorHandler) -> Rc[Compiler] {
        AllocatorType :: BumpAllocator
        ast_allocator       := mem.alloc(AllocatorType)
        bc_allocator        := mem.alloc(AllocatorType)
        job_allocator       := mem.alloc(AllocatorType)
        scope_allocator     := mem.alloc(AllocatorType)
        type_allocator      := mem.alloc(AllocatorType)

        <<ast_allocator     = AllocatorType.new(1024 * 1024 * 10)   // 10 Mb
        <<bc_allocator      = AllocatorType.new(1024 * 1024 * 10)   // 10 Mb
        <<job_allocator     = AllocatorType.new(1024 * 1024 * 1)    //  1 Mb
        <<scope_allocator   = AllocatorType.new(1024 * 1024 * 10)   // 10 Mb
        <<type_allocator    = AllocatorType.new(1024 * 1024 * 1)    //  1 Mb

        comp := Rc[Compiler].new(Compiler(
            mutex           = Mutex.new()
            threads         = Array[Thread].create()

            error_handler   = error_handler
            string_database = StringDatabase.new()

            code_runner     = Rc[CodeRunner].new(DefaultCodeRunner())

            ast_allocator   = ast_allocator
            bc_allocator    = bc_allocator
            job_allocator   = job_allocator
            scope_allocator = scope_allocator
            type_allocator  = type_allocator
        ))
        comp.get().error_handler.text_provider = ^comp.get()
        comp.get().global_scope = comp.get().new_scope()
        comp.get().define_builtin_types(<<comp.get().global_scope)

        // create mutex for global scope if thread_count > 1
        if thread_count > 0 {
            comp.get().global_scope.mutex = Some(Mutex.new())
        }

        for 0..thread_count {
            comp.get().threads.add(Thread.new(cast comp.get().thread_func))
        }
        return comp
    }

    define_builtin_types :: (&Self, scope: &Scope) {
        // ints
        scope.define_value("u8",  @type_info(type), .Type(@type_info(u8)))
        scope.define_value("u16", @type_info(type), .Type(@type_info(u16)))
        scope.define_value("u32", @type_info(type), .Type(@type_info(u32)))
        scope.define_value("u64", @type_info(type), .Type(@type_info(u64)))
        scope.define_value("i8",  @type_info(type), .Type(@type_info(i8)))
        scope.define_value("i16", @type_info(type), .Type(@type_info(i16)))
        scope.define_value("i32", @type_info(type), .Type(@type_info(i32)))
        scope.define_value("i64", @type_info(type), .Type(@type_info(i64)))

        // floats
        scope.define_value("f32", @type_info(type), .Type(@type_info(f32)))
        scope.define_value("f64", @type_info(type), .Type(@type_info(f64)))

        // chars
        scope.define_value("char8",  @type_info(type), .Type(@type_info(char8)))
        scope.define_value("char16", @type_info(type), .Type(@type_info(char16)))
        scope.define_value("char32", @type_info(type), .Type(@type_info(char32)))

        // other
        scope.define_value("bool", @type_info(type), .Type(@type_info(bool)))
        scope.define_value("string", @type_info(type), .Type(@type_info(string)))
        scope.define_value("void", @type_info(type), .Type(@type_info(void)))
        scope.define_value("type", @type_info(type), .Type(@type_info(type)))

        // defaults
        scope.define_value("int", @type_info(type), .Type(@type_info(int)))
        scope.define_value("float", @type_info(type), .Type(@type_info(float)))
        scope.define_value("char", @type_info(type), .Type(@type_info(char)))
    }

    lock :: (&Self) {
        if threads.get_length() > 1 then mutex.lock()
    }

    release :: (&Self) {
        if threads.get_length() > 1 then mutex.release()
    }

    add_job :: (&Self, job: $T) {
        self.lock()
        defer self.release()

        ptr := mem.alloc(T, job_allocator)
        <<ptr = job
        ptr.compiler = ^self
        jobs.push(ptr)
    }

    run_job :: (&Self, context: ^FiberContext) {
        context.job.execute()
    }

    new_scope :: (&Self, parent: ^Scope = null, constant: bool = false) -> ^Scope {
        self.lock()
        defer self.release()

        scope := mem.alloc(Scope, scope_allocator)
        <<scope = Scope(
            parent      = parent
            constant    = constant
        )
        return scope
    }

    new_type :: (&Self, type_info: $T) -> ^T {
        self.lock()
        defer self.release()

        result := mem.alloc(T, type_allocator)
        <<result = type_info
        return result
    }

    new_ast :: (&Self, ast: $T) -> ^T {
        self.lock()
        defer self.release()

        result := mem.alloc(T, ast_allocator)
        <<result = ast
        result.id = next_ast_id
        next_ast_id += 1
        return result
    }
}

impl Compiler {
    start_compilation :: (&Self) {
        for threads {
            it.start()
        }
    }

    on_done :: (&Self, callback: Fn()) {
        Data :: struct {
            thread      : Thread
            callback    : Fn()
            compiler    : ^Compiler
        }
        thread_func :: (data: ^Data) {
            data.compiler.wait_for_threads()

            g_logger.log("on_done: Done waiting for all threads")
            data.callback()

            Memory.drop(<<data)
            mem.free(data)
        }

        data := mem.alloc(Data)
        t := Thread.create(cast(Fn(^Data)) thread_func, data)
        <<data = Data(
            thread      = t
            callback    = callback
            compiler    = ^self
        )
        data.thread.start()
    }

    wait_for_threads :: (&Self) {
        handles := mem.alloc_raw(HANDLE, cast threads.get_length())

        for threads {
            handles[it_index] = it.data.handle
        }
        WaitForMultipleObjects(cast threads.get_length(), handles, 1, INFINITE)
    }

    wait_until_done :: (&Self) {
        wait_for_threads()
        if waiting_fibers.count() > 0 {
            error_handler.report_error("[Compile] {} fibers were still waiting", [waiting_fibers.count()])
        }

        g_logger.log("[Compiler] finished compilation with {} fibers", [fibers.get_length()])
    }

    find_free_fiber :: (&Self) -> ^FiberContext {
        for f : fibers {
            if f.job == null and f.thread == -1 {
                return f
            }
        }
        {
            new_fiber := mem.alloc(FiberContext)
            <<new_fiber = FiberContext(
                fiber   = Fiber.new(cast(Fn(^FiberContext)) self.fiber_func, new_fiber)
                interp  = Interpreter.new(error_handler)
            )
            fibers.add(new_fiber)
            return new_fiber
        }
    }

    fiber_func :: (&Self, fiber_context: ^FiberContext) {
        while true {
            while fiber_context.job == null {
                Fiber.yield()
            }

            fiber_context.job.progressed = false
            self.run_job(fiber_context)
            fiber_context.job.done = true
            fiber_context.job = null
        }
    }

    thread_func :: (&Self) {
        Fiber.init()
        thread_id := Thread.current().id

        current_fiber : ^FiberContext = null
        while true #label main_loop {
            {
                // g_logger.log("[{}] waiting for lock", [active_threads])
                self.lock()
                defer self.release()
                // g_logger.log("[{}] got lock", [active_threads])

                // if fiber made progress or finished, move all stuff from q2 to q
                if current_fiber != null {
                    active_threads -= 1
                    current_fiber.thread = -1

                    // done or progressed
                    if current_fiber.job == null or current_fiber.job.progressed {
                        any_progress = true
                        while self.waiting_fibers.count() > 0 {
                            self.ready_fibers.push(self.waiting_fibers.pop())
                        }
                        any_progress = false
                    }

                    if current_fiber.job != null {
                        self.waiting_fibers.push(current_fiber)
                    }

                    current_fiber = null
                }

                // no ready fibers
                if self.ready_fibers.count() == 0 {
                    if self.jobs.count() > 0 {
                        job := self.jobs.pop()
                        fiber := self.find_free_fiber()
                        fiber.job = job
                        self.ready_fibers.push(fiber)

                    // this doesn't work right now
                    /*
                    } else if self.waiting_fibers.count() > 0 {
                        if self.active_threads > 0 then continue

                        // if all fibers are paused and we didn't make any progress
                        // then we're done
                        if !any_progress then break main_loop
                        self.ready_fibers.push(self.waiting_fibers.pop())
                    // */

                    } else {
                        if self.active_threads > 0 then continue
                        
                        // g_logger.log("[{}] exit thread", [active_threads])
                        break main_loop
                    }
                }

                current_fiber = self.ready_fibers.pop()
                current_fiber.thread = thread_id
                active_threads += 1
            }

            // g_logger.log("[{}] resuming fiber", [active_threads])
            current_fiber.fiber.resume()
        }

        // cancel all fibers
        self.lock()
        defer self.release()
        for fib : waiting_fibers {
            if fib.job != null {
                fib.job.cancelled = true
                fib.fiber.resume()
            }
        }
    }
}
