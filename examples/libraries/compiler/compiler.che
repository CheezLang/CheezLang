use import std.array
use import std.fiber
use import std.hash
use import std.map
use import std.mem.arena_allocator
use import std.mem.bump_allocator
use import std.mem.std_heap_allocator
use import std.os.windows_constants
use import std.os.windows_functions
use import std.os.windows_types
use import std.printable
use import std.rc
use import std.ring_queue
use import std.string
use import std.thread
use import std.time

mem :: import std.mem.allocator
C   :: import std.c
io  :: import std.io
fmt :: import std.fmt
fs  :: import std.io.fs

use import logging.logger

use import ast
use import ast_dumper
use import bytecode_generator
use import config
use import error_handler
use import interpreter
use import jobs
use import lexer
use import parser
use import scope
use import string_database
use import types
use import value

enable_profiler :: false

#export_scope


wait_until :: (cond: Code, on_error: Code, on_yield: Code = {}, on_resume: Code = {}) #macro {
    fiber_context := Fiber.user_data(FiberContext)
    fiber_context.job.progressed = true

    loop {
        if @insert(cond) then break
        if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] suspending on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        
        @insert(on_yield)
        Fiber.yield()
        @insert(on_resume)
        if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] resuming on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
        fiber_context.job.progressed = false

        if fiber_context.job.cancelled {
            @insert(on_error)
            loop Fiber.yield()
        }
    }
    if const DEBUG_ENABLED then if DEBUG_WAIT then g_logger.log("[{}] [{}] done on {}", [fiber_context.thread, fiber_context.job.get_name(), @expr_to_string(@insert(cond))])
    fiber_context.job.progressed = true
}

compile_files :: (files: []String, thread_count: int) {
    console_error_handler := ConsoleErrorHandler.new(null)

    g_logger.log("compile files: {}", [files])

    if thread_count < 1 or thread_count > 32 {
        console_error_handler.report_error("Invalid thread_count: {}", [thread_count])
        return
    }

    compiler := Compiler.new(thread_count, ^console_error_handler)
    main_workspace := compiler.get().get_main_workspace()

    main_workspace.get().global_scope.define_native_function("get_compiler", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        frame.set_return(g_compiler)
    }, fn() -> ^Compiler))

    main_workspace.get().global_scope.define_native_function("print_string", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, string)])
        io.set_console_color(.White, .Black)
    }, fn(string)))
    main_workspace.get().global_scope.define_native_function("print_int", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, int)])
        io.set_console_color(.White, .Black)
    }, fn(int)))
    main_workspace.get().global_scope.define_native_function("print_float", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, f64)])
        io.set_console_color(.White, .Black)
    }, fn(f64)))
    main_workspace.get().global_scope.define_native_function("print_bool", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, bool)])
        io.set_console_color(.White, .Black)
    }, fn(bool)))
    main_workspace.get().global_scope.define_native_function("print_array", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
        frame := interp.top_frame()
        io.set_console_color(.Green, .Black)
        io.formatln("{}", [frame.get_arg(0, [3]int)])
        io.set_console_color(.White, .Black)
    }, fn([3]int)))
    // main_workspace.get().global_scope.define_native_function("print", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
    //     frame := interp.top_frame()
    //     io.set_console_color(.Green, .Black)
    //     io.formatln("{}", [frame.get_arg(0, ^any)])
    //     io.set_console_color(.White, .Black)
    // }, fn(^any)))

    main_workspace.get().global_scope.define_native_function("debugbreak", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {},
        fn())
    )

    // strings
    main_workspace.get().global_scope.define_native_function("new_string", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {
            frame := interp.top_frame()
            str := mem.alloc(String)
            *str = String.empty()
            frame.set_return(str)
        },
        fn() -> ^String)
    )
    main_workspace.get().global_scope.define_native_function("append_string", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {
            frame := interp.top_frame()
            str := frame.get_arg(0, ^String)
            value := frame.get_arg(1, string)
            str.append_string(value)
        },
        fn(^String, string))
    )
    main_workspace.get().global_scope.define_native_function("print", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {
            frame := interp.top_frame()
            str := frame.get_arg(0, ^String)
            io.set_console_color(.Green, .Black)
            io.formatln("{}", [str.slice()])
            io.set_console_color(.White, .Black)
        },
        fn(^String))
    )
    main_workspace.get().global_scope.define_native_function("slice", NativeFunctionWrapper.new(
        cast(NativeFunction) (interp) => {
            frame := interp.top_frame()
            str := frame.get_arg(0, ^String)
            frame.set_return(str.slice())
        },
        fn(^String) -> string)
    )
    
    for(by_ref=true) file in files {
        main_workspace.get().create_and_add_job(LoadFileJob.new(file.clone()))
    }

    start := get_time_milliseconds()
    compiler.get().start_compilation()
    compiler.get().wait_until_done()
    end := get_time_milliseconds()
    dur := end - start
    g_logger.log("[Compiler] Compilation took {} ms", [dur])
}

FiberContext :: struct {
    fiber   : ^Fiber
    interp  : ^Interpreter
    job     : ^CompilationJob = null
    thread  : int = -1
}


FunctionTypeWrapper :: struct #copy {
    typ : ^TypeInfoFunction
}

impl Hashable for FunctionTypeWrapper {
    hash :: (&Self) -> uint {
        return @bin_xor(uint(typ.param_types.length) * 987654321, 0x268af332e)
    }
}

impl Equatable[FunctionTypeWrapper] for FunctionTypeWrapper {
    equal :: (&Self, other: &FunctionTypeWrapper) -> bool {
        return TypeInfo.same(typ, other.typ)
    }
}

Workspace :: struct {
    id              : int
    _compiler       : ^void
    jobs            := RingQueue[^CompilationJob].new()

    mutex           : Mutex
    mutex_ast       : Mutex
    mutex_bc        : Mutex
    mutex_job       : Mutex
    mutex_scope     : Mutex
    mutex_type      : Mutex

    error_handler   : ^ErrorHandler
    string_database : StringDatabase

    global_scope    : ^Scope = null
    all_nodes       := Array[^AstNode].create()

    code_runner     : Rc[CodeRunner]

    structs         := Map[int, ^AstStruct].new()
    structs_mutex   := Mutex.new()

    string_sources_file := String.empty()
    string_location := Location(line=1, column=1)

    // filename -> filecontent
    // contains all source files loaded during compilation
    sources         := Map[string, bool].new()

    native_function_wrappers := Map[FunctionTypeWrapper, NativeFunctionWrapper2].new()

    next_ast_id     := 1

    // allocators
    ast_allocator   : ^mem.Allocator
    bc_allocator    : ^mem.Allocator
    job_allocator   : ^mem.Allocator
    scope_allocator : ^mem.Allocator
    type_allocator  : ^mem.Allocator
}

impl Workspace {
    new :: (id: int, compiler: &Compiler, error_handler: ^ErrorHandler, create_mutexes: bool) -> Rc[Workspace] {
        AllocatorType :: BumpAllocator
        create_allocator :: (size: uint) -> ^mem.Allocator {
            allocator := mem.alloc(AllocatorType)
            *allocator = AllocatorType.new(size)
            return allocator
        }

        workspace := Rc[Workspace].new(Workspace(
            id              = id
            _compiler       = ^*compiler

            mutex           = Mutex.new()
            mutex_ast       = Mutex.new()
            mutex_bc        = Mutex.new()
            mutex_job       = Mutex.new()
            mutex_scope     = Mutex.new()
            mutex_type      = Mutex.new()

            string_database = StringDatabase.new()
            error_handler   = PrefixErrorHandler.new(&*error_handler, fmt.format("Workspace #{}", [id]))

            code_runner     = Rc[CodeRunner].new(DefaultCodeRunner())

            ast_allocator   = create_allocator(0x1000) // 4 Kb
            bc_allocator    = create_allocator(0x1000) // 4 Kb
            job_allocator   = create_allocator(0x1000) // 4 Kb
            scope_allocator = create_allocator(0x1000) // 4 Kb
            type_allocator  = create_allocator(0x1000) // 4 Kb
        ))

        workspace.get().global_scope = workspace.get().new_scope()
        workspace.get().define_builtin_types(&*workspace.get().global_scope)

        // @todo: make these paths not absolute and include workspace id or name
        string_sources_file := fmt.format("d:\dev\CheezLang\gen\int\string_sources_{}.che", [id])
        workspace.get().string_sources_file = match fs.get_full_path(string_sources_file.slice()) {
            Ok($path) -> path
            Err(_) -> string_sources_file.clone()
        }
        compiler.sources.set(workspace.get().string_sources_file.slice(), "".to_owned())
        workspace.get().string_location.file = workspace.get().string_sources_file.slice()
        fs.write_file(workspace.get().string_sources_file.slice(), "")

        // create mutex for global scope if thread_count > 1
        if create_mutexes {
            workspace.get().global_scope.mutex = Some(Mutex.new())
        }

        return workspace
    }

    get_compiler :: (&Self) -> &Compiler {
        return &*cast(^Compiler)_compiler
    }

    add_load_file_job :: (&Self, filename: string) -> ^CompilationJob {
        _ := add_load_file_job
        return create_and_add_job(LoadFileJob.new(filename.to_owned()))
    }

    define_builtin_types :: (&Self, scope: &Scope) {
        // ints
        scope.define_value("u8",  @type_info(type), .Type(@type_info(u8)))
        scope.define_value("u16", @type_info(type), .Type(@type_info(u16)))
        scope.define_value("u32", @type_info(type), .Type(@type_info(u32)))
        scope.define_value("u64", @type_info(type), .Type(@type_info(u64)))
        scope.define_value("i8",  @type_info(type), .Type(@type_info(i8)))
        scope.define_value("i16", @type_info(type), .Type(@type_info(i16)))
        scope.define_value("i32", @type_info(type), .Type(@type_info(i32)))
        scope.define_value("i64", @type_info(type), .Type(@type_info(i64)))

        // floats
        scope.define_value("f32", @type_info(type), .Type(@type_info(f32)))
        scope.define_value("f64", @type_info(type), .Type(@type_info(f64)))

        // chars
        scope.define_value("char8",  @type_info(type), .Type(@type_info(char8)))
        scope.define_value("char16", @type_info(type), .Type(@type_info(char16)))
        scope.define_value("char32", @type_info(type), .Type(@type_info(char32)))

        // other
        scope.define_value("bool", @type_info(type), .Type(@type_info(bool)))
        scope.define_value("string", @type_info(type), .Type(@type_info(string)))
        scope.define_value("void", @type_info(type), .Type(@type_info(void)))
        scope.define_value("type", @type_info(type), .Type(@type_info(type)))

        // defaults
        scope.define_value("int", @type_info(type), .Type(@type_info(int)))
        scope.define_value("float", @type_info(type), .Type(@type_info(float)))
        scope.define_value("char", @type_info(type), .Type(@type_info(char)))

        // structs
        scope.define_value("String", @type_info(type), .Type(@type_info(String)))

        // temp
        register_native_function_type(fn(^String))
        register_native_function_type(fn(^String, string) -> ^String)
        register_native_function_type(fn(^Compiler) -> ^Workspace)
        register_native_function_type(fn(^Workspace, string) -> ^CompilationJob)
    }

    lock :: (&Self, mutex: &Mutex) {
        mutex.lock()
    }

    release :: (&Self, mutex: &Mutex) {
        mutex.release()
    }

    add_string_source :: (&Self, content: string) -> Rc[Lexer] {
        self.lock(&mutex)
        defer self.release(&mutex)

        string_sources := get_compiler().sources[string_sources_file.slice()]
        string_sources.append_string(content)
        fs.append_file(string_sources_file.slice(), content)

        lexer := Lexer.from_string(content, &string_database)
        lexer.get().location = string_location
        lexer.get().offset = string_location.byte_index
        string_location.byte_index = string_sources.get_length()
        string_location.line += content.count_char('`n')
        string_location.column = 1

        return lexer
    }

    register_struct :: (&Self, typ: ^TypeInfoStruct, ast: ^AstStruct) {
        self.lock(&mutex)
        defer self.release(&mutex)

        structs[int(typ)] = ast
    }

    get_struct_ast :: (&Self, typ: ^TypeInfoStruct) -> Option[^AstStruct] {
        self.lock(&mutex)
        defer self.release(&mutex)

        return match structs.get(int(typ)) {
            Some($ast) -> Some(*ast)
            None -> None
        }
    }

    create_and_add_job :: (&Self, job: $T) -> ^CompilationJob {
        job_ptr := create_job(job)
        add_job(job_ptr)
        return job_ptr
    }

    create_job :: (&Self, job: $T) -> ^CompilationJob {
        self.lock(&mutex_job)
        defer self.release(&mutex_job)

        ptr := mem.alloc(T, job_allocator)
        *ptr = job
        ptr.compiler = ^*get_compiler()
        ptr.workspace = ^*self
        return ptr
    }

    add_job :: (&Self, job: ^CompilationJob) {
        self.lock(&mutex_job)
        defer self.release(&mutex_job)
        jobs.push(job)
    }

    run_job :: (&Self, context: ^FiberContext) {
        context.job.execute()
    }

    new_scope :: (&Self, parent: ^Scope = null, constant: bool = false) -> ^Scope {
        self.lock(&mutex_scope)
        defer self.release(&mutex_scope)

        scope := mem.alloc(Scope, scope_allocator)
        *scope = Scope(
            parent      = parent
            constant    = constant
        )
        return scope
    }

    new_type :: (&Self, type_info: $T) -> ^T {
        self.lock(&mutex_type)
        defer self.release(&mutex_type)

        result := mem.alloc(T, type_allocator)
        *result = type_info
        return result
    }

    poly_type :: (&Self) -> ^TypeInfo {
        typ := self.new_type(TypeInfoPoly(
            size        = 0
            alignment   = 1
            impl_funcs  = []
            traits      = []
        ))

        return typ
    }

    pointer_type :: (&Self, target: ^TypeInfo, mutable: bool) -> ^TypeInfo {
        size := match target {
            TypeInfoTrait(_) -> 16
            TypeInfoAny(_) -> 24
        }
        typ := self.new_type(TypeInfoPointer(
            size        = size
            alignment   = 8
            impl_funcs  = []
            traits      = []
            target      = target
            is_mut      = mutable
            is_fat      = size > 8
        ))

        return typ
    }

    reference_type :: (&Self, target: ^TypeInfo, mutable: bool) -> ^TypeInfo {
        size := match target {
            TypeInfoTrait(_) -> 16
            TypeInfoAny(_) -> 24
        }
        typ := self.new_type(TypeInfoReference(
            size        = size
            alignment   = 8
            impl_funcs  = []
            traits      = []
            target      = target
            is_mut      = mutable
            is_fat      = size > 8
        ))

        return typ
    }

    new_type_data_array :: (&Self, $T: type, count: int) -> []T {
        self.lock(&mutex_type)
        defer self.release(&mutex_type)

        result := mem.alloc_n(T, cast count, type_allocator)
        C.memset(result.data, 0, cast @sizeof(T) * count)
        return result
    }

    new_ast :: (&Self, ast: $T) -> ^T {
        self.lock(&mutex_ast)
        defer self.release(&mutex_ast)

        result := mem.alloc(T, ast_allocator)
        *result = ast
        result.id = next_ast_id
        next_ast_id += 1
        return result
    }

    register_native_function_type :: (&Self, $FuncType: type) {
        self.lock(&mutex)
        defer self.release(&mutex)

        helper :: (func: fn(), interp: ^Interpreter) {
            frame := interp.top_frame()
            ArgTupleType :: @param_type_tuple(FuncType)
            slots : [(@sizeof(ArgTupleType) + 7) / 8]u64 = default
            args := &*cast(^ArgTupleType)slots.data
            index := 0
            @for_function_parameters(FuncType, (ArgType, i) => {
                // args[i] = frame.get(index, ArgType)
                ptr := cast(^ArgType)^args[i]
                *ptr = frame.get(i, ArgType)
                // io.formatln("{} : {} = {}", [i, @typename(ArgType), args[i]])

                index += (@sizeof(ArgType) + 7) / 8
            })

            if const FuncType.return_type == void {
                @call_with_tuple_args(cast(FuncType) func, args)
            } else {
                result := @call_with_tuple_args(cast(FuncType) func, args)
                frame.set_return(result)
            }
        }

        type_wrapper := match @type_info(FuncType) {
            TypeInfoFunction($ti) -> FunctionTypeWrapper(ti)
            _ -> {
                return
            }
        }

        h := helper
        if !native_function_wrappers.contains(type_wrapper) {
            native_function_wrappers[type_wrapper] = helper
        }
    }

    get_native_function_wrapper :: (&Self, ti: ^TypeInfoFunction) -> Option[NativeFunctionWrapper2] {
        self.lock(&mutex)
        defer self.release(&mutex)

        return match native_function_wrappers.get(FunctionTypeWrapper(ti)) {
            Some($wrapper) -> Some(*wrapper)
            None -> None
        }
    }
}

g_compiler : ^Compiler = null
Compiler :: struct {
    // there is a weird bug where the pointer to the  debug adapter at some point changes to point to the compiler
    // and thus overrides variables of the compiler
    // so put this dummy memory here so that if that happens
    // the state of the compiler is "protected"
    dummy           : [1024]u8 = default

    workspaces      := Array[Rc[Workspace]].create()

    fibers          := Array[^FiberContext].create(1024)
    ready_fibers    := RingQueue[^FiberContext].new(10)
    waiting_fibers  := RingQueue[^FiberContext].new(10)
    any_progress    := false

    mutex           : Mutex
    threads         : Array[Thread]
    active_threads  := 0

    global_error_handler : ^ErrorHandler

    code_runner     : Rc[CodeRunner]

    // filename -> filecontent
    // contains all source files loaded during compilation
    sources         := Map[string, String].new()
}

impl Drop for Compiler {
    drop :: (&Self) {
        // for f in fibers {
        //     Memory.drop(f.fiber)
        // }
    }
}

impl TextProvider for Compiler {
    get_text :: (&Self, filename: string) -> string {
        // for s in self.sources {
        //     g_logger.log("{}", [s.name])
        // }
        return match self.sources.get(filename) {
            Some($content) -> content.slice()
            None -> @assert(false)
        }
    }
}

impl Compiler {
    new :: (thread_count: int, error_handler: ^ErrorHandler) -> Rc[Compiler] {
        comp := Rc[Compiler].new(Compiler(
            mutex           = Mutex.new()
            threads         = Array[Thread].create()

            global_error_handler = error_handler

            code_runner     = Rc[CodeRunner].new(DefaultCodeRunner())
        ))
        g_compiler = ^*comp.get()
        comp.get().global_error_handler.text_provider = ^*comp.get()


        // create main workspace
        comp.get().workspaces.add(Workspace.new(0, comp.get(), error_handler, thread_count > 0))

        for 0..thread_count {
            comp.get().threads.add(Thread.new(cast comp.get().thread_func))
        }
        return comp
    }

    lock :: (&Self) {
        if threads.get_length() > 1 then mutex.lock()
    }

    release :: (&Self) {
        if threads.get_length() > 1 then mutex.release()
    }

    run_job :: (&Self, context: ^FiberContext) {
        context.job.execute()
    }

    get_main_workspace :: (&Self) -> Rc[Workspace] {
        return workspaces[0].clone()
    }

    get_source :: (&Self, path: string) -> string {
        self.lock()
        defer self.release()
        
        if !sources.contains(path) {
            content := fs.read_file(path)
            return match content {
                Ok($content) -> {
                    result := content.slice()
                    sources.set(path, content)
                    result
                }

                Err($msg) -> {
                    global_error_handler.report_error("Failed to load file '{}'", [path])
                    sources.set(path, "".to_owned())
                    ""
                }
            }
        }

        return sources[path].slice()
    }

    create_workspace :: (&Self) -> ^Workspace {
        _ := create_workspace
        workspaces.add(Workspace.new(workspaces.count(), self, global_error_handler, threads.count() > 0))
        

        workspaces.peek_last().get().global_scope.define_native_function("print_string", NativeFunctionWrapper.new(cast(NativeFunction) (interp) => {
            frame := interp.top_frame()
            io.set_console_color(.Green, .Black)
            io.formatln("{}", [frame.get_arg(0, string)])
            io.set_console_color(.White, .Black)
        }, fn(string)))
        return ^*workspaces.peek_last().get()
    }
}

impl Compiler {
    start_compilation :: (&Self) {
        for &threads {
            it.start()
        }
    }

    on_done :: (&Self, callback: Fn()) {
        Data :: struct {
            thread      : Thread
            callback    : Fn()
            compiler    : ^Compiler
        }
        thread_func :: (data: ^Data) {
            data.compiler.wait_for_threads()

            g_logger.log("on_done: Done waiting for all threads")
            data.callback()

            Memory.drop(*data)
            mem.free(data)
        }

        data := mem.alloc(Data)
        t := Thread.create(cast(Fn(^Data)) thread_func, data)
        *data = Data(
            thread      = t
            callback    = callback
            compiler    = ^*self
        )
        data.thread.start()
    }

    wait_for_threads :: (&Self) {
        handles := mem.alloc_raw(HANDLE, cast threads.get_length())

        for &threads {
            handles[it_index] = it.data.handle
        }
        WaitForMultipleObjects(cast threads.get_length(), handles, 1, INFINITE)
    }

    wait_until_done :: (&Self) {
        wait_for_threads()
        if waiting_fibers.count() > 0 {
            global_error_handler.report_error("[Compile] {} fibers were still waiting", [waiting_fibers.count()])
        }

        g_logger.log("[Compiler] finished compilation with {} fibers", [fibers.get_length()])
    }

    find_free_fiber :: (&Self) -> ^FiberContext {
        for f in &fibers {
            if f.job == null and f.thread == -1 {
                return *f
            }
        }
        {
            new_fiber := mem.alloc(FiberContext)
            *new_fiber = FiberContext(
                fiber   = Fiber.new(cast(Fn(^FiberContext)) self.fiber_func, new_fiber)
                interp  = Interpreter.new(global_error_handler)
            )
            fibers.add(new_fiber)
            return new_fiber
        }
    }

    fiber_func :: (&Self, fiber_context: ^FiberContext) {
        while true {
            while fiber_context.job == null {
                Fiber.yield()
            }

            fiber_context.job.progressed = false
            self.run_job(fiber_context)
            fiber_context.job.done = true
            fiber_context.job = null
        }
    }

    thread_func :: (&Self) {
        Fiber.init()
        thread_id := Thread.current().id

        current_fiber : ^FiberContext = null
        while true #label main_loop {
            {
                self.lock()
                defer self.release()

                // if fiber made progress or finished, move all stuff from q2 to q
                if current_fiber != null {
                    active_threads -= 1
                    current_fiber.thread = -1

                    // done or progressed
                    if current_fiber.job == null or current_fiber.job.progressed {
                        any_progress = true
                        while self.waiting_fibers.count() > 0 {
                            fiber := self.waiting_fibers.pop()
                            self.ready_fibers.push(fiber)
                        }
                        any_progress = false
                    }

                    if current_fiber.job != null {
                        self.waiting_fibers.push(current_fiber)
                    }

                    current_fiber = null
                }

                // no ready fibers
                if self.ready_fibers.count() == 0 {
                    has_jobs := false
                    g_logger.log("{} workspaces", [self.workspaces.count()])
                    for workspace in &self.workspaces {
                        if workspace.get().jobs.count() > 0 {
                            job := workspace.get().jobs.pop()
                            fiber := self.find_free_fiber()
                            fiber.job = job

                            self.ready_fibers.push(fiber)

                            has_jobs = true
                            break
                        }
                    }
                    if has_jobs {
                        // do nothing
                    // this doesn't work right now
                    /*
                    } else if self.waiting_fibers.count() > 0 {
                        if self.active_threads > 0 then continue

                        // if all fibers are paused and we didn't make any progress
                        // then we're done
                        if !any_progress then break main_loop
                        self.ready_fibers.push(self.waiting_fibers.pop())
                    // */

                    } else {
                        if self.active_threads > 0 then continue
                        break main_loop
                    }
                }

                current_fiber = self.ready_fibers.pop()
                current_fiber.thread = thread_id
                active_threads += 1
            }

            current_fiber.fiber.resume()
        }

        // cancel all fibers
        self.lock()
        defer self.release()
        for(by_ref=false) fib in &waiting_fibers {
            if fib.job != null {
                fib.job.cancelled = true
                fib.fiber.resume()
            }
        }
    }
}
