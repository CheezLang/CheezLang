use import std.string
use import std.array

use import compiler.ast

fmt :: import std.fmt

#export_scope

pretty_print_ast :: (node: &AstNode) -> String {
    result := String.empty()
    pretty_print_ast_helper(result, node)
    return result
}

#file_scope

append_indented :: (result: &String, str: &String, indent: int) {
    for line : str.slice().split_at_char('`n') {
        for 0..indent {
            result += " "
        }
        result += line
        result += "`n"
    }
}

pretty_print_ast_helper :: (result: &String, node: &AstNode) {
    match node {
        AstStruct($str) -> {
            fmt.format_into(result, "struct ``{")
            // @todo
            fmt.format_into(result, "``}")
        }
        
        AstTrait($str) -> {
            fmt.format_into(result, "trait ``{")
            // @todo
            fmt.format_into(result, "``}")
        }
        
        AstEnum($str) -> {
            fmt.format_into(result, "enum ``{")
            // @todo
            fmt.format_into(result, "``}")
        }

        AstFunction($func) -> {
            result += "("
            for param : func.params {
                if it_index > 0 then result.append_string(", ")
                pretty_print_ast_helper(result, <<param)
            }
            result += ") "
            // @todo return type
            pretty_print_ast_helper(result, <<func.body)
        }

        AstTuple($tuple) -> {
            result += "("
            for value : tuple.values {
                if it_index > 0 then result.append_string(", ")
                pretty_print_ast_helper(result, <<value)
            }
            result += ")"
        }

        AstConstDecl($decl) -> {
            pretty_print_ast_helper(result, decl.pattern)
            result += " :"
            if decl.type_expr != null then {
                result += " "
                pretty_print_ast_helper(result, <<decl.type_expr)
                result += " "
            }
            result += ": "
            pretty_print_ast_helper(result, decl.value_expr)
        }

        AstDecl($decl) -> {
            pretty_print_ast_helper(result, decl.pattern)
            result += " :"
            if decl.type_expr != null then {
                result += " "
                pretty_print_ast_helper(result, <<decl.type_expr)
                result += " "
            }
            if decl.value_expr != null {
                result += "= "
                pretty_print_ast_helper(result, <<decl.value_expr)
            }
        }

        AstAssignment($ass) -> {
            pretty_print_ast_helper(result, ass.pattern)
            result += " = "
            pretty_print_ast_helper(result, ass.value_expr)
        }

        // AstMove($move) -> {
        //     fmt.format_into(result, "AstMove #{} ({})`n", [move.id, move.location])
        //         pretty_print_ast_helper(result, move.target)
        //         pretty_print_ast_helper(result, move.source)
        // }

        // AstPipe($pipe) -> {
        //     fmt.format_into(result, "AstPipe #{} ({})`n", [pipe.id, pipe.location])
        //         pretty_print_ast_helper(result, pipe.left)
        //         pretty_print_ast_helper(result, pipe.right)
        // }

        AstBlock($block) -> {
            r := String.empty()

            result += "{`n"
            for child : block.children {
                r.clear()
                pretty_print_ast_helper(r, <<child)
                append_indented(result, r, 4)
            }
            result += "}"
        }

        AstIdentifier($id) -> {
            result += id.name
        }

        AstNumberLiteral($num) -> {
            fmt.format_into(result, "{}", [num.int_value])
        }

        AstString($str) -> {
            fmt.format_into(result, "{}", [str.string_value])
        }

        AstBool($bol) -> {
            fmt.format_into(result, "{}", [bol.bool_value])
        }

        AstNull($nul) -> {
            result += "null"
        }

        AstBinary($bin) -> {
            result += "("
            pretty_print_ast_helper(result, bin.left)
            fmt.format_into(result, " {} ", [bin.operator.lexeme()])
            pretty_print_ast_helper(result, bin.right)
            result += ")"
        }

        AstUnary($un) -> {
            result += "("
            fmt.format_into(result, "{}", [un.operator.lexeme()])
            pretty_print_ast_helper(result, un.sub)
            result += ")"
        }

        AstArgument($arg) -> {
            if arg.name != null {
                pretty_print_ast_helper(result, <<arg.name)
                result += " = "
            }
            pretty_print_ast_helper(result, arg.value_expr)
        }

        AstParameter($param) -> {
            pretty_print_ast_helper(result, param.name)
            result += " :"
            if param.type_expr != null then {
                result += " "
                pretty_print_ast_helper(result, <<param.type_expr)
                result += " "
            }
            if param.default_value != null {
                result += "= "
                pretty_print_ast_helper(result, <<param.default_value)
            }
        }

        AstCall($call) -> {
            pretty_print_ast_helper(result, call.function)
            result += "("
            for arg : call.arguments {
                pretty_print_ast_helper(result, <<arg)
            }
            result += ")"
        }

        AstIf($iff) -> {
            result += "if "
            pretty_print_ast_helper(result, iff.condition)
            result += " then "
            pretty_print_ast_helper(result, iff.true_case)

            if iff.false_case != null {
                result += " else "
                pretty_print_ast_helper(result, <<iff.false_case)
            }
        }

        AstLoop($lop) -> {
            result += "loop "
            pretty_print_ast_helper(result, lop.body)
        }

        AstFor($forr) -> {
            if forr.it_name != null then
                pretty_print_ast_helper(result, <<forr.it_name)
            if forr.index_name != null {
                if forr.it_name != null {
                    result += ", "
                }
                pretty_print_ast_helper(result, <<forr.index_name)
            }

            result += " : "
            pretty_print_ast_helper(result, forr.collection)
            result += " do "
            pretty_print_ast_helper(result, forr.body)
        }

        AstBreak($brake) -> {
            result += "break"
            if brake.label != null {
                result += " "
                pretty_print_ast_helper(result, <<brake.label)
            }
            if brake.value_expr != null {
                result += " with "
                pretty_print_ast_helper(result, <<brake.value_expr)
            }
        }

        AstContinue($cont) -> {
            result += "continue"
            if cont.label != null {
                result += " "
                pretty_print_ast_helper(result, <<cont.label)
            }
        }

        AstReturn($ret) -> {
            result += "return"
            if ret.value_expr != null {
                result += " "
                pretty_print_ast_helper(result, <<ret.value_expr)
            }
        }

        AstDefer($def) -> {
            result += "deref "
            pretty_print_ast_helper(result, def.sub)
        }

        $node -> {
            result += "<ERROR> not implemented`n"
        }
    }
}
