use import std.string
use import std.array

use import compiler.ast

fmt :: import std.fmt

#export_scope

dump_ast :: (node: &AstNode, recurse: bool = true) -> String {
    result := String.empty()
    dump_ast_helper(result, node, recurse, 0)
    return result
}

#file_scope

dump_ast_helper :: (result: &String, node: &AstNode, recurse: bool, indent: int) {
    print :: (msg: string, amount: int) #macro {
        for 0 .. amount {
            result += "  "
        }
        @link(result) += msg
    }

    print("", indent)

    match node {
        AstStruct($str) -> {
            fmt.format_into(result, "AstStruct #{} ({})`n", [str.id, str.location])
            if recurse {
            }
        }
        
        AstTrait($str) -> {
            fmt.format_into(result, "AstTrait #{} ({})`n", [str.id, str.location])
            if recurse {
            }
        }
        
        AstEnum($str) -> {
            fmt.format_into(result, "AstEnum #{} ({})`n", [str.id, str.location])
            if recurse {
            }
        }

        AstFunction($func) -> {
            fmt.format_into(result, "AstFunction #{} ({})`n", [func.id, func.location])
            if recurse {
                print("params:`n", indent + 1)
                for param : func.params {
                    dump_ast_helper(result, <<param, recurse, indent + 2)
                }
                print("body:`n", indent + 1)
                dump_ast_helper(result, <<func.body, recurse, indent + 2)
            }
        }

        AstConstDecl($decl) -> {
            fmt.format_into(result, "AstConstDecl #{} ({})`n", [decl.id, decl.location])
            if recurse {
                dump_ast_helper(result, decl.pattern, recurse, indent + 1)
                if decl.type_expr != null then
                    dump_ast_helper(result, <<decl.type_expr, recurse, indent + 1)
                dump_ast_helper(result, decl.value_expr, recurse, indent + 1)
            }
        }

        AstDecl($decl) -> {
            fmt.format_into(result, "AstDecl #{} ({})`n", [decl.id, decl.location])
            if recurse {
                dump_ast_helper(result, decl.pattern, recurse, indent + 1)
                if decl.type_expr != null then
                    dump_ast_helper(result, <<decl.type_expr, recurse, indent + 1)
                if decl.value_expr != null then
                    dump_ast_helper(result, <<decl.value_expr, recurse, indent + 1)
            }
        }

        AstAssignment($ass) -> {
            fmt.format_into(result, "AstAssignment #{} ({})`n", [ass.id, ass.location])
            if recurse {
                dump_ast_helper(result, ass.pattern, recurse, indent + 1)
                dump_ast_helper(result, ass.value_expr, recurse, indent + 1)
            }
        }

        AstMove($move) -> {
            fmt.format_into(result, "AstMove #{} ({})`n", [move.id, move.location])
            if recurse {
                dump_ast_helper(result, move.target, recurse, indent + 1)
                dump_ast_helper(result, move.source, recurse, indent + 1)
            }
        }

        AstPipe($pipe) -> {
            fmt.format_into(result, "AstPipe #{} ({})`n", [pipe.id, pipe.location])
            if recurse {
                dump_ast_helper(result, pipe.left, recurse, indent + 1)
                dump_ast_helper(result, pipe.right, recurse, indent + 1)
            }
        }

        AstBlock($block) -> {
            fmt.format_into(result, "AstBlock #{} ({})`n", [block.id, block.location])
            if recurse {
                for child : block.children {
                    dump_ast_helper(result, <<child, recurse, indent + 1)
                }
            }
        }

        AstIdentifier($id) -> {
            fmt.format_into(result, "AstIdentifier #{} '{}' ({})`n", [id.id, id.name, id.location])
        }

        AstNumberLiteral($num) -> {
            fmt.format_into(result, "AstNumberLiteral #{} {} ({})`n", [num.id, num.int_value, num.location])
        }

        AstString($num) -> {
            fmt.format_into(result, "AstString #{} '{}' ({})`n", [num.id, num.string_value, num.location])
        }

        AstBool($num) -> {
            fmt.format_into(result, "AstBool #{} {} ({})`n", [num.id, num.bool_value, num.location])
        }

        AstNull($num) -> {
            fmt.format_into(result, "AstNull #{} ({})`n", [num.id, num.location])
        }

        AstBinary($bin) -> {
            fmt.format_into(result, "AstBinary #{} {} ({})`n", [bin.id, bin.operator, bin.location])
            if recurse {
                dump_ast_helper(result, bin.left, recurse, indent + 1)
                dump_ast_helper(result, bin.right, recurse, indent + 1)
            }
        }

        AstUnary($un) -> {
            fmt.format_into(result, "AstUnary #{} {} ({})`n", [un.id, un.operator, un.location])
            if recurse {
                dump_ast_helper(result, un.sub, recurse, indent + 1)
            }
        }

        AstArgument($arg) -> {
            fmt.format_into(result, "AstArgument #{} ({})`n", [arg.id, arg.location])
            if recurse {
                if arg.name != null then
                    dump_ast_helper(result, <<arg.name, recurse, indent + 1)
                dump_ast_helper(result, arg.value_expr, recurse, indent + 1)
            }
        }

        AstParameter($param) -> {
            fmt.format_into(result, "AstParameter #{} ({})`n", [param.id, param.location])
            if recurse {
                dump_ast_helper(result, param.name, recurse, indent + 1)
                dump_ast_helper(result, <<param.type_expr, recurse, indent + 1)

                if param.default_value != null then
                    dump_ast_helper(result, <<param.default_value, recurse, indent + 1)
            }
        }

        AstCall($call) -> {
            fmt.format_into(result, "AstCall #{} ({})`n", [call.id, call.location])
            if recurse {
                dump_ast_helper(result, call.function, recurse, indent + 1)
                for arg : call.arguments {
                    dump_ast_helper(result, <<arg, recurse, indent + 1)
                }
            }
        }

        AstIf($iff) -> {
            fmt.format_into(result, "AstIf #{} ({})`n", [iff.id, iff.location])
            if recurse {
                dump_ast_helper(result, iff.condition, recurse, indent + 1)
                dump_ast_helper(result, iff.true_case, recurse, indent + 1)
                if iff.false_case != null then
                    dump_ast_helper(result, <<iff.false_case, recurse, indent + 1)
            }
        }

        AstLoop($lop) -> {
            fmt.format_into(result, "AstLoop #{} ({})`n", [lop.id, lop.location])
            if recurse {
                dump_ast_helper(result, lop.body, recurse, indent + 1)
            }
        }

        AstFor($forr) -> {
            fmt.format_into(result, "AstFor #{} ({})`n", [forr.id, forr.location])
            if recurse {
                if forr.it_name != null then
                    dump_ast_helper(result, <<forr.it_name, recurse, indent + 1)
                if forr.index_name != null then
                    dump_ast_helper(result, <<forr.index_name, recurse, indent + 1)
                dump_ast_helper(result, forr.collection, recurse, indent + 1)
                dump_ast_helper(result, forr.body, recurse, indent + 1)
            }
        }

        AstBreak($brake) -> {
            fmt.format_into(result, "AstBreak #{} ({})`n", [brake.id, brake.location])
            if recurse {
                if brake.label != null then
                    dump_ast_helper(result, <<brake.label, recurse, indent + 1)
                if brake.value_expr != null then
                    dump_ast_helper(result, <<brake.value_expr, recurse, indent + 1)
            }
        }

        AstContinue($cont) -> {
            fmt.format_into(result, "AstContinue #{} ({})`n", [cont.id, cont.location])
            if recurse {
                if cont.label != null then
                    dump_ast_helper(result, <<cont.label, recurse, indent + 1)
            }
        }

        AstReturn($ret) -> {
            fmt.format_into(result, "AstReturn #{} ({})`n", [ret.id, ret.location])
            if recurse {
                if ret.value_expr != null then
                    dump_ast_helper(result, <<ret.value_expr, recurse, indent + 1)
            }
        }

        AstDefer($def) -> {
            fmt.format_into(result, "AstDefer #{} ({})`n", [def.id, def.location])
            if recurse {
                dump_ast_helper(result, def.sub, recurse, indent + 1)
            }
        }

        $node -> {
            result += "<ERROR> not implemented`n"
        }
    }
}
