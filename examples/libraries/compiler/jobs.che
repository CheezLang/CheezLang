
use import std.fiber
use import std.string
use import std.array
use import std.mem.std_heap_allocator

fs  :: import std.io.fs
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import lexer
use import parser
use import ast_dumper
use import compiler
use import bytecode_generator
use import scope
use import config
use import value


#export_scope

CompilationJob :: trait {
    progressed  : bool = false
    done        : bool = false
    compiler    : &Compiler = null

    get_name :: (ref Self) -> string;
    execute :: (ref Self, compiler: ref Compiler);
}

LoadFileJob :: struct CompilationJob {
    name : String
    path : String
}

impl LoadFileJob {
    new :: (path: String) -> LoadFileJob {
        return LoadFileJob(
            name = fmt.format("LoadFileJob '{}'", [path])
            path = path
        )
    }
}

CompileGlobalNodeJob :: struct CompilationJob {
    name : String
    node : &AstNode
}

impl CompileGlobalNodeJob {
    new :: (node: &AstNode) -> CompileGlobalNodeJob {
        return CompileGlobalNodeJob(
            name = fmt.format("CompileGlobalNodeJob #{}", [node.id])
            node = node
        )
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name :: (ref Self) -> string {
        return name.slice()
    }

    debug_log :: (ref Self, msg: string, args: []&any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [CompileGlobalNode #{}] {}", [Fiber.user_data(FiberContext).thread, node.id, str])
        } 
    }

    execute :: (ref Self, compiler: ref Compiler) {
        debug_log("Begin compilation")

        node.scope = compiler.global_scope
        compile_node(<<node)

        debug_log("Done")
    }

    compile_node :: (ref Self, node: ref AstNode) -> ref AstNode {
        return match node {
            AstConstDecl($decl)     -> compile_const_decl(decl)
            AstFunction($func)      -> compile_function(func)
            AstBlock($block)        -> compile_block(block)
            AstArgument($arg)       -> compile_argument(arg)
            AstCall($call)          -> compile_call(call)
            AstIdentifier($id)      -> compile_identifier(id)
            AstString($str)         -> compile_string(str)
            AstBool($bol)           -> compile_bool(bol)
            AstNumberLiteral($num)  -> compile_number(num)

            _ -> {
                dump := dump_ast(node, recurse = false)
                compiler.error_handler.report_error_at(node.location, "compile_node: not implemented: {}", [dump])
                node
            }
        }

        return node
    }

    compile_string :: (ref Self, str: ref AstString) -> ref AstNode {
        str.value = .String(str.string_value)
        return str
    }

    compile_bool :: (ref Self, bol: ref AstBool) -> ref AstNode {
        bol.value = .Bool(bol.bool_value)
        return bol
    }

    compile_number :: (ref Self, num: ref AstNumberLiteral) -> ref AstNode {
        num.value = .Int(num.int_value)
        return num
    }

    compile_identifier :: (ref Self, id: ref AstIdentifier) -> ref AstNode {
        sym := id.scope.get_symbol(id.name)
        match sym {
            .Val(($typ, $value)) -> match value {
                .Function($func) -> {
                    // id.typ = cast typ
                    id.value = value
                }
                
                $val -> {
                    compiler.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [val])
                }
            }

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None)
                id.value = decl.value_expr.value
            }

            .NativeFunc($func) -> {
                id.value = .NativeFunc(func)
            }

            $sym -> {
                compiler.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [sym])
            }
        }

        return id
    }

    compile_argument :: (ref Self, arg: ref AstArgument) -> ref AstNode {
        arg.value_expr <- compile_node(arg.value_expr)
        return arg
    }

    compile_call :: (ref Self, call: ref AstCall) -> ref AstNode {
        call.function.scope = call.scope
        call.function <- compile_node(call.function)
        
        match call.function.value {
            .Function($func) -> {
                // call.typ = cast typ
                // call.value = value
                call.ast_function = func

                for arg : call.arguments {
                    arg = cast &compile_node(<<arg)
                }
            }

            .NativeFunc($func) -> {
                // call.typ = cast typ
                // call.value = value
                for arg : call.arguments {
                    arg = cast &compile_node(<<arg)
                }
            }

            $val -> {
                compiler.error_handler.report_error_at(call.location, "[compile_call] not implemented: {}", [val])
            }
        }

        return call
    }

    compile_block :: (ref Self, block: ref AstBlock) -> ref AstNode {
        block.sub_scope = compiler.new_scope(block.scope)

        for child : block.children {
            child.scope = block.sub_scope
            child = &compile_node(<<child)
        }

        return block
    }

    compile_function :: (ref Self, func: ref AstFunction) -> ref AstNode {
        debug_log("compile_function '{}': Begin", [func.name])
        func.param_scope = compiler.new_scope(func.scope)
        func.body.scope = func.param_scope
        func.value = Value.Function(&func)

        debug_log("compile_function '{}': Compile Body", [func.name])
        func.body = &compile_node(<<func.body)

        debug_log("compile_function '{}': Generate Bytecode", [func.name])
        code_gen := ByteCodeGenerator.new(compiler.string_database, <<compiler.error_handler, compiler.bc_allocator)
        code_gen.get().generate_code_for_function(&func)

        // @temp
        if func.name == "Main" {
            if compiler.error_handler.has_errors() {
                return func
            }
            debug_log("compile_function '{}': Call Main", [func.name])
            context := Fiber.user_data(FiberContext)
            context.interp.comp_call(func)
            compiler.code_runner.get().run(<<context.interp)
        }
        debug_log("compile_function '{}': End", [func.name])

        return func
    }

    compile_const_decl :: (ref Self, decl: ref AstConstDecl) -> ref AstNode {
        decl.value_expr.scope = decl.scope

        match decl.value_expr {
            AstFunction($func) -> {
                func.name = decl.name.name
            }
        }

        match decl.scope.define_const_decl(decl.name.name, decl) {
            Err() -> compiler.error_handler.report_error_at(decl.name.location, "A symbol with this name already exists in this scope")
        }

        decl.value_expr <- compile_node(decl.value_expr)
        decl.value = decl.value_expr.value

        return decl
    }
}

impl CompilationJob for LoadFileJob {
    get_name :: (ref Self) -> string {
        return name.slice()
    }

    debug_log :: (ref Self, msg: string, args: []&any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [LoadFileJob '{}'] {}", [Fiber.user_data(FiberContext).thread, path, str])
        } 
    }

    execute :: (ref Self, compiler: ref Compiler) {
        debug_log("Begin loading")

        full_path := match fs.get_full_path(path.slice()) {
            Ok($p) -> compiler.string_database.intern(p.slice())
            Err(_) -> compiler.string_database.intern(path.slice())
        }

        if !compiler.sources.contains(full_path) {
            content := fs.read_file(full_path)

            match content {
                Ok($content) -> {
                    lexer := Lexer.from_string(content.slice(), compiler.string_database)
                    lexer.get().location.file = full_path
                    parser := Parser.new(lexer.get(), compiler.error_handler, compiler.ast_allocator)

                    loop {
                        decl := parser.parse_constant_declaration()
                        if decl == null then break
                        dump := dump_ast(<<decl)
                        // io.println(dump)

                        compiler.add_job(CompileGlobalNodeJob.new(decl))
                    }

                    compiler.sources.set(full_path, content)
                }

                Err(_) -> {
                    compiler.error_handler.report_error("Failed to load source file '{}'", [full_path])
                }
            }
        }
        
        debug_log("Done")
    }
}


#file_scope
