use import std.array
use import std.fiber
use import std.math
use import std.mem.std_heap_allocator
use import std.printable
use import std.string

C    :: import std.c
fmt  :: import std.fmt
fs   :: import std.io.fs
io   :: import std.io
mem  :: import std.mem.allocator
util :: import std.util

use import logging.logger

use import ast
use import ast_cloner
use import ast_dumper
use import ast_pretty_printer
use import bytecode_generator
use import compiler
use import config
use import lexer
use import parser
use import scope
use import types
use import validator
use import value

#export_scope

CompilationJob :: trait {
    cancelled   : bool = false
    progressed  : bool = false
    done        : bool = false
    compiler    : ^Compiler = null
    workspace   : ^Workspace = null

    get_name :: (&Self) -> string;
    execute :: (&Self);
}

LoadFileJob :: struct CompilationJob {
    name : String
    path : String
}

impl LoadFileJob {
    new :: (path: String) -> LoadFileJob {
        return LoadFileJob(
            name = fmt.format("LoadFileJob '{}'", [path])
            path = path
        )
    }
}

RunCodeJob :: struct CompilationJob {
    name        : String
    function    : ^AstFunction
}

impl RunCodeJob {
    new :: (function: ^AstFunction) -> RunCodeJob {
        return RunCodeJob(
            name        = fmt.format("RunCodeJob '{}'", [function.name])
            function    = function
        )
    }
}

CompileGlobalNodeJob :: struct CompilationJob {
    name        : String
    node        : ^AstNode
    function    : ^AstFunction = null
}

impl CompileGlobalNodeJob {
    new :: (node: ^AstNode) -> CompileGlobalNodeJob {
        return CompileGlobalNodeJob(
            name = fmt.format("CompileGlobalNodeJob #{}", [node.id])
            node = node
        )
    }
}

CompileStructMemberJob :: struct CompilationJob {
    name    : String
    structt : ^AstStruct
    node    : ^AstNode
}

impl CompileStructMemberJob {
    new :: (structt: ^AstStruct, node: ^AstNode) -> CompileStructMemberJob {
        return CompileStructMemberJob(
            name    = fmt.format("CompileStructMemberJob #{}", [node.id])
            structt = structt
            node    = node
        )
    }
}

impl CompilationJob for CompileStructMemberJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [CompileStructMemberJob #{}] {}", [workspace.id, node.id, str])
        }}
    }

    execute :: (&Self) {
        debug_log("Begin compilation")

        compile_node := CompileNode(
            job         = ^*self
            compiler    = compiler
            workspace   = workspace
            node        = node
            function    = null
        )

        match node {
            AstDecl($decl) -> {
                compile_node.compile_node(&*decl, CNContext())
                structt.members.add(decl)
            }

            AstConstDecl($decl) -> {
                compile_node.compile_node(&*decl, CNContext())
                structt.constants.add(decl)
            }

            _ -> {
                node = ^*compile_node.evaluate_node(&*node, CNContext())
                if node.value == .Poison {
                    poison(&*node)
                    return
                }

                match node.typ {
                    TypeInfoString($ti) -> {
                        @assert(node.value == .String)
                        str := node.value.String
                        lexer := workspace.add_string_source(str)
                        parser := Parser.new(lexer.get(), workspace.error_handler, workspace.ast_allocator, workspace.next_ast_id)
                        workspace.next_ast_id += 0xFFFFFFFF // ?

                        loop {
                            node := parser.parse_node()
                            if node == null then break

                            if const DEBUG_ENABLED { if DUMP_AST {
                                dump := dump_ast(&*node)
                                g_logger.log("[{}] {}", [self.name, dump])
                            }}
                            if const DEBUG_ENABLED { if PRINT_AST {
                                dump := pretty_print_ast(&*node)
                                g_logger.log("[{}] {}", [self.name, dump])
                            }}

                            node.scope = self.node.scope
                            job := workspace.create_job(CompileStructMemberJob.new(structt, node))
                            workspace.add_job(job)
                            wait_until(job.done, {
                            })
                        }
                    }
                }
            }
        }

        debug_log("Done")
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [CompileGlobalNodeJob #{}] {}", [workspace.id, node.id, str])
        }}
    }

    execute :: (&Self) {
        debug_log("Begin compilation")

        compile_node := CompileNode(
            job         = ^*self
            compiler    = compiler
            workspace   = workspace
            node        = node
            function    = null
        )

        node.set_flags(.AllowPubModifier)
        node = ^*compile_node.compile_node(&*node, CNContext())

        if node.value == .Poison {
            debug_log("Failed. Got poison")
            return
        }

        if const VALIDATE_AST {
            debug_log("Validate node")
            if !validate_node(&*node, workspace.error_handler) {
                debug_log("Validation failed")
                return
            }
        }

        if const DEBUG_ENABLED { if PRINT_TYPED_AST {
            dump := pretty_print_typed_ast(&*node)
            g_logger.log("[{}] {}", [self.name, dump])
        }}

        debug_log("Done")
    }
}

impl CompilationJob for RunCodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [RunCodeJob '{}'] {}", [workspace.id, function.name, str])
        }}
    }

    execute :: (&Self) {
        if workspace.error_handler.has_errors() {
            return
        }
        debug_log("Begin execution")
        context := Fiber.user_data(FiberContext)
        context.interp.comp_call(&*function)
        match compiler.code_runner.get().run(&*context.interp) {
            .Error($msg) -> {
                frame := context.interp.top_frame()
                location := frame.func.debug_info.get_location_for_ip(frame.ip)
                workspace.error_handler.report_error_at(location, "{}", [msg])
            }
        }
        debug_log("Done")
    }
}

impl CompilationJob for LoadFileJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [LoadFileJob '{}'] {}", [workspace.id, path, str])
        }}
    }

    execute :: (&Self) {
        debug_log("Begin loading")

        full_path := match fs.get_full_path(path.slice()) {
            Ok($p) -> workspace.string_database.intern(p.slice())
            Err(_) -> workspace.string_database.intern(path.slice())
        }

        match workspace.load_file(full_path) {
            Err(_) -> {
                workspace.error_handler.report_error("Failed to load file '{}'", [full_path])
                return
            }

            Ok($file) -> match file { Some($file) -> {
                // todo: workspace.string_database must be protected in multi threading
                lexer := Lexer.from_string(file.content, &workspace.string_database)
                lexer.get().location.file = full_path
                parser := Parser.new(lexer.get(), workspace.error_handler, workspace.ast_allocator, workspace.next_ast_id)
                workspace.next_ast_id += 0xFFFFFFFF // ?

                loop {
                    node := parser.parse_node()
                    if node == null then break

                    if const DEBUG_ENABLED { if DUMP_AST {
                        dump := dump_ast(&*node)
                        g_logger.log("[{}] {}", [self.name, dump])
                    }}
                    if const DEBUG_ENABLED { if PRINT_AST {
                        dump := pretty_print_ast(&*node)
                        g_logger.log("[{}] {}", [self.name, dump])
                    }}

                    node.scope = file.global_scope
                    file.nodes.add(node)

                    match node {
                        AstConstDecl($decl) -> {
                            define_const_decl(&*decl)
                            AstNode.set_flags(&*decl, .IsDefinedInScope)
                        }
                        AstDecl($decl) -> {
                            define_decl(&*decl)
                            AstNode.set_flags(&*decl, .IsDefinedInScope)
                        }
                    }
                }

                for node in &file.nodes {
                    workspace.add_job(workspace.create_job(CompileGlobalNodeJob.new(*node)))
                }
            }}
        }

        debug_log("Done")
    }

    define_decl :: (&Self, decl: &AstDecl) {
        decl.name = match &*decl.pattern {
            AstIdentifier($id) -> id.name
            _ -> {
                workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                return
            }
        }

        // define symbol but only if not _
        if decl.name != "_" {
            match decl.scope.define_decl(decl.name, decl) {
                Err() -> {
                    workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                }
            }
        }
    }

    define_const_decl :: (&Self, decl: &AstConstDecl) {
        decl.value_expr.scope = decl.scope

        name := match decl.pattern {
            AstIdentifier($id) -> id.name
            _ -> {
                workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                return
            }
        }

        // set name of value expr if its a function or struct/trait/enum
        match decl.value_expr {
            AstFunction($func) -> {
                func.name = name
            }
            AstStruct($str) -> {
                str.name = name
            }
            AstEnum($en) -> {
                en.name = name
            }
            AstTrait($tr) -> {
                tr.name = name
            }
            AstPoly($poly) -> {
                poly.name = name
            }
        }

        // define symbol but only if not _
        if name != "_" {
            match decl.scope.define_const_decl(name, decl) {
                Err() -> {
                    workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                }
            }
        }
    }
}


CompileNode :: struct {
    job         : ^CompilationJob
    compiler    : ^Compiler
    workspace   : ^Workspace
    node        : ^AstNode
    function    : ^AstFunction
}
CNContext :: struct #copy {
    expected : ^TypeInfo = null
}

impl CNContext {
    with_expected :: (Self, typ: ^TypeInfo) -> CNContext {
        expected = typ
        return self
    }
}

impl CompileNode {
    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [{}] {}", [workspace.id, job.get_name(), str])
        }}
    }

    evaluate_node :: (&Self, node: &AstNode, ctx: CNContext) -> &AstNode {
        // {
        //     dump := dump_ast(node, recurse = false)
        //     debug_log("evaluate_node: {}", [dump])
        // }
        if node.typ != null {
            return node
        }
        node.scope = workspace.new_scope(node.scope, constant = true)
        node <- compile_node(node, ctx)
        handle_poison(node, node)

        if node.value == .None {
            code_gen := ByteCodeGenerator.new(&workspace.string_database, &*workspace.error_handler, workspace.bc_allocator)
            code := code_gen.get().generate_code_for_expression(node)
            context := Fiber.user_data(FiberContext)
            context.interp.push_frame(code)
            defer context.interp.pop_frame()
            match compiler.code_runner.get().run(&*context.interp) {
                .Error($msg) -> {
                    frame := context.interp.top_frame()
                    location := frame.func.debug_info.get_location_for_ip(frame.ip)
                    workspace.error_handler.report_error_at(location, "{}", [msg])
                    poison(node)
                    return node
                }
            }

            frame := context.interp.top_frame()

            node.value = match &*node.typ {
                TypeInfoInt(_)      -> .Int(frame.get_local(0, int))
                TypeInfoFloat(_)    -> .Float(frame.get_local(0, f64))
                TypeInfoBool(_)     -> .Bool(frame.get_local(0, bool))
                TypeInfoString(_)   -> .String(frame.get_local(0, string))

                _ -> .None
            }
        }

        return node
    }

    compile_node :: (&Self, node: &AstNode, ctx: CNContext) -> &AstNode {
        // g_logger.log("compile_node"
        if node.typ != null {
            return node
        }

        {
            // dump := dump_ast(node, recurse = false)
            // debug_log("compile_node: {}", [dump])
        }

        return match node {
        // result : &AstNode = match node {
            AstArgument($arg)       -> compile_argument(arg, ctx)
            AstArray($arr)          -> compile_array(arr, ctx)
            AstArrayType($arr)      -> compile_array_type(arr, ctx)
            AstAssignment($ass)     -> compile_assignment(ass, ctx)
            AstBinary($bin)         -> compile_binary(bin, ctx)
            AstBlock($block)        -> compile_block(block, ctx)
            AstBool($bol)           -> compile_bool(bol, ctx)
            AstBreak($brake)        -> compile_break(brake, ctx)
            AstCall($call)          -> compile_call(call, ctx)
            AstCast($cst)           -> compile_cast(cst, ctx)
            AstConstDecl($decl)     -> compile_const_decl(decl, ctx)
            AstContinue($cont)      -> compile_continue(cont, ctx)
            AstDecl($decl)          -> compile_decl(decl, ctx)
            AstDefer($def)          -> compile_defer(def, ctx)
            AstDot($dot)            -> compile_dot(dot, ctx)
            AstFor($forr)           -> compile_for(forr, ctx)
            AstFunction($func)      -> compile_function(func, ctx)
            AstIdentifier($id)      -> compile_identifier(id, ctx)
            AstIf($iff)             -> compile_if(iff, ctx)
            AstImport($imp)         -> compile_import(imp, ctx)
            AstIndex($index)        -> compile_index(index, ctx)
            AstLoop($lop)           -> compile_loop(lop, ctx)
            AstNumberLiteral($num)  -> compile_number(num, ctx)
            AstPoly($poly)          -> compile_poly(poly, ctx)
            AstReturn($ret)         -> compile_return(ret, ctx)
            AstString($str)         -> compile_string(str, ctx)
            AstStruct($str)         -> compile_struct(str, ctx)
            AstUfc($ufc)            -> compile_ufc(ufc, ctx)
            AstUnary($un)           -> compile_unary(un, ctx)

            _ -> {
                dump := dump_ast(node, recurse = false)
                workspace.error_handler.report_error_at(node.location, "compile_node: not implemented: {}", [dump])
                node
            }
        }

        // if result.typ == null {
        //     workspace.error_handler.report_error_at(result.location, "[ERROR] typ is null")
        //     poison(result)
        // }

        // return result
    }

    compile_dot :: (&Self, dot: &AstDot, ctx: CNContext) -> &AstNode {
        if dot.sub == null {
            workspace.error_handler.report_error_at(dot.location, "compile_dot: anonymous not implemented")
            poison(dot)
            return dot
        }

        original_sub := dot.sub
        dot.sub.scope = dot.scope
        dot.sub <- compile_node(&*dot.sub, ctx)
        handle_poison(dot, *dot.sub)

        match dot.sub.typ {
            TypeInfoPointer($ti) -> {
                deref := workspace.new_ast(AstUnary(
                    id          = -1
                    location    = dot.sub.location
                    scope       = dot.sub.scope
                    sub         = &*dot.sub
                    operator    = .Deref
                ))
                dot.sub <- compile_node(&*deref, ctx.with_expected(ti.target))
                handle_poison(dot, *dot.sub)
            }
        }

        name := dot.name.name
        match dot.sub.typ {
            TypeInfoArray($ti) -> {
                if name == "length" or name == "count" { // @todo: remove length eventually
                    dot.typ = @type_info(int)
                    dot.value = .Int(ti.count)
                } else if name == "data" {
                    workspace.error_handler.report_error_at(dot.location, "TODO: array.data")
                    poison(dot)
                    return dot
                } else {
                    workspace.error_handler.report_error_at(
                        dot.name.location,
                        "Type '{}' has no subscript '{}'",
                        [dot.sub.typ, name])
                    poison(dot)
                    return dot
                }
            }

            TypeInfoStruct($ti) -> {
                // wait_until(ti.members != null, {
                //     // @todo: report error? i dont think its necessary here
                // })

                match workspace.get_struct_ast(ti) {
                    Some($ast) -> wait_until(ast.members_done, {
                        // nothing to see here...
                    })
                }

                // check if member with this name exists
                member : ^TypeInfoStructMember = null
                for(by_ref=true) mem in ti.members {
                    if mem.name == name {
                        member = mem
                        break
                    }
                }

                if member != null {
                    dot.typ = member.typ
                    dot.symbol = .StructMember(member)
                    if dot.sub.has_flags(.LValue) then AstNode.set_flags(dot, .LValue)
                    return dot
                }

                func : ^TypeInfoImplFunction = null
                for(by_ref=true) ti.impl_funcs {
                    if it.name == name {
                        func = ^*it
                        break
                    }
                }

                if func != null {
                    match workspace.get_native_function_wrapper(cast func.typ) {
                        Some($wrapper) -> {
                            return compile_node(&*workspace.new_ast(AstUfc(
                                id          = -1
                                location    = dot.location
                                scope       = dot.scope
                                typ         = func.typ
                                value_expr  = &*original_sub
                                symbol      = .NativeFunc2(wrapper)
                                value       = .NativeFunc2(wrapper, func.pointer)
                            )), ctx)
                        }

                        None -> {
                            workspace.error_handler.report_error_at(
                                dot.name.location,
                                "Can't call native function '{}' because no wrapper is available for type '{}'",
                                [name, func.typ])
                            poison(dot)
                            return dot
                        }
                    }
                }
                
                // @todo: find functions with this name

                workspace.error_handler.report_error_at(dot.name.location, "Struct '{}' has no member or function '{}'", [ti.name, name])
                poison(dot)
                return dot
            }

            TypeInfoModule(_) -> {
                @assert(dot.sub.value == .Module)
                file := dot.sub.value.Module

                dot.name.scope = file.global_scope
                AstNode.set_flags(dot.name, .OnlyPubDeclarations)
                compile_node(dot.name, ctx)
                dot.typ = dot.name.typ
                dot.value = dot.name.value
            }

            _ -> {
                workspace.error_handler.report_error_at(dot.sub.location, "Invalid type on left size of '.': '{}'", [dot.sub.typ])
                poison(dot)
                return dot
            }
        }

        return dot
    }

    compile_assignment :: (&Self, ass: &AstAssignment, ctx: CNContext) -> &AstNode {
        // @todo: check if assignment is of form <expr>[<index>] = <value>
        // and the []set operator is overridden
        // in that case turn it into @typeof(<expr>)."[]set"(<expr>, <index>, <value>)

        ass.pattern.scope = ass.scope
        ass.pattern <- compile_node(ass.pattern, ctx)
        handle_poison(ass, ass.pattern)

        // @todo: check if pattern is lvalue

        ass.value_expr.scope = ass.scope
        ass.value_expr <- compile_node(ass.value_expr, ctx.with_expected(ass.pattern.typ))
        handle_poison(ass, ass.value_expr)

        // check types
        if !TypeInfo.same(ass.value_expr.typ, ass.pattern.typ) {
            workspace.error_handler.report_error_at(
                ass.value_expr.location,
                "Can't assign value of type '{}' to pattern of type '{}'",
                [ass.value_expr.typ, ass.pattern.typ])
            poison(ass)
            return ass
        }

        match ass.pattern {
            AstIdentifier($id) -> match id.symbol {
                .Decl($decl) -> {
                    // check for mutability
                    if !decl.mutable {
                        workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to '{}' because it is not mutable", [id.name])
                        poison(ass)
                        return ass
                    }
                }

                .ConstDecl($decl) -> {
                    workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to constant '{}'", [id.name])
                    poison(ass)
                    return ass
                }

                _ -> {
                    workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                    poison(ass)
                    return ass
                }
            }

            AstDot($dot) if dot.symbol == .StructMember -> {
                // ok
            }

            AstDot($dot) -> {
                workspace.error_handler.report_error_at(ass.pattern.location, "compile_assignment: not implemented: <expr>.<id>")
                poison(ass)
                return ass
            }

            AstIndex($node) -> {
                match node.sub.typ {
                    TypeInfoArray($ti) -> match node.index.typ {
                        TypeInfoInt(_) -> {
                            // ok
                        }

                        _ -> {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                            poison(node)
                            return node
                        }
                    }

                    _ -> {
                        workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                        poison(node)
                        return node
                    }
                }
            }

            AstUnary($un) if un.operator == .Deref -> {
                match un.sub.typ {
                    TypeInfoPointer($ti) -> {
                        if !ti.is_mut {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to immutable pointer")
                            poison(ass)
                            return ass
                        }
                    }
                    TypeInfoReference($ti) -> {
                        if !ti.is_mut {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to immutable reference")
                            poison(ass)
                            return ass
                        }
                    }
                }
                // ok
                // workspace.error_handler.report_error_at(ass.pattern.location, "compile_assignment: not implemented: *<expr>")
                // poison(ass)
                // return ass
            }

            _ -> {
                workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                poison(ass)
                return ass
            }
        }

        // ok
        ass.typ = @type_info(void)
        return ass
    }
    
    compile_array :: (&Self, arr: &AstArray, ctx: CNContext) -> &AstNode {
        arr.typ = @type_info(void)

        expected : ^TypeInfo = null
        if ctx.expected != null then match &*ctx.expected {
            TypeInfoArray($arr_type) -> { expected = arr_type.target }
        }

        for(by_ref=true) val in &arr.values {
            val.scope = arr.scope
            *val = ^*compile_node(&**val, ctx.with_expected(expected))
            
            if val.value == .Poison {
                poison(arr)
                return arr
            }

            if expected == null {
                expected = val.typ
            }

            if !TypeInfo.same(val.typ, expected) {
                workspace.error_handler.report_error_at(val.location, "Type of value ({}) does not match expected type {}", [val.typ, expected])
                poison(arr)
                return arr
            }
        }

        if expected == null {
            workspace.error_handler.report_error_at(arr.location, "Failed to infer type of array expression")
            poison(arr)
            return arr
        }

        arr.typ = workspace.new_type(TypeInfoArray(
            size        = arr.values.count() * expected.size
            alignment   = expected.alignment
            traits      = []
            impl_funcs  = []
            count       = arr.values.count()
            target      = expected
        ))

        return arr
    }

    compile_array_type :: (&Self, arr: &AstArrayType, ctx: CNContext) -> &AstNode {
        arr.typ = @type_info(type)

        count : Option[int] = if arr.count == null {
            None
        } else {
            arr.count.scope = arr.scope
            arr.count = ^*evaluate_node(&*arr.count, ctx.with_expected(@type_info(int)))

            handle_poison(arr, arr.count)

            if !TypeInfo.same(arr.count.typ, @type_info(int)) {
                workspace.error_handler.report_error_at(arr.count.location, "Expected int, got '{}'", [arr.count.typ])
                poison(arr)
                return arr
            }

            @assert(arr.count.value == .Int)
            count := arr.count.value.Int

            Some(count)
        }

        arr.target.scope = arr.scope
        arr.target = evaluate_node(arr.target, ctx.with_expected(@type_info(type)))
        if arr.target.value == .Poison or arr.target.typ != @type_info(type) {
            poison(arr)
            return arr
        }

        @assert(arr.target.value == .Type)
        target := arr.target.value.Type

        arr.value = match count {
            Some($count) -> .Type(workspace.new_type(TypeInfoArray(
                size        = count * target.size
                alignment   = target.alignment
                traits      = []
                impl_funcs  = []
                count       = count
                target      = target
            )))

            None -> .Type(workspace.new_type(TypeInfoSlice(
                size        = 2 * @sizeof(^void)
                alignment   = target.alignment
                traits      = []
                impl_funcs  = []
                target      = target
            )))
        }

        return arr
    }

    compile_ufc :: (&Self, ufc: &AstUfc, ctx: CNContext) -> &AstNode {
        // ufc.value
        return ufc
    }

    compile_unary :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        return match un.operator {
            .Neg    -> compile_unary_neg(un, ctx)
            .Not    -> compile_unary_not(un, ctx)
            .Ref    -> compile_unary_ptr_or_ref(un, ctx)
            .RefMut -> compile_unary_ptr_or_ref(un, ctx)
            .Ptr    -> compile_unary_ptr_or_ref(un, ctx)
            .PtrMut -> compile_unary_ptr_or_ref(un, ctx)
            .Deref  -> compile_unary_deref(un, ctx)
        }
    }

    compile_unary_neg :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)

        // check types
        if un.sub.typ == null { return un }

        match &*un.sub.typ {
            TypeInfoInt(_) -> {}
            TypeInfoFloat(_) -> {}

            $ti -> {
                workspace.error_handler.report_error_at(
                    un.sub.location,
                    "Expected type bool, got {}",
                    [un.sub.typ])
                return un
            }
        }
        un.typ = un.sub.typ

        // set value if known at compile time
        match un.value {
            .Int($b) -> {
                un.value = .Int(-b)
            }
            .Float($b) -> {
                un.value = .Float(-b)
            }
        }
        return un
    }

    compile_unary_not :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx.with_expected(@type_info(bool)))

        // check types
        if un.sub.typ == null { return un }
        if un.sub.typ != @type_info(bool) {
            workspace.error_handler.report_error_at(
                un.sub.location,
                "Expected type bool, got {}",
                [un.sub.typ])
            return un
        }

        un.typ = @type_info(bool)

        // set value if known at compile time
        match un.value {
            .Bool($b) -> {
                un.value = .Bool(!b)
            }
        }
        return un
    }

    compile_unary_ptr_or_ref :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        mutable, reference, str := match un.operator {
            .Ref    -> false, true, "reference"
            .RefMut -> true, true, "reference"
            .Ptr    -> false, false, "pointer"
            .PtrMut -> true, false, "pointer"
        }

        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)
        handle_poison(un, un.sub)

        if un.sub.typ == @type_info(type) {
            @assert(un.sub.value == .Type)
            un.typ = un.sub.typ
            if reference {
                un.value = .Type(workspace.reference_type(un.sub.value.Type, mutable))
            } else {
                un.value = .Type(workspace.pointer_type(un.sub.value.Type, mutable))
            }
        } else {
            if !un.sub.has_flags(.LValue) {
                workspace.error_handler.report_error_at(un.location, "Can't create {} to non l-value", [str])
                poison(un)
                return un
            }

            match un.sub {
                AstIdentifier($id) -> match id.symbol {
                    .Decl($decl) -> {
                        if mutable and !decl.mutable {
                            workspace.error_handler.report_error_at(un.location, "Can't create mutable {} to immutable variabe", [str])
                            poison(un)
                            return un
                        }
                    }
                }
                AstDot($dot) -> {
                    if mutable {
                        node := dot.sub
                        loop {
                            match node {
                                AstDot($dot) -> {
                                    node = dot.sub
                                }
                                AstIdentifier($id) -> match id.symbol {
                                    .Decl($decl) -> {
                                        if !decl.mutable {
                                            workspace.error_handler.report_error_at(un.location, "Can't create mutable {} to immutable variabe", [str])
                                            poison(un)
                                            return un
                                        }

                                        break
                                    }

                                    _ -> break
                                }

                                _ -> break
                            }
                        }
                    }
                }
            }

            if reference {
                un.typ = workspace.reference_type(un.sub.typ, mutable)
            } else {
                un.typ = workspace.pointer_type(un.sub.typ, mutable)
            }
        }

        return un
    }

    compile_unary_deref :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)
        handle_poison(un, un.sub)

        if !un.sub.has_flags(.LValue) {
            workspace.error_handler.report_error_at(un.location, "Can't dereference non l-value")
            poison(un)
            return un
        }

        match un.sub.typ {
            TypeInfoPointer($ti) -> {
                un.typ = ti.target
            }
            TypeInfoReference($ti) -> {
                un.typ = ti.target
            }

            _ -> {
                workspace.error_handler.report_error_at(
                    un.location,
                    "Can't dereference value of type '{}'",
                    [un.sub.typ]
                )
                poison(un)
            }
        }
        return un
    }

    compile_binary :: (&Self, bin: &AstBinary, ctx: CNContext) -> &AstNode {
        bin.left.scope = bin.scope
        bin.right.scope = bin.scope

        bin.left <- compile_node(bin.left, ctx)
        bin.right <- compile_node(bin.right, ctx)

        handle_poison(bin, bin.left)
        handle_poison(bin, bin.right)

        // find matching operator
        match bin.operator {
            .Add -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Sub -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mul -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Div -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mod -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }

            .Equal      -> {
                bin.typ = @type_info(bool)
            }
            .NotEqual   -> {
                bin.typ = @type_info(bool)
            }
            .Less       -> {
                bin.typ = @type_info(bool)
            }
            .LessEq     -> {
                bin.typ = @type_info(bool)
            }
            .Greater    -> {
                bin.typ = @type_info(bool)
            }
            .GreaterEq  -> {
                bin.typ = @type_info(bool)
            }

            .And        -> {
                bin.typ = @type_info(bool)
            }
            .Or         -> {
                bin.typ = @type_info(bool)
            }

            .Move       -> {
                bin.typ = bin.left.typ
            }

            .Pipe       -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .Range      -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
            .RangeIncl  -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
        }

        // @todo
        return bin
    }

    compile_if :: (&Self, iff: &AstIf, ctx: CNContext) -> &AstNode {
        iff.condition.scope = iff.scope
        compile_node(iff.condition, ctx.with_expected(@type_info(bool)))
        if iff.condition.typ == null {
            return iff
        }

        match &*iff.condition.typ {
            TypeInfoBool(_) -> {}
            TypeInfoPointer(_) -> {}

            _ -> {
                workspace.error_handler.report_error_at(
                    iff.condition.location,
                    "Type of condition must be bool or pointer, but is {}",
                    [iff.condition.typ])
            }
        }

        iff.true_case.scope = iff.scope
        compile_node(iff.true_case, ctx)

        if iff.false_case != null {
            // compile else
            iff.false_case.scope = iff.scope
            compile_node(&*iff.false_case, ctx)

            // cal type of iff
            if iff.true_case.typ == iff.false_case.typ {
                iff.typ = iff.true_case.typ
            } else {
                // @todo: maybe we can do something better here
                iff.typ = @type_info(void)
            }
        } else {
            iff.typ = @type_info(void)
        }

        return iff
    }

    compile_import :: (&Self, node: &AstImport, ctx: CNContext) -> &AstNode {
        match node.path {
            AstString($str) -> {
                str.typ = @type_info(void)

                search_paths := Array[string].create()
                search_paths.add(fs.Path.get_containing_directory(node.location.file))
                search_paths.add(compiler.module_path)

                for search_path in &search_paths {
                    import_path := fs.Path.concat(*search_path, str.string_value)
                    import_path_n := fs.Path.normalize(import_path.slice())

                    match compiler.get_source(import_path_n.slice()) {
                        Err(_) -> continue
                    }
                    match workspace.get_file(import_path_n.slice()) {
                        Some($file) -> {
                            node.typ = workspace.new_module_type()
                            node.value = .Module(file)
                            return node
                        }
                    }

                    job := cast(^LoadFileJob) workspace.create_and_add_job(LoadFileJob.new(import_path_n.clone()))
                    wait_until(job.done, {})

                    match workspace.get_file(import_path_n.slice()) {
                        Some($file) -> {
                            node.typ = workspace.new_module_type()
                            node.value = .Module(file)
                            return node
                        }
                    }
                }

                workspace.error_handler.report_error_at(
                    node.path.location,
                    "Can't find file '{}'",
                    [str.string_value],
                    details = [("Searched in '{}'", cast([]^any)[search_paths.slice()])]
                )
                poison(node)
                return node
            }

            _ -> {
                workspace.error_handler.report_error_at(node.path.location, "Invalid import path")
                poison(node)
                return node
            }
        }

        return node
    }

    compile_index :: (&Self, node: &AstIndex, ctx: CNContext) -> &AstNode {
        node.sub.scope = node.scope
        node.sub <- compile_node(node.sub, ctx)
        handle_poison(node, node.sub)

        match node.sub.value {
            .Poly($poly) -> {
                if node.arguments.count() != poly.params.length {
                    workspace.error_handler.report_error_at(node.location, "Wrong number of arguments. Expected {}", [poly.params.length])
                    poison(node)
                    return node
                } else {
                    for arg in &node.arguments {
                        param := poly.params[it_index]

                        arg.scope = node.scope
                        evaluate_node(&**arg, ctx.with_expected(param.var_type))

                        if arg.value == .Poison {
                            poison(node)
                            return node
                        }
                        if !TypeInfo.same(arg.typ, param.var_type) {
                            workspace.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter '{}' ({}).",
                                [arg.typ, param.name, param.var_type])
                        }
                    }
                }

                cloner := AstCloner(workspace.next_ast_id, workspace.ast_allocator)
                clone := cloner.clone(^*poly.value_expr)
                if clone == null {
                    poison(node)
                    return node
                }

                scope := workspace.new_scope(poly.scope)

                for arg in &node.arguments {
                    param := poly.params[it_index]

                    scope.define_value(param.name, arg.typ, arg.value)
                }

                clone.scope = scope
                result := evaluate_node(&*clone, ctx)
                node.typ = result.typ
                node.value = result.value
                return node
            }
        }

        match node.sub.typ {
            TypeInfoArray($ti) -> {
                for arg in &node.arguments {
                    arg.scope = node.scope
                    compile_node(&**arg, ctx)
                    handle_poison(node, **arg)
                }
                node.index = *node.arguments[0]

                if node.arguments.count() != 1 {
                    workspace.error_handler.report_error_at(node.location, "Wrong number of arguments. Expected 1")
                    poison(node)
                    return node
                }

                match node.index.typ {
                    TypeInfoInt(_) -> {
                        // ok
                        node.typ = ti.target
                    }

                    _ -> {
                        workspace.error_handler.report_error_at(
                            node.index.location,
                            "Type '{}' can't be used as index for type '{}'",
                            [node.index.typ, node.sub.typ])
                        poison(node)
                        return node
                    }
                }
            }

            _ -> {
                workspace.error_handler.report_error_at(
                    node.sub.location,
                    "Type '{}' has not operator '[]'",
                    [node.sub.typ])
                poison(node)
                return node
            }
        }

        return node
    }

    compile_loop :: (&Self, lop: &AstLoop, ctx: CNContext) -> &AstNode {
        lop.typ = @type_info(void)
        lop.body.scope = lop.scope
        compile_node(lop.body, ctx)
        return lop
    }

    compile_for :: (&Self, forr: &AstFor, ctx: CNContext) -> &AstNode {
        forr.typ = @type_info(void)
        forr.collection.scope = forr.scope
        compile_node(forr.collection, ctx.with_expected(null))
        forr.body.scope = forr.scope
        compile_node(forr.body, ctx)
        return forr
    }

    compile_break :: (&Self, brake: &AstBreak, ctx: CNContext) -> &AstNode {
        brake.typ = @type_info(void)
        if brake.value_expr != null {
            brake.value_expr.scope = brake.scope
            compile_node(&*brake.value_expr, ctx)
        }
        return brake
    }

    compile_continue :: (&Self, cont: &AstContinue, ctx: CNContext) -> &AstNode {
        cont.typ = @type_info(void)
        return cont
    }

    compile_return :: (&Self, ret: &AstReturn, ctx: CNContext) -> &AstNode {
        if self.function == null {
            workspace.error_handler.report_error_at(ret.location, "Can't use return outside of a function")
            return ret
        }

        ret.typ = @type_info(void)
        if ret.value_expr != null {
            ret.value_expr.scope = ret.scope
            compile_node(&*ret.value_expr, ctx.with_expected(self.function.return_type))

            if !TypeInfo.same(ret.value_expr.typ, self.function.return_type) {
                workspace.error_handler.report_error_at(
                    ret.value_expr.location,
                    "Type of return value ({}) does not match return type of containing function ({}).",
                    [ret.value_expr.typ, self.function.return_type])
            }
        }

        return ret
    }

    compile_defer :: (&Self, def: &AstDefer, ctx: CNContext) -> &AstNode {
        def.typ = @type_info(void)
        def.sub.scope = def.scope
        compile_node(def.sub, ctx.with_expected(null))
        return def
    }

    compile_string :: (&Self, str: &AstString, ctx: CNContext) -> &AstNode {
        str.typ = @type_info(string) // @todo: string_literal type
        str.value = .String(str.string_value)
        return str
    }

    compile_struct :: (&Self, str: &AstStruct, ctx: CNContext) -> &AstNode {
        str.typ = @type_info(type)
        str.sub_scope = workspace.new_scope(str.scope)

        jobs := Array[^CompileStructMemberJob].create()

        // @todo: create a job for each child, so children can depend on other children
        for child in &str.children {
            child.scope = str.sub_scope
            child.set_flags(.AllowPubModifier)
            job := workspace.create_job(CompileStructMemberJob.new(^*str, *child))
            jobs.add(cast job)
            workspace.add_job(job)
        }

        for job in &jobs {
            wait_until(job.done, {
                // nothing to see here...
            })
        }
        str.members_done = true

        // create type info
        member_type_infos := workspace.new_type_data_array(TypeInfoStructMember, str.members.count())
        for mem in &str.members {
            member_type_infos[it_index].index = it_index
            member_type_infos[it_index].name = mem.name
            member_type_infos[it_index].typ = mem.var_type
        }
        str.struct_type = workspace.new_type(TypeInfoStruct(
            size        = -1        // will be calculated later
            alignment   = -1        // will be calculated later
            traits      = []        // will be calculated later
            impl_funcs  = []        // will be calculated later
            name        = str.name
            members     = member_type_infos
        ))
        workspace.register_struct(cast str.struct_type, ^*str)

        // calculate size and alignment
        {
            alignment   := 1
            size        := 0
            for mem in &str.members {
                wait_until(mem.var_type.size >= 0 and mem.var_type.alignment >= 0, {
                    workspace.error_handler.report_error_at(
                        str.location,
                        "Failed to compute size and alignment of struct type. Size of member '{}' unknown"
                        [mem.name])
                })

                // g_logger.log("mem: {}, {}", [mem.])

                member_type_infos[it_index].offset = util.next_aligned_num(size, mem.var_type.alignment)
                alignment = max(alignment, mem.var_type.alignment)
                size += mem.var_type.size
                size = util.next_aligned_num(size, mem.var_type.alignment)
            }

            size = util.next_aligned_num(size, alignment)

            str.struct_type.size = size
            str.struct_type.alignment = alignment
        }

        str.value = .Type(str.struct_type)
        return str
    }

    compile_bool :: (&Self, bol: &AstBool, ctx: CNContext) -> &AstNode {
        bol.typ = @type_info(bool)
        bol.value = .Bool(bol.bool_value)
        return bol
    }

    compile_number :: (&Self, num: &AstNumberLiteral, ctx: CNContext) -> &AstNode {
        num.typ = match num.value {
            .Int(_) -> @type_info(int)
            .Float(_) -> @type_info(f64)
            _ -> @assert(false)
        }
        return num
    }

    compile_poly :: (&Self, poly: &AstPoly, ctx: CNContext) -> &AstNode {
        poly.param_scope = workspace.new_scope(poly.scope)
        poly.value_expr.scope = poly.param_scope

        match poly.value_expr {
            AstFunction($func) -> {
                func.name = poly.name
            }
            AstStruct($str) -> {
                str.name = poly.name
            }
            AstEnum($en) -> {
                en.name = poly.name
            }
            AstTrait($tr) -> {
                tr.name = poly.name
            }
            AstPoly($poly) -> {
                poly.name = poly.name
            }
        }

        for param in &poly.params {
            param.scope = poly.scope
            compile_node(&**param, ctx.with_expected(null))
            handle_poison(poly, **param)
        }

        poly.typ = @type_info(void)
        poly.value = .Poly(^*poly)
        return poly
    }

    compile_identifier :: (&Self, id: &AstIdentifier, ctx: CNContext) -> &AstNode {
        id.symbol = id.scope.get_symbol(id.name, AstNode.has_flags(id, .OnlyPubDeclarations))
        match id.symbol {
            .Val($value) -> {
                id.typ = value.typ
                id.value = value.value
            }

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None and decl.value_expr.typ != null, {
                    workspace.error_handler.report_error_at(id.location, "Failed to get value and type of constant declaration")
                })
                id.typ = decl.value_expr.typ // @todo: get type of type expr if available
                id.value = decl.value_expr.value
            }

            .Decl($decl) -> {
                wait_until(decl.var_type != null, {
                    workspace.error_handler.report_error_at(id.location, "Failed to get type of declaration")
                })
                AstNode.set_flags(id, .LValue)
                id.typ = decl.var_type
            }

            .NativeFunc($func) -> {
                id.typ = cast func.function_type
                id.value = .NativeFunc(func)
            }

            .NotFound -> {
                workspace.error_handler.report_error_at(id.location, "Unknown symbol '{}'", [id.name])
                poison(id)
                loop Fiber.yield()
                return id
            }

            .Private($node) -> {
                workspace.error_handler.report_error_at(id.location, "Can't access '{}' from here because it's not public", [id.name],
                    details = [("'{}' defined here: {}", [id.name, node.location])])
                poison(id)
                return id
            }

            .Poison -> {
                workspace.error_handler.report_error_at(id.location, "Can't use variable '{}' in constant context", [id.name])
                poison(id)
                return id
            }

            $sym -> {
                workspace.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [sym])
                poison(id)
                return id
            }
        }

        return id
    }

    compile_argument :: (&Self, arg: &AstArgument, ctx: CNContext) -> &AstNode {
        arg.value_expr.scope = arg.scope
        arg.value_expr <- compile_node(arg.value_expr, ctx)
        arg.typ = arg.value_expr.typ
        arg.value = arg.value_expr.value
        return arg
    }

    compile_cast :: (&Self, cst: &AstCast, ctx: CNContext) -> &AstNode {
        if cst.type_expr == null {
            workspace.error_handler.report_error_at(cst.location, "Auto cast not implemented yet.")
            poison(cst)
            return cst
        }
        cst.type_expr.scope = cst.scope
        cst.type_expr = ^*evaluate_node(&*cst.type_expr, ctx.with_expected(@type_info(type)))

        if cst.type_expr.value == .Poison {
            poison(cst)
            return cst
        }

        if cst.type_expr.typ != @type_info(type) {
            workspace.error_handler.report_error_at(cst.location, "Expected type, got ({})", [cst.type_expr.typ])
            poison(cst)
            return cst
        }

        @assert(cst.type_expr.value == .Type)
        cst.typ = cst.type_expr.value.Type

        cst.value_expr.scope = cst.scope
        cst.value_expr <- compile_node(cst.value_expr, ctx.with_expected(cst.typ))

        if cst.value_expr.value == .Poison {
            poison(cst)
            return cst
        }

        // if type is same, return sub expression since cast is not necesarry
        if cst.value_expr.typ == cst.typ {
            return cst.value_expr
        }

        // check if cast is valid
        // @todo

        return cst
    }

    compile_call :: (&Self, call: &AstCall, ctx: CNContext) -> &AstNode {
        call.function.scope = call.scope
        call.function <- compile_node(call.function, ctx.with_expected(null))

        if call.function.value == .Poison {
            poison(call)
            return call
        }

        match call.function {
            AstUfc($ufc) -> {
                new_args := Array[^AstArgument].create(call.arguments.count() + 1)
                new_args.add(workspace.new_ast(AstArgument(
                    location    = ufc.location
                    scope       = ufc.scope
                    name        = null
                    value_expr  = ufc.value_expr
                )))
                for arg in &call.arguments {
                    new_args.add(*arg)
                }
                call.arguments = new_args
            }
        }

        {
            // dump := pretty_print_typed_ast(call)
            // g_logger.log("dump: {}", [dump])
        }

        match call.function.value {
            .Type($typ) -> {
                if call.arguments.count() != 1 {
                    workspace.error_handler.report_error_at(call.location, "Cast requires exactly one argument");
                    poison(call)
                    return call
                }

                // create cast
                cast_ast := workspace.new_ast(AstCast(
                    id          = -1
                    location    = call.location
                    scope       = call.scope
                    type_expr   = ^*call.function
                    value_expr  = &**call.arguments[0]
                ))

                return compile_node(&*cast_ast, ctx)
            }

            .Function($func) -> {
                // call.typ = cast typ
                // call.value = value
                call.ast_function = func

                if call.arguments.count() != func.params.length {
                    workspace.error_handler.report_error_at(call.location, "Wrong number of arguments in function call")
                } else {
                    for arg in &call.arguments {
                        param := func.params[it_index]

                        arg.scope = call.scope
                        *arg = cast ^*compile_node(&**arg, ctx.with_expected(param.var_type))

                        if arg.value == .Poison {
                            poison(call)
                            return call
                        }
                        if !TypeInfo.same(arg.typ, param.var_type) {
                            workspace.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter '{}' ({}).",
                                [arg.typ, param.name, param.var_type])
                        }
                    }
                }

                call.typ = func.return_type
            }

            .NativeFunc($func) -> {
                func_type := cast(^TypeInfoFunction) call.function.typ

                call.typ = func_type.return_type

                if call.arguments.count() != func_type.param_types.length {
                    workspace.error_handler.report_error_at(
                        call.location,
                        "Wrong number of arguments ({}) in function call. Expected {}",
                        [call.arguments.count(), func_type.param_types.length])
                } else {
                    for arg in &call.arguments {
                        param_type := *func_type.param_types[it_index]
                        arg.scope = call.scope
                        *arg = cast ^*compile_node(&**arg, ctx.with_expected(param_type))

                        if arg.value == .Poison {
                            poison(call)
                            return call
                        }
                        if !TypeInfo.same(arg.typ, param_type) {
                            workspace.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter ({}).",
                                [arg.typ, param_type])
                        }
                    }
                }
            }

            .NativeFunc2($func) -> {
                func_type := cast(^TypeInfoFunction) call.function.typ

                call.typ = func_type.return_type

                if call.arguments.count() != func_type.param_types.length {
                    workspace.error_handler.report_error_at(
                        call.location,
                        "Wrong number of arguments ({}) in function call. Expected {}",
                        [call.arguments.count(), func_type.param_types.length])
                } else {
                    for arg in &call.arguments {
                        param_type := *func_type.param_types[it_index]
                        arg.scope = call.scope
                        *arg = cast ^*compile_node(&**arg, ctx.with_expected(param_type))

                        if arg.value == .Poison {
                            poison(call)
                            return call
                        }
                        if !TypeInfo.same(arg.typ, param_type) {
                            workspace.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter ({}).",
                                [arg.typ, param_type])
                        }
                    }
                }
            }

            $val -> {
                workspace.error_handler.report_error_at(call.function.location, "[compile_call] not implemented: {}", [val])
                poison(call)
                return call
            }
        }

        return call
    }

    compile_block :: (&Self, block: &AstBlock, ctx: CNContext) -> &AstNode {
        block.sub_scope = workspace.new_scope(block.scope)

        for child in &block.children {
            // g_logger.log("compile_block {}", [it_index])

            child.scope = block.sub_scope

            expected : ^TypeInfo = if it_index == block.children.count() - 1 then ctx.expected else null
            *child = ^*compile_node(&**child, ctx.with_expected(expected))

            if child.value == .Poison {
                poison(block)
                return block
            }
        }

        // calc type of block
        if block.children.count() > 0 {
            block.typ = block.children.peek_last().typ
        } else {
            block.typ = @type_info(void)
        }

        return block
    }

    compile_function :: (&Self, func: &AstFunction, ctx: CNContext) -> &AstNode {
        // debug_log("compile_function")
        // @todo: polymorphic functions

        _prev_func := self.function
        self.function = ^*func
        defer self.function = _prev_func

        debug_log("compile_function '{}': Begin", [func.name])
        func.param_scope = workspace.new_scope(func.scope)
        func.body.scope = func.param_scope
        func.value = Value.Function(^*func)

        // infer types of parameters
        param_types := mem.alloc_n(^TypeInfo, cast func.params.count(), workspace.type_allocator)
        for param in &func.params {
            param.scope = func.param_scope

            param.name = match param.pattern {
                AstIdentifier($id) -> id.name
                _ if param.pattern == null -> "_"

                _ -> {
                    workspace.error_handler.report_error_at(param.location, "Non-identifier patterns not implemented yet")
                    return func
                }
            }

            // compile type expression
            if param.type_expr != null {
                param.type_expr.scope = param.scope
                param.type_expr = ^*compile_node(&*param.type_expr, ctx.with_expected(@type_info(type)))
                
                if param.type_expr.typ != @type_info(type) {
                    workspace.error_handler.report_error_at(param.type_expr.location, "Expected type, got {}", [param.type_expr.typ])
                    return func
                } else {
                    @assert(param.type_expr.value == .Type)
                    param.var_type = param.type_expr.value.Type
                }
            }

            // default value
            if param.value_expr != null {
                param.value_expr = ^*compile_node(&*param.value_expr, ctx.with_expected(param.var_type))
                if param.value_expr.typ == null { return func }
                param.value = param.value_expr.value

                if param.var_type == null {
                    param.var_type = param.value_expr.typ
                }
            }

            // define param
            if param.name != "_" {
                match param.scope.define_decl(param.name, &**param) {
                    Err() -> {
                        workspace.error_handler.report_error_at(param.pattern.location, "A parameter with this name already exists")
                    }
                }
            }

            *param_types[it_index] = param.var_type
        }

        // handle return type
        func.return_type = @type_info(void)
        if func.return_type_expr != null {
            func.return_type_expr.scope = func.param_scope
            func.return_type_expr = ^*compile_node(&*func.return_type_expr, ctx.with_expected(@type_info(type)))

            if func.return_type_expr.value == .Poison {
                poison(func)
                return func
            } else if func.return_type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(func.return_type_expr.location, "Expected type, got {}", [func.return_type_expr.typ])
                poison(func)
                return func
            } else {
                @assert(func.return_type_expr.value == .Type)
                func.return_type = func.return_type_expr.value.Type
            }
        }

        // set function type
        func.typ = workspace.new_type(TypeInfoFunction(
            size        = 8
            alignment   = 8
            traits      = []
            impl_funcs  = []
            param_types = param_types
            return_type = func.return_type
        ))

        // compile body
        debug_log("compile_function '{}': Compile Body", [func.name])
        func.body = ^*compile_node(&*func.body, ctx.with_expected(null)) // @todo: use return type as expected?
        if func.body.value == .Poison {
            poison(func)
            return func
        }

        // generate byte code
        debug_log("compile_function '{}': Generate Bytecode", [func.name])
        code_gen := ByteCodeGenerator.new(&workspace.string_database, &*workspace.error_handler, workspace.bc_allocator)
        code_gen.get().generate_code_for_function(^*func)

        debug_log("compile_function '{}': End", [func.name])
        return func
    }

    compile_decl :: (&Self, decl: &AstDecl, ctx: CNContext) -> &AstNode {
        decl.typ = @type_info(void)
        if !AstNode.has_flags(decl, .IsDefinedInScope) {

            decl.name = match &*decl.pattern {
                AstIdentifier($id) -> id.name
                _ -> {
                    workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                    return decl
                }
            }

            // define symbol but only if not _
            if decl.name != "_" {
                match decl.scope.define_decl(decl.name, decl) {
                    Err() -> {
                        workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                    }
                }
            }
        }

        if decl.public and !AstNode.has_flags(decl, .AllowPubModifier) {
            workspace.error_handler.report_error_at(decl.pattern.location, "Modifier 'pub' is not allowed here")
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^*compile_node(&*decl.type_expr, ctx.with_expected(@type_info(type)))
            
            // error handling
            if decl.type_expr.value == .Poison {
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            } else if decl.type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        // compile value if present
        if decl.value_expr != null {
            decl.value_expr.scope = decl.scope
            decl.value_expr = ^*compile_node(&*decl.value_expr, ctx.with_expected(decl.var_type))
            if decl.value_expr.typ == null { return decl }
            decl.value = decl.value_expr.value

            // error handling
            if decl.value_expr.value == .Poison {
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            }

            if decl.var_type == null {
                decl.var_type = decl.value_expr.typ
            }

            if !TypeInfo.same(decl.value_expr.typ, decl.var_type) {
                workspace.error_handler.report_error_at(decl.value_expr.location, "Value type ({}) does not match expected type ({})", [decl.value_expr.typ, decl.var_type])
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            }
        }

        // check if var_type is valid
        if !validate_variable_type(decl.var_type, decl.pattern.location) {
            return decl
        }

        // @todo: create cast if necessary

        return decl
    }

    validate_variable_type :: (&Self, typ: ^TypeInfo, location: Location) -> bool {
        @assert(typ != null)
        if typ == @type_info(void) {
            workspace.error_handler.report_error_at(location, "Variable can't have type {}", [typ])
            return false
        }

        return true
    }

    compile_const_decl :: (&Self, decl: &AstConstDecl, ctx: CNContext) -> &AstNode {
        debug_log("compile_const_decl")
        decl.typ = @type_info(void)

        if !AstNode.has_flags(decl, .IsDefinedInScope) {
            decl.value_expr.scope = decl.scope

            name := match decl.pattern {
                AstIdentifier($id) -> id.name
                _ -> {
                    workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                    return decl
                }
            }


            // set name of value expr if its a function or struct/trait/enum
            match decl.value_expr {
                AstFunction($func) -> {
                    func.name = name
                }
                AstStruct($str) -> {
                    str.name = name
                }
                AstEnum($en) -> {
                    en.name = name
                }
                AstTrait($tr) -> {
                    tr.name = name
                }
                AstPoly($poly) -> {
                    poly.name = name
                }
            }


            // define symbol but only if not _
            if name != "_" {
                match decl.scope.define_const_decl(name, decl) {
                    Err() -> {
                        workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                    }
                }
            }
        }

        if decl.public and !AstNode.has_flags(decl, .AllowPubModifier) {
            workspace.error_handler.report_error_at(decl.pattern.location, "Modifier 'pub' is not allowed here")
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^*compile_node(&*decl.type_expr, ctx.with_expected(@type_info(type)))
            
            if decl.type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        debug_log("compile_const_decl 1")

        decl.value_expr <- evaluate_node(decl.value_expr, ctx.with_expected(decl.var_type))
        debug_log("compile_const_decl 2")
        decl.value = decl.value_expr.value

        if decl.value == .Poison {
            poison(decl)
            return decl
        }

        debug_log("compile_const_decl 3")

        if decl.value_expr.typ != @type_info(void) and decl.value == .None {
            workspace.error_handler.report_error_at(decl.value_expr.location, "Value is not constant")
            poison(decl)
            return decl
        }

        if decl.var_type == null {
            decl.var_type = decl.value_expr.typ
        }

        // @todo: create cast if necessary

        return decl
    }
}


#file_scope

handle_poison :: (node: &AstNode, possible_poison: Code) #macro {
    if @insert(possible_poison).value == .Poison {
        node.typ = @type_info(void)
        node.value = .Poison
        return node
    }
}

poison :: (node: &AstNode) {
    node.typ = @type_info(void)
    node.value = .Poison
}

impl TypeInfo {
    same :: (a: ^TypeInfo, b: ^TypeInfo) -> bool {
        if a == b {
            return true
        }

        return match a, b {
            TypeInfoArray($a), TypeInfoArray($b) -> a.count == b.count and same(a.target, b.target)

            // TypeInfoPointer($a), TypeInfoPointer($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            // TypeInfoReference($a), TypeInfoReference($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            TypeInfoPointer($a), TypeInfoPointer($b) -> same(a.target, b.target)
            TypeInfoReference($a), TypeInfoReference($b) -> same(a.target, b.target)

            // temp
            // TypeInfoPointer($a), TypeInfoReference($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            // TypeInfoReference($a), TypeInfoPointer($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            TypeInfoPointer($a), TypeInfoReference($b) -> same(a.target, b.target)
            TypeInfoReference($a), TypeInfoPointer($b) -> same(a.target, b.target)
            //

            TypeInfoFunction($a), TypeInfoFunction($b) -> {
                if a.param_types.length != b.param_types.length {
                    return false
                }
                if !same(a.return_type, b.return_type) {
                    return false
                }
                for 0 .. a.param_types.length {
                    if !same(*a.param_types[it], *b.param_types[it]) {
                        return false
                    }
                }
                return true
            }

            _ -> false
        }
    }
}