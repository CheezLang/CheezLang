use import std.array
use import std.fiber
use import std.mem.std_heap_allocator
use import std.printable
use import std.string

fmt :: import std.fmt
fs  :: import std.io.fs
io  :: import std.io
mem :: import std.mem.allocator

use import logging.logger

use import ast
use import ast_dumper
use import ast_pretty_printer
use import bytecode_generator
use import compiler
use import config
use import lexer
use import parser
use import scope
use import types
use import validator
use import value


#export_scope

CompilationJob :: trait {
    cancelled   : bool = false
    progressed  : bool = false
    done        : bool = false
    compiler    : ^Compiler = null

    get_name :: (&Self) -> string;
    execute :: (&Self, compiler: &Compiler);
}

LoadFileJob :: struct CompilationJob {
    name : String
    path : String
}

impl LoadFileJob {
    new :: (path: String) -> LoadFileJob {
        return LoadFileJob(
            name = fmt.format("LoadFileJob '{}'", [path])
            path = path
        )
    }
}

RunCodeJob :: struct CompilationJob {
    name        : String
    function    : ^AstFunction
}

impl RunCodeJob {
    new :: (function: ^AstFunction) -> RunCodeJob {
        return RunCodeJob(
            name        = fmt.format("RunCodeJob '{}'", [function.name])
            function    = function
        )
    }
}

CompileGlobalNodeJob :: struct CompilationJob {
    name        : String
    node        : ^AstNode
    function    : ^AstFunction = null
}

impl CompileGlobalNodeJob {
    new :: (node: ^AstNode) -> CompileGlobalNodeJob {
        return CompileGlobalNodeJob(
            name = fmt.format("CompileGlobalNodeJob #{}", [node.id])
            node = node
        )
    }
}

CNContext :: struct #copy {
    expected : ^TypeInfo = null
}

impl CNContext {
    with_expected :: (Self, typ: ^TypeInfo) -> CNContext {
        expected = typ
        return self
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [CompileGlobalNode #{}] {}", [Fiber.user_data(FiberContext).thread, node.id, str])
        } 
    }

    execute :: (&Self, compiler: &Compiler) {
        debug_log("Begin compilation")

        node.scope = compiler.global_scope
        compile_node(<<node, CNContext())

        if const VALIDATE_AST {
            debug_log("Validate node", [])
            if !validate_node(<<node, compiler.error_handler) {
                // @todo
            }
        }

        if const PRINT_TYPED_AST {
            dump := pretty_print_typed_ast(<<node)
            g_logger.log("{}", [dump])
        }

        debug_log("Done")
    }

    compile_node :: (&Self, node: &AstNode, ctx: CNContext) -> &AstNode {
        return match node {
            AstArgument($arg)       -> compile_argument(arg, ctx)
            AstBinary($bin)         -> compile_binary(bin, ctx)
            AstUnary($un)           -> compile_unary(un, ctx)
            AstBlock($block)        -> compile_block(block, ctx)
            AstBool($bol)           -> compile_bool(bol, ctx)
            AstBreak($brake)        -> compile_break(brake, ctx)
            AstCall($call)          -> compile_call(call, ctx)
            AstConstDecl($decl)     -> compile_const_decl(decl, ctx)
            AstContinue($cont)      -> compile_continue(cont, ctx)
            AstDecl($decl)          -> compile_decl(decl, ctx)
            AstDefer($def)          -> compile_defer(def, ctx)
            AstFor($forr)           -> compile_for(forr, ctx)
            AstFunction($func)      -> compile_function(func, ctx)
            AstIdentifier($id)      -> compile_identifier(id, ctx)
            AstIf($iff)             -> compile_if(iff, ctx)
            AstLoop($lop)           -> compile_loop(lop, ctx)
            AstNumberLiteral($num)  -> compile_number(num, ctx)
            AstReturn($ret)         -> compile_return(ret, ctx)
            AstString($str)         -> compile_string(str, ctx)

            _ -> {
                dump := dump_ast(node, recurse = false)
                compiler.error_handler.report_error_at(node.location, "compile_node: not implemented: {}", [dump])
                node
            }
        }

        return node
    }

    compile_unary :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        return match un.operator {
            .Neg    -> compile_unary_neg(un, ctx)
            .Not    -> compile_unary_not(un, ctx)
            .Ref    -> compile_unary_ref(un, ctx)
            .RefMut -> compile_unary_ref_mut(un, ctx)
            .Ptr    -> compile_unary_ptr(un, ctx)
            .Deref  -> compile_unary_deref(un, ctx)
        }
    }

    compile_unary_neg :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)

        // check types
        if un.sub.typ == null { return un }

        match &<<un.sub.typ {
            TypeInfoInt(_) -> {}
            TypeInfoFloat(_) -> {}

            $ti -> {
                compiler.error_handler.report_error_at(
                    un.sub.location,
                    "Expected type bool, got {}",
                    [un.sub.typ])
                return un
            }
        }
        un.typ = un.sub.typ

        // set value if known at compile time
        match un.value {
            .Int($b) -> {
                un.value = .Int(-b)
            }
            .Float($b) -> {
                un.value = .Float(-b)
            }
        }
        return un
    }

    compile_unary_not :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx.with_expected(@type_info(bool)))

        // check types
        if un.sub.typ == null { return un }
        if un.sub.typ != @type_info(bool) {
            compiler.error_handler.report_error_at(
                un.sub.location,
                "Expected type bool, got {}",
                [un.sub.typ])
            return un
        }

        un.typ = @type_info(bool)

        // set value if known at compile time
        match un.value {
            .Bool($b) -> {
                un.value = .Bool(!b)
            }
        }
        return un
    }

    compile_unary_ref :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        compiler.error_handler.report_error_at(un.location, "compile_unary_ref: not implemented")
        return un
    }

    compile_unary_ref_mut :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        compiler.error_handler.report_error_at(un.location, "compile_unary_ref_mut: not implemented")
        return un
    }

    compile_unary_ptr :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        compiler.error_handler.report_error_at(un.location, "compile_unary_ptr: not implemented")
        return un
    }

    compile_unary_deref :: (&Self, un: &AstUnary, ctx: CNContext) -> &AstNode {
        compiler.error_handler.report_error_at(un.location, "compile_unary_deref: not implemented")
        return un
    }

    compile_binary :: (&Self, bin: &AstBinary, ctx: CNContext) -> &AstNode {
        bin.left.scope = bin.scope
        bin.right.scope = bin.scope

        bin.left <- compile_node(bin.left, ctx)
        bin.right <- compile_node(bin.right, ctx)

        if bin.left.typ == null or bin.right.typ == null {
            return bin
        }

        // find matching operator
        match bin.operator {
            .Add -> {
                if bin.left.typ != bin.right.typ {
                    compiler.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Sub -> {
                if bin.left.typ != bin.right.typ {
                    compiler.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mul -> {
                if bin.left.typ != bin.right.typ {
                    compiler.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Div -> {
                if bin.left.typ != bin.right.typ {
                    compiler.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mod -> {
                if bin.left.typ != bin.right.typ {
                    compiler.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }

            .Equal      -> {
                bin.typ = @type_info(bool)
            }
            .NotEqual   -> {
                bin.typ = @type_info(bool)
            }
            .Less       -> {
                bin.typ = @type_info(bool)
            }
            .LessEq     -> {
                bin.typ = @type_info(bool)
            }
            .Greater    -> {
                bin.typ = @type_info(bool)
            }
            .GreaterEq  -> {
                bin.typ = @type_info(bool)
            }

            .And        -> {
                bin.typ = @type_info(bool)
            }
            .Or         -> {
                bin.typ = @type_info(bool)
            }

            .Assign     -> {
                bin.typ = @type_info(void)
            }

            .Move       -> {
                bin.typ = bin.left.typ
            }

            .Pipe       -> {
                compiler.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .Range      -> {
                compiler.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
            .RangeIncl  -> {
                compiler.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
        }

        // @todo
        return bin
    }

    compile_if :: (&Self, iff: &AstIf, ctx: CNContext) -> &AstNode {
        iff.condition.scope = iff.scope
        compile_node(iff.condition, ctx.with_expected(@type_info(bool)))
        if iff.condition.typ == null {
            return iff
        }

        match &<<iff.condition.typ {
            TypeInfoBool(_) -> {}
            TypeInfoPointer(_) -> {}

            _ -> {
                compiler.error_handler.report_error_at(
                    iff.condition.location,
                    "Type of condition must be bool or pointer, but is {}",
                    [iff.condition.typ])
            }
        }

        iff.true_case.scope = iff.scope
        compile_node(iff.true_case, ctx)

        if iff.false_case != null {
            // compile else
            iff.false_case.scope = iff.scope
            compile_node(<<iff.false_case, ctx)

            // cal type of iff
            if iff.true_case.typ == iff.false_case.typ {
                iff.typ = iff.true_case.typ
            } else {
                // @todo: maybe we can do something better here
                iff.typ = @type_info(void)
            }
        } else {
            iff.typ = @type_info(void)
        }

        return iff
    }

    compile_loop :: (&Self, lop: &AstLoop, ctx: CNContext) -> &AstNode {
        lop.typ = @type_info(void)
        lop.body.scope = lop.scope
        compile_node(lop.body, ctx)
        return lop
    }

    compile_for :: (&Self, forr: &AstFor, ctx: CNContext) -> &AstNode {
        forr.typ = @type_info(void)
        forr.collection.scope = forr.scope
        compile_node(forr.collection, ctx.with_expected(null))
        forr.body.scope = forr.scope
        compile_node(forr.body, ctx)
        return forr
    }

    compile_break :: (&Self, brake: &AstBreak, ctx: CNContext) -> &AstNode {
        brake.typ = @type_info(void)
        if brake.value_expr != null {
            brake.value_expr.scope = brake.scope
            compile_node(<<brake.value_expr, ctx)
        }
        return brake
    }

    compile_continue :: (&Self, cont: &AstContinue, ctx: CNContext) -> &AstNode {
        cont.typ = @type_info(void)
        return cont
    }

    compile_return :: (&Self, ret: &AstReturn, ctx: CNContext) -> &AstNode {
        if self.function == null {
            compiler.error_handler.report_error_at(ret.location, "Can't use return outside of a function")
            return ret
        }

        ret.typ = @type_info(void)
        if ret.value_expr != null {
            ret.value_expr.scope = ret.scope
            compile_node(<<ret.value_expr, ctx.with_expected(self.function.return_type))

            if ret.value_expr.typ != self.function.return_type {
                compiler.error_handler.report_error_at(
                    ret.value_expr.location,
                    "Type of return value ({}) does not match return type of containing function ({}).",
                    [ret.value_expr.typ, self.function.return_type])
            }
        }

        return ret
    }

    compile_defer :: (&Self, def: &AstDefer, ctx: CNContext) -> &AstNode {
        def.typ = @type_info(void)
        def.sub.scope = def.scope
        compile_node(def.sub, ctx.with_expected(null))
        return def
    }


    compile_string :: (&Self, str: &AstString, ctx: CNContext) -> &AstNode {
        str.typ = @type_info(string) // @todo: string_literal type
        str.value = .String(str.string_value)
        return str
    }

    compile_bool :: (&Self, bol: &AstBool, ctx: CNContext) -> &AstNode {
        bol.typ = @type_info(bool)
        bol.value = .Bool(bol.bool_value)
        return bol
    }

    compile_number :: (&Self, num: &AstNumberLiteral, ctx: CNContext) -> &AstNode {
        num.typ = match num.value {
            .Int(_) -> @type_info(int)
            .Float(_) -> @type_info(f64)
            _ -> @assert(false)
        }
        return num
    }

    compile_identifier :: (&Self, id: &AstIdentifier, ctx: CNContext) -> &AstNode {
        id.symbol = id.scope.get_symbol(id.name)
        match id.symbol {
            .Val($value) -> {
                id.typ = value.typ
                id.value = value.value
            }

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None, {
                    compiler.error_handler.report_error_at(id.location, "Failed to get value of constant declaration")
                })
                id.typ = decl.value_expr.typ // @todo: get type of type expr if available
                id.value = decl.value_expr.value
            }

            .Decl($decl) -> {
                wait_until(decl.var_type != null, {
                    compiler.error_handler.report_error_at(id.location, "Failed to get type of declaration")
                })
                id.typ = decl.var_type
            }

            .NativeFunc($func) -> {
                id.typ = cast func.function_type
                id.value = .NativeFunc(func)
            }

            .NotFound -> {
                compiler.error_handler.report_error_at(id.location, "Unknown symbol '{}'", [id.name])
                Fiber.yield()
            }

            $sym -> {
                id.typ = @type_info(void)
                compiler.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [sym])
            }
        }

        return id
    }

    compile_argument :: (&Self, arg: &AstArgument, ctx: CNContext) -> &AstNode {
        arg.value_expr.scope = arg.scope
        arg.value_expr <- compile_node(arg.value_expr, ctx)
        arg.typ = arg.value_expr.typ
        arg.value = arg.value_expr.value
        return arg
    }

    compile_call :: (&Self, call: &AstCall, ctx: CNContext) -> &AstNode {
        call.function.scope = call.scope
        call.function <- compile_node(call.function, ctx.with_expected(null))
        
        call.typ = @type_info(void)

        match call.function.value {
            .Function($func) -> {
                // call.typ = cast typ
                // call.value = value
                call.ast_function = func

                if call.arguments.count() != func.params.length {
                    compiler.error_handler.report_error_at(call.location, "Wrong number of arguments in function call")
                } else {
                    for arg : call.arguments {
                        param := &func.params[it_index]

                        arg.scope = call.scope
                        arg = cast ^compile_node(<<arg, ctx.with_expected(param.var_type))

                        if arg.typ != param.var_type {
                            compiler.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter '{}' ({}).",
                                [arg.typ, param.name, param.var_type])
                        }
                    }
                }

                call.typ = func.return_type
            }

            .NativeFunc($func) -> {
                g_logger.log("Native call: ", [call.function.typ])
                func_type := cast(^TypeInfoFunction) call.function.typ

                call.typ = func_type.return_type

                if call.arguments.count() != func_type.param_types.length {
                    compiler.error_handler.report_error_at(
                        call.location,
                        "Wrong number of arguments ({}) in function call. Expected {}",
                        [call.arguments.count(), func_type.param_types.length])
                } else {
                    for arg : call.arguments {
                        param_type := &func_type.param_types[it_index]
                        arg.scope = call.scope
                        arg = cast ^compile_node(<<arg, ctx.with_expected(param_type))

                        if arg.typ != param_type {
                            compiler.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter ({}).",
                                [arg.typ, param_type])
                        }
                    }
                }
            }

            $val -> {
                compiler.error_handler.report_error_at(call.location, "[compile_call] not implemented: {}", [val])
            }
        }

        return call
    }

    compile_block :: (&Self, block: &AstBlock, ctx: CNContext) -> &AstNode {
        block.sub_scope = compiler.new_scope(block.scope)

        for child : block.children {
            child.scope = block.sub_scope

            expected : ^TypeInfo = if it_index == block.children.count() - 1 then ctx.expected else null
            child = ^compile_node(<<child, ctx.with_expected(expected))
        }

        // calc type of block
        if block.children.count() > 0 {
            block.typ = block.children.peek_last().typ
        } else {
            block.typ = @type_info(void)
        }

        return block
    }

    compile_function :: (&Self, func: &AstFunction, ctx: CNContext) -> &AstNode {
        // @todo: polymorphic functions

        _prev_func := self.function
        self.function = ^func
        defer self.function = _prev_func

        debug_log("compile_function '{}': Begin", [func.name])
        func.param_scope = compiler.new_scope(func.scope)
        func.body.scope = func.param_scope
        func.value = Value.Function(^func)

        // infer types of parameters
        param_types := mem.alloc_n(^TypeInfo, cast func.params.count(), compiler.type_allocator)
        for param : func.params {
            param.scope = func.param_scope

            param.name = match &<<param.pattern {
                AstIdentifier($id) -> id.name
                _ -> {
                    compiler.error_handler.report_error_at(param.location, "Non-identifier patterns not implemented yet")
                    return func
                }
            }

            // compile type expression
            if param.type_expr != null {
                param.type_expr.scope = param.scope
                param.type_expr = ^compile_node(<<param.type_expr, ctx.with_expected(@type_info(type)))
                
                if param.type_expr.typ != @type_info(type) {
                    compiler.error_handler.report_error_at(param.type_expr.location, "Expected type, got {}", [param.type_expr.typ])
                    return func
                } else {
                    @assert(param.type_expr.value == .Type)
                    param.var_type = param.type_expr.value.Type
                }
            }

            // default value
            if param.value_expr != null {
                param.value_expr = ^compile_node(<<param.value_expr, ctx.with_expected(param.var_type))
                if param.value_expr.typ == null { return func }
                param.value = param.value_expr.value

                if param.var_type == null {
                    param.var_type = param.value_expr.typ
                }
            }

            // define param
            if param.name != "_" {
                match param.scope.define_decl(param.name, <<param) {
                    Err() -> {
                        compiler.error_handler.report_error_at(param.pattern.location, "A parameter with this name already exists")
                    }
                }
            }

            param_types[it_index] = param.var_type
        }

        // handle return type
        func.return_type = @type_info(void)
        if func.return_type_expr != null {
            func.return_type_expr.scope = func.param_scope
            func.return_type_expr = ^compile_node(<<func.return_type_expr, ctx.with_expected(@type_info(type)))

            if func.return_type_expr.typ != @type_info(type) {
                compiler.error_handler.report_error_at(func.return_type_expr.location, "Expected type, got {}", [func.return_type_expr.typ])
                return func
            } else {
                @assert(func.return_type_expr.value == .Type)
                func.return_type = func.return_type_expr.value.Type
            }
        }

        // set function type
        func.typ = compiler.new_type(TypeInfoFunction(
            size        = 8
            alignment   = 8
            traits      = []
            param_types = param_types
            return_type = func.return_type
        ))

        // compile body
        debug_log("compile_function '{}': Compile Body", [func.name])
        func.body = ^compile_node(<<func.body, ctx.with_expected(null)) // @todo: use return type as expected?

        // generate byte code
        debug_log("compile_function '{}': Generate Bytecode", [func.name])
        code_gen := ByteCodeGenerator.new(compiler.string_database, <<compiler.error_handler, compiler.bc_allocator)
        code_gen.get().generate_code_for_function(^func)

        // @temp
        if func.name == "Main" {
            compiler.add_job(RunCodeJob.new(^func))
        }

        debug_log("compile_function '{}': End", [func.name])
        return func
    }

    compile_decl :: (&Self, decl: &AstDecl, ctx: CNContext) -> &AstNode {
        decl.typ = @type_info(void)
        decl.value_expr.scope = decl.scope

        decl.name = match &<<decl.pattern {
            AstIdentifier($id) -> id.name
            _ -> {
                compiler.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                return decl
            }
        }

        // define symbol but only if not _
        if decl.name != "_" {
            match decl.scope.define_decl(decl.name, decl) {
                Err() -> {
                    compiler.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                }
            }
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^compile_node(<<decl.type_expr, ctx.with_expected(@type_info(type)))
            
            if decl.type_expr.typ != @type_info(type) {
                compiler.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
                return decl
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        if decl.value_expr != null {
            decl.value_expr = ^compile_node(<<decl.value_expr, ctx.with_expected(decl.var_type))
            if decl.value_expr.typ == null { return decl }
            decl.value = decl.value_expr.value

            if decl.var_type == null {
                decl.var_type = decl.value_expr.typ
            }
        }

        // check if var_type is valid
        if !validate_variable_type(decl.var_type, decl.pattern.location) {
            return decl
        }

        // @todo: create cast if necessary

        return decl
    }

    validate_variable_type :: (&Self, typ: ^TypeInfo, location: Location) -> bool {
        @assert(typ != null)
        if typ == @type_info(void) {
            compiler.error_handler.report_error_at(location, "Variable can't have type {}", [typ])
            return false
        }

        return true
    }

    compile_const_decl :: (&Self, decl: &AstConstDecl, ctx: CNContext) -> &AstNode {
        decl.typ = @type_info(void)
        decl.value_expr.scope = decl.scope

        name := match decl.pattern {
            AstIdentifier($id) -> id.name
            _ -> {
                compiler.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                return decl
            }
        }

        // set name of value expr if its a function or struct/trait/enum
        match decl.value_expr {
            AstFunction($func) -> {
                func.name = name
            }
        }

        // define symbol but only if not _
        if name != "_" {
            match decl.scope.define_const_decl(name, decl) {
                Err() -> {
                    compiler.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                }
            }
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^compile_node(<<decl.type_expr, ctx.with_expected(@type_info(type)))
            
            if decl.type_expr.typ != @type_info(type) {
                compiler.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        decl.value_expr <- compile_node(decl.value_expr, ctx.with_expected(decl.var_type))
        decl.value = decl.value_expr.value

        if decl.var_type == null {
            decl.var_type = decl.value_expr.typ
        }

        // @todo: create cast if necessary

        return decl
    }
}

impl CompilationJob for RunCodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [RunCodeJob '{}'] {}", [Fiber.user_data(FiberContext).thread, function.name, str])
        } 
    }

    execute :: (&Self, compiler: &Compiler) {
        if compiler.error_handler.has_errors() {
            return
        }
        debug_log("Start", [function.name])
        context := Fiber.user_data(FiberContext)
        context.interp.comp_call(<<function)
        compiler.code_runner.get().run(<<context.interp)
        debug_log("Done", [function.name])
    }
}

impl CompilationJob for LoadFileJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [LoadFileJob '{}'] {}", [Fiber.user_data(FiberContext).thread, path, str])
        } 
    }

    execute :: (&Self, compiler: &Compiler) {
        debug_log("Begin loading")

        full_path := match fs.get_full_path(path.slice()) {
            Ok($p) -> compiler.string_database.intern(p.slice())
            Err(_) -> compiler.string_database.intern(path.slice())
        }

        if !compiler.sources.contains(full_path) {
            content := fs.read_file(full_path)

            match content {
                Ok($content) -> {
                    compiler.sources.set(full_path, content)
                    lexer := Lexer.from_string(compiler.sources.at(full_path).slice(), compiler.string_database)
                    lexer.get().location.file = full_path
                    parser := Parser.new(lexer.get(), compiler.error_handler, compiler.ast_allocator)

                    loop {
                        decl := parser.parse_node()
                        if decl == null then break

                        if const DUMP_AST {
                            dump := dump_ast(<<decl)
                            g_logger.log("{}", [dump])
                        }
                        if const PRINT_AST {
                            dump := pretty_print_ast(<<decl)
                            g_logger.log("{}", [dump])
                        }

                        compiler.add_job(CompileGlobalNodeJob.new(decl))
                    }
                }

                Err(_) -> {
                    compiler.error_handler.report_error("Failed to load source file '{}'", [full_path])
                }
            }
        }
        
        debug_log("Done")
    }
}


#file_scope
