
use import std.fiber
use import std.string
use import std.array
use import std.mem.std_heap_allocator

fs  :: import std.io.fs
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import lexer
use import parser
use import ast_dumper
use import ast_pretty_printer
use import compiler
use import bytecode_generator
use import scope
use import config
use import value


#export_scope

CompilationJob :: trait {
    cancelled   : bool = false
    progressed  : bool = false
    done        : bool = false
    compiler    : ^Compiler = null

    get_name :: (&Self) -> string;
    execute :: (&Self, compiler: &Compiler);
}

LoadFileJob :: struct CompilationJob {
    name : String
    path : String
}

impl LoadFileJob {
    new :: (path: String) -> LoadFileJob {
        return LoadFileJob(
            name = fmt.format("LoadFileJob '{}'", [path])
            path = path
        )
    }
}

CompileGlobalNodeJob :: struct CompilationJob {
    name : String
    node : ^AstNode
}

impl CompileGlobalNodeJob {
    new :: (node: ^AstNode) -> CompileGlobalNodeJob {
        return CompileGlobalNodeJob(
            name = fmt.format("CompileGlobalNodeJob #{}", [node.id])
            node = node
        )
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [CompileGlobalNode #{}] {}", [Fiber.user_data(FiberContext).thread, node.id, str])
        } 
    }

    execute :: (&Self, compiler: &Compiler) {
        debug_log("Begin compilation")

        node.scope = compiler.global_scope
        compile_node(<<node)

        debug_log("Done")
    }

    compile_node :: (&Self, node: &AstNode) -> &AstNode {
        return match node {
            AstConstDecl($decl)     -> compile_const_decl(decl)
            AstFunction($func)      -> compile_function(func)
            AstBlock($block)        -> compile_block(block)
            AstArgument($arg)       -> compile_argument(arg)
            AstCall($call)          -> compile_call(call)
            AstIdentifier($id)      -> compile_identifier(id)
            AstString($str)         -> compile_string(str)
            AstBool($bol)           -> compile_bool(bol)
            AstNumberLiteral($num)  -> compile_number(num)
            AstIf($iff)             -> compile_if(iff)
            AstLoop($lop)           -> compile_loop(lop)
            AstFor($forr)           -> compile_for(forr)
            AstBreak($brake)        -> compile_break(brake)
            AstContinue($cont)      -> compile_continue(cont)
            AstReturn($ret)         -> compile_return(ret)
            AstDefer($def)          -> compile_defer(def)
            AstBinary($bin)         -> compile_binary(bin)

            _ -> {
                dump := dump_ast(node, recurse = false)
                compiler.error_handler.report_error_at(node.location, "compile_node: not implemented: {}", [dump])
                node
            }
        }

        return node
    }

    compile_binary :: (&Self, bin: &AstBinary) -> &AstNode {
        // @todo
        return bin
    }

    compile_if :: (&Self, iff: &AstIf) -> &AstNode {
        iff.condition.scope = iff.scope
        compile_node(iff.condition)

        iff.true_case.scope = iff.scope
        compile_node(iff.true_case)

        if iff.false_case != null {
            iff.false_case.scope = iff.scope
            compile_node(<<iff.false_case)
        }
        return iff
    }

    compile_loop :: (&Self, lop: &AstLoop) -> &AstNode {
        lop.body.scope = lop.scope
        compile_node(lop.body)
        return lop
    }

    compile_for :: (&Self, forr: &AstFor) -> &AstNode {
        forr.collection.scope = forr.scope
        compile_node(forr.collection)
        forr.body.scope = forr.scope
        compile_node(forr.body)
        return forr
    }

    compile_break :: (&Self, brake: &AstBreak) -> &AstNode {
        if brake.value_expr != null {
            brake.value_expr.scope = brake.scope
            compile_node(<<brake.value_expr)
        }
        return brake
    }

    compile_continue :: (&Self, cont: &AstContinue) -> &AstNode {

        return cont
    }

    compile_return :: (&Self, ret: &AstReturn) -> &AstNode {
        if ret.value_expr != null {
            ret.value_expr.scope = ret.scope
            compile_node(<<ret.value_expr)
        }

        return ret
    }

    compile_defer :: (&Self, def: &AstDefer) -> &AstNode {
        def.sub.scope = def.scope
        compile_node(def.sub)
        return def
    }


    compile_string :: (&Self, str: &AstString) -> &AstNode {
        str.value = .String(str.string_value)
        return str
    }

    compile_bool :: (&Self, bol: &AstBool) -> &AstNode {
        bol.value = .Bool(bol.bool_value)
        return bol
    }

    compile_number :: (&Self, num: &AstNumberLiteral) -> &AstNode {
        num.value = .Int(num.int_value)
        return num
    }

    compile_identifier :: (&Self, id: &AstIdentifier) -> &AstNode {
        sym := id.scope.get_symbol(id.name)
        match sym {
            .Val(($typ, $value)) -> match value {
                .Function($func) -> {
                    // id.typ = cast typ
                    id.value = value
                }
                
                $val -> {
                    compiler.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [val])
                }
            }

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None, {
                    compiler.error_handler.report_error_at(id.location, "Failed to get value of constant declaration")
                })
                id.value = decl.value_expr.value
            }

            .NativeFunc($func) -> {
                id.value = .NativeFunc(func)
            }

            .NotFound -> {
                compiler.error_handler.report_error_at(id.location, "Unknown symbol '{}'", [id.name])
                Fiber.yield()
            }

            $sym -> {
                compiler.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [sym])
            }
        }

        return id
    }

    compile_argument :: (&Self, arg: &AstArgument) -> &AstNode {
        arg.value_expr <- compile_node(arg.value_expr)
        return arg
    }

    compile_call :: (&Self, call: &AstCall) -> &AstNode {
        call.function.scope = call.scope
        call.function <- compile_node(call.function)
        
        match call.function.value {
            .Function($func) -> {
                // call.typ = cast typ
                // call.value = value
                call.ast_function = func

                for arg : call.arguments {
                    arg = cast ^compile_node(<<arg)
                }
            }

            .NativeFunc($func) -> {
                // call.typ = cast typ
                // call.value = value
                for arg : call.arguments {
                    arg = cast ^compile_node(<<arg)
                }
            }

            $val -> {
                compiler.error_handler.report_error_at(call.location, "[compile_call] not implemented: {}", [val])
            }
        }

        return call
    }

    compile_block :: (&Self, block: &AstBlock) -> &AstNode {
        block.sub_scope = compiler.new_scope(block.scope)

        for child : block.children {
            child.scope = block.sub_scope
            child = ^compile_node(<<child)
        }

        return block
    }

    compile_function :: (&Self, func: &AstFunction) -> &AstNode {
        debug_log("compile_function '{}': Begin", [func.name])
        func.param_scope = compiler.new_scope(func.scope)
        func.body.scope = func.param_scope
        func.value = Value.Function(^func)

        debug_log("compile_function '{}': Compile Body", [func.name])
        func.body = ^compile_node(<<func.body)

        debug_log("compile_function '{}': Generate Bytecode", [func.name])
        code_gen := ByteCodeGenerator.new(compiler.string_database, <<compiler.error_handler, compiler.bc_allocator)
        code_gen.get().generate_code_for_function(^func)

        // @temp
        if func.name == "Main" {
            if compiler.error_handler.has_errors() {
                return func
            }
            debug_log("compile_function '{}': Call Main", [func.name])
            context := Fiber.user_data(FiberContext)
            context.interp.comp_call(func)
            compiler.code_runner.get().run(<<context.interp)
        }
        debug_log("compile_function '{}': End", [func.name])

        return func
    }

    compile_const_decl :: (&Self, decl: &AstConstDecl) -> &AstNode {
        decl.value_expr.scope = decl.scope

        name := match &decl.pattern {
            AstIdentifier($id) -> id.name
            _ -> {
                compiler.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                return decl
            }
        }

        match decl.value_expr {
            AstFunction($func) -> {
                func.name = name
            }
        }

        // define symbol but only if not _
        if name != "_" {
            match decl.scope.define_const_decl(name, decl) {
                Err() -> {
                    compiler.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                }
            }
        }

        decl.value_expr <- compile_node(decl.value_expr)
        decl.value = decl.value_expr.value

        return decl
    }
}

impl CompilationJob for LoadFileJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[{}] [LoadFileJob '{}'] {}", [Fiber.user_data(FiberContext).thread, path, str])
        } 
    }

    execute :: (&Self, compiler: &Compiler) {
        debug_log("Begin loading")

        full_path := match fs.get_full_path(path.slice()) {
            Ok($p) -> compiler.string_database.intern(p.slice())
            Err(_) -> compiler.string_database.intern(path.slice())
        }

        if !compiler.sources.contains(full_path) {
            content := fs.read_file(full_path)

            match content {
                Ok($content) -> {
                    compiler.sources.set(full_path, content)
                    lexer := Lexer.from_string(compiler.sources.at(full_path).slice(), compiler.string_database)
                    lexer.get().location.file = full_path
                    parser := Parser.new(lexer.get(), compiler.error_handler, compiler.ast_allocator)

                    loop {
                        decl := parser.parse_node()
                        if decl == null then break

                        if const DEBUG_JOBS {
                            dump := pretty_print_ast(<<decl)
                            // dump := dump_ast(<<decl)
                            io.println(dump)
                        }

                        compiler.add_job(CompileGlobalNodeJob.new(decl))
                    }
                }

                Err(_) -> {
                    compiler.error_handler.report_error("Failed to load source file '{}'", [full_path])
                }
            }
        }
        
        debug_log("Done")
    }
}


#file_scope
