use import std.printable
use import std.string
use import std.array

use import lexer
use import type
use import interpreter
use import scope
use import value

#export_scope

AstNode :: trait {
    id       : int
    location : Location
    scope    : &Scope = null
    typ      : &Type  = null
    value    : Value = Value.None
}

// statements
AstConstDecl :: struct AstNode {
    name        : ref AstIdentifier
    type_expr   : &AstNode
    value_expr  : ref AstNode
}
impl AstNode for AstConstDecl {}

AstDecl :: struct AstNode {
    pattern     : ref AstNode
    type_expr   : &AstNode
    value_expr  : &AstNode
}
impl AstNode for AstDecl {}

AstImport :: struct AstNode {
    path : ref AstNode
}
impl AstNode for AstImport {}

// expressions

AstStruct :: struct AstNode {
    name        := "#anonymous"
}
impl AstNode for AstStruct {}

AstTrait :: struct AstNode {
    name        := "#anonymous"
}
impl AstNode for AstTrait {}

AstEnum :: struct AstNode {
    name        := "#anonymous"
}
impl AstNode for AstEnum {}

AstFunction :: struct AstNode {
    param_scope : &Scope
    name        := "#anonymous"

    params      : Array[&AstParameter]
    body        : &AstNode

    bytecode    : &CBCFunction = null
}
impl AstNode for AstFunction {}

AstArgument :: struct AstNode {
    name        : &AstIdentifier
    value_expr  : ref AstNode
}
impl AstNode for AstArgument {}

AstParameter :: struct AstNode {
    name            : ref AstIdentifier
    type_expr       : &AstNode
    default_value   : &AstNode
}
impl AstNode for AstParameter {}

AstBlock :: struct AstNode {
    sub_scope   : &Scope
    children    : Array[&AstNode]
}
impl AstNode for AstBlock {}

AstCall :: struct AstNode {
    function        : ref AstNode
    arguments       : Array[&AstArgument]
    ast_function    : &AstFunction = null
}
impl AstNode for AstCall {}

AstIdentifier :: struct AstNode {
    name : string
}
impl AstNode for AstIdentifier {}

AstNumberLiteral :: struct AstNode {
    int_value : int
}
impl AstNode for AstNumberLiteral {}

AstString :: struct AstNode {
    string_value : string
}
impl AstNode for AstString {}

AstBool :: struct AstNode {
    bool_value : bool
}
impl AstNode for AstBool {}

AstNull :: struct AstNode {
    
}
impl AstNode for AstNull {}

AstBinary :: struct AstNode {
    operator    : Operator
    left        : ref AstNode
    right       : ref AstNode

    Operator :: enum #copy { Add, Sub, Mul, Div, Mod, And, Or, Less, LessEq, Greater, GreaterEq, Equal, NotEqual }
}
impl AstNode for AstBinary {}

AstUnary :: struct AstNode {
    operator    : Operator
    sub         : ref AstNode

    Operator :: enum #copy { Neg, Not }
}
impl AstNode for AstUnary {}

AstAssignment :: struct AstNode {
    pattern     : ref AstNode
    value_expr  : ref AstNode
}
impl AstNode for AstAssignment {}

AstMove :: struct AstNode {
    target : ref AstNode
    source : ref AstNode
}
impl AstNode for AstMove {}

AstPipe :: struct AstNode {
    left  : ref AstNode
    right : ref AstNode
}
impl AstNode for AstPipe {}

AstIf :: struct AstNode {
    true_case   : ref AstNode
    false_case  : &AstNode
}
impl AstNode for AstIf {}

AstFor :: struct AstNode {
    it_name     : &AstIdentifier
    index_name  : &AstIdentifier
    collection  : ref AstNode
    body        : ref AstNode
}
impl AstNode for AstFor {}

AstLoop :: struct AstNode {
    body : ref AstNode
}
impl AstNode for AstLoop {}

AstMatch :: struct AstNode {
    value_expr  : ref AstNode
    // @todo: cases
}
impl AstNode for AstMatch {}

AstBreak :: struct AstNode {
    label       : &AstIdentifier
    value_expr  : &AstNode
}
impl AstNode for AstBreak {}

AstContinue :: struct AstNode {
    label : &AstIdentifier
}
impl AstNode for AstContinue {}

AstReturn :: struct AstNode {
    value_expr : &AstNode
}
impl AstNode for AstReturn {}

AstTuple :: struct AstNode {
    values : Array[&AstNode]
}
impl AstNode for AstTuple {}

AstArray :: struct AstNode {
    values : Array[&AstNode]
}
impl AstNode for AstArray {}

AstDot :: struct AstNode {
    sub     : &AstNode
    name    : ref AstIdentifier
}
impl AstNode for AstDot {}

AstIndex :: struct AstNode {
    sub     : ref AstNode
    name    : ref AstNode
}
impl AstNode for AstIndex {}

AstRange :: struct AstNode {
    from    : &AstNode
    to      : &AstNode
}
impl AstNode for AstRange {}

impl AstFunction {
    get_parameter :: (ref Self, name: string) -> Option[ref AstParameter] {
        for p : params {
            if p.name.name == name {
                return Some(<<p)
            }
        }
        return None
    }
}

// impl Printable for BinaryExpr.Operator {
//     print :: (ref Self, str: ref String, format: string) {
//         match self {
//             BinaryExpr.Operator.Add       -> str.append_string("+")
//             BinaryExpr.Operator.Sub       -> str.append_string("-")
//             BinaryExpr.Operator.Mul       -> str.append_string("*")
//             BinaryExpr.Operator.Div       -> str.append_string("/")
//             BinaryExpr.Operator.Mod       -> str.append_string("%")
//             BinaryExpr.Operator.And       -> str.append_string("and")
//             BinaryExpr.Operator.Or        -> str.append_string("or")
//             BinaryExpr.Operator.Less      -> str.append_string("<")
//             BinaryExpr.Operator.LessEq    -> str.append_string("<=")
//             BinaryExpr.Operator.Greater   -> str.append_string(">")
//             BinaryExpr.Operator.GreaterEq -> str.append_string(">=")
//             BinaryExpr.Operator.Equal     -> str.append_string("==")
//             BinaryExpr.Operator.NotEqual  -> str.append_string("!=")
//         }
//     }
// }

// impl Printable for UnaryExpr.Operator {
//     print :: (ref Self, str: ref String, format: string) {
//         match self {
//             UnaryExpr.Operator.Neg -> str.append_char('-')
//             UnaryExpr.Operator.Not -> str.append_char('!')
//         }
//     }
// }

// impl Printable for AstNode {
//     print :: (ref Self, str: ref String, format: string) {
//         match self {
//             AstIdentifier($expr)     -> str.appendf("{}", expr.name)
//             AstNumberLiteral($expr) -> str.appendf("{}", expr.value)
//             BinaryExpr($expr) -> str.append_printables("({} {} {})", [&expr.left, &expr.op, &expr.right])
//             UnaryExpr($expr)  -> str.append_printables("{}{}", [&expr.op, &expr.sub])
//             MoveExpr($expr)   -> str.append_printables("({} <- {})", [&expr.target, &expr.source])
//             PipeExpr($expr)   -> str.append_printables("{} | {}", [&expr.left, &expr.right])
//         }
//     }
// }

// impl Printable for Stmt {
//     print :: (ref Self, str: ref String, format: string) {
//         match self {
//             DeclStmt($stmt) -> {
//                 str.append_printables("{} :", [&stmt.pattern])

//                 match ref stmt.typ {
//                     Some($expr) -> {
//                         str.append_printables(" {} ", [&expr])
//                     }
//                 }

//                 str.append_char(if stmt.is_const then ':' else '=')

//                 match ref stmt.init {
//                     Some($expr) -> {
//                         str.append_printables(" {}", [&expr])
//                     }
//                 }
//             }

//             UseStmt($stmt) -> {
//                 str.append_printables("use {}", [&stmt.expr])
//             }
//         }
//     }
// }
