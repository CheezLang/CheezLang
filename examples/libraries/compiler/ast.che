use import lexer
use import type

use import std.printable
use import std.string

#export_scope

Stmt :: struct #extendable {
    id       : int
    location : Location = default
}

DeclStmt :: struct #extend(Stmt) {
    is_const : bool
    pattern  : ref Expr
    typ      : Option[ref Expr]
    init     : Option[ref Expr]
}

UseStmt :: struct #extend(Stmt) {
    expr : ref Expr
}

// expressions
Expr :: struct #extendable {
    id       : int
    location : Location = default
    typ      : &Type    = null
}

IdExpr :: struct #extend(Expr) {
    name : string
}

NumberExpr :: struct #extend(Expr) {
    value : int
}

BinaryExpr :: struct #extend(Expr) {
    op    : Operator
    left  : ref Expr
    right : ref Expr

    Operator :: enum #copy { Add, Sub, Mul, Div, Mod, And, Or, Less, LessEq, Greater, GreaterEq, Equal, NotEqual }
}

UnaryExpr :: struct #extend(Expr) {
    op  : Operator
    sub : ref Expr

    Operator :: enum #copy { Neg, Not }
}

MoveExpr :: struct #extend(Expr) {
    target : ref Expr
    source : ref Expr
}

PipeExpr :: struct #extend(Expr) {
    left  : ref Expr
    right : ref Expr
}

impl Printable for BinaryExpr.Operator {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            BinaryExpr.Operator.Add       -> str.append_string("+")
            BinaryExpr.Operator.Sub       -> str.append_string("-")
            BinaryExpr.Operator.Mul       -> str.append_string("*")
            BinaryExpr.Operator.Div       -> str.append_string("/")
            BinaryExpr.Operator.Mod       -> str.append_string("%")
            BinaryExpr.Operator.And       -> str.append_string("and")
            BinaryExpr.Operator.Or        -> str.append_string("or")
            BinaryExpr.Operator.Less      -> str.append_string("<")
            BinaryExpr.Operator.LessEq    -> str.append_string("<=")
            BinaryExpr.Operator.Greater   -> str.append_string(">")
            BinaryExpr.Operator.GreaterEq -> str.append_string(">=")
            BinaryExpr.Operator.Equal     -> str.append_string("==")
            BinaryExpr.Operator.NotEqual  -> str.append_string("!=")
        }
    }
}

impl Printable for UnaryExpr.Operator {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            UnaryExpr.Operator.Neg -> str.append_char('-')
            UnaryExpr.Operator.Not -> str.append_char('!')
        }
    }
}

impl Printable for Expr {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            IdExpr($expr)     -> str.appendf("{}", expr.name)
            NumberExpr($expr) -> str.appendf("{}", expr.value)
            BinaryExpr($expr) -> str.append_printables("({} {} {})", [&expr.left, &expr.op, &expr.right])
            UnaryExpr($expr)  -> str.append_printables("{}{}", [&expr.op, &expr.sub])
            MoveExpr($expr)   -> str.append_printables("({} <- {})", [&expr.target, &expr.source])
            PipeExpr($expr)   -> str.append_printables("{} | {}", [&expr.left, &expr.right])
        }
    }
}

impl Printable for Stmt {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            DeclStmt($stmt) -> {
                str.append_printables("{} :", [&stmt.pattern])

                match ref stmt.typ {
                    Some($expr) -> {
                        str.append_printables(" {} ", [&expr])
                    }
                }

                str.append_char(if stmt.is_const then ':' else '=')

                match ref stmt.init {
                    Some($expr) -> {
                        str.append_printables(" {}", [&expr])
                    }
                }
            }

            UseStmt($stmt) -> {
                str.append_printables("use {}", [&stmt.expr])
            }
        }
    }
}
