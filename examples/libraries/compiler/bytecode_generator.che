use import std.array
use import std.string
use import std.rc

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import ast
use import ast_dumper
use import error_handler
use import type
use import interpreter
use import string_database
use import value

#export_scope

CodeGenerator :: trait {
    generate_code_for_function :: (ref Self, func: &AstFunction);
}

ByteCodeGenerator :: struct {
    strings         : ref StringDatabase
    error_handler   : ref ErrorHandler
    allocator       : &mem.Allocator
    builder         : InstructionBuilder

    function        : &AstFunction = null
}

impl ByteCodeGenerator {
    new :: (strings: ref StringDatabase, error_handler: ref ErrorHandler, allocator: &mem.Allocator) -> Rc[ByteCodeGenerator] {
        return Rc[ByteCodeGenerator].new(ByteCodeGenerator(
            strings         = strings
            error_handler   = error_handler
            allocator       = allocator
            builder         = InstructionBuilder.new(strings)
        ))
    }

    allocate_function :: (ref Self, name: string, path: string, params: Array[String]) -> &CBCFunction {
        func := mem.alloc(CBCFunction, allocator)
        <<func = CBCFunction(
            ast_function = function
            debug_info = CBCDebugInfo(
                path       = path.to_owned()
                parameters = params
            )
        )
        return func
    }
}

impl CodeGenerator for ByteCodeGenerator {
    generate_code_for_function :: (ref Self, func: &AstFunction) {
        if function != null {
            error_handler.report_error_at(
                func.location,
                "Failed to generate code for this function because we're already generating code for another function at {}",
                [function.location])
            return
        }

        function = func
        defer function <- null

        file_path := func.location.file
        params := Array[String].create()

        cbc_func := self.allocate_function(func.name, file_path, params)
        builder.begin_function(cbc_func)

        builder.set_current_line(func.body.location.line)
        generate_expression(<<func.body)
        builder.set_current_line(func.body.location.end_line)
        builder.build_return_void()

        builder.end_function()

        func.bytecode = cbc_func
    }

    generate_expression :: (ref Self, node: ref AstNode) {
        builder.set_current_line(node.location.line)
        match node {
            AstBlock($block)        -> generate_block(block)
            AstCall($call)          -> generate_call(call)
            AstArgument($arg)       -> generate_argument(arg)
            AstIdentifier($id)      -> generate_identifier(id)
            AstNumberLiteral($num)  -> generate_number_literal(num)
            AstBool($bol)           -> generate_bool(bol)
            AstString($str)         -> generate_string(str)

            _ -> {
                dump := dump_ast(node, recurse = false)
                error_handler.report_error(
                    "generate_expression: not implemented: {}",
                    [dump])
            }
        }
    }

    generate_bool :: (ref Self, bol: ref AstBool) {
        builder.set_current_line(bol.location.line)
        builder.build_const(if bol.bool_value then 1 else 0)
    }

    generate_string :: (ref Self, str: ref AstString) {
        // @todo
        builder.set_current_line(str.location.line)
        builder.build_const(-str.string_value.bytes.length)
    }

    generate_argument :: (ref Self, arg: ref AstArgument) {
        generate_expression(arg.value_expr)
    }

    generate_block :: (ref Self, block: ref AstBlock) {
        builder.set_current_line(block.location.line)
        for child : block.children {
            generate_expression(<<child)
        }
    }

    generate_call :: (ref Self, call: ref AstCall) {
        builder.set_current_line(call.location.line)
        builder.build_noop()

        match call.function.value {
            .Function($func) -> {
                for arg : call.arguments {
                    generate_expression(<<arg)
                }
                builder.set_current_line(call.location.line)
                builder.build_comp_call(call.ast_function)
            }

            .NativeFunc($func) -> {
                for arg : call.arguments {
                    generate_expression(<<arg)
                }
                builder.set_current_line(call.location.line)
                builder.build_native_call(func, call.arguments.count())
            }

            _ -> {
                error_handler.report_error_at(call.function.location, "Can't call {}", [call.function.value])
            }
        }
        // match call.function {
        //     AstIdentifier($id) -> {


        //         if id.name == "print" {
        //             for arg : call.arguments {
        //                 generate_expression(<<arg)
        //                 builder.set_current_line(call.location.line)
        //                 builder.build_print()
        //             }
        //         } else {
        //             for arg : call.arguments {
        //                 generate_expression(<<arg)
        //             }
        //             builder.set_current_line(call.location.line)
        //             builder.build_comp_call(call.ast_function)
        //         }
        //     }

        //     _ -> {
        //         error_handler.report_error_at(call.function.location, "Can't call non-identifier")
        //     }
        // }
    }

    generate_number_literal :: (ref Self, num: ref AstNumberLiteral) {
        builder.set_current_line(num.location.line)
        builder.build_const(num.int_value)
    }

    generate_identifier :: (ref Self, id: ref AstIdentifier) {
        builder.set_current_line(id.location.line)
        match function.get_parameter(id.name) {
            Some($param) -> {
                builder.build_load_local(-1)
            }

            None -> {
                msg := fmt.format("Unknown identifier '{}'", [id.name])
                error_handler.report_error_at(id.location, msg.slice())
                builder.build_panic(msg.slice())
            }
        }
    }
}

InstructionBuilder :: struct {
    function        : &CBCFunction
    current_line    : int
    strings         : ref StringDatabase
}

impl InstructionBuilder {
    new :: (strings: ref StringDatabase) -> InstructionBuilder {
        return InstructionBuilder(
            function        = null
            current_line    = -1
            strings         = strings
        )
    }

    begin_function :: (ref Self, func: &CBCFunction) {
        current_line = -1
        function = func
    }

    end_function :: (ref Self) {
        function = null
    }

    code_view :: (ref Self) -> []u64 {
        return function.instructions.slice()
    }

    set_current_line :: (ref Self, line: int) {
        lines := ref function.debug_info.lines
        if lines.count() > 0 and lines.peek_last().count == 0 {
            lines.peek_last().line = line
        } else if current_line != line {
            function.debug_info.lines.add(LineInfo(line, 0))
        }
        current_line = line
    }

    next :: (ref Self) -> int {
        return function.instructions.get_length()
    }

    add_debug_info_line :: () #macro #transparent {
        @assert(function.debug_info.lines.count() > 0)
        current_instruction_count := function.instructions.count()
        defer {
            new_instruction_count := function.instructions.count()
            function.debug_info.lines.peek_last().count += new_instruction_count - current_instruction_count
        }
    }

    build_noop :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Noop)
    }

    build_const :: (ref Self, value: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Const)
        function.instructions.add(<<cast(&u64)&value)
    }

    build_address_of :: (ref Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.AddressOf)
        function.instructions.add(<<cast(&u64)&index)
    }

    build_load :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Load)
    }

    build_store :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Store)
    }

    build_load_local :: (ref Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.LoadLocal)
        function.instructions.add(<<cast(&u64)&index)
    }

    build_store_local :: (ref Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.StoreLocal)
        function.instructions.add(<<cast(&u64)&index)
    }

    build_add :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Add)
    }

    build_sub :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Sub)
    }

    build_mul :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mul)
    }

    build_div :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Div)
    }

    build_mod :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mod)
    }

    build_and :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.And)
    }

    build_or :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Or)
    }

    build_ieq :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ieq)
    }

    build_ilt :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ilt)
    }

    build_ile :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ile)
    }

    build_igt :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Igt)
    }

    build_ige :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ige)
    }

    build_branch :: (ref Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Branch)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_branch_if :: (ref Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.BranchIf)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_call :: (ref Self, name: string, arity: int = 0) {
        add_debug_info_line()
        name = strings.intern(name)
        function.instructions.add(cast Instruction.Call)
        function.instructions.add(cast name.bytes.data)
        function.instructions.add(cast name.bytes.length)
        function.instructions.add(cast arity)
    }

    build_native_call :: (ref Self, func: NativeFunction, arity: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.NativeCall)
        func, data := FatFunctions.destructure(func, u64, u64)
        function.instructions.add(func)
        function.instructions.add(data)
        function.instructions.add(cast arity)
    }

    build_comp_call :: (ref Self, ast_func: &AstFunction) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CompCall)
        function.instructions.add(cast ast_func)
        function.instructions.add(0)
        function.instructions.add(0)
    }

    build_return :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Return)
    }

    build_return_void :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.ReturnVoid)
    }

    build_halt :: (ref Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Halt)
    }

    build_panic :: (ref Self, msg: string) {
        add_debug_info_line()
        msg = strings.intern(msg)
        function.instructions.add(cast Instruction.Panic)
        function.instructions.add(cast msg.bytes.data)
        function.instructions.add(cast msg.bytes.length)
    }
}