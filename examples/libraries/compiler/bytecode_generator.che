use import std.array
use import std.map
use import std.rc
use import std.string

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import ast_dumper
use import error_handler
use import types
use import interpreter
use import string_database
use import value

#export_scope

CodeGenerator :: trait {
    generate_code_for_function :: (&Self, func: ^AstFunction);
}

ByteCodeGenerator :: struct {
    strings         : &StringDatabase
    error_handler   : &ErrorHandler
    allocator       : ^mem.Allocator
    builder         : InstructionBuilder

    variables       := Map[int, int].new()

    function        : ^AstFunction = null
}

impl ByteCodeGenerator {
    new :: (strings: &StringDatabase, error_handler: &ErrorHandler, allocator: ^mem.Allocator) -> Rc[ByteCodeGenerator] {
        return Rc[ByteCodeGenerator].new(ByteCodeGenerator(
            strings         = strings
            error_handler   = error_handler
            allocator       = allocator
            builder         = InstructionBuilder.new(strings)
        ))
    }

    allocate_function :: (&Self, name: string, path: string, params: Array[String]) -> ^CBCFunction {
        func := mem.alloc(CBCFunction, allocator)
        <<func = CBCFunction(
            ast_function = function
            debug_info = CBCDebugInfo(
                path       = path.to_owned()
                parameters = params
            )
        )
        return func
    }
}

impl CodeGenerator for ByteCodeGenerator {
    generate_code_for_function :: (&Self, func: ^AstFunction) {
        if function != null {
            error_handler.report_error_at(
                func.location,
                "Failed to generate code for this function because we're already generating code for another function at {}",
                [function.location])
            return
        }

        function = func
        defer function <- null

        file_path := func.location.file
        params := Array[String].create()

        cbc_func := self.allocate_function(func.name, file_path, params)
        builder.begin_function(cbc_func)

        generate_expression(<<func.body)
        builder.set_current_line(func.body.location.end_line)
        builder.build_return_void()

        builder.end_function()

        func.bytecode = cbc_func
    }

    generate_expression :: (&Self, node: &AstNode) {
        builder.set_current_line(node.location.line)
        match node {
            AstArgument($arg)       -> generate_argument(arg)
            AstBinary($bin)         -> generate_binary(bin)
            AstBlock($block)        -> generate_block(block)
            AstBool($bol)           -> generate_bool(bol)
            AstBreak($brake)        -> generate_break(brake)
            AstCall($call)          -> generate_call(call)
            AstContinue($cont)      -> generate_continue(cont)
            AstDecl($decl)          -> generate_decl(decl)
            AstDefer($def)          -> generate_defer(def)
            AstFor($forr)           -> generate_for(forr)
            AstIdentifier($id)      -> generate_identifier(id)
            AstIf($iff)             -> generate_if(iff)
            AstLoop($lop)           -> generate_loop(lop)
            AstNumberLiteral($num)  -> generate_number_literal(num)
            AstReturn($ret)         -> generate_return(ret)
            AstString($str)         -> generate_string(str)

            _ -> {
                dump := dump_ast(node, recurse = false)
                error_handler.report_error(
                    "generate_expression: not implemented: {}",
                    [dump])
            }
        }
    }

    generate_decl :: (&Self, decl: &AstDecl) {
        builder.set_current_line(decl.location.line)
        builder.build_noop()

        index := builder.add_local(decl.id, decl.name, decl.var_type.size)
        variables[decl.id] = index

        g_logger.log("type_size: {}", [decl.var_type.size])

        if decl.value_expr != null {
            generate_expression(<<decl.value_expr)
            builder.build_store_local(index)
        }
    }

    generate_binary :: (&Self, bin: &AstBinary) {
        builder.set_current_line(bin.location.line)
        builder.build_const(0)
        // @todo
    }

    generate_if :: (&Self, iff: &AstIf) {
        builder.set_current_line(iff.location.line)
        
        // condition
        generate_expression(iff.condition)
        br_true := builder.build_branch_if(0)

        // else case
        if iff.false_case != null {
            generate_expression(<<iff.false_case)
        } else {
            builder.set_current_line(iff.location.end_line)
            builder.build_const(0)
        }

        // builder.set_current_line(iff.location.end_line)
        br_end := builder.build_branch(0)

        // if case
        l_true := builder.next()
        generate_expression(iff.true_case)

        // end
        l_end := builder.next()

        // fix branches
        builder.fix_branch(br_true, l_true)
        builder.fix_branch(br_end, l_end)
    }

    generate_loop :: (&Self, lop: &AstLoop) {
        builder.set_current_line(lop.location.line)
        loop_start := builder.next()
        generate_expression(lop.body)
        builder.build_pop()
        builder.build_branch(loop_start)
    }

    generate_for :: (&Self, forr: &AstFor) {
        builder.set_current_line(forr.location.line)
        builder.build_const(0)
    }

    generate_break :: (&Self, brake: &AstBreak) {
        builder.set_current_line(brake.location.line)
        builder.build_const(0)
    }

    generate_continue :: (&Self, cont: &AstContinue) {
        builder.set_current_line(cont.location.line)
        builder.build_const(0)
    }

    generate_return :: (&Self, ret: &AstReturn) {
        builder.set_current_line(ret.location.line)

        if ret.value_expr != null {
            generate_expression(<<ret.value_expr)
            builder.set_current_line(ret.location.line)
            builder.build_return()
        } else {
            builder.build_return_void()
        }
    }

    generate_defer :: (&Self, def: &AstDefer) {
        builder.set_current_line(def.location.line)
        builder.build_const(0)
    }

    generate_bool :: (&Self, bol: &AstBool) {
        builder.set_current_line(bol.location.line)
        builder.build_const(if bol.bool_value then 1 else 0)
    }

    generate_string :: (&Self, str: &AstString) {
        // @todo
        builder.set_current_line(str.location.line)
        builder.build_const(-str.string_value.bytes.length)
    }

    generate_argument :: (&Self, arg: &AstArgument) {
        generate_expression(arg.value_expr)
    }

    generate_block :: (&Self, block: &AstBlock) {
        builder.set_current_line(block.location.line)
        for child : block.children {
            generate_expression(<<child)

            // pop value if not last and type is not void
            if it_index < block.children.count() - 1 and child.typ != @type_info(void) {
                builder.build_pop()
            }
        }
    }

    generate_call :: (&Self, call: &AstCall) {
        builder.set_current_line(call.location.line)
        builder.build_noop()

        match call.function.value {
            .Function($func) -> {
                for arg : call.arguments {
                    generate_expression(<<arg)
                }
                builder.set_current_line(call.location.line)
                builder.build_comp_call(call.ast_function)
                builder.build_const(0) // @temp
            }

            .NativeFunc($func) -> {
                for arg : call.arguments {
                    generate_expression(<<arg)
                }
                builder.set_current_line(call.location.line)
                builder.build_native_call(func, call.arguments.count())
                builder.build_const(0) // @temp
            }

            _ -> {
                error_handler.report_error_at(call.function.location, "Can't call {}", [call.function.value])
            }
        }
        // match call.function {
        //     AstIdentifier($id) -> {


        //         if id.name == "print" {
        //             for arg : call.arguments {
        //                 generate_expression(<<arg)
        //                 builder.set_current_line(call.location.line)
        //                 builder.build_print()
        //             }
        //         } else {
        //             for arg : call.arguments {
        //                 generate_expression(<<arg)
        //             }
        //             builder.set_current_line(call.location.line)
        //             builder.build_comp_call(call.ast_function)
        //         }
        //     }

        //     _ -> {
        //         error_handler.report_error_at(call.function.location, "Can't call non-identifier")
        //     }
        // }
    }

    generate_number_literal :: (&Self, num: &AstNumberLiteral) {
        builder.set_current_line(num.location.line)
        builder.build_const(num.int_value)
    }

    generate_identifier :: (&Self, id: &AstIdentifier) {
        builder.set_current_line(id.location.line)
        builder.build_const(0)
        // match function.get_parameter(id.name) {
        //     Some($param) -> {
        //         builder.build_load_local(-1)
        //     }

        //     None -> {
        //         msg := fmt.format("Unknown identifier '{}'", [id.name])
        //         error_handler.report_error_at(id.location, msg.slice())
        //         builder.build_panic(msg.slice())
        //     }
        // }
    }
}

InstructionBuilder :: struct {
    function        : ^CBCFunction
    current_line    : int
    strings         : &StringDatabase
}

impl InstructionBuilder {
    new :: (strings: &StringDatabase) -> InstructionBuilder {
        return InstructionBuilder(
            function        = null
            current_line    = -1
            strings         = strings
        )
    }

    begin_function :: (&Self, func: ^CBCFunction) {
        current_line = -1
        function = func
    }

    end_function :: (&Self) {
        function = null
    }

    code_view :: (&Self) -> []u64 {
        return function.instructions.slice()
    }

    fix_branch :: (&Self, branch: int, address: int) {
        function.instructions[branch] = u64(address)
    }

    set_current_line :: (&Self, line: int) {
        lines := &function.debug_info.lines
        if lines.count() > 0 and lines.peek_last().count == 0 {
            lines.peek_last().line = line
        } else if current_line != line {
            function.debug_info.lines.add(LineInfo(line, 0))
        }
        current_line = line
    }

    add_local :: (&Self, id: int, name: string, size: int) -> int {
        // size is in bytes, but the index is in stack slots, which are 8 bytes, so add 7 and divide by 8
        slots := (size + 7) / 8

        // debug info
        function.debug_info.locals.add(VariableInfo(id, name, function.local_slots))

        //
        current_size := function.local_slots
        function.local_slots += slots
        return current_size
    }

    next :: (&Self) -> int {
        return function.instructions.get_length()
    }

    add_debug_info_line :: () #macro #transparent {
        @assert(function.debug_info.lines.count() > 0)
        current_instruction_count := function.instructions.count()
        defer {
            new_instruction_count := function.instructions.count()
            function.debug_info.lines.peek_last().count += new_instruction_count - current_instruction_count
        }
    }

    build_noop :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Noop)
    }

    build_pop :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Pop)
    }

    build_const :: (&Self, value: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Const)
        function.instructions.add(<<cast(^u64)^value)
    }

    build_address_of :: (&Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.AddressOf)
        function.instructions.add(<<cast(^u64)^index)
    }

    build_load :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Load)
    }

    build_store :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Store)
    }

    build_load_local :: (&Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.LoadLocal)
        function.instructions.add(<<cast(^u64)^index)
    }

    build_store_local :: (&Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.StoreLocal)
        function.instructions.add(<<cast(^u64)^index)
    }

    build_add :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Add)
    }

    build_sub :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Sub)
    }

    build_mul :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mul)
    }

    build_div :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Div)
    }

    build_mod :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mod)
    }

    build_and :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.And)
    }

    build_or :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Or)
    }

    build_ieq :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ieq)
    }

    build_ilt :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ilt)
    }

    build_ile :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ile)
    }

    build_igt :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Igt)
    }

    build_ige :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ige)
    }

    build_branch :: (&Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Branch)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_branch_if :: (&Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.BranchIf)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_call :: (&Self, name: string, arity: int = 0) {
        add_debug_info_line()
        name = strings.intern(name)
        function.instructions.add(cast Instruction.Call)
        function.instructions.add(cast name.bytes.data)
        function.instructions.add(cast name.bytes.length)
        function.instructions.add(cast arity)
    }

    build_native_call :: (&Self, func: NativeFunction, arity: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.NativeCall)
        func, data := FatFunctions.destructure(func, u64, u64)
        function.instructions.add(func)
        function.instructions.add(data)
        function.instructions.add(cast arity)
    }

    build_comp_call :: (&Self, ast_func: ^AstFunction) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CompCall)
        function.instructions.add(cast ast_func)
        function.instructions.add(0)
        function.instructions.add(0)
    }

    build_return :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Return)
    }

    build_return_void :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.ReturnVoid)
    }

    build_halt :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Halt)
    }

    build_panic :: (&Self, msg: string) {
        add_debug_info_line()
        msg = strings.intern(msg)
        function.instructions.add(cast Instruction.Panic)
        function.instructions.add(cast msg.bytes.data)
        function.instructions.add(cast msg.bytes.length)
    }
}