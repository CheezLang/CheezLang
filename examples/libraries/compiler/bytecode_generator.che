use import std.array
use import std.map
use import std.rc
use import std.string

mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import logging.logger

use import ast
use import ast_dumper
use import error_handler
use import interpreter
use import lexer
use import string_database
use import types
use import value

#export_scope

CodeGenerator :: trait {
    generate_code_for_function :: (&Self, func: ^AstFunction);
}

ByteCodeGenerator :: struct {
    strings         : &StringDatabase
    error_handler   : &ErrorHandler
    allocator       : ^mem.Allocator
    builder         : InstructionBuilder

    variables       := Map[int, int].new()

    function        : ^AstFunction = null

    build_range_checks  := true
    build_null_checks   := true
}

impl ByteCodeGenerator {
    new :: (strings: &StringDatabase, error_handler: &ErrorHandler, allocator: ^mem.Allocator) -> Rc[ByteCodeGenerator] {
        return Rc[ByteCodeGenerator].new(ByteCodeGenerator(
            strings         = strings
            error_handler   = error_handler
            allocator       = allocator
            builder         = InstructionBuilder.new(strings)
        ))
    }

    allocate_function :: (&Self, name: string, path: string) -> ^CBCFunction {
        func := mem.alloc(CBCFunction, allocator)
        *func = CBCFunction(
            ast_function = function
            debug_info = CBCDebugInfo(
                path       = path.to_owned()
            )
        )
        return func
    }
}

impl CodeGenerator for ByteCodeGenerator {
    generate_code_for_function :: (&Self, func: ^AstFunction) {
        if function != null {
            error_handler.report_error_at(
                func.location,
                "Failed to generate code for this function because we're already generating code for another function at {}",
                [function.location])
            return
        }

        function = func
        defer function <- null

        file_path := func.location.file
        cbc_func := self.allocate_function(func.name, file_path)
        builder.begin_function(cbc_func)

        slot_index := 0
        for(reverse=true) param in &func.params {
            slot_index -= slots_for_size(param.var_type.size)
            variables.set(param.id, slot_index)
            cbc_func.debug_info.params.add(VariableInfo(param.id, param.name, slot_index, param.var_type))
        }
        cbc_func.parameter_slots = -slot_index

        generate_expression(&*func.body)
        builder.set_location(func.body.location.end())
        builder.build_return_void()

        builder.end_function()

        func.bytecode = cbc_func
    }

    generate_code_for_expression :: (&Self, node: &AstNode) -> ^CBCFunction {
        file_path := node.location.file
        cbc_func := self.allocate_function("$expr", file_path)
        builder.begin_function(cbc_func)
        generate_expression(node)
        builder.build_store_stack(0, slots_for_size(node.typ.size))
        builder.build_halt()
        builder.end_function()
        return cbc_func
    }

    generate_expression :: (&Self, node: &AstNode, deref: bool = true) {
        builder.set_location(node.location)
        match node {
            AstArgument($arg)       -> generate_argument(arg)
            AstArray($arr)          -> generate_array(arr)
            AstAssignment($ass)     -> generate_assignment(ass)
            AstBinary($bin)         -> generate_binary(bin)
            AstBlock($block)        -> generate_block(block)
            AstBool($bol)           -> generate_bool(bol)
            AstBreak($brake)        -> generate_break(brake)
            AstCall($call)          -> generate_call(call)
            AstCast($cst)           -> generate_cast(cst)
            AstConstDecl($decl)     -> generate_const_decl(decl)
            AstContinue($cont)      -> generate_continue(cont)
            AstDecl($decl)          -> generate_decl(decl)
            AstDefer($def)          -> generate_defer(def)
            AstDot($dot)            -> generate_dot(dot, deref)
            AstFor($forr)           -> generate_for(forr)
            AstIdentifier($id)      -> generate_identifier(id, deref)
            AstIf($iff)             -> generate_if(iff)
            AstIndex($index)        -> generate_index(index)
            AstLoop($lop)           -> generate_loop(lop)
            AstNumberLiteral($num)  -> generate_number_literal(num)
            AstReturn($ret)         -> generate_return(ret)
            AstString($str)         -> generate_string(str)
            AstUnary($un)           -> generate_unary(un)

            _ -> {
                dump := dump_ast(node, recurse = false)
                error_handler.report_error(
                    "generate_expression: not implemented: {}",
                    [dump])
            }
        }
    }

    generate_const_decl :: (&Self, decl: &AstConstDecl) {
        // do nothing
    }

    generate_assignment :: (&Self, ass: &AstAssignment) {
        match ass.pattern {
            // x = z
            AstIdentifier($id) -> match id.symbol {
                .Decl($decl) -> {
                    // @todo: figure out if this is a local variable or a global
                    generate_expression(ass.value_expr)
                    builder.set_location(ass.location)
                    builder.build_store_local(*self.variables[decl.id], slots_for_size(ass.value_expr.typ.size))
                }
                
                _ -> {
                    error_handler.report_error_at(ass.pattern.location, "generate_assignment: symbol not implemented: {}", [id.symbol])
                }
            }

            // x[y] = z
            AstIndex($node) -> {
                match node.sub.typ {
                    TypeInfoArray($ti) -> match node.index.typ {
                        TypeInfoInt(_) -> {
                            // address
                            generate_expression(node.sub, deref = false)
                            generate_expression(&*node.index)
                            // @todo: cast index to i64

                            if self.build_range_checks {
                                builder.build_const_int(0)
                                builder.build_const_int(ti.count)
                                builder.build_check_range()
                            }

                            builder.build_const_int(ti.target.size)
                            builder.build_mul(.I64)
                            builder.build_add(.I64)

                            // value
                            generate_expression(ass.value_expr)

                            // =
                            builder.build_store(slots_for_size(ti.target.size))
                        }

                        _ -> {
                            error_handler.report_error_at(
                                node.index.location,
                            "generate_assignment not implemented for index: ({})[{}]",
                                [node.sub.typ, node.index.typ])
                        }
                    }

                    _ -> {
                        error_handler.report_error_at(
                            node.sub.location,
                            "generate_assignment not implemented for index: '{}'",
                            [node.sub.typ])
                    }
                }
            }

            AstDot($dot) if dot.symbol == .StructMember -> {
                member := dot.symbol.StructMember
                
                // struct ptr
                generate_expression(&*dot.sub, deref = false)
                // @todo: deal with non l-values
                builder.build_const_int(member.offset)
                builder.build_add(.I64)

                // value
                generate_expression(ass.value_expr)

                // =
                builder.build_store(slots_for_size(dot.typ.size))
            }

            AstUnary($un) if un.operator == .Deref -> {
                // ptr
                generate_expression(un.sub)

                // value
                generate_expression(ass.value_expr)

                // =
                builder.build_store(slots_for_size(un.typ.size))
            }

            _ -> {
                error_handler.report_error_at(ass.pattern.location, "generate_assignment: pattern not implemented")
            }
        }
    }

    generate_array :: (&Self, arr: &AstArray) {
        builder.set_location(arr.location)

        // pushes the array and then the index
        builder.build_push(slots_for_size(arr.typ.size))
        builder.build_load_address()

        for val in &arr.values {
            builder.build_dup(1)
            generate_expression(&**val)
            builder.build_store(slots_for_size(val.typ.size))

            // increment pointer
            builder.build_const_int(slots_for_size(val.typ.size) * @sizeof(u64))
            builder.build_add(.U64)
        }
        // pop index
        builder.build_pop(1)
    }

    generate_decl :: (&Self, decl: &AstDecl) {
        builder.set_location(decl.location)
        builder.build_noop()

        index := builder.add_local(decl.id, decl.name, decl.var_type)
        variables.set(decl.id, index)

        if decl.value_expr != null {
            generate_expression(&*decl.value_expr)
            builder.build_store_local(index, slots_for_size(decl.var_type.size))
        }
    }

    generate_unary :: (&Self, un: &AstUnary) {
        match un.operator {
            .Not -> {
                generate_expression(un.sub)
                builder.set_location(un.location)
                builder.build_not()
            }
            .Neg -> {
                generate_expression(un.sub)
                builder.set_location(un.location)
                builder.build_neg(type_info_to_inst_number_type(un.sub.typ))
            }

            .Ptr -> {
                generate_expression(un.sub, deref = false)
            }
            .PtrMut -> {
                generate_expression(un.sub, deref = false)
            }
            .Ref -> {
                generate_expression(un.sub, deref = false)
            }
            .RefMut -> {
                generate_expression(un.sub, deref = false)
            }

            .Deref -> {
                generate_expression(un.sub)
                builder.build_load(slots_for_size(un.typ.size))
            }

            _ -> error_handler.report_error_at(un.location, "Code gen for unary not implemented")
        }
    }

    generate_binary :: (&Self, bin: &AstBinary) {
        generate_expression(bin.left)
        generate_expression(bin.right)
        builder.set_location(bin.location)
        match bin.operator {
            .Add        -> builder.build_add(type_info_to_inst_number_type(bin.typ))
            .Sub        -> builder.build_sub(type_info_to_inst_number_type(bin.typ))
            .Mul        -> builder.build_mul(type_info_to_inst_number_type(bin.typ))
            .Div        -> builder.build_div(type_info_to_inst_number_type(bin.typ))
            .Mod        -> builder.build_mod(type_info_to_inst_number_type(bin.typ))
            
            .Equal      -> builder.build_ieq(type_info_to_inst_number_type(bin.left.typ))
            .NotEqual   -> builder.build_ine(type_info_to_inst_number_type(bin.left.typ))
            .Less       -> builder.build_ilt(type_info_to_inst_number_type(bin.left.typ))
            .LessEq     -> builder.build_ile(type_info_to_inst_number_type(bin.left.typ))
            .Greater    -> builder.build_igt(type_info_to_inst_number_type(bin.left.typ))
            .GreaterEq  -> builder.build_ige(type_info_to_inst_number_type(bin.left.typ))

            .And        -> builder.build_and()
            .Or         -> builder.build_or()

            .Move       -> {
                error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .Pipe       -> {
                error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .Range      -> {
                error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .RangeIncl  -> {
                error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
        }
    }

    generate_if :: (&Self, iff: &AstIf) {
        builder.set_location(iff.location)
        
        // condition
        generate_expression(iff.condition)
        br_true := builder.build_branch_if(0)

        // else case
        if iff.false_case != null {
            generate_expression(&*iff.false_case)
        } else {
            builder.set_location(iff.location)
            builder.build_const_int(0)
        }

        // builder.set_location(iff.location)
        br_end := builder.build_branch(0)

        // if case
        l_true := builder.next()
        generate_expression(iff.true_case)

        // end
        l_end := builder.next()

        // fix branches
        builder.fix_branch(br_true, l_true)
        builder.fix_branch(br_end, l_end)
    }

    generate_index :: (&Self, node: &AstIndex) {
        match node.sub.typ {
            TypeInfoArray($ti) -> match node.index.typ {
                TypeInfoInt(_) -> {
                    generate_expression(node.sub, deref = false)
                    generate_expression(&*node.index)
                    // @todo: cast index to i64

                    if self.build_range_checks {
                        builder.build_const_int(0)
                        builder.build_const_int(ti.count)
                        builder.build_check_range()
                    }

                    builder.build_const_int(ti.target.size)
                    builder.build_mul(.I64)
                    builder.build_add(.I64)
                    builder.build_load(slots_for_size(ti.target.size))
                }

                _ -> {
                    error_handler.report_error_at(
                        node.index.location,
                    "generate_index not implemented for: ({})[{}]",
                        [node.sub.typ, node.index.typ])
                }
            }

            _ -> {
                error_handler.report_error_at(
                    node.sub.location,
                    "generate_index not implemented for: '{}'",
                    [node.sub.typ])
            }
        }
    }

    generate_loop :: (&Self, lop: &AstLoop) {
        builder.set_location(lop.location)
        loop_start := builder.next()
        generate_expression(lop.body)
        builder.build_pop(slots_for_size(lop.body.typ.size))
        builder.build_branch(loop_start)
    }

    generate_for :: (&Self, forr: &AstFor) {
        builder.set_location(forr.location)
        builder.build_const_int(0)
    }

    generate_break :: (&Self, brake: &AstBreak) {
        builder.set_location(brake.location)
        builder.build_const_int(0)
    }

    generate_continue :: (&Self, cont: &AstContinue) {
        builder.set_location(cont.location)
        builder.build_const_int(0)
    }

    generate_return :: (&Self, ret: &AstReturn) {
        builder.set_location(ret.location)

        if ret.value_expr != null {
            generate_expression(&*ret.value_expr)
            builder.set_location(ret.location)
            builder.build_return()
        } else {
            builder.build_return_void()
        }
    }

    generate_dot :: (&Self, dot: &AstDot, deref: bool) {
        builder.set_location(dot.location)

        name := dot.name.name
        match dot.sub.typ {
            TypeInfoArray($ti) -> {
                if name == "length" or name == "count" { // @todo: remove length eventually
                    builder.build_const_int(ti.count)
                } else if name == "data" {
                    error_handler.report_error_at(dot.location, "generate_dot: not implemented: {}.{}", [dot.sub.typ, dot.name.name])
                } else {
                    @assert(false)
                }
            }

            TypeInfoStruct($ti) -> {
                member := dot.symbol.StructMember
                
                // struct ptr
                generate_expression(&*dot.sub, deref = false)
                // @todo: deal with non l-values
                builder.build_const_int(member.offset)
                builder.build_add(.I64)

                if deref {
                    builder.build_load(slots_for_size(dot.typ.size))
                } else {
                    // pointer is already on top of stack
                }
            }

            _ -> {
                error_handler.report_error_at(dot.location, "generate_dot: not implemented: {}.{}", [dot.sub.typ, dot.name.name])
            }
        }
    }

    generate_defer :: (&Self, def: &AstDefer) {
        error_handler.report_error_at(def.location, "generate_defer: not implemented")
        builder.set_location(def.location)
        builder.build_const_int(0)
    }

    generate_bool :: (&Self, bol: &AstBool) {
        builder.set_location(bol.location)
        builder.build_const_int(if bol.bool_value then 1 else 0)
    }

    generate_string :: (&Self, str: &AstString) {
        builder.set_location(str.location)
        // @! strings are length first, then pointer
        // same as slices
        builder.build_const_int(cast str.string_value.bytes.length)
        builder.build_const_int(cast str.string_value.bytes.data)
    }

    generate_argument :: (&Self, arg: &AstArgument) {
        generate_expression(arg.value_expr)
    }

    generate_block :: (&Self, block: &AstBlock) {
        builder.set_location(block.location)
        for child in &block.children {
            generate_expression(&**child)

            // pop value if not last and type is not void
            if it_index < block.children.count() - 1 and child.typ != @type_info(void) {
                builder.build_pop(slots_for_size(child.typ.size))
            }
        }

        builder.set_location(block.location.end())
        builder.build_noop()
    }

    generate_cast :: (&Self, cst: &AstCast) {
        from := cst.value_expr.typ
        to := cst.typ

        generate_expression(cst.value_expr)

        builder.set_location(cst.location)
        match from, to {
            TypeInfoFloat($from), TypeInfoFloat($to) -> {
                if from.size < to.size {
                    builder.build_cast_float_to_double()
                } else if from.size > to.size {
                    builder.build_cast_double_to_float()
                }
            }

            TypeInfoInt($from), TypeInfoInt($to) -> {
                match from.signed, to.signed {
                    true, true -> builder.build_cast_signed(type_info_to_inst_number_type(from), type_info_to_inst_number_type(to))
                    false, false -> builder.build_cast_unsigned(type_info_to_inst_number_type(from), type_info_to_inst_number_type(to))
                    true, false -> {
                        builder.build_cast_signed(type_info_to_inst_number_type(from), .I64)
                        builder.build_cast_signed_to_unsigned()
                        builder.build_cast_unsigned(.U64, type_info_to_inst_number_type(to))
                    }
                    false, true -> {
                        builder.build_cast_unsigned(type_info_to_inst_number_type(from), .U64)
                        builder.build_cast_unsigned_to_signed()
                        builder.build_cast_signed(.I64, type_info_to_inst_number_type(to))
                    }
                }
            }

            TypeInfoFloat($from), TypeInfoInt($to) -> {
                if from.size != 8 then
                    builder.build_cast_float_to_double()

                if to.signed then
                    builder.build_cast_double_to_signed()
                else
                    builder.build_cast_double_to_unsigned()

                if to.size != 8 {
                    if to.signed then
                        builder.build_cast_signed(.I64, type_info_to_inst_number_type(to))
                    else
                        builder.build_cast_unsigned(.U64, type_info_to_inst_number_type(to))
                }
            }

            TypeInfoInt($from), TypeInfoFloat($to) -> {
                if from.size != 8 {
                    if from.signed then
                        builder.build_cast_signed(type_info_to_inst_number_type(from), .I64)
                    else
                        builder.build_cast_unsigned(type_info_to_inst_number_type(from), .U64)
                }

                if from.signed then
                    builder.build_cast_signed_to_double()
                else
                    builder.build_cast_unsigned_to_double()

                if to.size != 8 {
                    builder.build_cast_double_to_float()
                }
            }

            _ -> {
                error_handler.report_error_at(cst.location, "generate_cast: not implemented: ({}) to ({})", [from, to])
            }
        }
    }

    generate_call :: (&Self, call: &AstCall) {
        builder.set_location(call.location)
        builder.build_noop()

        match call.function.value {
            .Function($func) -> {
                for arg in &call.arguments {
                    generate_expression(&**arg)
                }
                builder.set_location(call.location)
                builder.build_comp_call(call.ast_function)
            }

            .NativeFunc($func) -> {
                for arg in &call.arguments {
                    generate_expression(&**arg)
                }
                builder.set_location(call.location)
                builder.build_native_call(func)
            }

            .NativeFunc2($func) -> {
                for arg in &call.arguments {
                    generate_expression(&**arg)
                }
                builder.set_location(call.location)
                builder.build_native_call2(func.wrapper, func.func, NativeFunctionWrapper.slots_for_type(cast call.function.typ))
            }

            _ -> {
                error_handler.report_error_at(call.function.location, "generate_call: Can't call {}", [call.function.value])
            }
        }
        // match call.function {
        //     AstIdentifier($id) -> {


        //         if id.name == "print" {
        //             for arg in call.arguments {
        //                 generate_expression(*arg)
        //                 builder.set_location(call.location)
        //                 builder.build_print()
        //             }
        //         } else {
        //             for arg in call.arguments {
        //                 generate_expression(*arg)
        //             }
        //             builder.set_location(call.location)
        //             builder.build_comp_call(call.ast_function)
        //         }
        //     }

        //     _ -> {
        //         error_handler.report_error_at(call.function.location, "Can't call non-identifier")
        //     }
        // }
    }

    generate_number_literal :: (&Self, num: &AstNumberLiteral) {
        builder.set_location(num.location)

        match num.value {
            .Int($i)    -> builder.build_const_int(i)
            .Float($f)  -> builder.build_const_float(f)
        }
    }

    generate_identifier :: (&Self, id: &AstIdentifier, deref: bool) {
        builder.set_location(id.location)
        match id.symbol {
            .Decl($decl) -> match self.variables.get(decl.id) {
                Some($index) -> {
                    if deref {
                        builder.build_load_local(*index, slots_for_size(decl.var_type.size))
                    } else {
                        builder.build_address_of(*index)
                    }
                }
                None -> {
                    msg :: "[FATAL] Failed to get index of declaration"
                    builder.build_panic(msg)
                    error_handler.report_error_at(id.location, msg)
                }
            }

            .ConstDecl($decl) -> match decl.value {
                .Int($i) -> builder.build_const_int(i)
                .Float($f) -> builder.build_const_float(f)
                .Bool($b) -> builder.build_const_int(if b then 1 else 0)
                .String($s) -> {
                    builder.build_const_int(cast s.bytes.length)
                    builder.build_const_int(cast s.bytes.data)
                }
            }

            .Val($val) -> match val.value {
                .Int($i) -> builder.build_const_int(i)
                .Float($f) -> builder.build_const_float(f)
                .Bool($b) -> builder.build_const_int(if b then 1 else 0)
                .String($s) -> {
                    builder.build_const_int(cast s.bytes.length)
                    builder.build_const_int(cast s.bytes.data)
                }
            }

            _ -> {
                error_handler.report_error_at(id.location, "generate_identifier: not implemented: {}", [id.symbol])
            }
        }
        // match function.get_parameter(id.name) {
        //     Some($param) -> {
        //         builder.build_load_local(-1)
        //     }

        //     None -> {
        //         msg := fmt.format("Unknown identifier '{}'", [id.name])
        //         error_handler.report_error_at(id.location, msg.slice())
        //         builder.build_panic(msg.slice())
        //     }
        // }
    }
}

InstructionBuilder :: struct {
    function            : ^CBCFunction
    current_location    : Location
    strings             : &StringDatabase
}

impl InstructionBuilder {
    new :: (strings: &StringDatabase) -> InstructionBuilder {
        return InstructionBuilder(
            function            = null
            current_location    = Location(line = -1, column = -1)
            strings             = strings
        )
    }

    begin_function :: (&Self, func: ^CBCFunction) {
        current_location = Location(line = -1, column = -1)
        function = func
    }

    end_function :: (&Self) {
        function = null
    }

    code_view :: (&Self) -> []u64 {
        return function.instructions.slice()
    }

    fix_branch :: (&Self, branch: int, address: int) {
        *function.instructions[branch] = u64(address)
    }

    set_location :: (&Self, location: Location) {
        locations := &function.debug_info.locations
        if locations.count() > 0 and locations.peek_last().count == 0 {
            locations.peek_last().location = location
        } else if current_location.line != location.line or current_location.column != location.column {
            function.debug_info.locations.add(LineInfo(location, 0))
        }
        current_location = location
    }

    add_local :: (&Self, id: int, name: string, type_info: ^TypeInfo) -> int {
        // debug info
        function.debug_info.locals.add(VariableInfo(id, name, function.local_slots, type_info))

        //
        current_size := function.local_slots
        function.local_slots += slots_for_size(type_info.size)
        return current_size
    }

    next :: (&Self) -> int {
        return function.instructions.get_length()
    }

    add_debug_info_line :: () #macro #transparent {
        @assert(function.debug_info.locations.count() > 0)
        current_instruction_count := function.instructions.count()
        defer {
            new_instruction_count := function.instructions.count()
            function.debug_info.locations.peek_last().count += new_instruction_count - current_instruction_count
        }
    }

    build_noop :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Noop)
    }

    build_push :: (&Self, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Push)
        function.instructions.add(cast slots)
    }

    build_pop :: (&Self, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Pop)
        function.instructions.add(cast slots)
    }

    build_dup :: (&Self, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Dup)
        function.instructions.add(cast slots)
    }

    build_const_int :: (&Self, value: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.ConstInt)
        function.instructions.add(cast value)
    }

    build_const_float :: (&Self, value: f64) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.ConstFloat)
        function.instructions.add(*cast(^u64)^value)
    }

    build_load_address :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.LoadAddress)
    }

    build_address_of :: (&Self, index: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.AddressOf)
        function.instructions.add(*cast(^u64)^index)
    }

    build_load :: (&Self, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Load)
        function.instructions.add(cast slots)
    }

    build_store :: (&Self, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Store)
        function.instructions.add(cast slots)
    }

    build_load_local :: (&Self, index: int, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.LoadLocal)
        function.instructions.add(*cast(^u64)^index)
        function.instructions.add(cast slots)
    }

    build_store_local :: (&Self, index: int, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.StoreLocal)
        function.instructions.add(*cast(^u64)^index)
        function.instructions.add(cast slots)
    }

    build_store_stack :: (&Self, index: int, slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.StoreStack)
        function.instructions.add(cast index)
        function.instructions.add(cast slots)
    }

    build_cast_float_to_double :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastFD)
    }

    build_cast_double_to_float :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastDF)
    }

    build_cast_double_to_signed :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastDS)
    }

    build_cast_double_to_unsigned :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastDU)
    }

    build_cast_signed_to_double :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastSD)
    }

    build_cast_unsigned_to_double :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastUD)
    }

    build_cast_signed :: (&Self, from: InstNumTyp, to: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastSigned)
        function.instructions.add(cast from)
        function.instructions.add(cast to)
    }

    build_cast_unsigned :: (&Self, from: InstNumTyp, to: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastUnsigned)
        function.instructions.add(cast from)
        function.instructions.add(cast to)
    }

    build_cast_signed_to_unsigned :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastSU)
    }

    build_cast_unsigned_to_signed :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CastUS)
    }

    build_add :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Add)
        function.instructions.add(cast typ)
    }

    build_sub :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Sub)
        function.instructions.add(cast typ)
    }

    build_mul :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mul)
        function.instructions.add(cast typ)
    }

    build_div :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Div)
        function.instructions.add(cast typ)
    }

    build_mod :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Mod)
        function.instructions.add(cast typ)
    }

    build_and :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.And)
    }

    build_or :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Or)
    }

    build_neg :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Neg)
        function.instructions.add(cast typ)
    }

    build_not :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Not)
    }

    build_ieq :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ieq)
        function.instructions.add(cast typ)
    }

    build_ine :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ine)
        function.instructions.add(cast typ)
    }

    build_ilt :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ilt)
        function.instructions.add(cast typ)
    }

    build_ile :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ile)
        function.instructions.add(cast typ)
    }

    build_igt :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Igt)
        function.instructions.add(cast typ)
    }

    build_ige :: (&Self, typ: InstNumTyp) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Ige)
        function.instructions.add(cast typ)
    }

    build_branch :: (&Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Branch)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_branch_if :: (&Self, address: int) -> int {
        add_debug_info_line()
        function.instructions.add(cast Instruction.BranchIf)
        function.instructions.add(cast address)
        return function.instructions.count() - 1
    }

    build_call :: (&Self, name: string, arity: int = 0) {
        add_debug_info_line()
        name = strings.intern(name)
        function.instructions.add(cast Instruction.Call)
        function.instructions.add(cast name.bytes.data)
        function.instructions.add(cast name.bytes.length)
        function.instructions.add(cast arity)
    }

    build_native_call :: (&Self, func: ^NativeFunctionWrapper) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.NativeCall)
        function.instructions.add(cast func)
    }

    build_native_call2 :: (&Self, wrapper: NativeFunctionWrapper2, func: fn(), arg_slots: int) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.NativeCall2)
        function.instructions.add(*cast(^uint) ^wrapper)
        function.instructions.add(*cast(^uint) ^func)
        function.instructions.add(cast arg_slots)
    }

    build_comp_call :: (&Self, ast_func: ^AstFunction) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CompCall)
        function.instructions.add(cast ast_func)
        function.instructions.add(0)
        function.instructions.add(0)
    }

    build_return :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Return)
    }

    build_return_void :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.ReturnVoid)
    }

    build_halt :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.Halt)
    }

    build_check_range :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CheckRange)
    }

    build_check_null :: (&Self) {
        add_debug_info_line()
        function.instructions.add(cast Instruction.CheckNull)
    }

    build_panic :: (&Self, msg: string) {
        add_debug_info_line()
        msg = strings.intern(msg)
        function.instructions.add(cast Instruction.Panic)
        function.instructions.add(cast msg.bytes.data)
        function.instructions.add(cast msg.bytes.length)
    }
}

#file_scope

slots_for_size :: (size_in_bytes: int) -> int {
    return (size_in_bytes + 7) / 8
}

type_info_to_inst_number_type :: (type_info: ^TypeInfo) -> InstNumTyp {
    return match &*type_info {
        TypeInfoInt($ti) -> match ti.size, ti.signed {
            (1, true)   -> .I8
            (2, true)   -> .I16
            (4, true)   -> .I32
            (8, true)   -> .I64
            (1, false)  -> .U8
            (2, false)  -> .U16
            (4, false)  -> .U32
            (8, false)  -> .U64
            _ -> @assert(false)
        }
        TypeInfoFloat($ti) -> match ti.size {
            4 -> .F32
            8 -> .F64
            _ -> @assert(false)
        }
        _ -> @assert(false)
    }
}
