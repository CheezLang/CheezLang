use import std.array
use import std.hash_table
use import std.map
use import std.string
use import std.box
use import std.rc
use import std.thread
use import std.mem.std_heap_allocator
use import std.os.windows
use import std.os.windows_functions

io  :: import std.io
mem :: import std.mem.allocator
fmt :: import std.fmt
fs  :: import std.io.fs

use import json.json
use import dap.debug_adapter
use import logging.logger

use import compiler
use import interpreter
use import jobs
use import bytecode_generator
use import string_database
use import error_handler
use import ast
use import lexer
use import parser
use import ast_dumper
use import value

LOG_PATH :: "P:/dev/CheezLang/data/logs/debugger_log.txt"
CBC_FILE :: "p:/dev/debug_adapter_test/fac.cbc"

Main :: () {
    logger := FileLogger.new(LOG_PATH)
    // g_logger = cast ^logger.get()
    {
        l : ^Logger = ^logger.get()
        Logger.set_global_logger(l)
    }

    debugger := CheezDebugAdapter.new()
    adapter := DebugAdapter.new(debugger)

    adapter.get().run()
}

DebuggerCallbacks :: trait {
    hit_breakpoint :: (&Self);
    step_done :: (&Self);
    terminated :: (&Self);
    output_generated :: (&Self, format: string, args: []^any = [], category: string = "console");
}

Debugger :: struct {
    interp      : ^Interpreter
    cond_run    : Rc[ConditionVariable]
    lock_run    : Rc[ReentrantLock]
    cond_pause  : Rc[ConditionVariable]
    lock_pause  : Rc[ReentrantLock]
    callbacks   : ^DebuggerCallbacks

    breakpoints : Map[String, Array[Breakpoint]]

    running     : bool = false
    fp_old      : int  = 0
    line_break  : int  = 0
    no_break    : bool = false
    break_cond  := BreakCondition.None
    old_frame   := StackFrame()
}

BreakCondition :: enum {
    None, StepIn, StepOut, Step
}

impl Debugger {
    new :: () -> Rc[Debugger] {
        return Rc[Debugger].new(Debugger(
            interp      = null
            cond_run    = ConditionVariable.new()
            lock_run    = ReentrantLock.new()
            cond_pause  = ConditionVariable.new()
            lock_pause  = ReentrantLock.new()
            breakpoints = Map[String, Array[Breakpoint]].new()
            running     = false
            no_break    = false
            callbacks   = null
        ))
    }

    set_callbacks :: (&Self, callbacks: ^DebuggerCallbacks) {
        self.callbacks = callbacks
    }

    store_old_state :: (&Self) {
        if interp == null {
            return
        }
        self.old_frame = <<^interp.frames[interp.fp]
        self.fp_old = interp.fp
        self.line_break = get_current_line()
    }

    get_current_line :: (&Self) -> int {
        frame := &interp.get_stackframes()[interp.fp]
        return frame.func.debug_info.get_line_for_ip(frame.ip)
    }

    launch :: (&Self) {
        resume()
    }

    pause :: (&Self) {
        running = false
        // cond_pause.get().wait(lock_pause.get())
        // lock_pause.get().release()
    }

    resume :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.None
        cond_run.get().notify()
    }

    step :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.Step
        cond_run.get().notify()
    }

    step_in :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.StepIn
        cond_run.get().notify()
    }

    step_out :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.StepOut
        cond_run.get().notify()
    }

    is_on_breakpoint :: (&Self) -> bool {
        if interp == null {
            return false
        }
        if breakpoints.count() == 0 {
            return false
        }

        frame := &interp.get_stackframes()[interp.fp]

        path := frame.func.debug_info.path.slice()
        line := frame.func.debug_info.get_line_for_ip(frame.ip)

        match breakpoints.get(path) {
            Some($arr) -> {
                for(by_ref=true) breakpoint : arr.slice() {
                    if breakpoint.line == line {
                        return true
                    }
                }
            }
        }

        return false
    }

    generate_output :: (&Self, format: string, args: []^any = [], category: string = "console") {
        if callbacks != null then callbacks.output_generated(format, args, category)
    }
}

impl CodeRunner for Debugger {
    run :: (&Self, interp: &Interpreter) {
        self.interp = ^interp

        self.store_old_state()

        if self.is_on_breakpoint() {
            if callbacks != null then callbacks.hit_breakpoint()
            running = false
        }

        loop {
            while !running {
                cond_run.get().wait(lock_run.get())
            }
            defer lock_run.get().release()

            // dont break on breakpoints on first iteration
            no_break = true

            // 
            while running {
                frame := &interp.get_stackframes()[interp.fp]
                line := frame.func.debug_info.get_line_for_ip(frame.ip)

                if frame.func != old_frame.func or line != line_break {
                    no_break = false
                }

                if !no_break and self.is_on_breakpoint() {
                    self.old_frame = default
                    self.fp_old = 0
                    self.line_break = 0
                    self.break_cond = BreakCondition.None
                    running = false
                    if callbacks != null then callbacks.hit_breakpoint()
                    break
                }

                do_break := match &self.break_cond {
                    .None    -> false
                    .Step    -> interp.fp < fp_old or (frame.func == old_frame.func and line != line_break)
                    .StepIn  -> interp.fp != fp_old or (frame.func == old_frame.func and line != line_break)
                    .StepOut -> interp.fp < fp_old
                }

                if do_break {
                    self.old_frame = default
                    self.fp_old = 0
                    self.line_break = 0
                    self.break_cond = BreakCondition.None
                    running = false
                    if callbacks != null then callbacks.step_done()
                    break
                }

                match interp.step() {
                    .Done -> {
                        running = false
                        if callbacks != null then callbacks.terminated()
                        return
                    }
                }

                if !running {
                    if callbacks != null then callbacks.hit_breakpoint()
                    break
                }
            }

            running = false
            // cond_pause.get().notify()
        }
    }
}

CheezDebugAdapter :: struct CommandHandler {
    debugger        : Rc[Debugger]
    variable_refs   : Array[Rc[VariableRef]]

    string_db       := StringDatabase.new()

    text_provider   : ^TextProvider = null

    compiler        := Rc[Compiler].empty()
}

impl CheezDebugAdapter {
    new :: () -> Rc[CommandHandler] {
        command_handler := mem.alloc(CheezDebugAdapter)
        <<command_handler = CheezDebugAdapter(
            adapter = null
            debugger = Debugger.new()
            variable_refs   = Array[Rc[VariableRef]].create()
        )

        return Rc[CommandHandler].from_pointer(command_handler, owned = true)
    }

    clear_variable_refs :: (&Self) {
        variable_refs.clear()
    }

    get_variable_reference :: (&Self, index: int) -> &VariableRef {
        @assert(index >= 1 and index <= variable_refs.count())
        return variable_refs[index - 1].get()
    }

    add_variable_ref:: (&Self, var_ref: Rc[VariableRef]) -> int {
        index := variable_refs.count() + 1
        var_ref.get().index = index
        variable_refs.add(var_ref)
        return index
    }

    collect_scopes :: (&Self, frame: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()


        locals := LocalsScope.new(debugger.get().interp, frame)
        result.add(locals.clone().change_type(VariableRef))

        args := ArgumentsScope.new(debugger.get().interp, frame)
        result.add(args.clone().change_type(VariableRef))

        registers := RegistersScope.new(debugger.get().interp, frame)
        result.add(registers.clone().change_type(VariableRef))

        return result
    }

    print_string :: (&Self, interp: ^Interpreter) {
        frame := interp.top_frame()
        self.adapter.emit_output_event(fmt.format("{}", [frame.get_arg(0, string)]), "console")
    }

    print_int :: (&Self, interp: ^Interpreter) {
        frame := interp.top_frame()
        self.adapter.emit_output_event(fmt.format("{}", [frame.get_arg(0, int)]), "console")
    }

    print_float :: (&Self, interp: ^Interpreter) {
        frame := interp.top_frame()
        self.adapter.emit_output_event(fmt.format("{}", [frame.get_arg(0, f64)]), "console")
    }

    debug_break :: (&Self, interp: ^Interpreter) {
        debugger.get().pause()
    }

    compile_cheez_program :: (&Self, path: string) {
        compiler = Compiler.new(1, ^self)

        // register native functions
        compiler.get().global_scope.define_native_function(
            "print_string",
            NativeFunctionWrapper.new(cast(NativeFunction) self.print_string, fn(string)))
        compiler.get().global_scope.define_native_function(
            "print_int",
            NativeFunctionWrapper.new(cast(NativeFunction) self.print_int, fn(int)))
        compiler.get().global_scope.define_native_function(
            "print_float",
            NativeFunctionWrapper.new(cast(NativeFunction) self.print_float, fn(f64)))
        compiler.get().global_scope.define_native_function(
            "debugbreak",
            NativeFunctionWrapper.new(cast(NativeFunction) self.debug_break, fn()))
        //

        compiler.get().code_runner = debugger.clone().change_type(CodeRunner)
        compiler.get().add_job(LoadFileJob.new(path.to_owned()))
        compiler.get().start_compilation()
    }
}

impl ErrorHandler for CheezDebugAdapter {
    has_errors :: (&Self) -> bool {
        return false
    }

    report_error_at :: (&Self, location: &Location, message: string, args: []^any) {
        msg := fmt.format(message, args)
        g_logger.log("[Code Gen] {}: {}", [location, msg])
    }

    report_error :: (&Self, message: string, args: []^any) {
        msg := fmt.format(message, args)
        g_logger.log("[Code Gen] {}", [msg])
    }
}


impl DebuggerCallbacks for CheezDebugAdapter {
    hit_breakpoint :: (&Self) {
        self.adapter.emit_stop_event("breakpoint")
    }

    step_done :: (&Self) {
        self.adapter.emit_stop_event("step")
    }

    terminated :: (&Self) {
        self.adapter.emit_terminated_event()
    }

    output_generated :: (&Self, format: string, args: []^any = [], category: string = "console") {
        g_logger.log("output_generated")
        self.adapter.emit_output_event(fmt.format(format, args), category)
    }
}

impl CommandHandler for CheezDebugAdapter {
    initialize :: (&Self) -> Result[(), String] {
        adapter.emit_initialized_event()
        // adapter.enqueue_event(.Initialized)
        return Ok()
    }

    launch :: (&Self, arguments: DapReqLaunch) -> Result[(), String] {
        debugger.get().set_callbacks(^self)

        if arguments.program.slice().ends_with(".che") {
            self.compile_cheez_program(arguments.program.slice())
        } else {
            return Err(fmt.format("Can't debug the file '{}'", [arguments.program]))
        }

        debugger.get().launch()

        return Ok()
    }

    threads :: (&Self) -> Result[Array[DapThread], String] {
        g_logger.log("request threads")
        result := Array[DapThread].create()
        result.add(DapThread(0, "Main Thread".to_owned()))
        g_logger.log("{}", [result.slice()])
        return Ok(result)
    }

    set_breakpoints :: (&Self, arguments: DapSetBreakpoints) -> Result[(), String] {
        breaks := Array[Breakpoint].create()
        for br : arguments.breakpoints {
            breaks.add(Breakpoint(br.line))
        }
        debugger.get().breakpoints[arguments.source.path.slice()] = breaks

        return Ok()
    }

    stacktrace :: (&Self) -> Result[Array[DapStackFrame], String] {
        debugger.get().pause()

        frames := debugger.get().interp.get_stackframes()

        stack_frames := Array[DapStackFrame].create()

        use_prev_ip := false
        for(by_ref=true, reverse=true) frame : frames {
            defer { use_prev_ip = true }
            ip := if use_prev_ip then frame.ip_prev else frame.ip
            line := frame.func.debug_info.get_line_for_ip(ip)

            g_logger.log("stackframe: line: {}, func: '{}', path: '{}'", [line, frame.func.ast_function.name, frame.func.debug_info.path])

            stack_frames.add(DapStackFrame(
                id     = frames.length - it_index - 1
                name   = frame.func.ast_function.name.to_owned()
                source = DapSource(
                    name = "fac.cbc".to_owned()
                    path = frame.func.debug_info.path.clone()
                )
                line   = line
                column = 5 // @todo
            ))
        }

        return Ok(stack_frames)
    }

    scopes :: (&Self, arguments: DapReqScopes) -> Result[Array[DapScope], String] {
        debugger.get().pause()

        frame_id := arguments.frame_id

        frame := &debugger.get().interp.get_stackframes()[frame_id]
        scopes_json := Array[DapScope].create()

        scopes := self.collect_scopes(frame_id)
        for scope : scopes {
            self.add_variable_ref(scope.clone().change_type(VariableRef))

            scopes_json.add(DapScope(
                variables_reference = scope.get().index
                name                = scope.get().name.clone()
                presentation_hint   = scope.get().hint.clone()
            ))
        }

        return Ok(scopes_json)
    }

    variables :: (&Self, arguments: DapReqVariables) -> Result[Array[DapVariable], String] {
        debugger.get().pause()

        index := arguments.variables_reference
        variables_json := Array[DapVariable].create()

        var_ref := &self.get_variable_reference(index)
        vars := var_ref.get_variables()
        for var : vars {
            self.add_variable_ref(var.clone())

            match &var.get() {
                Variable($var) -> {

                    variables_json.add(DapVariable(
                        name = var.name.clone()
                        value = var.value.clone()
                        variables_reference = 0
                    ))
                }
                _ -> { @assert(false) }
            }
        }

        return Ok(variables_json)
    }

    pause :: (&Self) -> Result[(), String] {
        debugger.get().pause()
        adapter.emit_stop_event("pause")
        return Ok()
    }

    resume :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().resume()
        return Ok()
    }

    next :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step()
        return Ok()
    }

    step_in :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step_in()
        return Ok()
    }

    step_out :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step_out()
        return Ok()
    }
}

#file_scope



Breakpoint :: struct #copy {
    line : int
}

VariableRef :: trait {
    interp  : ^Interpreter
    frame   : int
    name    : String
    hint    : String
    index   : int

    get_variables :: (&Self) -> Array[Rc[VariableRef]];
}

ArgumentsScope :: struct VariableRef {

}

impl ArgumentsScope {
    new :: (interp: ^Interpreter, frame: int) -> Rc[ArgumentsScope] {
        return Rc[ArgumentsScope].new(ArgumentsScope(interp, frame, "Arguments".to_string(), "arguments".to_string(), -1))
    }
}

impl VariableRef for ArgumentsScope {
    get_variables :: (&Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := &interp.get_stackframes()[self.frame]
        for param : stackframe.func.debug_info.params {
            value := stackframe.stack[stackframe.bp + param.index]
            var := Variable.new(interp, frame, param.name.to_owned(), fmt.format("{}", [value]))
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

LocalsScope :: struct VariableRef {

}

impl LocalsScope {
    new :: (interp: ^Interpreter, frame: int) -> Rc[LocalsScope] {
        return Rc[LocalsScope].new(LocalsScope(interp, frame, "Locals".to_string(), "locals".to_string(), -1))
    }
}

impl VariableRef for LocalsScope {
    get_variables :: (&Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := &interp.get_stackframes()[self.frame]
        for local : stackframe.func.debug_info.locals {
            value := stackframe.stack[stackframe.bp + local.index]
            var := Variable.new(interp, frame, local.name.to_owned(), fmt.format("{}", [value]))
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

RegistersScope :: struct VariableRef {

}

impl RegistersScope {
    new :: (interp: ^Interpreter, frame: int) -> Rc[RegistersScope] {
        return Rc[RegistersScope].new(RegistersScope(interp, frame, "Registers".to_string(), "registers".to_string(), -1))
    }
}

impl VariableRef for RegistersScope {
    get_variables :: (&Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        stackframe := &interp.get_stackframes()[self.frame]

        ip := Variable.new(interp, frame, "ip".to_owned(), fmt.format("{}", [stackframe.ip]))
        result.add(ip.clone().change_type(VariableRef))
        sp := Variable.new(interp, frame, "sp".to_owned(), fmt.format("{}", [stackframe.sp]))
        result.add(sp.clone().change_type(VariableRef))
        bp := Variable.new(interp, frame, "bp".to_owned(), fmt.format("{}", [stackframe.bp]))
        result.add(bp.clone().change_type(VariableRef))

        return result
    }
}

Variable :: struct VariableRef {
    value : String
}

impl Variable {
    new :: (interp: ^Interpreter, frame: int, name: String, value: String) -> Rc[Variable] {
        return Rc[Variable].new(Variable(interp, frame, name, String.empty(), -1, value))
    }
}

impl VariableRef for Variable {
    get_variables :: (&Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        return result
    }
}