use import std.array
use import std.box
use import std.hash_table
use import std.map
use import std.math
use import std.mem.std_heap_allocator
use import std.os.windows
use import std.os.windows_functions
use import std.rc
use import std.ring_queue
use import std.string
use import std.thread

fmt  :: import std.fmt
fs   :: import std.io.fs
io   :: import std.io
mem  :: import std.mem.allocator
util :: import std.util

use import dap.debug_adapter
use import json.json
use import logging.logger

use import ast
use import ast_dumper
use import bytecode_generator
use import compiler
use import error_handler
use import interpreter
use import jobs
use import lexer
use import parser
use import scope
use import string_database
use import value

LOG_PATH :: "D:/dev/CheezLang/data/logs/debugger_log.txt"

Main :: () {
    logger := FileLogger.new(LOG_PATH)
    // g_logger = cast ^logger.get()
    {
        l : ^Logger = ^*logger.get()
        Logger.set_global_logger(l)
    }

    debugger := CheezDebugAdapter.new()
    adapter := DebugAdapter.new(debugger)

    adapter.get().run()
}

DebuggerCallbacks :: trait {
    hit_breakpoint :: (&Self);
    step_done :: (&Self);
    continued :: (&Self);
    error :: (&Self, msg: string);
    output_generated :: (&Self, format: string, args: []^any = [], category: string = "console");
}

Debugger :: struct {
    current_interp  : ^Interpreter
    cond_run        : Rc[ConditionVariable]
    lock_run        : Rc[ReentrantLock]
    cond_pause      : Rc[ConditionVariable]
    lock_pause      : Rc[ReentrantLock]
    callbacks       : ^DebuggerCallbacks

    breakpoints     : Map[String, Array[Breakpoint]]

    running         : bool = false
    fp_old          : int  = 0
    line_break      : int  = 0
    no_break        : bool = false
    break_cond      := BreakCondition.None
    old_frame       := StackFrame()
}

BreakCondition :: enum {
    None, StepIn, StepOut, Step
}

impl Debugger {
    new :: () -> Rc[Debugger] {
        return Rc[Debugger].new(Debugger(
            current_interp  = null
            cond_run        = ConditionVariable.new()
            lock_run        = ReentrantLock.new()
            cond_pause      = ConditionVariable.new()
            lock_pause      = ReentrantLock.new()
            breakpoints     = Map[String, Array[Breakpoint]].new()
            running         = false
            no_break        = false
            callbacks       = null
        ))
    }

    set_callbacks :: (&Self, callbacks: ^DebuggerCallbacks) {
        self.callbacks = callbacks
    }

    store_old_state :: (&Self) {
        if current_interp == null {
            return
        }

        frame := current_interp.top_frame()

        self.old_frame = *frame
        self.fp_old = current_interp.fp
        self.line_break = frame.func.debug_info.get_location_for_ip(frame.ip).line
    }

    launch :: (&Self) {
        resume()
    }

    pause :: (&Self) {
        running = false
        // cond_pause.get().wait(lock_pause.get())
        // lock_pause.get().release()
    }

    resume :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.None
        cond_run.get().notify()
    }

    step :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.Step
        cond_run.get().notify()
    }

    step_in :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.StepIn
        cond_run.get().notify()
    }

    step_out :: (&Self) {
        running = true
        store_old_state()
        self.break_cond = BreakCondition.StepOut
        cond_run.get().notify()
    }

    is_on_breakpoint :: (&Self) -> bool {
        if current_interp.fp < 0 {
            // currently not executing anything
            return false
        }
        if current_interp == null {
            return false
        }
        if breakpoints.count() == 0 {
            return false
        }

        frame := current_interp.get_stackframes()[current_interp.fp]

        path := frame.func.debug_info.path.slice()
        location := frame.func.debug_info.get_location_for_ip(frame.ip)

        match breakpoints.get(path) {
            Some($arr) -> {
                for(by_ref=true) breakpoint in arr.slice() {
                    if breakpoint.line == location.line {
                        return true
                    }
                }
            }
        }

        return false
    }

    generate_output :: (&Self, format: string, args: []^any = [], category: string = "console") {
        if callbacks != null then callbacks.output_generated(format, args, category)
    }
}

impl CodeRunner for Debugger {
    run :: (&Self, interp: &Interpreter) -> InterpStepResult {
        self.current_interp = interp

        self.store_old_state()

        if self.is_on_breakpoint() {
            if callbacks != null then callbacks.hit_breakpoint()
            running = false
        }

        loop {
            while !running {
                cond_run.get().wait(lock_run.get())
            }
            defer lock_run.get().release()

            // dont break on breakpoints on first iteration
            no_break = true

            // 
            while running {
                frame := interp.get_stackframes()[interp.fp]
                location := frame.func.debug_info.get_location_for_ip(frame.ip)

                if frame.func != old_frame.func or location.line != line_break {
                    no_break = false
                }

                if !no_break and self.is_on_breakpoint() {
                    self.old_frame = default
                    self.fp_old = 0
                    self.line_break = 0
                    self.break_cond = BreakCondition.None
                    running = false
                    if callbacks != null then callbacks.hit_breakpoint()
                    break
                }

                do_break := match &self.break_cond {
                    .None    -> false
                    .Step    -> interp.fp < fp_old or (frame.func == old_frame.func and location.line != line_break)
                    .StepIn  -> interp.fp != fp_old or (frame.func == old_frame.func and location.line != line_break)
                    .StepOut -> interp.fp < fp_old
                }

                if do_break {
                    self.old_frame = default
                    self.fp_old = 0
                    self.line_break = 0
                    self.break_cond = BreakCondition.None
                    running = false
                    if callbacks != null then callbacks.step_done()
                    break
                }

                step_result := interp.step()
                match step_result {
                    .Done -> {
                        // running = false
                        if callbacks != null then callbacks.continued()
                        return .Done
                    }

                    .Error($msg) -> {
                        self.old_frame = default
                        self.fp_old = 0
                        self.line_break = 0
                        self.break_cond = BreakCondition.None
                        running = false
                        if callbacks != null then callbacks.error(msg.slice())
                        break
                        // return
                    }
                }

                // it could be that the current fiber yielded while in interp.step()
                // and then another fiber executed this function, overriding self.current_interp
                // so we need to reset it here
                // (we're only dealing with one thread anyways)
                self.current_interp = ^*interp

                if !running {
                    if callbacks != null then callbacks.hit_breakpoint()
                    break
                }
            }

            running = false
            // cond_pause.get().notify()
        }

        return .Done
    }
}

g_debug_adapter : ^CheezDebugAdapter = null
g_print_buffer : ^String = null

println_string :: (interp: ^Interpreter) {
    if g_print_buffer == null {
        g_print_buffer = mem.alloc(String)
        *g_print_buffer = String.empty()
    }

    frame := interp.top_frame()
    msg := fmt.format("{}", [frame.get_arg(0, string)])
    *g_print_buffer += &msg

    g_debug_adapter.adapter.emit_output_event(g_print_buffer.clone(), "console")
    g_print_buffer.clear()
}

print_string :: (interp: ^Interpreter) {
    if g_print_buffer == null {
        g_print_buffer = mem.alloc(String)
        *g_print_buffer = String.empty()
    }

    frame := interp.top_frame()
    msg := fmt.format("{}", [frame.get_arg(0, string)])
    *g_print_buffer += &msg

    if msg.slice().ends_with("`n") {
        g_debug_adapter.adapter.emit_output_event(g_print_buffer.clone(), "console")
        g_print_buffer.clear()
    }
}

debug_break :: (interp: ^Interpreter) {
    g_debug_adapter.debugger.get().pause()
}

CheezDebugAdapter :: struct CommandHandler {
    debugger        : Rc[Debugger]
    variable_refs   : Array[Rc[VariableRef]]

    string_db       := StringDatabase.new()

    text_provider   : ^TextProvider = null

    compiler        := Rc[Compiler].empty()
}

impl CheezDebugAdapter {
    new :: () -> Rc[CommandHandler] {
        command_handler := mem.alloc(CheezDebugAdapter)
        *command_handler = CheezDebugAdapter(
            adapter = null
            debugger = Debugger.new()
            variable_refs   = Array[Rc[VariableRef]].create()
        )
        g_debug_adapter = command_handler

        return Rc[CommandHandler].from_pointer(command_handler, owned = true)
    }

    clear_variable_refs :: (&Self) {
        variable_refs.clear()
    }

    get_variable_reference :: (&Self, index: int) -> &VariableRef {
        @assert(index >= 1 and index <= variable_refs.count())
        return variable_refs[index - 1].get()
    }

    add_variable_ref:: (&Self, var_ref: Rc[VariableRef]) -> int {
        index := variable_refs.count() + 1
        var_ref.get().index = index
        variable_refs.add(var_ref)
        return index
    }

    collect_scopes :: (&Self, frame: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()


        locals := LocalsScope.new(debugger.get().current_interp, frame)
        result.add(locals.clone().change_type(VariableRef))

        args := ArgumentsScope.new(debugger.get().current_interp, frame)
        result.add(args.clone().change_type(VariableRef))

        debugger := DebuggerScope.new(debugger.get().current_interp, frame, ^*self)
        result.add(debugger.clone().change_type(VariableRef))

        return result
    }

    on_done :: (&Self) {
        self.adapter.emit_terminated_event()
    }

    compile_cheez_program :: (&Self, path: string) {
        compiler = Compiler.new(1, ^*self)
        main_workspace := compiler.get().get_main_workspace()

        // register native functions
        compiler.get().user_defined_builtins.add((
            "_get_compiler",
            Symbol.NativeFunc(NativeFunctionWrapper.new(
                cast(NativeFunction) (interp) => {
                    frame := interp.top_frame()
                    frame.set_return(g_compiler)
                },
                fn() -> ^Compiler
            ))
        ))

        compiler.get().user_defined_builtins.add((
            "_println",
            Symbol.NativeFunc(NativeFunctionWrapper.new(cast(NativeFunction) println_string, fn(string)))
        ))
        compiler.get().user_defined_builtins.add((
            "_print",
            Symbol.NativeFunc(NativeFunctionWrapper.new(cast(NativeFunction) print_string, fn(string)))
        ))

        compiler.get().user_defined_builtins.add((
            "_debugbreak",
            Symbol.NativeFunc(NativeFunctionWrapper.new(cast(NativeFunction) debug_break, fn()))
        ))
        //

        //
        compiler.get().code_runner = debugger.clone().change_type(CodeRunner)
        main_workspace.get().create_and_add_job(LoadFileJob.new(path.to_owned()))
        compiler.get().start_compilation()

        compiler.get().on_done(cast self.on_done)
    }
}

impl ErrorHandler for CheezDebugAdapter {
    has_errors :: (&Self) -> bool {
        return false
    }

    report_error_at :: (&Self, location: Location, message: string, args: []^any, prefix: string = "", details: [](fmt: string, args: []^any) = []) {
        msg := fmt.format(message, args)
        g_logger.log("[Code Gen] {}: {}", [location, msg])
    }

    report_error :: (&Self, message: string, args: []^any, prefix: string = "", details: [](fmt: string, args: []^any) = []) {
        msg := fmt.format(message, args)
        g_logger.log("[Code Gen] {}", [msg])
    }
}


impl DebuggerCallbacks for CheezDebugAdapter {
    hit_breakpoint :: (&Self) {
        self.adapter.emit_stop_event("breakpoint")
    }

    step_done :: (&Self) {
        self.adapter.emit_stop_event("step")
    }

    continued :: (&Self) {
        self.adapter.emit_continued_event()
    }

    error :: (&Self, msg: string) {
        self.adapter.emit_stop_event("exception", Some(msg), Some(msg))
    }

    output_generated :: (&Self, format: string, args: []^any = [], category: string = "console") {
        self.adapter.emit_output_event(fmt.format(format, args), category)
    }
}

impl CommandHandler for CheezDebugAdapter {
    initialize :: (&Self) -> Result[(), String] {
        adapter.emit_initialized_event()
        // adapter.enqueue_event(.Initialized)
        return Ok()
    }

    launch :: (&Self, arguments: DapReqLaunch) -> Result[(), String] {
        debugger.get().set_callbacks(^*self)

        if arguments.program.slice().ends_with(".che") {
            self.compile_cheez_program(arguments.program.slice())
        } else {
            return Err(fmt.format("Can't debug the file '{}'", [arguments.program]))
        }

        debugger.get().launch()

        return Ok()
    }

    threads :: (&Self) -> Result[Array[DapThread], String] {
        result := Array[DapThread].create()
        result.add(DapThread(0, "Main Thread".to_owned()))
        return Ok(result)
    }

    set_breakpoints :: (&Self, arguments: DapSetBreakpoints) -> Result[(), String] {
        breaks := Array[Breakpoint].create()
        for br in &arguments.breakpoints {
            breaks.add(Breakpoint(br.line))
        }
        debugger.get().breakpoints[arguments.source.path.slice()] = breaks

        return Ok()
    }

    stacktrace :: (&Self) -> Result[Array[DapStackFrame], String] {
        debugger.get().pause()

        frames := debugger.get().current_interp.get_stackframes()

        stack_frames := Array[DapStackFrame].create()

        use_prev_ip := false
        for(by_ref=true, reverse=true) frame in frames {
            defer { use_prev_ip = true }
            ip := if use_prev_ip then frame.ip_prev else frame.ip
            location := frame.func.debug_info.get_location_for_ip(ip)

            name := if frame.func.ast_function != null {
                frame.func.ast_function.name
            } else {
                "$expr"
            }

            stack_frames.add(DapStackFrame(
                id     = frames.length - it_index - 1
                name   = name.to_owned()
                source = DapSource(
                    name = name.to_owned()
                    path = frame.func.debug_info.path.clone()
                )
                line    = location.line
                column  = location.column
            ))
        }

        return Ok(stack_frames)
    }

    scopes :: (&Self, arguments: DapReqScopes) -> Result[Array[DapScope], String] {
        debugger.get().pause()
        self.clear_variable_refs()

        frame_id := arguments.frame_id

        if frame_id < 0 or frame_id > debugger.get().current_interp.fp {
            return Err(fmt.format("Failed to get scopes, frame id out of bounds"))
        }

        frame := debugger.get().current_interp.get_stackframes()[frame_id]
        scopes_json := Array[DapScope].create()

        scopes := self.collect_scopes(frame_id)
        for scope in &scopes {
            self.add_variable_ref(scope.clone().change_type(VariableRef))

            scopes_json.add(DapScope(
                variables_reference = scope.get().index
                name                = scope.get().name.clone()
                presentation_hint   = scope.get().hint.clone()
            ))
        }

        return Ok(scopes_json)
    }

    variables :: (&Self, arguments: DapReqVariables) -> Result[Array[DapVariable], String] {
        debugger.get().pause()

        index := arguments.variables_reference
        start := arguments.start.unwrap_or(0)
        count := arguments.count.unwrap_or(int.max)

        variables := Array[DapVariable].create()

        if index <= 0 or index > variable_refs.count() {
            return Err(fmt.format("Failed to get variables, variableReferences out of bounds: {}", [variable_refs.count()]))
        }

        var_ref := self.get_variable_reference(index)
        vars := var_ref.get_variables(start, count)
        for var in &vars {
            var_index := self.add_variable_ref(var.clone())

            match var.get() {
                Variable($var) -> {
                    if var.named_variables == 0 and var.indexed_variables == 0 {
                        var_index = 0
                    }
                    variables.add(DapVariable(
                        name                = var.name.clone()
                        value               = var.value.clone()
                        type_name           = fmt.format("{}", [var.type_info])
                        variables_reference = var_index
                        named_variables     = var.named_variables
                        indexed_variables   = var.indexed_variables
                    ))
                }
                _ -> { @assert(false) }
            }
        }

        return Ok(variables)
    }

    pause :: (&Self) -> Result[(), String] {
        debugger.get().pause()
        adapter.emit_stop_event("pause")
        return Ok()
    }

    resume :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().resume()
        return Ok()
    }

    next :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step()
        return Ok()
    }

    step_in :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step_in()
        return Ok()
    }

    step_out :: (&Self) -> Result[(), String] {
        self.clear_variable_refs()
        debugger.get().step_out()
        return Ok()
    }
}

#file_scope



Breakpoint :: struct #copy {
    line : int
}

VariableProvider :: trait {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]];
}

VariableRef :: trait {
    interp  : ^Interpreter
    frame   : int
    name    : String
    hint    : Option[String]
    index   : int

    get_variables :: (&Self, start: int, count: int) -> Array[Rc[VariableRef]];
}

DebuggerScope :: struct VariableRef {
    debug_adapter : ^CheezDebugAdapter
    debugger      : ^Debugger
    compiler      : ^Compiler
}

impl DebuggerScope {
    new :: (interp: ^Interpreter, frame: int, debug_adapter: ^CheezDebugAdapter) -> Rc[DebuggerScope] {
        return Rc[DebuggerScope].new(DebuggerScope(
            interp          = interp
            frame           = frame
            name            = "Debugger".to_string()
            hint            = None
            index           = -1
            debug_adapter   = debug_adapter
            debugger        = ^*debug_adapter.debugger.get()
            compiler        = ^*debug_adapter.compiler.get()
        ))
    }
}

impl VariableRef for DebuggerScope {
    get_variables :: (&Self, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        result.add(
            Variable.new(
                debug_adapter.debugger.get().current_interp, frame, "DebugAdapter".to_owned(), @type_info(CheezDebugAdapter), debug_adapter
            ).change_type(VariableRef))

        result.add(
            Variable.new(
                debug_adapter.debugger.get().current_interp, frame, "Debugger".to_owned(), @type_info(Debugger), debugger
            ).change_type(VariableRef))

        result.add(
            Variable.new(
                debug_adapter.debugger.get().current_interp, frame, "Compiler".to_owned(), @type_info(Compiler), compiler
            ).change_type(VariableRef))

        result.add(
            Variable.new(
                debug_adapter.debugger.get().current_interp, frame, "Interpreter".to_owned(), @type_info(Interpreter), debug_adapter.debugger.get().current_interp
            ).change_type(VariableRef))

        result.add(
            Variable.new(
                debug_adapter.debugger.get().current_interp, frame, "Current Function".to_owned(), @type_info(CBCFunction), debug_adapter.debugger.get().current_interp.top_frame().func
            ).change_type(VariableRef))

        return result
    }
}

ArgumentsScope :: struct VariableRef {}

impl ArgumentsScope {
    new :: (interp: ^Interpreter, frame: int) -> Rc[ArgumentsScope] {
        return Rc[ArgumentsScope].new(ArgumentsScope(interp, frame, "Arguments".to_string(), Some("arguments".to_string()), -1))
    }
}

impl VariableRef for ArgumentsScope {
    get_variables :: (&Self, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := interp.get_stackframes()[self.frame]
        for param in &stackframe.func.debug_info.params {
            var := Variable.new(
                interp, frame, param.name.to_owned(), param.type_info, ^*stackframe.stack[stackframe.bp + param.index])
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

LocalsScope :: struct VariableRef {}

impl LocalsScope {
    new :: (interp: ^Interpreter, frame: int) -> Rc[LocalsScope] {
        return Rc[LocalsScope].new(LocalsScope(interp, frame, "Locals".to_string(), Some("locals".to_string()), -1))
    }
}

impl VariableRef for LocalsScope {
    get_variables :: (&Self, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := interp.get_stackframes()[self.frame]
        for local in &stackframe.func.debug_info.locals {
            var := Variable.new(
                interp, frame, local.name.to_owned(), local.type_info, ^*stackframe.stack[stackframe.bp + local.index])
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

Variable :: struct VariableRef {
    value               : String
    named_variables     : int
    indexed_variables   : int

    type_info           : ^TypeInfo
    pointer             : ^void
}

impl Variable {
    new :: (interp: ^Interpreter, frame: int, name: String, type_info: ^TypeInfo, pointer: ^void) -> Rc[Variable] {
        any_value := Any.from_pointers(pointer, type_info)

        named_variables, indexed_variables := match type_info {
            TypeInfoTuple($ti)      -> ti.members.length, 0
            TypeInfoStruct($ti)     -> ti.members.length, 0
            TypeInfoEnum($ti)       -> (if {
                mem := ti.get_enum_member(ti.get_tag(pointer))
                mem != null and mem.typ != null
            } then 1 else 0), 0
            TypeInfoArray($ti)      -> 0, ti.count
            TypeInfoSlice($ti)      -> 0, *cast(^int)pointer
            TypeInfoPointer($ti) if ti.target == @type_info(void)
                                    -> 0, 0
            TypeInfoPointer($ti)    -> (if (*cast(^int)pointer) == 0 then 0 else 1, 0)
            _ -> 0, 0
        }

        value := match type_info {
            $ti if ti == @type_info(String) -> {
                ptr := cast(^String)pointer
                fmt.format("`"{}`"", [ptr.slice()])
            }

            TypeInfoString(_) -> fmt.format("`"{}`"", [any_value])

            $ti if ti == @type_info(^void) -> {
                if (*cast(^int)pointer) == 0 {
                    "null".to_owned()
                } else {
                    fmt.format("0x{:x}", [int(pointer)])
                }
            }

            TypeInfoPointer($ti) -> {
                if (*cast(^int)pointer) == 0 {
                    "null".to_owned()
                } else {
                    match ti.target {
                        TypeInfoTrait($ti_trait) -> {
                            trait_ptr := cast(^__Trait)pointer
                            ti := trait_ptr.vtable.type_info
                            if ti != null {
                                type_info = ti
                                pointer = trait_ptr.value
                                named_variables, indexed_variables = match type_info {
                                    TypeInfoStruct($ti)     -> ti.members.length, 0
                                    TypeInfoArray($ti)      -> 0, ti.count
                                    TypeInfoPointer($ti)    -> (if (*cast(^int)pointer) == 0 then 0 else 1, 0)
                                    _ -> 0, 0
                                }
                                fmt.format("[{}] {}", [ti, any_value])
                            } else {
                                fmt.format("{}", [any_value])
                            }
                        }

                        _ -> {
                            fmt.format("{}", [any_value])
                        }
                    }
                }
            }

            TypeInfoReference($ti) -> {
                match ti.target {
                    TypeInfoTrait($ti_trait) -> {
                        trait_ptr := cast(^__Trait)pointer
                        ti_concrete := trait_ptr.vtable.type_info
                        if ti_concrete != null {
                            type_info = ti_concrete
                            pointer = trait_ptr.value
                            any_value = Any.from_pointers(pointer, type_info)
                            named_variables, indexed_variables = match type_info {
                                TypeInfoStruct($ti)     -> ti.members.length, 0
                                TypeInfoArray($ti)      -> 0, ti.count
                                TypeInfoPointer($ti)    -> (if (*cast(^int)pointer) == 0 then 0 else 1, 0)
                                _ -> 0, 0
                            }
                            fmt.format("[{}] &{}", [ti_concrete, any_value])
                        } else {
                            type_info = ti.target
                            pointer = *cast(^^void)pointer

                            any_value = Any.from_pointers(pointer, type_info)
                            fmt.format("&{}", [any_value])
                        }
                    }

                    _ -> {
                        type_info = ti.target
                        pointer = *cast(^^void)pointer

                        any_value = Any.from_pointers(pointer, type_info)
                        fmt.format("&{}", [any_value])
                    }
                }
            }

            TypeInfoStruct($ti) -> ti.name.to_owned()
            TypeInfoTrait($ti) -> ti.name.to_owned()

            _ -> fmt.format("{:?}", [any_value])
        }

        return Rc[Variable].new(Variable(
            interp              = interp
            frame               = frame
            name                = name
            hint                = None
            index               = -1
            value               = value
            named_variables     = named_variables
            indexed_variables   = indexed_variables
            type_info           = type_info
            pointer             = pointer
        ))
    }
}

impl VariableRef for Variable {
    get_variables :: (&Self, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        trait_func := self.type_info.get_trait_function(VariableProvider, "get_variables", fn(^void, ^Interpreter, int, int, int) -> Array[Rc[VariableRef]])

        if trait_func != null {
            return trait_func(self.pointer, self.interp, self.frame, start, count)
        }

        match self.type_info {
            TypeInfoTuple($ti) -> {
                for 0 .. min(ti.members.length, count) {
                    index := start + it
                    if index < 0 or index >= ti.members.length then break
                    member := ti.members[index]

                    name := fmt.format("{}", [it])

                    var := Variable.new(
                        interp, frame, name, member.typ, util.pointer_add(self.pointer, member.offset))
                    result.add(var.clone().change_type(VariableRef))
                }
            }

            TypeInfoStruct($ti) -> {
                for 0 .. min(ti.members.length, count) {
                    index := start + it
                    if index < 0 or index >= ti.members.length then break
                    member := ti.members[index]
                    var := Variable.new(
                        interp, frame, member.name.to_owned(), member.typ, util.pointer_add(self.pointer, member.offset))
                    result.add(var.clone().change_type(VariableRef))
                }
            }

            TypeInfoEnum($ti) -> {
                mem := ti.get_enum_member(ti.get_tag(pointer))
                if mem != null and mem.typ != null {
                    var := Variable.new(
                        interp,
                        frame,
                        "*".to_owned(),
                        mem.typ,
                        util.pointer_add(self.pointer, ti.tag_type.size)
                    )
                    result.add(var.clone().change_type(VariableRef))
                }
            }

            TypeInfoArray($ti) -> {
                for 0 .. min(ti.count, count) {
                    index := start + it
                    if index < 0 or index >= ti.count then break
                    var := Variable.new(
                        interp, frame, fmt.format("[{}]", [index]), ti.target, util.pointer_add(self.pointer, index * ti.target.size))
                    result.add(var.clone().change_type(VariableRef))
                }
            }

            TypeInfoSlice($ti) -> {
                slice := *cast(^[]int)self.pointer

                g_logger.log("slice_length: {}", [slice.length])

                for 0 .. min(slice.length, count) {
                    index := start + it
                    if index < 0 or index >= slice.length then break
                    var := Variable.new(
                        interp, frame, fmt.format("[{}]", [index]), ti.target, util.pointer_add(slice.data, index * ti.target.size))
                    result.add(var.clone().change_type(VariableRef))
                }
            }

            TypeInfoPointer($ti) -> {
                ptr := *cast(^^void)pointer
                var := Variable.new(
                    interp,
                    frame,
                    "*".to_owned(),
                    ti.target,
                    ptr
                )
                result.add(var.clone().change_type(VariableRef))
            }

            TypeInfoReference($ti) -> {
                ptr := *cast(^^void)pointer
                var := Variable.new(
                    interp,
                    frame,
                    "*".to_owned(),
                    ti.target,
                    ptr
                )
                result.add(var.clone().change_type(VariableRef))
            }
        }

        return result
    }
}

impl(T: type) VariableProvider for Array[T] {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        for self {
            var := Variable.new(interp, frame, fmt.format("[{}]", [it_index]), @type_info(T), ^*it)
            result.add(var.change_type(VariableRef))
        }

        return result
    }
}

impl(T: type) VariableProvider for RingQueue[T] {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        for self {
            var := Variable.new(interp, frame, fmt.format("[{}]", [it_index]), @type_info(T), ^*it)
            result.add(var.change_type(VariableRef))
        }

        return result
    }
}

impl(K: type, V: type) VariableProvider for Map[K, V] {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        for self {
            var := Variable.new(interp, frame, fmt.format("{}", [*it.name]), @type_info(V), ^*it.value)
            result.add(var.change_type(VariableRef))
        }

        return result
    }
}

impl(T: type) VariableProvider for Rc[T] {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        var := Variable.new(interp, frame, "*".to_owned(), @type_info(T), self.value)
        result.add(var.change_type(VariableRef))

        return result
    }
}

impl(T: type) VariableProvider for Box[T] {
    get_variables :: (&Self, interp: ^Interpreter, frame: int, start: int, count: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        var := Variable.new(interp, frame, "*".to_owned(), @type_info(T), self.value)
        result.add(var.change_type(VariableRef))

        return result
    }
}

impl(T: type) Clone for Option[T] if T : Clone {
    clone :: (&Self) -> Option[T] {
        return match self {
            Some($value) -> Some(value.clone())
            None -> None
        }
    }
}