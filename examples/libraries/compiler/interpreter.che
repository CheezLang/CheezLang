use import std.array
use import std.hash_table
use import std.map
use import std.math
use import std.string

C   :: import std.c
fmt :: import std.fmt
fs  :: import std.io.fs
io  :: import std.io
mem :: import std.mem.allocator

use import logging.logger

use import ast
use import bytecode_generator
use import compiler
use import config
use import error_handler
use import lexer
use import string_database
use import value

#export_scope


CodeRunner :: trait {
    run :: (&Self, interp: &Interpreter) -> InterpStepResult;
}

DefaultCodeRunner :: struct CodeRunner {

}

impl CodeRunner for DefaultCodeRunner {
    run :: (&Self, interp: &Interpreter) -> InterpStepResult {
        return interp.run()
    }
}

LineInfo :: struct #copy {
    location    : Location
    count       : int
}

VariableInfo :: struct #copy {
    id          : int
    name        : string
    index       : int
    type_info   : ^TypeInfo
}

CBCDebugInfo :: struct {
    path        := String.empty()
    locations   := Array[LineInfo].create()
    locals      := Array[VariableInfo].create()
    params      := Array[VariableInfo].create()
}

impl CBCDebugInfo {
    get_location_for_ip :: (&Self, ip: int) -> Location {
        i := 0
        for &self.locations {
            if it.count == 0 then continue
            i += it.count
            if i > ip {
                return it.location
            }
        }

        return Location(line = -1, column = -1)
    }
}

CBCFunction :: struct {
    ast_function        : ^AstFunction = null
    instructions        := Array[u64].create()
    parameter_indices   := Array[int].create()
    parameter_slots     := 0
    local_slots         := 0
    debug_info          := CBCDebugInfo()
}

StackFrame :: struct {
    ip_prev : int   = default
    ip      : int   = default
    sp      : int   = default
    bp      : int   = default
    code    : []u64 = default
    stack   : []int = default
    func    : ^CBCFunction = null
    return_value_slots := 0
    parameter_indices : []int = default
}

impl StackFrame {
    push_int :: (&Self, val: int) {
        *stack[sp] = val
        sp += 1
    }

    pop_int :: (&Self) -> int {
        @assert(sp > 0)
        sp -= 1
        return *stack[sp]
    }

    get :: (&Self, index: int, $T: type) -> T {
        return *cast(^T)^*stack[index]
    }

    get_local :: (&Self, index: int, $T: type) -> T {
        return *cast(^T)^*stack[bp + index]
    }

    get_arg :: (&Self, index: int, $T: type) -> T {
        @assert(index >= 0 and index < parameter_indices.length)
        return *cast(^T)^*stack[bp + *parameter_indices[index]]
    }

    set_return :: (&Self, v: $T) {
        *cast(^T)^*stack[0] = v
        return_value_slots = (@sizeof(T) + 7) / 8
    }

    dump_stack :: (&Self) -> String {
        str := String.with_capacity(128)

        &str += "[ "

        // parameters
        for i in 0..bp {
            if i > 0 {
                &str += ", "
            }
            str.appendf("{}", *stack[i])
        }

        // locals
        &str += " | "

        if sp - bp > 10 {
            &str += "... "
        }

        if sp >= bp {
            for i in max(bp, sp - 10) .. sp {
                str.appendf("{}", *stack[i])
                if i < sp - 1 {
                    &str += ", "
                }
            }
        }

        &str += " ]"

        return str
    }
}

InterpStepResult :: enum {
    Continue
    Done
    Error : String
}

Interpreter :: struct {
    sp              : int
    fp              : int
    frames          : [1024 * 8]StackFrame
    stack           : [1024 * 1024]int
    strings         : StringDatabase
    error_handler   : ^ErrorHandler
}

impl Interpreter {
    new :: (error_handler: ^ErrorHandler) -> ^Interpreter {
        interp := mem.alloc(Interpreter)
        *interp = Interpreter(
            sp          = 0
            fp          = -1
            frames      = default
            stack       = default
            strings     = StringDatabase.new()
            error_handler = error_handler
        )
        return interp
    }

    print :: (format: string, args: []^any = [], category: string = "console") {
        g_logger.log(format, args)
    }

    top_frame :: (&Self) -> ^StackFrame {
        @assert(fp >= 0)
        return ^*frames[fp]
    }

    get_stackframes :: (&Self) -> []StackFrame {
        return frames[..=fp]
    }

    comp_call :: (&Self, function: &AstFunction) -> bool {
        return push_frame(function.bytecode)
    }

    push_frame :: (&Self, func: ^CBCFunction) -> bool {
        if fp + 1 >= frames.length {
            frame := frames[fp]
            location := frame.func.debug_info.get_location_for_ip(frame.ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", [
                frame.func.debug_info.path.slice()
                location.line
                location.column
                fp
                frame.sp
                frame.ip_prev
                Instruction.pretty_print(frame.code[frame.ip_prev..])
                frame.dump_stack()
            ], "stdout")
            return false
        }

        if sp + func.local_slots >= stack.length {
            frame := frames[fp]
            location := frame.func.debug_info.get_location_for_ip(frame.ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}, required={}) {}           {}", [
                frame.func.debug_info.path.slice()
                location.line
                location.column
                fp
                frame.sp
                frame.ip_prev
                sp + func.local_slots
                Instruction.pretty_print(frame.code[frame.ip_prev..])
                frame.dump_stack()
            ], "stdout")
            return false
        }

        _fp, _sp := fp, sp

        if fp >= 0 {
            sp += frames[fp].sp - frames[fp].bp
        }
        fp += 1

        if sp - func.parameter_slots < 0 {
            g_logger.log("[INTERP] Trying to call function with {} arguments but not enough arguments are on the stack (sp = {})", [func.parameter_slots, sp])
            // frame := &frames[fp]
            // g_logger.log("[INTERP] {}:{}:{}: Trying to call function with {} arguments but not enough arguments are on the stack at (fp={}, sp={}, ip={}) {}           {}", [
            //     func.parameter_slots
            //     frame.func.debug_info.path.slice()
            //     location.line
            //     location.column
            //     fp
            //     frame.sp
            //     frame.ip_prev
            //     Instruction.pretty_print(frame.code[frame.ip_prev..])
            //     frame.dump_stack()
            // ], "stdout")
            return false
        }

        return_value_slots := 0
        if func.ast_function != null {
            return_value_slots = (func.ast_function.return_type.size + 7) / 8
        }

        *frames[fp] = StackFrame(
            ip                  = 0
            sp                  = func.parameter_slots + func.local_slots
            bp                  = func.parameter_slots
            code                = func.instructions.slice()
            stack               = stack[sp-func.parameter_slots .. ]
            func                = func
            return_value_slots  = return_value_slots
            parameter_indices   = func.parameter_indices.slice()
        )

        if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
            g_logger.log("push_frame {} (fp = {} -> {}, sp = {} -> {}, local_slots = {})", [func.parameter_slots, _fp, fp, _sp, sp, func.local_slots])
        }}

        return true
    }

    push_native_frame :: (&Self, wrapper: ^NativeFunctionWrapper) -> ^StackFrame {
        if fp + 1 >= frames.length {
            frame := frames[fp]
            location := frame.func.debug_info.get_location_for_ip(frame.ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", [
                frame.func.debug_info.path.slice()
                location.line
                location.column
                fp
                frame.sp
                frame.ip_prev
                Instruction.pretty_print(frame.code[frame.ip_prev..])
                frame.dump_stack()
            ], "stdout")
            return ^*frames[fp]
        }

        _fp, _sp := fp, sp
        defer { if const DEBUG_ENABLED then if DEBUG_INTERPRETER then g_logger.log("push_native_frame {} (fp = {} -> {}, sp = {} -> {})", [wrapper.arg_slots, _fp, fp, _sp, sp]) }

        if fp >= 0 {
            sp += frames[fp].sp - frames[fp].bp
        }
        fp += 1
        *frames[fp] = StackFrame(
            ip = 0
            sp = wrapper.arg_slots
            bp = wrapper.arg_slots
            code = null
            stack = stack[sp-wrapper.arg_slots .. ]
            func = null
            parameter_indices = wrapper.parameter_indices
        )

        return ^*frames[fp]
    }

    push_native_frame2 :: (&Self, arg_slots: int) -> ^StackFrame {
        if fp + 1 >= frames.length {
            frame := frames[fp]
            location := frame.func.debug_info.get_location_for_ip(frame.ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", [
                frame.func.debug_info.path.slice()
                location.line
                location.column
                fp
                frame.sp
                frame.ip_prev
                Instruction.pretty_print(frame.code[frame.ip_prev..])
                frame.dump_stack()
            ], "stdout")
            return ^*frames[fp]
        }

        _fp, _sp := fp, sp
        defer { if const DEBUG_ENABLED then if DEBUG_INTERPRETER then g_logger.log("push_native_frame2 {} (fp = {} -> {}, sp = {} -> {})", [arg_slots, _fp, fp, _sp, sp]) }

        if fp >= 0 {
            sp += frames[fp].sp - frames[fp].bp
        }
        fp += 1
        *frames[fp] = StackFrame(
            ip = 0
            sp = arg_slots
            bp = arg_slots
            code = null
            stack = stack[sp - arg_slots .. ]
            func = null
            parameter_indices = []
        )

        return ^*frames[fp]
    }

    pop_frame :: (&Self) {
        _fp, _sp := fp, sp
        defer { if const DEBUG_ENABLED then if DEBUG_INTERPRETER then g_logger.log("pop_frame (fp = {} -> {}, sp = {} -> {})", [_fp, fp, _sp, sp]) }

        fp -= 1
        if fp >= 0 {
            sp -= frames[fp].sp - frames[fp].bp
            frames[fp].sp -= frames[fp + 1].bp
        }
    }

    step :: (&Self) -> InterpStepResult {
        @assert(fp >= 0)
        frame := frames[fp]
        arg :: (T: type) #macro {
            val := *cast(^T)^*frame.code[frame.ip]
            frame.ip += 1
            val
        }

        push :: (val: $T) #macro {
            *frame.stack[frame.sp] = *cast(^int)^val
            frame.sp += 1
        }

        pop :: (T: type) #macro {
            @assert(frame.sp > 0)
            frame.sp -= 1
            *cast(^T)^*frame.stack[frame.sp]
        }

        peek :: (T: type, offset: int) #macro {
            @assert(frame.sp > 0)
            @assert(offset <= 0)
            *cast(^T)^*frame.stack[frame.sp + offset - 1]
        }

        set :: ($T: type, offset: int, val: T) #macro {
            @assert(frame.sp > 0)
            @assert(offset <= 0)
            *cast(^T)^*frame.stack[frame.sp + offset - 1] = val
        }


        // fetch
        frame.ip_prev = frame.ip
        opcode := *frame.code[frame.ip]

        if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
            g_logger.log("{}{}{}{}{}{}{}{}{}{}{}", [
                frame.func.debug_info.get_location_for_ip(frame.ip).line
                fmt.align(6), fp
                fmt.align(11), frame.sp
                fmt.align(17), frame.ip
                fmt.align(25), Instruction.pretty_print(frame.code[frame.ip..])
                fmt.align(45), frame.dump_stack()
            ], "stdout")

            //     frame.func.debug_info.get_location_for_ip(frame.ip).line
            //     fmt.align(6), fp
            //     fmt.align(11), frame.sp
            //     fmt.align(17), frame.ip
            //     fmt.align(25), Instruction.pretty_print(frame.code[frame.ip..])
            //     fmt.align(45), frame.dump_stack()
            // ])
        }}

        frame.ip += 1

        // decode and execute
        match Instruction(opcode) {
            .Noop -> {}

            .Push -> {
                slots := arg(int)
                index := frame.sp - frame.bp
                frame.sp += slots
                push(index)
            }
            .Pop -> {
                slots := arg(int)
                frame.sp -= slots
            }
            .Dup -> {
                slots := arg(int)
                C.memcpy(^*frame.stack[frame.sp], ^*frame.stack[frame.sp - slots], cast slots * @sizeof(u64))
                frame.sp += slots
            }

            .ConstInt -> {
                val := arg(int)
                push(val)
            }
            .ConstFloat -> {
                val := arg(f64)
                push(val)
            }

            .LoadAddress -> {
                index := pop(int)
                address := cast(int) ^*frame.stack[frame.bp + index]
                push(address)
            }
            .AddressOf -> {
                index := arg(int)
                address := cast(int) ^*frame.stack[frame.bp + index]
                push(address)
            }
            .Load -> {
                slots  := arg(int)
                address := pop(^int)
                C.memcpy(^*frame.stack[frame.sp], address, cast slots * @sizeof(u64))
                frame.sp += slots
            }
            .Store -> {
                slots := arg(int)
                frame.sp -= slots
                address := pop(^void)

                C.memcpy(address, ^*frame.stack[frame.sp + 1], cast slots * @sizeof(u64))
            }
            .LoadLocal -> {
                index := arg(int)
                slots  := arg(int)
                C.memmove(^*frame.stack[frame.sp], ^*frame.stack[frame.bp + index], cast slots * @sizeof(u64))
                frame.sp += slots
            }
            .StoreLocal -> {
                index := arg(int)
                slots  := arg(int)
                C.memmove(^*frame.stack[frame.bp + index], ^*frame.stack[frame.sp - slots], cast slots * @sizeof(u64))
                frame.sp -= slots
            }
            .StoreStack -> {
                index := arg(int)
                slots  := arg(int)
                C.memmove(^*frame.stack[index], ^*frame.stack[frame.sp - slots], cast slots * @sizeof(u64))
                frame.sp -= slots
            }

            .CastFD -> set(f64, 0, cast(f64) peek(f32, 0))
            .CastDF -> set(f32, 0, cast(f32) peek(f64, 0))
            .CastDS -> set(i64, 0, cast(i64) peek(f64, 0))
            .CastDU -> set(u64, 0, cast(u64) peek(f64, 0))
            .CastSD -> set(f64, 0, cast(f64) peek(i64, 0))
            .CastUD -> set(f64, 0, cast(f64) peek(u64, 0))
            
            .CastSU -> set(u64,  0, cast(u64) peek(i64, 0))
            .CastUS -> set(i64,  0, cast(i64) peek(u64, 0))

            .CastSigned -> {
                from := arg(InstNumTyp)
                to  := arg(InstNumTyp)
                match from, to {
                    use InstNumTyp
                    I8, I8  -> set(i8,  0, cast(i8)  peek(i8, 0))
                    I8, I16 -> set(i16, 0, cast(i16) peek(i8, 0))
                    I8, I32 -> set(i32, 0, cast(i32) peek(i8, 0))
                    I8, I64 -> set(i64, 0, cast(i64) peek(i8, 0))
                    
                    I16, I8  -> set(i8,  0, cast(i8)  peek(i16, 0))
                    I16, I16 -> set(i16, 0, cast(i16) peek(i16, 0))
                    I16, I32 -> set(i32, 0, cast(i32) peek(i16, 0))
                    I16, I64 -> set(i64, 0, cast(i64) peek(i16, 0))

                    I32, I8  -> set(i8,  0, cast(i8)  peek(i32, 0))
                    I32, I16 -> set(i16, 0, cast(i16) peek(i32, 0))
                    I32, I32 -> set(i32, 0, cast(i32) peek(i32, 0))
                    I32, I64 -> set(i64, 0, cast(i64) peek(i32, 0))

                    I64, I8  -> set(i8,  0, cast(i8)  peek(i64, 0))
                    I64, I16 -> set(i16, 0, cast(i16) peek(i64, 0))
                    I64, I32 -> set(i32, 0, cast(i32) peek(i64, 0))
                    I64, I64 -> set(i64, 0, cast(i64) peek(i64, 0))
                    _ -> @assert(false)
                }
            }
            .CastUnsigned -> {
                from := arg(InstNumTyp)
                to  := arg(InstNumTyp)
                match from, to {
                    use InstNumTyp
                    U8, U8  -> set(u8,  0, cast(u8)  peek(u8, 0))
                    U8, U16 -> set(u16, 0, cast(u16) peek(u8, 0))
                    U8, U32 -> set(u32, 0, cast(u32) peek(u8, 0))
                    U8, U64 -> set(u64, 0, cast(u64) peek(u8, 0))
                    
                    U16, U8  -> set(u8,  0, cast(u8)  peek(u16, 0))
                    U16, U16 -> set(u16, 0, cast(u16) peek(u16, 0))
                    U16, U32 -> set(u32, 0, cast(u32) peek(u16, 0))
                    U16, U64 -> set(u64, 0, cast(u64) peek(u16, 0))

                    U32, U8  -> set(u8,  0, cast(u8)  peek(u32, 0))
                    U32, U16 -> set(u16, 0, cast(u16) peek(u32, 0))
                    U32, U32 -> set(u32, 0, cast(u32) peek(u32, 0))
                    U32, U64 -> set(u64, 0, cast(u64) peek(u32, 0))

                    U64, U8  -> set(u8,  0, cast(u8)  peek(u64, 0))
                    U64, U16 -> set(u16, 0, cast(u16) peek(u64, 0))
                    U64, U32 -> set(u32, 0, cast(u32) peek(u64, 0))
                    U64, U64 -> set(u64, 0, cast(u64) peek(u64, 0))
                    _ -> @assert(false)
                }
            }

            .Add -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, -1, peek(f32, -1) + peek(f32, 0))
                    .F64 -> set(f64, -1, peek(f64, -1) + peek(f64, 0))
                    .I8  -> set(i8,  -1, peek(i8,  -1) + peek(i8,  0))
                    .I16 -> set(i16, -1, peek(i16, -1) + peek(i16, 0))
                    .I32 -> set(i32, -1, peek(i32, -1) + peek(i32, 0))
                    .I64 -> set(i64, -1, peek(i64, -1) + peek(i64, 0))
                    .U8  -> set(u8,  -1, peek(u8,  -1) + peek(u8,  0))
                    .U16 -> set(u16, -1, peek(u16, -1) + peek(u16, 0))
                    .U32 -> set(u32, -1, peek(u32, -1) + peek(u32, 0))
                    .U64 -> set(u64, -1, peek(u64, -1) + peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Sub -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, -1, peek(f32, -1) - peek(f32, 0))
                    .F64 -> set(f64, -1, peek(f64, -1) - peek(f64, 0))
                    .I8  -> set(i8,  -1, peek(i8,  -1) - peek(i8,  0))
                    .I16 -> set(i16, -1, peek(i16, -1) - peek(i16, 0))
                    .I32 -> set(i32, -1, peek(i32, -1) - peek(i32, 0))
                    .I64 -> set(i64, -1, peek(i64, -1) - peek(i64, 0))
                    .U8  -> set(u8,  -1, peek(u8,  -1) - peek(u8,  0))
                    .U16 -> set(u16, -1, peek(u16, -1) - peek(u16, 0))
                    .U32 -> set(u32, -1, peek(u32, -1) - peek(u32, 0))
                    .U64 -> set(u64, -1, peek(u64, -1) - peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Mul -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, -1, peek(f32, -1) * peek(f32, 0))
                    .F64 -> set(f64, -1, peek(f64, -1) * peek(f64, 0))
                    .I8  -> set(i8,  -1, peek(i8,  -1) * peek(i8,  0))
                    .I16 -> set(i16, -1, peek(i16, -1) * peek(i16, 0))
                    .I32 -> set(i32, -1, peek(i32, -1) * peek(i32, 0))
                    .I64 -> set(i64, -1, peek(i64, -1) * peek(i64, 0))
                    .U8  -> set(u8,  -1, peek(u8,  -1) * peek(u8,  0))
                    .U16 -> set(u16, -1, peek(u16, -1) * peek(u16, 0))
                    .U32 -> set(u32, -1, peek(u32, -1) * peek(u32, 0))
                    .U64 -> set(u64, -1, peek(u64, -1) * peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Div -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, -1, peek(f32, -1) / peek(f32, 0))
                    .F64 -> set(f64, -1, peek(f64, -1) / peek(f64, 0))
                    .I8  -> set(i8,  -1, peek(i8,  -1) / peek(i8,  0))
                    .I16 -> set(i16, -1, peek(i16, -1) / peek(i16, 0))
                    .I32 -> set(i32, -1, peek(i32, -1) / peek(i32, 0))
                    .I64 -> set(i64, -1, peek(i64, -1) / peek(i64, 0))
                    .U8  -> set(u8,  -1, peek(u8,  -1) / peek(u8,  0))
                    .U16 -> set(u16, -1, peek(u16, -1) / peek(u16, 0))
                    .U32 -> set(u32, -1, peek(u32, -1) / peek(u32, 0))
                    .U64 -> set(u64, -1, peek(u64, -1) / peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Mod -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, -1, peek(f32, -1) % peek(f32, 0))
                    .F64 -> set(f64, -1, peek(f64, -1) % peek(f64, 0))
                    .I8  -> set(i8,  -1, peek(i8,  -1) % peek(i8,  0))
                    .I16 -> set(i16, -1, peek(i16, -1) % peek(i16, 0))
                    .I32 -> set(i32, -1, peek(i32, -1) % peek(i32, 0))
                    .I64 -> set(i64, -1, peek(i64, -1) % peek(i64, 0))
                    .U8  -> set(u8,  -1, peek(u8,  -1) % peek(u8,  0))
                    .U16 -> set(u16, -1, peek(u16, -1) % peek(u16, 0))
                    .U32 -> set(u32, -1, peek(u32, -1) % peek(u32, 0))
                    .U64 -> set(u64, -1, peek(u64, -1) % peek(u64, 0))
                }
                frame.sp -= 1
            }

            .Not -> {
                v := pop(bool)
                push(!v)
            }
            .Neg -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(f32, 0, -peek(f32, 0))
                    .F64 -> set(f64, 0, -peek(f64, 0))
                    .I8  -> set(i8,  0, -peek(i8,  0))
                    .I16 -> set(i16, 0, -peek(i16, 0))
                    .I32 -> set(i32, 0, -peek(i32, 0))
                    .I64 -> set(i64, 0, -peek(i64, 0))
                    .U8  -> set(u8,  0, -peek(u8,  0))
                    .U16 -> set(u16, 0, -peek(u16, 0))
                    .U32 -> set(u32, 0, -peek(u32, 0))
                    .U64 -> set(u64, 0, -peek(u64, 0))
                }
            }

            .Ieq -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) == peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) == peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) == peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) == peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) == peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) == peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) == peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) == peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) == peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) == peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Ine -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) != peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) != peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) != peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) != peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) != peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) != peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) != peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) != peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) != peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) != peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Ilt -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) < peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) < peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) < peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) < peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) < peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) < peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) < peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) < peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) < peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) < peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Ile -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) <= peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) <= peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) <= peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) <= peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) <= peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) <= peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) <= peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) <= peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) <= peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) <= peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Igt -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) > peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) > peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) > peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) > peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) > peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) > peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) > peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) > peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) > peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) > peek(u64, 0))
                }
                frame.sp -= 1
            }
            .Ige -> {
                typ := arg(InstNumTyp)
                match typ {
                    .F32 -> set(bool, -1, peek(f32, -1) >= peek(f32, 0))
                    .F64 -> set(bool, -1, peek(f64, -1) >= peek(f64, 0))
                    .I8  -> set(bool, -1, peek(i8,  -1) >= peek(i8,  0))
                    .I16 -> set(bool, -1, peek(i16, -1) >= peek(i16, 0))
                    .I32 -> set(bool, -1, peek(i32, -1) >= peek(i32, 0))
                    .I64 -> set(bool, -1, peek(i64, -1) >= peek(i64, 0))
                    .U8  -> set(bool, -1, peek(u8,  -1) >= peek(u8,  0))
                    .U16 -> set(bool, -1, peek(u16, -1) >= peek(u16, 0))
                    .U32 -> set(bool, -1, peek(u32, -1) >= peek(u32, 0))
                    .U64 -> set(bool, -1, peek(u64, -1) >= peek(u64, 0))
                }
                frame.sp -= 1
            }

            .And -> {
                b, a := pop(bool), pop(bool)
                push(a and b)
            }
            .Or -> {
                b, a := pop(bool), pop(bool)
                push(a or b)
            }

            .Branch -> {
                frame.ip = arg(int)
            }
            .BranchIf -> {
                address := arg(int)
                if pop(bool) {
                    frame.ip = address
                }
            }

            .NativeCall2 -> {
                wrapper := arg(NativeFunctionWrapper2)
                func := arg(fn())
                arg_slots := arg(int)

                native_frame := push_native_frame2(arg_slots)
                
                if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
                    frame := top_frame()
                    g_logger.log("{}{}{}{}{}{}{}{}", [
                        fmt.align(0), fp
                        fmt.align(5), frame.sp
                        fmt.align(10), "EnterNativeFunction"
                        fmt.align(35), frame.dump_stack()
                    ], "stdout")
                }}
                wrapper(func, self)
                if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
                    frame := top_frame()
                    g_logger.log("ret_slots: {}{}{}{}{}{}{}{}{}", [
                        native_frame.return_value_slots
                        fmt.align(20), fp
                        fmt.align(25), frame.sp
                        fmt.align(30), "ExitNativeFunction"
                        fmt.align(55), frame.dump_stack()
                    ], "stdout")
                }}
                pop_frame()

                if fp >= 0 {
                    // increment sp by one for return value
                    // @todo: needs to work with return values bigger than 8 bytes (1 stack slot)
                    // @fixme frames[fp].sp += 1 // fails to compile
                    frames[fp].sp += native_frame.return_value_slots
                } else {
                    return .Done
                }
            }

            .NativeCall -> {
                wrapper := arg(^NativeFunctionWrapper)

                native_frame := push_native_frame(wrapper)
                
                if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
                    frame := top_frame()
                    g_logger.log("{}{}{}{}{}{}{}{}", [
                        fmt.align(0), fp
                        fmt.align(5), frame.sp
                        fmt.align(10), "EnterNativeFunction"
                        fmt.align(35), frame.dump_stack()
                    ], "stdout")
                }}
                wrapper.function(self)
                if const DEBUG_ENABLED { if DEBUG_INTERPRETER {
                    frame := top_frame()
                    g_logger.log("ret_slots: {}{}{}{}{}{}{}{}{}", [
                        native_frame.return_value_slots
                        fmt.align(20), fp
                        fmt.align(25), frame.sp
                        fmt.align(30), "ExitNativeFunction"
                        fmt.align(55), frame.dump_stack()
                    ], "stdout")
                }}
                pop_frame()

                if fp >= 0 {
                    // increment sp by one for return value
                    // @todo: needs to work with return values bigger than 8 bytes (1 stack slot)
                    // @fixme frames[fp].sp += 1 // fails to compile
                    frames[fp].sp += native_frame.return_value_slots
                } else {
                    return .Done
                }
            }
            .CompCall -> {
                func := arg(^AstFunction)
                _ := arg(int)
                _ := arg(int)
                wait_until(func.bytecode != null, {
                    // error_handler.report_error("Failed to execute bytecode: {}{}{}{}{}{}{}{}{}{}{}{}", [
                    //     fmt.align(30), frame.func.debug_info.get_location_for_ip(frame.ip_prev).line
                    //     fmt.align(35), fp
                    //     fmt.align(40), frame.sp
                    //     fmt.align(46), frame.ip_prev
                    //     fmt.align(54), Instruction.pretty_print(frame.code[frame.ip_prev..])
                    //     fmt.align(74), frame.dump_stack()
                    // ])
                })
                if !push_frame(func.bytecode) {
                    return .Done
                }
            }

            .Return -> {
                @assert(frame.sp > 0)
                C.memmove(^*frame.stack[0], ^*frame.stack[frame.sp - frame.return_value_slots], cast frame.return_value_slots * @sizeof(u64))
                pop_frame()
                if fp >= 0 {
                    // increment sp by one for return value
                    // @todo: needs to work with return values bigger than 8 bytes (1 stack slot)
                    // @fixme frames[fp].sp += 1 // fails to compile
                    frames[fp].sp += frame.return_value_slots
                } else {
                    return .Done
                }
            }
            .ReturnVoid -> {
                pop_frame()
                if fp < 0 {
                    return .Done
                }
            }

            .CheckRange -> {
                max := pop(int)
                min := pop(int)
                value := peek(int, 0)
                if value < min or value >= max {
                    return .Error(fmt.format("Range check failed: {} not in {}..{}", [value, min, max]))
                }
            }

            .CheckNull -> {
                value := pop(int)
                if value == 0 {
                    return .Error(fmt.format("Null check failed"))
                }
            }

            .Panic -> {
                str := string(arg(^u8), arg(int))
                return .Error(fmt.format("[PANIC] {}", [str]))
            }

            .Halt -> {
                return .Done
            }

            $unknown -> {
                g_logger.log("{}: Unknown Instruction '{}'", [
                    frame.func.debug_info.get_location_for_ip(frame.ip_prev)
                    Instruction.pretty_print(frame.code[frame.ip_prev..])
                ], "stdout")
            }
        }

        return .Continue
    }

    run :: (&Self) -> InterpStepResult {
        @assert(fp >= 0)
        loop {
            result := step()
            if result != .Continue {
                return result
            }
        }

        return .Done
    }
}

InstNumTyp :: enum {
    F32, F64
    I8, I16, I32, I64
    U8, U16, U32, U64
}

Instruction :: enum #repr("C") #tag_type(u64) {
    Noop

    Pop, Push, Dup
    ConstInt, ConstFloat
    LoadAddress, AddressOf
    Load, Store
    LoadLocal, StoreLocal
    StoreStack

    CastFD  // float to double
    CastDF  // double to float
    CastDS  // double to i64
    CastDU  // double to u64
    CastSD  // i64 to double
    CastUD  // u64 to double
    CastSU  // i64 to u64
    CastUS  // u64 to i64
    CastSigned      // i to i
    CastUnsigned    // u to u

    Add, Sub, Mul, Div, Mod
    Ieq, Ine, Ilt, Ile, Igt, Ige
    Neg

    Not
    And, Or

    Branch, BranchIf

    Call, NativeCall, NativeCall2, CompCall
    Return, ReturnVoid

    CheckRange, CheckNull

    Panic
    Halt
}

impl Instruction {
    pretty_print :: (code: []u64) -> String {
        @assert(code.length > 0)

        arg :: (T: type, index: int) #macro {
            *cast(^T)^*code[index + 1]
        }

        return match Instruction(*code[0]) {
            .Noop           -> fmt.format("Noop")

            .Push           -> fmt.format("Push {}", [arg(int, 0)])
            .Pop            -> fmt.format("Pop {}", [arg(int, 0)])
            .Dup            -> fmt.format("Dup {}", [arg(int, 0)])
            .ConstInt       -> fmt.format("ConstInt {}", [arg(int, 0)])
            .ConstFloat     -> fmt.format("ConstFloat {}", [arg(f64, 0)])
            .LoadAddress    -> fmt.format("LoadAddress")
            .AddressOf      -> fmt.format("AddressOf {}", [arg(int, 0)])
            .Load           -> fmt.format("Load {}", [arg(int, 0)])
            .Store          -> fmt.format("Store {}", [arg(int, 0)])
            .LoadLocal      -> fmt.format("LoadLocal {} {}", [arg(int, 0), arg(int, 1)])
            .StoreLocal     -> fmt.format("StoreLocal {} {}", [arg(int, 0), arg(int, 1)])
            .StoreStack     -> fmt.format("StoreStack {} {}", [arg(int, 0), arg(int, 1)])

            .CastFD         -> fmt.format("CastFD")
            .CastDF         -> fmt.format("CastDF")
            .CastDS         -> fmt.format("CastDS")
            .CastDU         -> fmt.format("CastDU")
            .CastSD         -> fmt.format("CastSD")
            .CastUD         -> fmt.format("CastUD")
            .CastSU         -> fmt.format("CastSU")
            .CastUS         -> fmt.format("CastUS")
            .CastSigned     -> fmt.format("CastSigned {} {}", [arg(InstNumTyp, 0), arg(InstNumTyp, 1)])
            .CastUnsigned   -> fmt.format("CastUnsigned {} {}", [arg(InstNumTyp, 0), arg(InstNumTyp, 1)])

            .Add            -> fmt.format("Add {}", [arg(InstNumTyp, 0)])
            .Sub            -> fmt.format("Sub {}", [arg(InstNumTyp, 0)])
            .Mul            -> fmt.format("Mul {}", [arg(InstNumTyp, 0)])
            .Div            -> fmt.format("Div {}", [arg(InstNumTyp, 0)])
            .Mod            -> fmt.format("Mod {}", [arg(InstNumTyp, 0)])

            .Not            -> fmt.format("Not")
            .Neg            -> fmt.format("Neg {}", [arg(InstNumTyp, 0)])

            .Ieq            -> fmt.format("Ieq {}", [arg(InstNumTyp, 0)])
            .Ine            -> fmt.format("Ine {}", [arg(InstNumTyp, 0)])
            .Ilt            -> fmt.format("Ilt {}", [arg(InstNumTyp, 0)])
            .Ile            -> fmt.format("Ile {}", [arg(InstNumTyp, 0)])
            .Igt            -> fmt.format("Igt {}", [arg(InstNumTyp, 0)])
            .Ige            -> fmt.format("Ige {}", [arg(InstNumTyp, 0)])

            .And            -> fmt.format("And")
            .Or             -> fmt.format("Or")
            
            .Branch         -> fmt.format("Branch {}", [arg(int, 0)])
            .BranchIf       -> fmt.format("BranchIf {}", [arg(int, 0)])

            .Call           -> fmt.format("Call {} {}", [string(arg(^u8, 0), arg(int, 1)), arg(int, 2)])
            .NativeCall     -> {
                wrapper := arg(^NativeFunctionWrapper, 0)
                fmt.format("NativeCall {}", [wrapper.function_type])
            }
            .NativeCall2    -> {
                wrapper := arg(NativeFunctionWrapper2, 0)
                func    := arg(fn(), 1)
                args    := arg(int, 2)
                fmt.format("NativeCall2 {}, {}, {}", [*cast(^^int)^wrapper, *cast(^^int)^func, args])
            }
            .CompCall       -> {
                func := arg(^AstFunction, 0)
                fmt.format("CompCall {}#{}", [func.name, func.id])
            }
            .Return         -> fmt.format("Return")
            .ReturnVoid     -> fmt.format("ReturnVoid")

            .CheckRange     -> fmt.format("CheckRange")
            .CheckNull      -> fmt.format("CheckNull")
            .Halt           -> fmt.format("Halt")
            .Panic          -> fmt.format("Panic `"{}`"", [string(arg(^u8, 0), arg(int, 1))])
            _               -> fmt.format("Unknown {}", [code[0]])
        }
    }
}