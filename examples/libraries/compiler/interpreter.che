use import std.array
use import std.hash_table
use import std.map
use import std.string
use import std.math

io  :: import std.io
fs  :: import std.io.fs
fmt :: import std.fmt
mem :: import std.mem.allocator

use import logging.logger

use import string_database
use import bytecode_generator
use import ast
use import compiler
use import config

#export_scope


CodeRunner :: trait {
    run :: (ref Self, interp: ref Interpreter);
}

NormalCodeRunner :: struct CodeRunner {

}

impl CodeRunner for NormalCodeRunner {
    run :: (ref Self, interp: ref Interpreter) {
        interp.run()
    }
}

LineInfo :: struct #copy {
    line  : int
    count : int
}

CBCDebugInfo :: struct {
    path        := String.empty()
    lines       := Array[LineInfo].create()
    locals      := Array[String].create()
    parameters  := Array[String].create()
}

impl CBCDebugInfo {
    get_line_for_ip :: (ref Self, ip: int) -> int {
        // g_logger.log("get_line_for_ip({}, lines: {})", [ip, lines.slice()])
        i := 0
        for lines {
            if it.count == 0 then continue
            i += it.count
            if i > ip {
                return it.line
            }
        }

        return -1
    }
    get_line_for_ip2 :: (ref Self, ip: int, print: Fn(string, []&any, string)) -> int {
        line := get_line_for_ip(ip)
        // print("get_line_for_ip({}) -> {}  (lines: {})", [ip, line, lines.slice()], "console")
        return line
    }
}

CBCFunction :: struct {
    ast_function    : &AstFunction = null
    instructions    := Array[u64].create()
    debug_info      := CBCDebugInfo()
}

StackFrame :: struct {
    ip_prev : int   = default
    ip      : int   = default
    sp      : int   = default
    bp      : int   = default
    code    : []u64 = default
    stack   : []int = default
    func    : &CBCFunction = null
}

impl StackFrame {
    dump_stack :: (ref Self) -> String {
        str := String.with_capacity(128)

        str += "[ "

        // parameters
        for i : 0..bp {
            if i > 0 {
                str += ", "
            }
            str.appendf("{}", stack[i])
        }

        // locals
        str += " | "

        for i : max(bp, sp - 5) .. sp {
            str.appendf("{}", stack[i])
            if i < sp - 1 {
                str += ", "
            }
        }

        str += " ]"

        return str
    }
}

Interpreter :: struct {
    sp          : int
    fp          : int
    frames      : [1024 * 8]StackFrame
    stack       : [1024 * 1024]int
    functions   : Map[String, &CBCFunction]
    strings     : StringDatabase
    printer     : Fn(string, []&any, string)
}

impl Interpreter {
    new :: () -> &Interpreter {
        interp := mem.alloc(Interpreter)
        <<interp = Interpreter(
            sp          = 0
            fp          = -1
            frames      = default
            stack       = default
            functions   = Map[String, &CBCFunction].new()
            strings     = StringDatabase.new()
            printer     = cast print
        )
        return interp
    }

    print :: (format: string, args: []&any = [], category: string = "console") {
        g_logger.log(format, args)
    }

    function_registered :: (ref Self, name: string) -> bool {
        return functions.contains(name)
    }

    get_stackframes :: (ref Self) -> []StackFrame {
        return frames[..=fp]
    }

    register_function :: (ref Self, name: string, code: &CBCFunction) {
        functions[name] = code
    }

    comp_call :: (ref Self, function: ref AstFunction) {
        push_frame(function.bytecode, function.params.count())
    }

    // call :: (ref Self, name: string, arg_count: int = 0) {
    //     match functions.get(name) {
    //         Some($func) -> {
    //             push_frame(func, arg_count)
    //         }
    //         None -> {
    //             g_logger.log("[ERROR] 'Call {}' failed. Unknown function '{}'", [name, name])
    //         }
    //     }
    // }

    push_frame :: (ref Self, func: &CBCFunction, arg_count: int = 0) {
        if fp + 1 >= frames.length {
            frame := ref frames[fp]
            printer("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", [
                frame.func.debug_info.path.slice()
                frame.func.debug_info.get_line_for_ip(frame.ip_prev)
                5 // @todo: this is the column, read from debug info
                fp
                frame.sp
                frame.ip_prev
                Instruction.pretty_print(frame.code[frame.ip_prev..])
                frame.dump_stack()
            ], "stdout")
            return
        }

        _fp, _sp := fp, sp
        defer { if const DEBUG_INTERPRETER then g_logger.log("push_frame {} (fp = {} -> {}, sp = {} -> {})", [arg_count, _fp, fp, _sp, sp]) }

        if fp >= 0 {
            sp += frames[fp].sp - frames[fp].bp
        }
        fp += 1
        frames[fp] = StackFrame(
            ip = 0
            sp = arg_count
            bp = arg_count
            code = func.instructions.slice()
            stack = stack[sp-arg_count .. ]
            func = func
        )
    }

    pop_frame :: (ref Self) {
        _fp, _sp := fp, sp
        defer { if const DEBUG_INTERPRETER then g_logger.log("pop_frame (fp = {} -> {}, sp = {} -> {})", [_fp, fp, _sp, sp]) }

        fp -= 1
        if fp >= 0 {
            sp -= frames[fp].sp - frames[fp].bp
            (&frames[fp]).sp -= frames[fp + 1].bp
        }
    }

    step :: (ref Self) -> enum { Continue, Done } {
        @assert(fp >= 0)
        frame := &frames[fp]
        arg :: (T: type) #macro {
            val := <<cast(&T)&frame.code[frame.ip]
            frame.ip += 1
            val
        }

        push :: (val: int) #macro {
            frame.stack[frame.sp] = val
            frame.sp += 1
        }

        pop :: () #macro {
            @assert(frame.sp > 0)
            frame.sp -= 1
            frame.stack[frame.sp]
        }

        // fetch
        frame.ip_prev = frame.ip
        opcode := frame.code[frame.ip]

        if const DEBUG_INTERPRETER {
            printer("{}{}{}{}{}{}{}{}{}{}{}", [
                frame.func.debug_info.get_line_for_ip(frame.ip)
                fmt.align(6), fp
                fmt.align(11), frame.sp
                fmt.align(17), frame.ip
                fmt.align(25), Instruction.pretty_print(frame.code[frame.ip..])
                fmt.align(45), frame.dump_stack()
            ], "stdout")

            //     frame.func.debug_info.get_line_for_ip(frame.ip)
            //     fmt.align(6), fp
            //     fmt.align(11), frame.sp
            //     fmt.align(17), frame.ip
            //     fmt.align(25), Instruction.pretty_print(frame.code[frame.ip..])
            //     fmt.align(45), frame.dump_stack()
            // ])
        }

        frame.ip += 1

        // decode and execute
        match Instruction(opcode) {
            .Noop -> {}
            
            .Const -> {
                val := arg(int)
                push(val)
            }
            .AddressOf -> {
                index := arg(int)
                address := cast(int) &frame.stack[frame.bp + index]
                push(address)
            }
            .Load -> {
                address := cast(&int) pop()
                push(<<address)
            }
            .Store -> {
                address := cast(&int) pop()
                value := pop()
                <<address = value
            }
            .LoadLocal -> {
                index := arg(int)
                push(frame.stack[frame.bp + index])
            }
            .StoreLocal -> {
                index := arg(int)
                frame.stack[frame.bp + index] = pop()
            }

            .Add -> {
                b, a := pop(), pop()
                push(a + b)
            }
            .Sub -> {
                b, a := pop(), pop()
                push(a - b)
            }
            .Mul -> {
                b, a := pop(), pop()
                push(a * b)
            }
            .Div -> {
                b, a := pop(), pop()
                push(a / b)
            }
            .Mod -> {
                b, a := pop(), pop()
                push(a % b)
            }
            .And -> {
                b, a := pop() != 0, pop() != 0
                push(cast a and b)
            }
            .Or -> {
                b, a := pop() != 0, pop() != 0
                push(cast a or b)
            }
            .Ieq -> {
                b, a := pop(), pop()
                push(cast a == b)
            }
            .Ilt -> {
                b, a := pop(), pop()
                push(cast a < b)
            }
            .Ile -> {
                b, a := pop(), pop()
                push(cast a <= b)
            }
            .Igt -> {
                b, a := pop(), pop()
                push(cast a > b)
            }
            .Ige -> {
                b, a := pop(), pop()
                push(cast a >= b)
            }

            .Branch -> {
                frame.ip = arg(int)
            }
            .BranchIf -> {
                address := arg(int)
                if pop() != 0 {
                    frame.ip = address
                }
            }

            .Call -> {
                str := string(arg(&u8), arg(int))
                count := arg(int)
                match functions.get(str) {
                    Some($func) -> {
                        push_frame(func, count)
                    }
                    None -> {
                        g_logger.log("[ERROR] 'Call {}' failed. Unknown function '{}'", [str, str])
                        return .Done
                    }
                }
            }
            .CompCall -> {
                func := arg(&AstFunction)
                _ := arg(int)
                _ := arg(int)
                wait_until(func.bytecode != null)
                push_frame(func.bytecode, func.params.count())
            }

            .Return -> {
                @assert(frame.sp > 0)
                frame.stack[0] = frame.stack[frame.sp - 1]
                pop_frame()
                if fp >= 0 {
                    // @fixme frames[fp].sp += 1 // fails to compile
                    (&frames[fp]).sp += 1
                } else {
                    return .Done
                }
            }
            .ReturnVoid -> {
                pop_frame()
                if fp < 0 {
                    return .Done
                }
            }

            .Panic -> {
                str := string(arg(&u8), arg(int))
                file := frame.func.debug_info.path.slice()
                line := frame.func.debug_info.get_line_for_ip(frame.ip_prev)
                g_logger.log("[PANIC] {}:{}: {}", [file, line, str], "stderr")
                return .Done
            }

            .Print -> {
                val := pop()

                // if printer != null {
                    printer("{}", [val], "console")
                // }
            }
            .Halt -> {
                return .Done
            }

            $unknown -> {
                g_logger.log("{}: Unknown Instruction '{}'", [
                    frame.func.debug_info.get_line_for_ip(frame.ip_prev)
                    Instruction.pretty_print(frame.code[frame.ip_prev..])
                ], "stdout")
            }
        }

        // frame = &frames[fp]
        // line := frame.func.debug_info.get_line_for_ip(frame.ip)
        // g_logger.log("{}{}{}{}{}{}{}{}{}{}{}", [
        //     line
        //     fmt.align(6), fp
        //     fmt.align(11), frame.sp
        //     fmt.align(17), frame.ip
        //     fmt.align(25), Instruction.pretty_print(frame.code[frame.ip..])
        //     fmt.align(45), frame.dump_stack()
        // ], "stdout")

        return .Continue
    }

    run :: (ref Self) {
        @assert(fp >= 0)
        frame := &frames[fp]
        while frame.ip >= 0 and frame.ip < frame.code.length {
            if step() == .Done {
                return
            }
        }
    }
}

Instruction :: enum #repr("C") #tag_type(u64) {
    Noop

    Const
    AddressOf
    Load, Store
    LoadLocal, StoreLocal

    Add, Sub, Mul, Div, Mod
    And, Or
    Ieq, Ilt, Ile, Igt, Ige

    Branch, BranchIf

    Call, CompCall
    Return, ReturnVoid

    Panic
    Print
    Halt
}

impl Instruction {
    pretty_print :: (code: []u64) -> String {
        @assert(code.length > 0)

        arg :: (T: type, index: int) #macro {
            <<cast(&T)&code[index + 1]
        }

        return match Instruction(code[0]) {
            .Noop           -> fmt.format("Noop")

            .Const          -> fmt.format("Const {}", [arg(int, 0)])
            .AddressOf      -> fmt.format("AddressOf {}", [arg(int, 0)])
            .Load           -> fmt.format("Load")
            .Store          -> fmt.format("Store")
            .LoadLocal      -> fmt.format("LoadLocal {}", [arg(int, 0)])
            .StoreLocal     -> fmt.format("StoreLocal {}", [arg(int, 0)])

            .Add            -> fmt.format("Add")
            .Sub            -> fmt.format("Sub")
            .Mul            -> fmt.format("Mul")
            .Div            -> fmt.format("Div")
            .Mod            -> fmt.format("Mod")

            .And            -> fmt.format("And")
            .Or             -> fmt.format("Or")
            .Ieq            -> fmt.format("Ieq")
            .Ilt            -> fmt.format("Ilt")
            .Ile            -> fmt.format("Ile")
            .Igt            -> fmt.format("Igt")
            .Ige            -> fmt.format("Ige")

            .Branch         -> fmt.format("Branch {}", [arg(int, 0)])
            .BranchIf       -> fmt.format("BranchIf {}", [arg(int, 0)])

            .Call           -> fmt.format("Call {} {}", [string(arg(&u8, 0), arg(int, 1)), arg(int, 2)])
            .CompCall       -> fmt.format("CompCall #{}", [arg(&AstFunction, 0).id])
            .Return         -> fmt.format("Return")
            .ReturnVoid     -> fmt.format("ReturnVoid")

            .Print          -> fmt.format("Print")
            .Halt           -> fmt.format("Halt")
            .Panic          -> fmt.format("Panic `"{}`"", [string(arg(&u8, 0), arg(int, 1))])
            _               -> fmt.format("Unknown {}", [code[0]])
        }
    }
}