use import std.array
use import std.ring_queue
use import std.fiber
use import std.thread
use import std.time
use import std.profiling
use import std.mem.allocator
use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
C :: import std.c
io :: import std.io

enable_profiler :: false

Main :: () {
    Instrumentor.init(true)
    Instrumentor.get().begin_session("compiler_test", "compiler_test_profile.json")
    compiler_test()
    Instrumentor.get().end_session()
}

compiler_test :: () {
    profile_function()
    Fiber.init()

    compiler := Compiler.new(1)
    defer {
        Memory.drop(compiler)
        free(compiler)
    }
    compiler.exprs.reserve(1000000)

    for(inclusive=true) id : 1..100000 {
        compiler.exprs.add(Expr(id))
    }

    // no dependencies
    //

    // 5:4, 4:3, 3:2, 2:1
    // for i : 0..compiler.exprs.get_length()/2 {
    //     left  := i * 2 + 1
    //     right := i * 2 + 2
    //     if left >= compiler.exprs.get_length() then break
    //     compiler.exprs[i].depend[0] = &compiler.exprs[left]
    //     if right >= compiler.exprs.get_length() then break
    //     compiler.exprs[i].depend[1] = &compiler.exprs[right]
    // }

    // 1:2, 2:3, 3:4, 4:5
    // for i : 0..compiler.exprs.get_length()-1 {
    //     compiler.exprs[i].depend[0] = &compiler.exprs[i+1]
    //     compiler.exprs[i].depend[1] = null
    // }

    start := get_time_milliseconds()
    compiler.compile_all()
    end := get_time_milliseconds()
    dur := end - start
    io.printfln("Compilation took {} ms", dur)
}

Expr :: struct {
    id      : int
    depend  : [2]&Expr = [null, null]
    done    := false
    progressed := false
}

CompileFiber :: struct {
    compiler: &Compiler
    fiber   : &Fiber
    expr    : &Expr = null
    thread  := -1
}

Compiler :: struct {
    exprs   := Array[Expr].create()
    expr_q  := RingQueue[&Expr].create()

    fibers  := Array[&CompileFiber].create(1024)
    fiber_q := RingQueue[&CompileFiber].create()
    fiber_q2:= RingQueue[&CompileFiber].create()

    mutex   : Mutex
    threads : Array[Thread]
    active_threads := 0
}

impl Drop for Compiler {
    drop :: (ref Self) {
        for f : fibers {
            Memory.drop(f.fiber)
        }
    }
}

wait_for_expr :: (expr: &Expr, wait_for: &Expr) {
    id := expr.id

    current_fiber := Fiber.current()
    compiler_fiber := cast(&CompileFiber) current_fiber.user_data
    expr.progressed = true

    while yield_count := 0, true, yield_count += 1 {
        if wait_for != null and !wait_for.done {
            if yield_count > 0 {
                expr.progressed = false
            }

            Fiber.yield()
        } else {
            break
        }
    }
    expr.progressed = true
}

compile_expr :: (expr: &Expr) {
    id := expr.id

    if const enable_profiler {
        str := String.empty()
        str.appendf("compile_expr({})", expr.id)
        profile_async("compile_expr", id, "b")
        defer profile_async("compile_expr", id, "e")
    }

    profile_async("compile_expr", id, "e")
    wait_for_expr(expr, expr.depend[0])
    profile_async("compile_expr", id, "b")

    profile_async("compile_expr", id, "e")
    wait_for_expr(expr, expr.depend[1])
    profile_async("compile_expr", id, "b")

    expr.done = true
}

compiler_fiber :: (fiber : &CompileFiber) {
    profile_function()
    while true {
        while fiber.expr == null {
            Fiber.yield()
        }

        fiber.expr.progressed = false
        compile_expr(fiber.expr)
        fiber.expr = null
    }
}

impl Compiler {
    new :: (thread_count: int) -> &Compiler {
        profile_function()
        comp := alloc(Compiler)

        threads := Array[Thread].create()
        for 0..thread_count {
            threads.add(Thread.create(thread_func, comp))
        }

        <<comp = Compiler(
            mutex = Mutex.create()
            threads = threads
        )

        return comp
    }

    lock :: (ref Self) {
        if threads.get_length() > 1 then mutex.lock()
    }

    release :: (ref Self) {
        if threads.get_length() > 1 then mutex.release()
    }

    thread_func :: (self: &Compiler) {
        profile_function()
        Fiber.init()
        thread_id := Thread.current().id

        current_fiber : &CompileFiber = null
        while true #label main_loop {
            {
                self.lock()
                defer self.release()

                self.active_threads -= 1

                // if fiber made progress or finished, move all stuff from q2 to q
                if current_fiber != null {
                    current_fiber.thread = -1
                    if current_fiber.expr == null or current_fiber.expr.progressed {
                        while self.fiber_q2.count() > 0 {
                            self.fiber_q.push(self.fiber_q2.pop())
                        }
                    }

                    // if still not done, push in q2
                    if current_fiber.expr != null {
                        self.fiber_q2.push(current_fiber)
                    }

                    current_fiber = null
                }

                if self.fiber_q.count() == 0 {
                    if self.expr_q.count() > 0 {
                        expr  := self.expr_q.pop()
                        fiber := self.find_free_fiber()
                        fiber.expr = expr
                        self.fiber_q.push(fiber)

                    //*
                    } else if self.fiber_q2.count() > 0 {
                        if self.active_threads > 0 then continue
                        self.fiber_q.push(self.fiber_q2.pop())
                    // */

                    } else {
                        break main_loop
                    }
                }

                current_fiber = self.fiber_q.pop()
                current_fiber.thread = thread_id
                self.active_threads += 1
            }

            expr_id := current_fiber.expr.id
            current_fiber.fiber.resume()
        }
    }
}

impl Compiler {
    compile_all :: (ref Self) {
        profile_function()
        io.printfln("[compiler] compiling {} statements with {} threads", (exprs.get_length(), threads.get_length()))

        for exprs {
            expr_q.push(&it)
        }

        for threads {
            it.start()
        }

        handles := alloc_raw(HANDLE, cast threads.get_length())

        for threads {
            handles[it_index] = it.data.handle
        }
        WaitForMultipleObjects(cast threads.get_length(), handles, 1, INFINITE)




        for expr : exprs {
            if !expr.done {
                io.printfln("err: expr [{}] is not done", expr.id)
            }
        }

        io.printfln("[compiler] finished compilation with {} fibers", fibers.get_length())
    }

    find_free_fiber :: (ref Self) -> &CompileFiber {
        profile_function()
        for f : fibers {
            if f.expr == null and f.thread == -1 {
                return f
            }
        }
        {
            profile_scope("create new fiber")
            new_fiber   := alloc(CompileFiber)
            <<new_fiber = CompileFiber(&self, Fiber.new(compiler_fiber, new_fiber))
            fibers.add(new_fiber)
            return new_fiber
        }
    }
}

// profiling stuff
profile_scope :: (name: string) #macro #transparent {
    if const enable_profiler {
        _ := Timer.start(name)
    } else {
        _ := 0
    }
}

profile_function :: () #macro #transparent {
    if const enable_profiler {
        _ := Timer.start(@function_signature())
    } else {
        _ := 0
    }
}

profile_async :: (name: string, id: int, ph: string) #macro {
    if const enable_profiler {
        Instrumentor.get().
            write_profile_async(name, id, get_time_microseconds(), ph, Thread.current().id)
    }
}