use import lexer
use import string_database
use import cheez_compiler
use import parser
use import error_handler

use import std.time
use import std.string
use import std.array
use import std.mem.arena_allocator
use import std.mem.allocator
use import std.process
io  :: import std.io
fs  :: import std.io.fs
fmt :: import std.fmt

use import clap.clap

Main :: () {
    args_array := get_cmd_args()
    compiler_args := parse_arguments(MainCommand, args_array.sliceF(1))

    if compiler_args == null {
        // io.println(get_help_message(MainCommand))
        return
    }

    io.println(fmt.format_any(<<compiler_args))

    match <<compiler_args {
        MainCommand.Compile($options) -> command_compile(&options)
        MainCommand.Project($poptions) -> match poptions {
            CommandProject.New($options) -> command_project_new(&options)
        }

        MainCommand.Help -> io.println(get_help_message(@type_info(MainCommand)))

        MainCommand.FindToken($options) -> find_tokens_of_type(&options)
    }
}

#file_scope

MainCommand :: enum {
    #name("help")
    #help("Displays this help info")
    Help

    #name("compile")
    #help("Compile files")
    Compile : CommandCompile

    #name("build")
    #help("Build a project using a build script (default: build.che)")
    Build : CommandBuild

    #name("project")
    #help("Manage projects")
    Project : CommandProject

    #name("run")
    #help("Run a bytecode or source file")
    Run : CommandRun

    #name("find-tokens")
    #help("Find all occurences of a specific token type in a file")
    FindToken : CommandFindToken
}

CommandCompile :: struct {
    #help("List of files to compile (.che extension optional)
e.g. ... compile foo.che bar.che
e.g. ... compile foo bar")
    files : Array[String]
}

CommandBuild :: struct {
    
}

CommandProject :: enum {
    #name("new")
    #help("Create a new project")
    New : CommandProjectNew

    #help("Change the type of a project")
    #name("change-type")
    ChangeType : ProjectType
}

CommandRun :: struct {
    #help("File to run. Can be a source file (.che) or bytecode file (.cheb)")
    file : String
}

CommandProjectNew :: struct {
    #help("The name of the project to be created")
    name : String

    #name("type")
    #help("The type of project you want to create")
    typ  : ProjectType

    #name("no-git")
    #help("Don't create a git repository")
    no_git: bool = false
}

CommandProjectChangeType :: struct {
    #help("The name of the project to be created")
    name : String

    #name("type")
    #help("The type of project you want to create")
    typ  : ProjectType
}

ProjectType :: enum {
    #name("program")
    #help("Executable program")
    Program
    #name("dynamic-lib")
    #help("Dynamic library")
    DynamicLibrary
    #name("static-lib")
    #help("Static library")
    StaticLibrary
}

CommandFindToken :: struct {
    #name("file")
    #help("The file to search tokens in")
    file : String

    #name("type")
    #help("The type of token to search for")
    typ : TokenType

    #name("suffix")
    #help("If searching for a literal, only include those with the specified suffix")
    suffix : Option[String] = None
}

find_tokens_of_type :: (options: &CommandFindToken) {
    console_error_handler := ConsoleErrorHandler.new(null)
    console_error_handler.code_color_error  = io.ConsoleColor.Green
    console_error_handler.code_color_normal = io.ConsoleColor.White
    string_db := StringDatabase.new()
    lexer := try_with(
        Lexer.from_file(
            options.file.slice(), string_db, console_error_handler), {
                io.printfln("Failed to open file '{}'", options.file.slice())
                return
            })
    console_error_handler.text_provider = lexer

    suffix, filter_suffix := match options.suffix {
        Some($str) -> str.slice(), true
        None -> "", false
    }

    loop {
        token := lexer.next_token()

        if int(token.ttype) == int(TokenType.EOF) then break
        if int(token.ttype) != int(options.typ) then continue

        if filter_suffix {
            match token.suffix {
                Some($s) if streq(suffix, s)  -> console_error_handler.report_error(token.location, "")
                None     if streq(suffix, "") -> console_error_handler.report_error(token.location, "")
            }
        } else {
            console_error_handler.report_error(token.location, "")
        }
    }
}

command_project_new :: (options: &CommandProjectNew) {
    // io.println(fmt.format("creating new project named '{}' of type {}", [options.name.slice(), options.typ]))
    match options.typ {
        ProjectType.Program -> command_project_new_program(options)
    }
}

command_project_new_program :: (options: &CommandProjectNew) {
    create_dir :: (dir_format: string, dir_args: []any) #macro {
        dir := fmt.format(dir_format, dir_args)
        // io.printfln("Creating directory '{}'", dir.slice())
        fs.create_directory(dir.slice())
    }

    create_file :: (path_format: string, path_args: []any, content_format: string, content_args: []any) {
        path    := fmt.format(path_format, path_args)
        content := fmt.format(content_format, content_args)
        // io.printfln("Creating file '{}'", path.slice())
        fs.write_file(path.slice(), content.slice())
    }

    io.printfln("Creating project files for new project '{}'", options.name.slice())
    create_dir("{}", [options.name.slice()])
    create_dir("{}/src", [options.name.slice()])
    create_dir("{}/bin", [options.name.slice()])
    create_dir("{}/modules", [options.name.slice()])

    create_file("{}/src/{}",
                [options.name.slice(), "main.che"],
"io :: import std.io

Main :: () ``{
    io.println(`"Hello, {}!`")
}",
                [options.name.slice()])

    create_file("{}/build.ps1",
                [options.name.slice()],
"[CmdletBinding()]
param ([Parameter(ValueFromRemainingArguments)] [string[]] $Passthrough)
&cheezc ./src/main.che --out ./bin --name {} --time @Passthrough",
                [options.name.slice()])

    if !options.no_git {
        create_file("{}/.gitignore", [options.name.slice()],
"# Build results
bin/", [])

        // find git.exe
        io.println("Initializing git repository...")
        match find_on_path("git.exe") {
            None -> {
                io.println("[ERROR] No git installation found.")
            }

            Some($path) -> {
                // init git repo
                run_process(path.slice(), ["init"], options.name.slice())
            }
        }
    }
}

command_compile :: (options: &CommandCompile) {
    console_error_handler := ConsoleErrorHandler.new(null)
    string_db := StringDatabase.new()
    compiler := CheezCompiler.create()
    io.println("compiling...")
    for file : options.files {
        io.printfln("parsing {}...", file.slice())
        match Lexer.from_file("../examples/test.che", string_db, console_error_handler) {
            Ok($l) -> {
                console_error_handler.text_provider = l
                parser := Parser.create(compiler, l)
                start := get_time_milliseconds()
                while true {
                    stmt := parser.parse_statement()
                    match stmt {
                        Some($stmt) -> {
                            io.println(<<stmt)
                        }

                        None -> {
                            break
                        }
                    }
                }

                end := get_time_milliseconds()
                elapsed := ((cast(double)end) - (cast(double)start)) / 1000.0
                io.printfln("elapsed: {}", elapsed)
            }

            Err($msg) -> {
                io.println(msg)
            }
        }
    }
}
