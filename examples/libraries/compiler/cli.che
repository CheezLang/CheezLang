use import lexer
use import string_database
use import cheez_compiler
use import parser

use import std.time
use import std.string
use import std.array
use import std.mem.arena_allocator
use import std.mem.allocator
io  :: import std.io
fs  :: import std.io.fs
fmt :: import std.fmt

use import clap.clap

Main :: () {
    args_array := get_cmd_args()
    compiler_args := parse_arguments(MainCommand, args_array.sliceF(1))

    if compiler_args == null {
        // print_help_message(MainCommand)
        return
    }

    io.println(fmt.format_any(<<compiler_args))

    match <<compiler_args {
        MainCommand.compile($options) -> command_compile(&options)
        MainCommand.project($poptions) -> match poptions {
            CommandProject.new($options) -> command_project_new(&options)
        }
    }
}

#file_scope

MainCommand :: enum {
    compile : CommandCompile
    build   : CommandBuild
    project : CommandProject
}

CommandCompile :: struct {
    files : Array[String]
}

CommandBuild :: struct {
    
}

CommandProject :: enum {
    new : CommandProjectNew
}

CommandProjectNew :: struct {
    name : String

    #name("type")
    typ  : ProjectType
}

ProjectType :: enum {
    Program
    DynamicLibrary
    StaticLibrary
}

command_project_new :: (options: &CommandProjectNew) {
    io.println(fmt.format("creating new project named '{}' of type {}", [options.name.slice(), options.typ]))
    match options.typ {
        ProjectType.Program -> command_project_new_program(options)
    }
}

command_project_new_program :: (options: &CommandProjectNew) {
    create_dir :: (dir_format: string, dir_args: []any) #macro {
        dir := fmt.format(dir_format, dir_args)
        io.printfln("Creating directory '{}'", dir.slice())
        fs.create_directory(dir.slice())
    }

    create_file :: (path_format: string, path_args: []any, content_format: string, content_args: []any) {
        path    := fmt.format(path_format, path_args)
        content := fmt.format(content_format, content_args)
        io.printfln("Creating file '{}'", path.slice())
        fs.create_file(path.slice(), content.slice())
    }

    create_dir("{}", [options.name.slice()])
    create_dir("{}/src", [options.name.slice()])
    create_dir("{}/bin", [options.name.slice()])
    create_dir("{}/modules", [options.name.slice()])

    create_file("{}/src/{}",
                [options.name.slice(), "main.che"],
                "io :: import std.io

Main :: () ``{
    io.println(`"Hello, {}!`")
}",
                [options.name.slice()])

    create_file("{}/build.ps1",
                [options.name.slice()],
                "[CmdletBinding()]
param ([Parameter(ValueFromRemainingArguments)] [string[]] $Passthrough)
&cheezc ./src/main.che --out ./bin --name {} --time @Passthrough",
                [options.name.slice()])
}

command_compile :: (options: &CommandCompile) {
    string_db := StringDatabase.create()
    compiler := CheezCompiler.create()
    io.println("compiling...")
    for file : options.files {
        io.printfln("parsing {}...", file.slice())
        match Lexer.from_file("../examples/test.che", string_db) {
            Ok($l) -> {
                parser := Parser.create(compiler, l)
                start := get_time_milliseconds()
                while true {
                    stmt := parser.parse_statement()
                    match stmt {
                        Some($stmt) -> {
                            io.println(<<stmt)
                        }

                        None -> {
                            break
                        }
                    }
                }

                end := get_time_milliseconds()
                elapsed := ((cast(double)end) - (cast(double)start)) / 1000.0
                io.printfln("elapsed: {}", elapsed)
            }

            Err($msg) -> {
                io.println(msg)
            }
        }
    }
}
