use import lexer

use import std.math
io  :: import std.io
fmt :: import std.fmt

#export_scope

ErrorHandler :: trait {
    has_errors :: (ref Self) -> bool;
    report_error :: (ref Self, location: ref Location, message: string);
}

TextProvider :: trait {
    get_text :: (ref Self, filename: string) -> string;
}

ConsoleErrorHandler :: struct {
    text_provider     : TextProvider
    error_count       := 0
    do_print_location := true
    code_color_error  := io.ConsoleColor.Red
    code_color_normal := io.ConsoleColor.Green
}

impl ConsoleErrorHandler {
    new :: (text_provider: TextProvider) -> ConsoleErrorHandler {
        return ConsoleErrorHandler(text_provider)
    }
}

impl ErrorHandler for ConsoleErrorHandler {
    has_errors :: (ref Self) -> bool {
        return error_count > 0
    }

    report_error :: (ref Self, location: ref Location, message: string) {
        error_count += 1

        io.printf("{}:{}:{}:", (location.file, location.line, location.column))
        io.set_console_color(io.ConsoleColor.Red, io.ConsoleColor.Black)
        io.printfln(" {}", message)
        io.set_console_color(io.ConsoleColor.White, io.ConsoleColor.Black)

        if do_print_location then print_location(location)
    }

    print_location :: (ref Self, location: ref Location) {
        text := text_provider.get_text(location.file)

        // returns index of first character in the same line
        find_start_of_line :: (text: string, byte_index: int) -> int {
            bytes := text.bytes
            start := byte_index
            byte_index -= 1
            while byte_index >= 0 and bytes[byte_index] != u8('`n') {
                start = byte_index
                byte_index -= 1
            }
            return start
        }

        // returns index of \n at the end of the same line
        find_end_of_line :: (text: string, byte_index: int) -> int {
            bytes := text.bytes
            while byte_index < text.bytes.length and bytes[byte_index] != u8('`n') {
                byte_index += 1
            }
            return byte_index
        }

        // 
        get_line_range :: (text: string, start_line: int, byte_index: int, byte_length: int) -> int..int {
            bytes    := text.bytes
            end_line := start_line
            end      := byte_index + byte_length

            while byte_index < end, byte_index += 1 {
                if bytes[byte_index] == u8('`n') {
                    end_line += 1
                }
            }

            return start_line..end_line
        }

        print_line_number :: (line: int, max_line_digits: int) {
            line_digits := count_digits(line)
            for 0 .. max_line_digits - line_digits {
                io.print(" ")
            }
            io.print(line)
            io.print("> ")
        }

        // print line containing error
        {
            // byte range of entire error location
            total_range := location.byte_index .. location.byte_index + location.byte_length

            lines := get_line_range(text, location.line, location.byte_index, location.byte_length)
            max_line_digits := count_digits(lines.end)

            index := location.byte_index
            for(inclusive=true) line : lines {
                // byte range of current line
                line_range  := find_start_of_line(text, index) .. find_end_of_line(text, index)

                // byte range of error in current line
                error_range := index .. min(line_range.end, total_range.end)

                sub1 := text[line_range.start  .. error_range.start]
                sub2 := text[error_range.start .. error_range.end]
                sub3 := text[error_range.end   .. line_range.end]

                sub1_bytes := sub1.bytes
                sub2_bytes := sub2.bytes
                sub3_bytes := sub3.bytes

                print_stuff :: (bytes: []u8) #macro {
                    for b : bytes do io.printf("{:x} ", b)
                }

                print_line_number(line, max_line_digits)
                io.set_console_color(code_color_normal, io.ConsoleColor.Black)
                io.print(sub1)
                io.set_console_color(code_color_error, io.ConsoleColor.Black)
                io.print(sub2)
                io.set_console_color(code_color_normal, io.ConsoleColor.Black)
                io.print(sub3)
                io.set_console_color(io.ConsoleColor.White, io.ConsoleColor.Black)
                io.println("")

                index = line_range.end + 1
            }
        }
    }
}