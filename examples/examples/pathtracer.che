#load("olc_pge/pixel_game_engine")
#load("std:io/io")
#load("std:mem/arena_allocator")
#load("std:array")
#load("std:math")
#load("std:random")
#load("std:random/mt")

typedef Vec3 = Vector3[double]

scale             : int : 2
width             : int : 800 / scale
height            : int : 450 / scale
thread_count      : int : 2

max_depth         : int       : 5
min_contribution  : double    : 0.2

pi: double : 3.14159265359

fn create(val: $T, allocator: Allocator) -> &T {
    ptr := alloc(T, allocator)
    <<ptr = val
    return ptr
}

impl double {
    fn to_radians(Self) -> Self {
        return self / 180.0 * pi
    }
}

impl Printable for Vec3 {
    fn print(ref Self, str: ref String, format: string) {
        str.appendf("{}, {}, {}", (x, y, z))
    }
}

struct Ray {
    pub pos: Vec3
    pub dir: Vec3
}

struct HitInfo {
    pub distance: double
    pub pos     : Vec3
    pub normal  : Vec3
    pub material: &Material
}

struct Material {
    pub diffuse     : Vec3
    pub emission    : Vec3
    pub reflection  : Vec3
    pub refraction  : Vec3
    pub ior         : double
}

impl Material {
    fn reflective(color: Vec3) -> Self {
        return Material(reflection = color)
    }

    fn refrective(color: Vec3, ior: double) -> Self {
        return Material(refraction = color, ior = ior)
    }
}

trait Object {
    fn intersect(ref Self, ray: Ray) -> Option[HitInfo];
}

struct Sphere {
    pos: Vec3
    rad: double
    mat: &Material
}

impl Object for Sphere {
    fn intersect(ref Self, ray: Ray) -> Option[HitInfo] {
        op := pos - ray.pos
        r2 := rad * rad
        b := op.dot(ray.dir)
        det := b * b - op.magsq() + r2
        if det < 0 {
            return None
        }

        epsilon := 0.0001
        det = sqrt(det)
        minusT := b - det
        plusT := b + det
        if minusT < epsilon and plusT < epsilon {
            return None
        }

        t := if minusT > epsilon {minusT} else {plusT}
        hitPos := ray.pos + ray.dir * t
        normal := hitPos - pos
        normal.normalize()
        return Some(HitInfo(t, hitPos, normal, mat))
    }
}

struct PathTracer {
    pge             : &PixelGameEngine
    allocator       : ArenaAllocator
    objects         : Array[Object]
    cam_fov         : double
    pub cam_pos     : Vec3
    pub cam_dir     : Vec3
    pub cam_right   : Vec3
    pub cam_up      : Vec3
    sample_t        : double
    total_t         : double
    pub buffer      : []Vec3
    threads         : [thread_count]HANDLE
    pub thread_datas: [thread_count](id: int, pt: &PathTracer, samples: int)
}

impl Drop for PathTracer {
    fn drop(ref Self) {
        free_n(buffer)
    }
}

impl PathTracer {
    fn create() -> Self {
        return PathTracer(
            allocator   = ArenaAllocator.create(1024)
            objects     = Array[Object].create()
            buffer      = {
                b := alloc_n(Vec3, u64(width * height))
                c_memset(b.data, 0, u64(b.length * @sizeof(Vec3)))
                b
            }
        )
    }

    fn add_object(ref Self, obj: $T) {
        dyn := alloc(T, allocator)
        <<dyn = obj
        objects.add(ref <<dyn)
    }

    fn intersect(ref Self, ray: Ray) -> Option[HitInfo] {
        let nearest: Option[HitInfo] = None

        for n : 0..objects.get_length() {
            hit := objects[n].intersect(ray)
            nearest = match (nearest, hit) {
                (None, Some($hit)) -> Some(hit)
                (Some($n), Some($hit)) if hit.distance < n.distance -> Some(hit)
                $_ -> nearest
            }
        }

        return nearest
    }

    fn calc_color(ref Self, ray: Ray, prng: &MTwister, contribution: double, depth: int = 0) -> Vec3 {
        if depth >= max_depth or contribution < min_contribution {
            return Vec3()
        }

        return match self.intersect(ray) {
            None -> Vec3()
            Some($hit) -> {
                result := Vec3()

                // emission
                result += hit.material.emission

                // diffuse
                if hit.material.diffuse.max_component() > 0 {
                    rand := StandardContinuousUniform[MTwister](prng)
                    r1 := rand.sample() * 2.0 * pi
                    r2 := rand.sample()
                    r2s := sqrt(r2)

                    w := hit.normal
                    u := if abs(w.x) > abs(w.z) {Vec3(-w.y, w.x, 0)} else {Vec3(0, -w.z, w.y)}
                    u.normalize()
                    v := u.cross(w)
                    newDir := u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1 - r2)
                    newRay := Ray(hit.pos, newDir)

                    result += hit.material.diffuse * calc_color(newRay, prng, contribution * hit.material.diffuse.max_component(), depth + 1)
                }

                // reflection
                if hit.material.reflection.max_component() > 0 {
                    newDir := ray.dir.reflect(hit.normal)
                    newRay := Ray(hit.pos, newDir)
                    nextContribution := contribution * hit.material.reflection.max_component()
                    result += hit.material.reflection * calc_color(newRay, prng, nextContribution, depth + 1)
                }

                // refraction
                refract_max := hit.material.refraction.max_component()
                if refract_max > 0 {
                    I := ray.dir.normalized()
                    n := hit.normal.normalized()

                    n1 := 1.0
                    n2 := hit.material.ior


                    outside := Vec3.dot(hit.normal, ray.dir) < 0
                    if !outside {
                        // coming from inside
                        (n1, n2) = (n2, n1)
                        n = -n
                    }

                    kr := fresnel(I, n, hit.material.ior)
                    color_refracted := if kr >= 1 then Vec3() else {
                        r := n1 / n2
                        c := -Vec3.dot(n, I)

                        f := r * c - sqrt(1 - r * r * (1 - c * c))
                        newDir := I * r + n * f
                        newRay := Ray(hit.pos + newDir * 0.01, newDir)
                        calc_color(newRay, prng, contribution * refract_max, depth + 1)
                    }

                    color_reflected := {
                        newDir := I.reflect(n)
                        newRay := Ray(hit.pos + newDir * 0.01, newDir)
                        calc_color(newRay, prng, contribution * refract_max, depth + 1)
                    }

                    color := color_reflected * kr + color_refracted * (1 - kr)
                    result += hit.material.refraction * color
                }

                result
            }
        }
    }

    fn fresnel(I: Vec3, N: Vec3, ior: double) -> kr: double {
        cosi := clamp(Vec3.dot(I, N), -1.0, 1.0, )
        etai := 1.0
        etat := ior
        if cosi > 0 { (etai, etat) = (etat, etai) }
        // Compute sini using Snell's law
        sint := etai / etat * sqrt(fmax(0.0, 1.0 - cosi * cosi))
        // Total internal reflection
        if sint >= 1 {
            kr = 1
        } else {
            cost := sqrt(fmax(0.0, 1.0 - sint * sint))
            cosi = fabs(cosi)
            Rs := ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost))
            Rp := ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost))
            kr = (Rs * Rs + Rp * Rp) / 2.0
        }
    }
}

fn pathtracer_thread(data: &(index: int, pt: &PathTracer)) -> u32 #stdcall {
    // data := @cast(&(index: int, pt: &PathTracer), _data)

    y_range := height / thread_count
    start_y := data.index * y_range
    let end_y   = (data.index + 1) * y_range - 1
    if height - end_y < y_range {
        end_y = height - 1
    }

    printfln("{}: {} -> {}", (data.index, start_y, end_y))
    seed := PseudoRandom.next_int()
    prng := MTwister.create(cast seed)

    while true {
        for(inclusive=true) current_y : start_y..end_y {
            // loop through current line
            for current_x : 0..width {
                index := current_x + current_y * width

                // x coordinate in range [-1; 1]
                // y coordinate in range [-1; 1]
                let blur_radius: double = 1
                x := (double(current_x) + prng.next_double() * blur_radius * 2 - blur_radius) / double(width) * 2 - 1
                y := (double(height - current_y - 1) + prng.next_double() * blur_radius * 2 - blur_radius) / double(height) * 2 - 1

                // calculate ray for current pixel
                dir := data.pt.cam_dir + data.pt.cam_right * x + data.pt.cam_up * y
                dir.normalize()

                // shoot ray into scene and calculate color
                color := data.pt.calc_color(Ray(data.pt.cam_pos, dir), &prng, 1)
                // println(color)
                data.pt.buffer[index] += color
            }
        }

        data.pt.thread_datas[data.index].samples += 1
    }
    return 0
}

impl Game for PathTracer {
    fn on_create(ref Self, pge: &PixelGameEngine) -> bool {
        self.pge = pge

        self.cam_fov = double.to_radians(60.0)
        aspect_ratio := double(width) / double(height)

        size := 10.0

        // calculate cam rays (forward, right, up)
        self.cam_pos = Vec3(0, 5, 3)
        self.cam_dir = Vec3(0, -0.25, 1)
        self.cam_dir.normalize()

        up := Vec3(0, 1, 0)
        self.cam_right = up.cross(self.cam_dir)
        self.cam_up    = self.cam_dir.cross(self.cam_right)

        up_mag := tan(self.cam_fov / 2)
        right_mag := up_mag * aspect_ratio

        self.cam_up     = self.cam_up.normalized() * up_mag
        self.cam_right  = self.cam_right.normalized() * right_mag

        printfln("  dir: {}", self.cam_dir)
        printfln("   up: {}", self.cam_up)
        printfln("right: {}", self.cam_right)

        // create objects
        let m_red   = create(Material(Vec3(0.9, 0.2, 0.2)), allocator)
        m_green := create(Material(Vec3(0.2, 0.9, 0.2)), allocator)
        let m_blue  = create(Material(Vec3(0.2, 0.2, 0.9)), allocator)
        let m_grey  = create(Material(Vec3(0.75, 0.75, 0.75)), allocator)

        let m_mirror= create(Material.reflective(Vec3(1, 1, 1)), allocator)
        m_glass := create(Material.refrective(Vec3(1, 1, 1), 1.95), allocator)

        m_light := create(Material(emission = Vec3(10, 10, 10)), allocator)

        self.add_object(Sphere(Vec3(-1000.0 - size / 2, 0, 0), 1000, m_red)) // left
        self.add_object(Sphere(Vec3(1000.0 + size / 2, 0, 0), 1000, m_green)) // right

        self.add_object(Sphere(Vec3(0, 0, 1000.0 + size / 2 + 10), 1000, m_grey)) // back
        self.add_object(Sphere(Vec3(0, 0, -1000.0 - size / 2 * 5), 1000, m_grey)) // front

        self.add_object(Sphere(Vec3(0, -1000.0, 0), 1000, m_grey)) // bot
        self.add_object(Sphere(Vec3(0, 1000.0 + size, 0), 1000, m_grey)) // top

        // spheres
        self.add_object(Sphere(Vec3(-0.25, 2.25, 8.5), 1.75, m_glass))
        self.add_object(Sphere(Vec3(3, 2, 13), 2, m_mirror))
        self.add_object(Sphere(Vec3(-2.5, 1, 12), 1, m_green))
        self.add_object(Sphere(Vec3(1.75, 1, 10), 1, m_blue))

        // light
        self.add_object(Sphere(Vec3(0, size + 9.75, 10), 10, m_light))

        // create threads
        for i : 0..thread_count {
            thread_datas[i] = (i, &self, 0)
            threads[i] = CreateThread(null, 0, cast pathtracer_thread, &thread_datas[i], 0, null)
        }
        return true
    }

    fn on_destroy(ref Self) -> bool {
        for i : 0..thread_count {
            TerminateThread(threads[i], 0)
            CloseHandle(threads[i])
        }
        return true
    }

    fn on_update(ref Self, dt: float) -> bool {
        if pge.get_key(Key.Escape).pressed {
            return false
        }

        //
        for current_y : 0..height {
            for current_x : 0..width {
                index := current_x + current_y * width
                thread_id := current_y / (height / thread_count)
                if thread_id >= thread_count {
                    thread_id = thread_count - 1
                }

                sample := thread_datas[thread_id].samples

                // calculate color of pixel by taking the average of the color
                // in the buffer
                pixel := {
                    bufferColor := buffer[index] / double(sample + 1)
                    // println(bufferColor)
                    bufferColor = bufferColor.clamped(0.0, 1.0) * 255.0
                    c := Vec3.change_type(bufferColor, u8)
                    Pixel.rgba(c.x, c.y, c.z)
                }
                pge.draw(current_x, current_y, pixel)
            }
        }

        sample_t += double(dt)
        if sample_t >= 1 {
            total_t += 1

            sps := double(thread_datas[0].samples) / total_t
            total_seconds := int(total_t + 0.1)
            s := String.format("Samples: {}, Total: {}s, Samples per second: {}", 
                (thread_datas[0].samples, total_seconds, sps))
            pge.set_window_title(s)

            sample_t -= 1
        }

        return true
    }
}

fn test_thread(data: &any) -> u32 #stdcall {
    index := int(data)
    println(index)

    return 0
}

fn Main() {
    game := PathTracer.create()
    pge := PixelGameEngine.create(game, width, height, 1, 1)
    if pge != null {
        pge.start()
    }
}