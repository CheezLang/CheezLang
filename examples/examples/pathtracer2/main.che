#load("std:io/io")
#load("std:math")
#load("std:random/mt")
#load("std:util")
#load("std:thread")
#load("../../bmp/bmp")
#load("misc")
#load("objects")
#load("material")
#load("texture")

let const report_progress: bool = true
typedef real = float

let use_bhv     : bool = true
let num_threads : int = 10
let grid_size   : int = 25

let width       : int = 192 * 2
let height      : int = 108 * 2
// let width       : int = 108 * 1
// let height      : int = 108 * 1
let samples     : int = 500
let max_depth   : int = 10

let scenes: []fn(ref Camera) -> Hittable = [simple_light, cornell_box, basic_scene, random_scene]
let const scene: int = 3

let file_write_mutex: Mutex = Mutex::create()

struct RenderContext {
    pub const id    : int
    pub const min   : Vector2(int)
    pub const max   : Vector2(int)
    pub image       : []double
    pub const world : Hittable
    pub const cam   : ref Camera
    pub const random: Random
}

fn Main() {
    println(if use_bhv then "bhv enabled" else "bhv disabled")

    let image = alloc_n(double, cast width * height * 3)

    let cam_pos = new vec3{20.0, 2.25, 5.0}
    let lookat  = new vec3{4.0, 1.0, 1.0}
    let cam = Camera::create(
        cam_pos,
        lookat,
        10,
        real(width) / real(height),
        0.0,
        vec3::mag(cam_pos - lookat))

    let world = scenes[scene](cam)

    for : 0..(get_time_milliseconds()%100) {
        global_random.next_double()
    }

    let start = get_time_milliseconds()
    {
        let thread_pool = ThreadPool::create(num_threads)

        let id = 1
        let size = grid_size
        let h = (height-1)/size+1
        let w = (width-1)/size+1
        for y: 0..h {
            for x: 0..w {
                let context = alloc(RenderContext)
                <<context = new RenderContext{
                    id = id
                    min = new {x*size, y*size}
                    max = new {min((x+1)*size, width), min((y+1)*size, height)}
                    image = image
                    world = world
                    cam = cam
                    random = Random::create(0) // crashes with seed not 0, wtf?
                }
                // printfln("thread {}: ({}, {}) -> ({}, {})", [context.id, context.min.x, context.min.y, context.max.x, context.max.y])

                // if global_random.next_double() < 0.5 {
                    thread_pool.enqueue(render_loop, context)
                // }

                id += 1
            }
        }

        thread_pool.terminate(true)
    }

    let end = get_time_milliseconds()
    let dur = double(end - start) / 1000

    printfln("resolution: {}x{}", [width, height])
    printfln("   samples: {}", [samples])
    printfln("      time: {}s", [dur])

    write_bmp(cast width, cast height, image.data, "image.bmp")
}

fn render_loop(context: &RenderContext) {
    {
        let h = (height - 1) / grid_size + 1
        let w = (width  - 1) / grid_size + 1
        let count = w * h
        printfln("block {}/{}: ({}, {}) -> ({}, {})", [context.id, count, context.min.x, context.min.y, context.max.x, context.max.y])
    }

    for : 0..(get_time_microseconds()%100) {
        context.random.next_double()
    }

    let start = get_time_milliseconds()
    let last_update = 0

    for py, py_index: context.min.y..context.max.y {
        for px, px_index: context.min.x..context.max.x {
            let col = new vec3{0.0, 0.0, 0.0}

            for s: 0..samples {
                let u = (real(px) + context.random.random_real()) / real(width)
                let v = (real(height - py - 1) + context.random.random_real()) / real(height)
                let r = context.cam.get_ray(u, v, context.random)
                col += color(r, context.world, context.random)
            }

            col /= real(samples)

            // gamma correction
            col = new vec3{real(sqrt(col.x)), real(sqrt(col.y)), real(sqrt(col.z))}

            context.image[(px + py * width) * 3 + 0] = double(col.x)
            context.image[(px + py * width) * 3 + 1] = double(col.y)
            context.image[(px + py * width) * 3 + 2] = double(col.z)
        }
    }
    printfln("block {}: finished", [context.id])

    // if const report_progress {
    //     file_write_mutex.lock()
    //     write_bmp(cast width, cast height, context.image.data, "image.bmp")
    //     file_write_mutex.release()
    // }
}

fn color(r: Ray, world: Hittable, random: ref Random, depth: int = 0) -> vec3 {
    return match world.hit(r, 0.001, 1000000.0, random) {
        Some($hit) -> {
            match hit.m.scatter(r, hit, random) {
                Scatter.ColorReflection($m) if depth < max_depth -> color(m.scattered, world, random, depth + 1) * m.att
                Scatter.Reflection($ray) if depth < max_depth -> color(ray, world, random, depth + 1)
                Scatter.Color($col) -> col

                $_ -> new vec3{0.0, 0.0, 0.0}
            }
        }

        None -> {
            let t: real = 0.5 * (r.direction.y + 1)
            new vec3{1, 1, 1} * (1 - t) + new vec3{0.5, 0.7, 1.0} * t
            // new vec3{0, 0, 0}
            // new vec3{1, 1, 1}
        }
    }
}

fn random_scene(cam: ref Camera) -> Hittable {
    let cam_pos = new vec3{20.0, 2.25, 5.0}
    let lookat  = new vec3{4.0, 1.0, 1.0}
    cam = Camera::create(
        cam_pos,
        lookat,
        10,
        real(width) / real(height),
        0.1,
        vec3::mag(cam_pos - lookat))

    //
    let list = Array(Hittable)::create()
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, -1000, 0}
        radius = 1000
        material = create_object(Material, new Lambertian{
            CheckerTexture::create(
                ConstantTexture::create(new vec3{0.1, 0.1, 0.1}),
                ConstantTexture::create(new vec3{0.9, 0.9, 0.9})
            )
        })
    }))

    for a: -11..11 {
        for b: -11..11 {
            let choose_mat = global_random.random_real()
            let center = new vec3{
                x = real(a) + real(0.9) * global_random.random_real(),
                y = 0.2
                z = real(b) + real(0.9) * global_random.random_real()
            }

            if vec3::mag(center - new vec3{4, 0.2, 0}) > 0.9 {
                if choose_mat < 0.65 { // diffuse
                    list.add(create_object(Hittable, new Sphere{
                        center = center
                        radius = 0.2
                        material = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{
                            x = global_random.random_real() * global_random.random_real()
                            y = global_random.random_real() * global_random.random_real()
                            z = global_random.random_real() * global_random.random_real()
                        })})
                    }))
                } else if choose_mat < 0.75 { // emissive
                    list.add(create_object(Hittable, new Sphere{
                        center = center
                        radius = 0.2
                        material = create_object(Material, new Emissive{new vec3{
                            x = 40 * global_random.random_real()
                            y = 40 * global_random.random_real()
                            z = 40 * global_random.random_real()
                        }})
                    }))
                } else if choose_mat < 0.9 { // metal
                    list.add(create_object(Hittable, new Sphere{
                        center = center
                        radius = 0.2
                        material = create_object(Material, new Metal{
                            albedo = new vec3{
                                x = 0.5 * (1.0 + global_random.random_real())
                                y = 0.5 * (1.0 + global_random.random_real())
                                z = 0.5 * (1.0 + global_random.random_real())
                            }
                            roughness = 0.5 * global_random.random_real()
                        })
                    }))
                } else { // glass
                    list.add(create_object(Hittable, new Sphere{
                        center = center
                        radius = 0.2
                        material = create_object(Material, new Dielectric{1.5})
                    }))
                }
            }
        }
    }

    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, 1, 0}
        radius = 1.0
        material = create_object(Material, new Dielectric{1.5})
    }))
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{-4, 1, 0}
        radius = 1.0
        material = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.4, 0.2, 0.1})})
    }))
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{4, 1, 0}
        radius = 1.0
        material = create_object(Material, new Metal{new vec3{0.7, 0.6, 0.5}, 0.0})
    }))

    let box = create_object(Hittable, Box::create(
        new{-100, 0, -100}, new{100, 1, 100}, null
        // new{-4, 0, 1}, new{4, 1, 2}, null
    ))

    let col: real = 1.0
    let den: real = 0.05
    list.add(ConstantMedium::create(box, den, ConstantTexture::create(new vec3{col, col, col})))

    if use_bhv {
        let bhv = BhvNode::create(list.slice())
        return create_object(Hittable, bhv)
    } else {
        return create_object(Hittable, list)
    }
}

fn basic_scene(cam: ref Camera) -> Hittable {
    let cam_pos = new vec3{20.0, 2.25, 5.0}
    let lookat  = new vec3{4.0, 1.0, 1.0}
    cam = Camera::create(
        cam_pos,
        lookat,
        10,
        real(width) / real(height),
        0.0,
        vec3::mag(cam_pos - lookat))

    let list = Array(Hittable)::create()
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, -1000, 0}
        radius = 1000
        material = create_object(Material, new Lambertian{
            CheckerTexture::create(
                ConstantTexture::create(new vec3{0.1, 0.1, 0.1}),
                ConstantTexture::create(new vec3{0.9, 0.9, 0.9})
            )
        })
    }))

    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, 1, 0}
        radius = 1.0
        material = create_object(Material, new Dielectric{1.5})
    }))
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{-4, 1, 0}
        radius = 1.0
        material = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.4, 0.2, 0.1})})
    }))
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{4, 1, 0}
        radius = 1.0
        material = create_object(Material, new Metal{new vec3{0.7, 0.6, 0.5}, 0.0})
    }))

    let box = create_object(Hittable, Box::create(
        new{-100, 0, -100}, new{100, 10, 100}, null
        // new{-4, 0, 1}, new{4, 1, 2}, null
    ))

    let col: real = 1.0
    let den: real = 0.025
    list.add(ConstantMedium::create(box, den, ConstantTexture::create(new vec3{col, col, col})))

    if use_bhv {
        let bhv = BhvNode::create(list.slice())
        return create_object(Hittable, bhv)
    } else {
        return create_object(Hittable, list)
    }
}

fn simple_light(cam: ref Camera) -> Hittable {
    cam = Camera::create(
        new vec3{20.0, 4.0, 5.0},
        new vec3{4.0, 2.5, 1.0},
        20,
        real(width) / real(height)
    )

    let list = Array(Hittable)::create()

    // ground
    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, -1000, 0}
        radius = 1000
        material = create_object(Material, new Lambertian{
            CheckerTexture::create(
                ConstantTexture::create(new vec3{0.1, 0.1, 0.1}),
                ConstantTexture::create(new vec3{0.9, 0.9, 0.9})
            )
        })
    }))

    list.add(create_object(Hittable, new Sphere{
        center = new vec3{0, 2, 0}
        radius = 2
        material = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.4, 0.7, 0.3})})
    }))

    list.add(create_object(Hittable, new XYRect{
        3, 5, 1, 3, -2
        create_object(Material, new Emissive{new vec3{4, 4, 4}})
    }))

    if use_bhv {
        let bhv = BhvNode::create(list.slice())
        return create_object(Hittable, bhv)
    } else {
        return create_object(Hittable, list)
    }
}

fn cornell_box(cam: ref Camera) -> Hittable {
    cam = Camera::create(
        new vec3{278, 278, -800},
        new vec3{278, 278, 0},
        40,
        real(width) / real(height),
        0,
        10
    )

    // materials
    let red = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.65, 0.05, 0.05})})
    let white = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.73, 0.73, 0.73})})
    let green = create_object(Material, new Lambertian{ConstantTexture::create(new vec3{0.12, 0.45, 0.15})})
    let light = create_object(Material, new Emissive{new vec3{15, 15, 15}})

    // room
    let list = Array(Hittable)::create()
    list.add(FlipNormals::create(create_object(Hittable, new YZRect{  0, 555,   0, 555, 555, green})))  // left
    list.add(                    create_object(Hittable, new YZRect{  0, 555,   0, 555,   0, red}))     // right
    list.add(                    create_object(Hittable, new ZXRect{213, 343, 227, 332, 554, light}))   // light
    // list.add(FlipNormals::create(create_object(Hittable, new ZXRect{  0, 555,   0, 555, 555, white})))  // ceiling
    list.add(                    create_object(Hittable, new ZXRect{  0, 555,   0, 555,   0, white}))   // floor
    // list.add(FlipNormals::create(create_object(Hittable, new XYRect{  0, 555,   0, 555, 555, white})))  // back

    // objects
    Box::create_faces(new vec3{130, 0, 65}, new vec3{295, 165, 230}, white, list)
    Box::create_faces(new vec3{265, 0, 295}, new vec3{430, 330, 460}, white, list)

    if use_bhv {
        let bhv = BhvNode::create(list.slice())
        return create_object(Hittable, bhv)
    } else {
        return create_object(Hittable, list)
    }
}