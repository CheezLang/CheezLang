#load("std:io/io")
#load("std:math")
#load("std:random/mt")
#load("std:util")
#load("../../bmp/bmp")
#load("misc")
#load("objects")
#load("material")

let const report_progress: bool = true

let width       : int = 160 * 3
let height      : int = 90  * 3
let samples     : int = 100
let max_depth   : int = 20

fn new_mat(mat: $T) -> Material {
    let mem = alloc(T)
    <<mem = mat
    return Material(<<mem)
}

fn new_hittable(hit: $T) -> Hittable {
    let mem = alloc(T)
    <<mem = hit
    return Hittable(<<mem)
}

fn random_scene(n: int) -> Hittable {
    let list = Array(Hittable)::create(n)
    list.add(new_hittable(new Sphere{
        center = new vec3{0, -1000, 0}
        radius = 1000
        material = new_mat(new Lambertian{new vec3{0.5, 0.5, 0.5}})
    }))

    for a: -11..11 {
        for b: -11..11 {
            let choose_mat = random.next_double()
            let center = new vec3{
                x = double(a) + 0.9 * random.next_double(),
                y = 0.2
                z = double(b) + 0.9 * random.next_double()
            }

            if vec3::mag(center - new vec3{4, 0.2, 0}) > 0.9 {
                if choose_mat < 0.8 { // diffuse
                    list.add(new_hittable(new Sphere{
                        center = center
                        radius = 0.2
                        material = new_mat(new Lambertian{new vec3{
                            x = random.next_double() * random.next_double()
                            y = random.next_double() * random.next_double()
                            z = random.next_double() * random.next_double()
                        }})
                    }))
                } else if choose_mat < 0.95 { // metal
                    list.add(new_hittable(new Sphere{
                        center = center
                        radius = 0.2
                        material = new_mat(new Metal{
                            albedo = new vec3{
                                x = 0.5 * (1.0 + random.next_double())
                                y = 0.5 * (1.0 + random.next_double())
                                z = 0.5 * (1.0 + random.next_double())
                            }
                            roughness = 0.5 * random.next_double()
                        })
                    }))
                } else { // glass
                    list.add(new_hittable(new Sphere{
                        center = center
                        radius = 0.2
                        material = new_mat(new Dielectric{1.5})
                    }))
                }
            }
        }
    }

    list.add(new_hittable(new Sphere{
        center = new vec3{0, 1, 0}
        radius = 1.0
        material = new_mat(new Dielectric{1.5})
    }))
    list.add(new_hittable(new Sphere{
        center = new vec3{-4, 1, 0}
        radius = 1.0
        material = new_mat(new Lambertian{new vec3{0.4, 0.2, 0.1}})
    }))
    list.add(new_hittable(new Sphere{
        center = new vec3{4, 1, 0}
        radius = 1.0
        material = new_mat(new Metal{new vec3{0.7, 0.6, 0.5}, 0.0})
    }))


    return new_hittable(list)
}

fn Main() {
    let image = alloc_n(double, cast width * height * 3)

    let lower_left_corner   = new vec3{-2.0, -1.0, -1.0}
    let horizontal          = new vec3{4.0, 0.0, 0.0}
    let vertical            = new vec3{0.0, 2.0, 0.0}
    let origin              = new vec3{0.0, 0.0, 0.0}

    let m1 = new Lambertian{new vec3{0.8, 0.3, 0.3}}
    let m2 = new Lambertian{new vec3{0.8, 0.8, 0.1}}
    let m3 = new Metal{new vec3{0.8, 0.6, 0.2}, 0.3}
    let m4 = new Dielectric{1.5}

    let s1 = new Sphere{new vec3{0, 0, -1}, 0.5, m1}
    let s2 = new Sphere{new vec3{0, -100.5, -1}, 100, m2}
    let s3 = new Sphere{new vec3{1, 0, -1}, 0.5, m3}
    let s4 = new Sphere{new vec3{-1, 0, -1}, 0.5, m4}
    let s5 = new Sphere{new vec3{-1, 0, -1}, -0.45, m4}

    // let world = Array(Hittable)::create()
    // world.add(s1)
    // world.add(s2)
    // world.add(s3)
    // world.add(s4)
    // world.add(s5)

    let world = random_scene(500)

    let cam_pos = new vec3{20.0, 2.25, 5.0}
    let lookat  = new vec3{4.0, 1.0, 1.0}
    let cam = Camera::create(
        cam_pos,
        lookat,
        10,
        double(width) / double(height),
        0.0,
        vec3::mag(cam_pos - lookat))

    let start = get_time_milliseconds()
    let last_update = 0

    for py: 0..height {
        for px: 0..width {
            let col = new vec3{0.0, 0.0, 0.0}

            for s: 0..samples {
                let u = (double(px) + random.next_double()) / double(width)
                let v = (double(height - py - 1) + random.next_double()) / double(height)
                let r = cam.get_ray(u, v)
                col += color(r, world, 0)
            }

            col /= double(samples)

            // gamma correction
            col = new vec3{sqrt(col.x), sqrt(col.y), sqrt(col.z)}

            image[(px + py * width) * 3 + 0] = col.x
            image[(px + py * width) * 3 + 1] = col.y
            image[(px + py * width) * 3 + 2] = col.z

            if const report_progress {
                let current_seconds = (get_time_milliseconds() - start) / 1000
                if current_seconds > last_update {
                    let progress = int(100.0 * double(px + py * width) / double(width * height))
                    printfln("{}% ({}s)", [progress, current_seconds])
                    last_update = current_seconds
                }
            }
        }
    }
    let end = get_time_milliseconds()
    let dur = double(end - start) / 1000

    printfln("resolution: {}x{}", [width, height])
    printfln("   samples: {}", [samples])
    printfln("      time: {}s", [dur])

    write_bmp(cast width, cast height, image.data, "image.bmp")
}

fn color(r: Ray, world: Hittable, depth: int) -> vec3 {
    return match world.hit(r, 0.001, 1000000.0) {
        Some($hit) -> {
            match hit.m.scatter(r, hit) {
                Some($m) if depth < max_depth ->
                    color(m.scattered, world, depth + 1) * m.att

                None -> new vec3{0.0, 0.0, 0.0}
            }
        }

        None -> {
            let t = 0.5 * (r.direction.y + 1)
            new vec3{1, 1, 1} * (1 - t) + new vec3{0.5, 0.7, 1.0} * t
        }
    }
}