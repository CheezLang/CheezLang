#load("std:array")
#load("std:math")
#load("misc")
#load("material")

struct HitRecord {
    pub t: real
    pub p: vec3
    pub n: vec3
    pub m: Material
    pub u: real
    pub v: real
}

trait Hittable {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord];
    fn bounding_box(ref Self) -> Option[AABB];
}

//
struct Sphere {
    pub const center: vec3
    pub const radius: real
    pub const material: Material
}

impl Hittable for Sphere {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        let oc = r.origin - center
        let b = vec3::dot(oc, r.direction)
        let c = vec3::dot(oc, oc) - radius * radius
        let discriminant = b * b - c

        if discriminant > 0 {
            let sqrt_dis = real(sqrt(discriminant))

            let temp = -b - sqrt_dis
            if temp < t_max and temp > t_min {
                let point = r.at(temp)
                return Some(new HitRecord{
                    t = temp
                    p = point
                    n = (point - center) / radius
                    m = material
                })
            }

            temp = -b + sqrt_dis
            if temp < t_max and temp > t_min {
                let point = r.at(temp)
                return Some(new HitRecord{
                    t = temp
                    p = point
                    n = (point - center) / radius
                    m = material
                })
            }
        }
        return None
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(AABB::create(
            center - new vec3{radius, radius, radius},
            center + new vec3{radius, radius, radius}
        ))
    }
}

//
impl Hittable for Array[Hittable] {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        let hit = Option[HitRecord].None
        let closest = t_max
        for : self.slice() {
            match it.hit(r, t_min, closest, random) {
                Some($h) -> {
                    hit = Some(h)
                    closest = h.t
                }
            }
        }

        return hit
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        if self.get_length() == 0 {
            return None
        }

        let box = match self[0].bounding_box() {
            Some($aabb) -> aabb
            None -> {
                return None
                AABB(default)
            }
        }

        for : self.sliceF(1) {
            box = match it.bounding_box() {
                Some($aabb) -> AABB::surrounding_box(box, aabb)
                None -> {
                    return None
                    AABB(default)
                }
            }
        }

        return Some(box)
    }
}

//
struct BhvNode {
    left    : Hittable
    right   : Hittable
    box     : AABB
}

fn test_macro(name: string, arr: []Hittable) {
    let address = int(arr.data)
    printfln("{}: [{}] {}", (name, address, arr.length))
    for : arr {
        it.bounding_box()
    }
}

fn quick_sort(arr: []Hittable, cmp: fn (Hittable, Hittable) -> int) {
        if arr.length <= 1 {
            return
        }

        let idx = 0
        let pivot = arr[arr.length - 1]
        while let i = 0, i < arr.length - 1, i += 1 {
            if cmp(arr[i], pivot) > 0 {
                (arr[idx], arr[i]) = (arr[i], arr[idx])
                idx += 1
            }
        }
        (arr[idx], arr[arr.length - 1]) = (arr[arr.length - 1], arr[idx])

        quick_sort(arr[0..idx], cmp)
        quick_sort(arr[idx+1..arr.length], cmp)
    }

fn box_compare_x(a: Hittable, b: Hittable) -> int {
    return match (a.bounding_box(), b.bounding_box()) {
        (Some($a), Some($b)) -> if a._min.x - b._min.x < 0 then -1 else 1

        $_ -> {
            println("no bounding box in BhvNode constructor")
            0
        }
    }
}

fn box_compare_y(a: Hittable, b: Hittable) -> int {
    return match (a.bounding_box(), b.bounding_box()) {
        (Some($a), Some($b)) -> if a._min.y - b._min.y < 0 then -1 else 1

        $_ -> {
            println("no bounding box in BhvNode constructor")
            0
        }
    }
}

fn box_compare_z(a: Hittable, b: Hittable) -> int {
    return match (a.bounding_box(), b.bounding_box()) {
        (Some($a), Some($b)) -> if a._min.z - b._min.z < 0 then -1 else 1

        $_ -> {
            println("no bounding box in BhvNode constructor")
            0
        }
    }
}

impl BhvNode {
    fn create(l: []Hittable) -> BhvNode {
        let compare_funcs = [box_compare_x, box_compare_y, box_compare_z]
        quick_sort(l, compare_funcs[int(global_random.random_real() * 3)])

        let (left, right) = if l.length == 1 {
            (l[0], l[0])
        } else if l.length == 2 {
            (l[0], l[1])
        } else {
            let mid = l.length / 2
            let a = alloc(BhvNode)
            <<a = BhvNode::create(l[0..mid])
            let b = alloc(BhvNode)
            <<b = BhvNode::create(l[mid..l.length])
            (Hittable(<<a), Hittable(<<b))
        }

        let aabb = match (left.bounding_box(), right.bounding_box()) {
            (Some($a), Some($b)) -> AABB::surrounding_box(a, b)
            $_ -> {
                println("no bounding box in BhvNode constructor")
                AABB(default)
            }
        }

        return new{left, right, aabb}
    }
}

impl Hittable for BhvNode {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        if box.hit(r, t_min, t_max) {
            let hit_left = left.hit(r, t_min, t_max, random)
            let hit_right = right.hit(r, t_min, t_max, random)

            return match (hit_left, hit_right) {
                (None, None)                        -> None
                (Some($hit), None)                  -> Some(hit)
                (None, Some($hit))                  -> Some(hit)
                (Some($hit_left), Some($hit_right)) -> Some(if hit_left.t < hit_right.t then hit_left else hit_right)
            }
        }

        return None
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(box)
    }
}

//
struct XYRect {
    x0  : real
    x1  : real
    y0  : real
    y1  : real
    z   : real
    mat : Material
}

impl Hittable for XYRect {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        let t = (z - r.origin.z) / r.direction.z
        if t < t_min or t > t_max {
            return None
        }

        let x = r.origin.x + t * r.direction.x
        let y = r.origin.y + t * r.direction.y
        if x < x0 or x > x1 or y < y0 or y > y1 {
            return None
        }

        return Some(new HitRecord {
            t = t
            p = r.at(t)
            m = mat
            n = new vec3{0, 0, 1}
            u = (x - x0) / (x1 - x0)
            v = (y - y0) / (y1 - y0)
        })
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(AABB::create(new vec3{x0, y0, z - real(0.0001)}, new vec3{x1, y1, z + real(0.0001)}))
    }
}

struct YZRect {
    y0  : real
    y1  : real
    z0  : real
    z1  : real
    x   : real
    mat : Material
}

impl Hittable for YZRect {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        let t = (x - r.origin.x) / r.direction.x
        if t < t_min or t > t_max {
            return None
        }

        let y = r.origin.y + t * r.direction.y
        let z = r.origin.z + t * r.direction.z
        if y < y0 or y > y1 or z < z0 or z > z1 {
            return None
        }

        return Some(new HitRecord {
            t = t
            p = r.at(t)
            m = mat
            n = new vec3{1, 0, 0}
            u = (y - y0) / (y1 - y0)
            v = (z - z0) / (z1 - z0)
        })
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(AABB::create(new vec3{x - real(0.0001), y0, z0}, new vec3{x + real(0.0001), y1, z1}))
    }
}

struct ZXRect {
    x0  : real
    x1  : real
    z0  : real
    z1  : real
    y   : real
    mat : Material
}

impl Hittable for ZXRect {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        let t = (y - r.origin.y) / r.direction.y
        if t < t_min or t > t_max {
            return None
        }

        let z = r.origin.z + t * r.direction.z
        let x = r.origin.x + t * r.direction.x
        if z < z0 or z > z1 or x < x0 or x > x1 {
            return None
        }

        return Some(new HitRecord {
            t = t
            p = r.at(t)
            m = mat
            n = new vec3{0, 1, 0}
            u = (z - z0) / (z1 - z0)
            v = (x - x0) / (x1 - x0)
        })
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(AABB::create(new vec3{x0, y - real(0.0001), z0}, new vec3{x1, y + real(0.0001), z1}))
    }
}

//
struct FlipNormals {
    obj: Hittable
}

impl FlipNormals {
    fn create(h: Hittable) -> Hittable {
        return create_object(Hittable, new FlipNormals{h})
    }
}

impl Hittable for FlipNormals {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        return match obj.hit(r, t_min, t_max, random) {
            Some($hit) -> {
                hit.n *= real(-1.0)
                Some(hit)
            }

            None -> None
        }
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return obj.bounding_box()
    }
}

//
struct Box {
    pmin    : vec3
    pmax    : vec3
    faces   : Array[Hittable]
}

impl Box {
    fn create(p0: vec3, p1: vec3, mat: Material) -> Box {
        let arr = Array[Hittable]::create(6)
        create_faces(p0, p1, mat, arr)
        return new Box{p0, p1, arr}
    }

    fn create_faces(p0: vec3, p1: vec3, mat: Material, arr: ref Array[Hittable]) {
        arr.add(create_object(Hittable, new XYRect{p0.x, p1.x, p0.y, p1.y, p1.z, mat}))
        arr.add(FlipNormals::create(create_object(Hittable, new XYRect{p0.x, p1.x, p0.y, p1.y, p0.z, mat})))

        arr.add(create_object(Hittable, new ZXRect{p0.x, p1.x, p0.z, p1.z, p1.y, mat}))
        arr.add(FlipNormals::create(create_object(Hittable, new ZXRect{p0.x, p1.x, p0.z, p1.z, p0.y, mat})))

        arr.add(create_object(Hittable, new YZRect{p0.y, p1.y, p0.z, p1.z, p1.x, mat}))
        arr.add(FlipNormals::create(create_object(Hittable, new YZRect{p0.y, p1.y, p0.z, p1.z, p0.x, mat})))
    }
}

impl Hittable for Box {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        return faces.hit(r, t_min, t_max, random)
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return Some(AABB::create(pmin, pmax))
    }
}

// volumes
struct ConstantMedium {
    boundary    : Hittable
    density     : real
    phase_func  : Material
}

impl ConstantMedium {
    fn create(boundary: Hittable, density: real, tex: Texture) -> Hittable {
        return create_object(Hittable, new ConstantMedium{
            boundary, density, create_object(Material, new Isotropic{tex})
        })
    }
}

impl Hittable for ConstantMedium {
    fn hit(ref Self, r: ref Ray, t_min: real, t_max: real, random: ref Random) -> Option[HitRecord] {
        match boundary.hit(r, -10000.0, 10000.0, random) {
            Some($h1) -> match boundary.hit(r, h1.t + 0.0001, 10000.0, random) {
                Some($h2) -> {
                    if h1.t < t_min {
                        h1.t = t_min
                    }

                    if h2.t > t_max {
                        h2.t = t_max
                    }

                    if h1.t >= h2.t {
                        return None
                    }

                    let dist_in_boundary = h2.t - h1.t
                    let hit_distance = -(1.0 / density) * real(log(random.next_double()))
                    if hit_distance < dist_in_boundary {
                        let t = h1.t + hit_distance
                        let hit = new HitRecord{
                            t = t
                            p = r.at(t)
                            n = new{1, 0, 0}
                            m = phase_func
                        }

                        return Some(hit)
                    }
                }
            }
        }

        return None
    }

    fn bounding_box(ref Self) -> Option[AABB] {
        return boundary.bounding_box()
    }
}