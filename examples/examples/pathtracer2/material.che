#load("misc")

struct MaterialRecord {
    pub const att       : vec3
    pub const scattered : Ray
}

trait Material {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord) -> Option(MaterialRecord);
}

struct Lambertian {
    pub const albedo: vec3
}

impl Material for Lambertian {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord) -> Option(MaterialRecord) {
        let target = hit.p + hit.n + random_in_unit_sphere()
        let ray = Ray::from_to(hit.p, target)
        return Some(new MaterialRecord{albedo, ray})
    }
}

struct Metal {
    pub const albedo    : vec3
    pub const roughness : double = 0.0
}

impl Material for Metal {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord) -> Option(MaterialRecord) {
        let reflected = r.direction.reflect(hit.n) + random_in_unit_sphere() * roughness
        return if vec3::dot(reflected, hit.n) > 0 then
            Some(new MaterialRecord{albedo, Ray::from_dir(hit.p, reflected)})
        else
            None
    }
}

struct Dielectric {
    pub const ior: double
}

impl Material for Dielectric {
    fn schlick(cosine: double, ior: double) -> double {
        let r0 = {
            let r = (1.0 - ior) / (1.0 + ior)
            r * r
        }

        return r0 + (1.0 - r0) * pow(1.0 - cosine, 5)
    }

    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord) -> Option(MaterialRecord) {
        let dir_dot_n = vec3::dot(r.direction, hit.n)
        let (outward_normal, ni_over_nt, cosine) = if dir_dot_n > 0 then
            (-hit.n, self.ior, self.ior * dir_dot_n)
        else
            (hit.n, 1.0 / self.ior, -dir_dot_n)

        let att = new vec3{1.0, 1.0, 1.0}
        let reflected = r.direction.reflect(hit.n)
        return match r.direction.refract(outward_normal, ni_over_nt) {
            Some($refr) ->
                if random.next_double() > schlick(cosine, self.ior) then
                    Some(new MaterialRecord{att, Ray::from_dir(hit.p, refr)})
                else
                    Some(new MaterialRecord{att, Ray::from_dir(hit.p, reflected)})

            None -> Some(new MaterialRecord{att, Ray::from_dir(hit.p, reflected)})
        }
    }
}
