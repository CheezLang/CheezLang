#load("misc")
#load("texture")


struct MaterialRecord {
    pub const att       : vec3
    pub const scattered : Ray
}

enum Scatter {
    ColorReflection: MaterialRecord
    Reflection: Ray
    Color: vec3
    None
}

trait Material {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter;
}

//
struct Lambertian {
    pub const albedo: Texture
}

impl Material for Lambertian {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        let target = hit.p + hit.n + random.random_in_unit_sphere()
        let ray = Ray::from_to(hit.p, target)
        let color = albedo.value(0, 0, hit.p)
        return Scatter.ColorReflection(new MaterialRecord{color, ray})
    }
}

//
struct Emissive {
    pub const color: vec3
}

impl Material for Emissive {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        return Scatter.Color(color)
    }
}

//
struct Metal {
    pub const albedo    : vec3
    pub const roughness : real = 0.0
}

impl Material for Metal {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        let reflected = r.direction.reflect(hit.n) + random.random_in_unit_sphere() * roughness
        return if vec3::dot(reflected, hit.n) > 0 then
            Scatter.ColorReflection(new MaterialRecord{albedo, Ray::from_dir(hit.p, reflected)})
        else
            Scatter.None
    }
}

//
struct Dielectric {
    pub const ior: real
}

impl Material for Dielectric {
    fn schlick(cosine: real, ior: real) -> real {
        let r0 = {
            let r = (1.0 - ior) / (1.0 + ior)
            r * r
        }

        return r0 + (1.0 - r0) * real(pow(1.0 - cosine, 5))
    }

    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        let dir_dot_n = vec3::dot(r.direction, hit.n)
        let (outward_normal, ni_over_nt, cosine) = if dir_dot_n > 0 then
            (-hit.n, self.ior, self.ior * dir_dot_n)
        else
            (hit.n, 1.0 / self.ior, -dir_dot_n)

        let reflected = r.direction.reflect(hit.n)
        return match r.direction.refract(outward_normal, ni_over_nt) {
            Some($refr) ->
                if random.random_real() > schlick(cosine, self.ior) then
                    Scatter.Reflection(Ray::from_dir(hit.p, refr))
                else
                    Scatter.Reflection(Ray::from_dir(hit.p, reflected))

            None -> Scatter.Reflection(Ray::from_dir(hit.p, reflected))
        }
    }
}



//
struct CheckerMaterial {
    size: real
    off : vec3
    even: Material
    odd : Material
}

impl CheckerMaterial {
    fn create(size: real, off: vec3, even: Material, odd: Material) -> Material {
        return create_object(Material, new CheckerMaterial{size=size, off=off, even=even, odd=odd})
    }
}

impl Material for CheckerMaterial {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        let sines = real(sin(size * (hit.p.x + off.x)) * sin(size * (hit.p.y + off.y)) * sin(size * (hit.p.z + off.z)))
        return if sines >= 0 then even.scatter(r, hit, random) else odd.scatter(r, hit, random)
    }
}

// isotropic
struct Isotropic {
    albedo: Texture
}

impl Material for Isotropic {
    fn scatter(ref Self, r: ref Ray, hit: ref HitRecord, random: ref Random) -> Scatter {
        return Scatter.ColorReflection(new MaterialRecord{
            att         = albedo.value(hit.u, hit.v, hit.p)
            scattered   = Ray::from_dir(hit.p, random.random_in_unit_sphere())
        })
    }
}