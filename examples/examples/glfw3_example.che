use import std.mem.allocator
use import std.string
use import std.array
use import std.math
use import std.time
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c

use import glfw.glfw3
use import opengl.opengl
use import opengl.constants
use import opengl.types
use import opengl.functions


imgui :: import imgui.imgui_binding
// use import imgui.cimgui_binding
// use import imgui.cimgui_glfw_binding
// use import imgui.cimgui_opengl3_binding

#export_scope

vec2 :: Vector2[float]
vec3 :: Vector3[float]
vec4 :: Vector4[float]

for_extension_vec4 :: (vec: ref vec4, code: Code) #for {
    { #label _block_all
        { #label _block_x
            it_index := 0
            it := ref vec.x
            @insert(code, _continue={break _block_x}, _break={break _block_all})
        }
        { #label _block_y
            it_index := 1
            it := ref vec.y
            @insert(code, _continue={break _block_y}, _break={break _block_all})
        }
        { #label _block_z
            it_index := 2
            it := ref vec.z
            @insert(code, _continue={break _block_z}, _break={break _block_all})
        }
        { #label _block_w
            it_index := 3
            it := ref vec.w
            @insert(code, _continue={break _block_w}, _break={break _block_all})
        }
    }
}

gladLoadGL :: () -> i32;

onKeyDown :: (window: &GLFWwindow, key: i32, scancode: i32, action: i32, mods: i32) {
}

on_framebuffer_resize :: (window: &GLFWwindow, w: i32, h: i32) {
    glViewport(0, 0, w, h)

    width  = cast w
    height = cast h
}

glfw_error_callback :: (error: i32, description: c_string) {
    C.printf("Glfw Error %d: %s\n", error, description)
}

gl_check_errors :: () {
    loop {
        err := glGetError()
        if int(err) == int(GL_NO_ERROR) then break
        io.printfln("[OpenGL] Error: {}", err)
    }
}

igListBoxStringArray :: (label: c_string, current_index: &i32, arr: ref Array[String]) -> bool {
    array_string_getter :: (data: &void, idx: i32, out_text: &c_string) -> bool {
        arr := ref <<cast(&Array[String]) data
        if idx < 0 or int(idx) >= arr.get_length() {
            return false
        }

        <<out_text = arr.access(idx).as_cstring()

        return true
    }

    if arr.get_length() == 0 {
        return false
    }

    return imgui.ListBoxFnPtr(label, current_index, array_string_getter, cast &arr, cast arr.get_length())
}

width  := 0
height := 0

Main :: () {
    glfwSetErrorCallback(glfw_error_callback)

    if !glfwInit() {
        io.println("Failed to initialize GLFW")
        return
    }
    defer glfwTerminate()

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
    glfwWindowHint(GLFW_VISIBLE, 0)
    glfwWindowHint(GLFW_MAXIMIZED, 1)
    glfwWindowHint(GLFW_RESIZABLE, 1)

    vidmode := glfwGetVideoMode(glfwGetPrimaryMonitor())

    window := glfwCreateWindow(vidmode.width, vidmode.height, "Hello World", null, null)
    if window == null {
        io.println("Failed to create window")
        return
    }
    defer glfwDestroyWindow(window)

    glfwMakeContextCurrent(window)
    glfwSwapInterval(0)
    if gladLoadGL() != 1 {
        return
    }

    glfwShowWindow(window)

    {
        w := 0i32
        h := 0i32
        glfwGetFramebufferSize(window, &w, &h)
        width = cast w
        height = cast h
    }

    glfwSetKeyCallback(window, onKeyDown)
    glfwSetFramebufferSizeCallback(window, on_framebuffer_resize)

    // imgui setup
    if !init_imgui(window) {
        return
    }
    defer shutdown_imgui()

    // opengl
    clear_color := vec4(1, 0, 1, 1)

    strings := Array[String].create()
    strings.add(String.from_string("Hello"))
    strings.add(String.from_string("World"))
    strings_selected := 0i32

    show_demo_window := false

    buff := alloc_n(char8, 256)
    C.memset(buff.data, 0, cast buff.length)
    defer free_n(buff)

    last_frame_time := get_time_microseconds()

    frame_timer := 0.0
    fps_counter := 0
    current_fps := 0

    while !glfwWindowShouldClose(window) {
        this_frame_time     := get_time_microseconds()
        last_frame_duration := this_frame_time - last_frame_time
        last_frame_time = this_frame_time

        // convert time from microseconds to seconds
        delta_time := double(last_frame_duration) * 0.000001

        frame_timer += delta_time
        if frame_timer >= 1 {
            current_fps = fps_counter
            frame_timer -= 1
            fps_counter = 0

            // io.println(current_fps)
            // io.println(1 / delta_time)
            // io.println(delta_time)
            // io.println("---")
        }


        glfwPollEvents()
        glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w)
        glClear(GL_COLOR_BUFFER_BIT)

        //
        begin_frame()

        {
            open := true

            pos   := imgui.ImVec2(0, 0)
            pivot := imgui.ImVec2(0, 0)
            imgui.SetNextWindowPos(pos, imgui.ImGuiCond_.Always, pivot)

            size_min := imgui.ImVec2(50, cast height)
            size_max := imgui.ImVec2(500, cast height)
            imgui.SetNextWindowSizeConstraints(size_min, size_max)
            imgui.Begin("Settings", &open, @bin_or(
                imgui.ImGuiWindowFlags_.NoMove,
                imgui.ImGuiWindowFlags_.NoCollapse,
                imgui.ImGuiWindowFlags_.NoFocusOnAppearing,
                imgui.ImGuiWindowFlags_.NoBringToFrontOnFocus))


            {
                delta_time_str := fmt.format_any(delta_time)
                imgui.LabelText("Frame duration", delta_time_str.as_cstring())
                fps_str := fmt.format_any(1 / delta_time)
                imgui.LabelText("Fps", fps_str.as_cstring())
                fps_counted_str := fmt.format_any(current_fps)
                imgui.LabelText("Fps", fps_counted_str.as_cstring())
            }

            imgui.ColorPicker3("clear color", cast(&float)&clear_color, 0)
            imgui.Separator()
            
            for component : clear_color {
                imgui.PushIDInt(i32(it_index))
                imgui.InputFloat("##", &component)
                imgui.PopID()
            }

            imgui.Separator()
            imgui.InputText("String to add", buff.data, cast buff.length)
            if imgui.SmallButton("Add String") {
                strings.add(String.from_cstring(buff.data))
                buff[0] = cast 0
            }
            imgui.Separator()

            igListBoxStringArray("strings", &strings_selected, strings)
            imgui.End()
        }

        if show_demo_window then
            imgui.ShowDemoWindow(&show_demo_window)

        end_frame()

        // present image
        glfwSwapBuffers(window)

        fps_counter += 1
    }
}

begin_frame :: () {
    imgui.ImGui_ImplOpenGL3_NewFrame()
    imgui.ImGui_ImplGlfw_NewFrame()
    imgui.NewFrame()
}

end_frame :: () {
    io := imgui.GetIO()

    // rendering
    imgui.EndFrame()
    imgui.Render()
    imgui.ImGui_ImplOpenGL3_RenderDrawData(imgui.GetDrawData())
}

init_imgui :: (window: &GLFWwindow) -> bool {
    context := imgui.CreateContext(null)

    if context == null {
        io.println("[ERROR] imgui.CreateContext failed")
        return false
    }

    imgui.StyleColorsDark(null)

    // change corners so they are right angles instead of rounded
    style := ref imgui.GetStyle()	
    style.WindowRounding = 0.0	

    //
    if !imgui.ImGui_ImplGlfw_InitForOpenGL(window, true) {
        io.println("[ERROR] imgui.ImGui_ImplGlfw_InitForOpenGL failed")
        return false
    }
    if !imgui.ImGui_ImplOpenGL3_Init("#version 130") {
        io.println("[ERROR] imgui.ImGui_ImplOpenGL3_Init failed")
        return false
    }

    return true
}

shutdown_imgui :: () {
    imgui.ImGui_ImplOpenGL3_Shutdown()
    imgui.ImGui_ImplGlfw_Shutdown()
    imgui.DestroyContext(null)
}