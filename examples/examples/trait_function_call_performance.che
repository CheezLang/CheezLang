#load("std:io/io")
#load("std:util")


trait TestTrait {
    fn traitFunction(n: u64);
}

struct Test {
    counter: u64

    // not used, just so that passing by value will be slow
    // comment out to see performance of pass by value with small structs
    a0: i32
    a1: i32
    a2: i32
    a3: i32
    a4: i32
    a5: i32
    a6: i32
    a7: i32
    a8: i32
    a9: i32
}

impl Test {
    fn normalFunction(n: u64) {
        counter += n
    }

    ref fn refFunction(n: u64) {
        counter += n
    }
}

impl TestTrait for Test {
    fn traitFunction(n: u64) {
        counter += n
    }
}

fn trait_function_call_performance() {
    let iterations = 100000000
    let n = 8


    print_f("iterations: {}, n: {}`n", [iterations, n])

    let t: Test
    let tt: TestTrait = t

    // call normalFunction() on Test
    // t is implicitly passed by value
    {
        t.counter = 0

        let start = getCurrentTimeInMicroseconds()
        defer {
            let end = getCurrentTimeInMicroseconds()
            let diff = end - start
            let ms = diff / 1000

            print_f("counter: {}`n", [t.counter])
            print_f("[{}] Time elapsed: {} ms ({} iterations)`n", ["t.normalFunction()", ms, iterations])
        }   

        while let i = 0; i < iterations; i += 1 {
            t.normalFunction(cast(u64)n)
        }
    }

    // call refFunction() on Test
    // t is implicitly passed as a pointer 
    {
        t.counter = 0

        let start = getCurrentTimeInMicroseconds()
        defer {
            let end = getCurrentTimeInMicroseconds()
            let diff = end - start
            let ms = diff / 1000

            print_f("counter: {}`n", [t.counter])
            print_f("[{}] Time elapsed: {} ms ({} iterations)`n", ["t.refFunction()", ms, iterations])
        }   

        while let i = 0; i < iterations; i += 1 {
            t.refFunction(cast(u64)n)
        }
    }

    // call traitFunction() on Test
    // t is implicitly converted to a trait object (vtable pointer + pointer to object)
    // and passed to the function
    {
        t.counter = 0
        
        let start = getCurrentTimeInMicroseconds()
        defer {
            let end = getCurrentTimeInMicroseconds()
            let diff = end - start
            let ms = diff / 1000

            print_f("counter: {}`n", [t.counter])
            print_f("[{}] Time elapsed: {} ms ({} iterations)`n", ["t.traitFunction()", ms, iterations])
        }   

        while let i = 0; i < iterations; i += 1 {
            t.traitFunction(cast(u64)n)
        }
    }

    // call traitFunction() on TestTrait
    // tt is implicitly  passed to the function
    // tt is already a trait object, so no implicit casting for every call
    {
        t.counter = 0
        
        let start = getCurrentTimeInMicroseconds()
        defer {
            let end = getCurrentTimeInMicroseconds()
            let diff = end - start
            let ms = diff / 1000

            print_f("counter: {}`n", [t.counter])
            print_f("[{}] Time elapsed: {} ms ({} iterations)`n", ["tt.traitFunction()", ms, iterations])
        }   

        while let i = 0; i < iterations; i += 1 {
            tt.traitFunction(cast(u64)n)
        }
    }
}
