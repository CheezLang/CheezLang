#load("std:io/io")
#load("std:math")
#load("std:array")
#load("std:mem/stack_allocator")
#load("std:random")
#load("bmp:bmp")

typedef Vec3 = Vector3(double)

///////////////////////////////////////////////////////////
fn xor(a: bool, b: bool) -> bool {
    return (a and !b) or (!a and b)
}

fn mod(a: $T, b: T) -> T {
    return ((a % b) + b) % b
}

///////////////////////////////////////////////////////////

struct Ray {
    pub origin: Vec3
    pub direction: Vec3
}

typedef DistanceShaderPair = (distance: double, shader: Shader)

////////////////////////////////// SDF //////////////////////////////////////////////

///////////////////// basic ///////////////////
trait SDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair;
}

struct Sphere {
    pub radius: double
    pub shader: Shader
}

impl SDF for Sphere {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        return (v.mag() - radius, shader)
    }
}

struct PlaneY {
    pub location: double
    pub shader: Shader
}

impl SDF for PlaneY {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        return (v.y - location, shader)
    }
}

struct Cube {
    pub radius: double
    pub shader: Shader
}

impl SDF for Cube {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let dx = fabs(v.x) - radius
        let dy = fabs(v.y) - radius
        let dz = fabs(v.z) - radius

        let d: double = 0

        if dx > 0 and dy > 0 and dz > 0 { // corner
            let r = new Vec3 {
                dx, dy, dz
            }
            d = r.mag()
        }
        else if dx > 0 and dy > 0 {
            let r = new Vec3 {
                x = dx
                y = dy
                z = 0
            }
            d = r.mag()
        }
        else if dx > 0 and dz > 0 {
            let r = new Vec3 {
                x = dx
                y = 0
                z = dz
            }
            d = r.mag()
        }
        else if dy > 0 and dz > 0 {
            let r = new Vec3 {
                x = 0
                y = dy
                z = dz
            }
            d = r.mag()
        }
        else {
            d = fmax(dx, fmax(dy, dz))
        }

        return (d, shader)
    }
}

///////////////////// transformations //////////////////////////

struct TranslatedSDF {
    pub sdf: SDF
    pub translation: Vec3
}

impl SDF for TranslatedSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        return sdf.distance(v - translation)
    }
}

struct ScaledSDF {
    pub sdf: SDF
    pub scale: Vec3
}

impl SDF for ScaledSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        return sdf.distance(v / scale)
    }
}

struct RotatedXSDF {
    pub sdf: SDF
    pub angle: double
}

struct RotatedYSDF {
    pub sdf: SDF
    pub angle: double
}

struct RotatedZSDF {
    pub sdf: SDF
    pub angle: double
}

impl SDF for RotatedXSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let rad = angle / 360 * 2 * 3.1415
        let c = cos(rad)
        let s = sin(rad)
        let y = c * v.y - s * v.z
        let z = s * v.y + c * v.z
        return sdf.distance(new Vec3{v.x, y, z})
    }
}

impl SDF for RotatedYSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let rad = angle / 360 * 2 * 3.1415
        let c = cos(rad)
        let s = sin(rad)
        let x = c * v.x + s * v.z
        let z = -s * v.x + c * v.z
        return sdf.distance(new Vec3{x, v.y, z})
    }
}

impl SDF for RotatedZSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let rad = angle / 360 * 2 * 3.1415
        let c = cos(rad)
        let s = sin(rad)
        let x = c * v.x - s * v.y
        let y = s * v.x + c * v.y
        return sdf.distance(new Vec3{x, y, v.z})
    }
}

////////////////////// combinations ///////////////////////
struct UnionSDF {
    pub sdf1: SDF
    pub sdf2: SDF
}

impl SDF for UnionSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)
        if a.distance < b.distance {
            return a
        } else {
            return b
        }
    }
}

struct IntersectionSDF {
    pub sdf1: SDF
    pub sdf2: SDF
}

impl SDF for IntersectionSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)
        if a.distance > b.distance {
            return a
        } else {
            return b
        }
    }
}

struct SubtractionSDF {
    pub sdf1: SDF
    pub sdf2: SDF
}

impl SDF for SubtractionSDF {
    fn distance(ref Self, v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)

        b.distance = -b.distance
        if a.distance > b.distance {
            return a
        } else {
            return b
        }
    }
}

////////////////////////////// shaders //////////////////////////////////

trait Shader {
    fn shade(ref Self, ray: Ray, raymarcher: ref Raymarcher) -> Vec3;
}

struct ConstantColorShader {
    color: Vec3
}

impl Shader for ConstantColorShader {
    fn shade(ref Self, ray: Ray, raymarcher: ref Raymarcher) -> Vec3 {
        return color
    }
}

//////
struct LambertianShader {
    color: Vec3
}

impl Shader for LambertianShader {
    fn shade(ref Self, ray: Ray, raymarcher: ref Raymarcher) -> Vec3 {
        let (ld, lc) = raymarcher.sampleLightDirection()
        let normal = raymarcher.normal(ray.origin)

        let i = Vec3::dot(normal, ld)
        let c = color * lc

        let sdfHit = ray.origin + ld * 0.001
        let shadowRay = new Ray{sdfHit, ld}
        let distance = raymarcher.sdf.distance(shadowRay.origin).distance

        while shadowRay.origin.mag() < raymarcher.backgroundDistance and fabs(distance) > 0.00005 {
            shadowRay.origin = shadowRay.origin + shadowRay.direction * distance
            distance = raymarcher.sdf.distance(shadowRay.origin).distance
        }

        let shadow: double = 1.0
        if shadowRay.origin.mag() < raymarcher.backgroundDistance {
            shadow = 0.3
        }

        c *= fmax(i, 0.1)
        return c * shadow
    }
}

struct CheckerBoardShader {
    size: double
    shader1: Shader
    shader2: Shader
}


impl Shader for CheckerBoardShader {
    fn shade(ref Self, ray: Ray, raymarcher: ref Raymarcher) -> Vec3 {
        let x = mod(ray.origin.x, 2 * size)
        let y = mod(ray.origin.y, 2 * size)
        let z = mod(ray.origin.z, 2 * size)

        if xor(x < size, xor(y < size, z < size)) {
            return shader1.shade(ray, raymarcher)
        } else {
            return shader2.shade(ray, raymarcher)
        }
    }
}

///////////////////////////// scene //////////////////////////////
struct Background {

}

impl Background {
    fn project(Self, ray: Ray) -> Vec3 {
        let i = ray.direction.y + 0.5
        i *= i
        return new Vec3 { i, i, i }
    }
}

struct Raymarcher {
    pub sdf: SDF
    pub background: Background
    pub backgroundDistance: double = 1000
}

impl Raymarcher {
    fn project(ref Self, ray: Ray) -> Vec3 {
        let ds = sdf.distance(ray.origin)

        while fabs(ds.distance) > 0.0000001 {
            ray.origin = ray.origin + ray.direction * ds.distance
            ds = sdf.distance(ray.origin)


            if ray.origin.mag() >= backgroundDistance {
                return background.project(ray)
            }
        }

        return ds.shader.shade(ray, self)
    }

    fn sampleLightDirection(ref Self) -> (ld: Vec3, lc: Vec3) {
        ld = new Vec3 { -1.0, 1.5, 1 }
        ld.normalize()
        lc = new Vec3 {1, 1, 1}
    }

    fn normal(ref Self, p: Vec3) -> Vec3 {
        let off: double = 0.001

        let n = new Vec3 {
            x = sdf.distance(new Vec3{p.x + off, p.y, p.z}).distance - sdf.distance(new Vec3{p.x - off, p.y, p.z}).distance
            y = sdf.distance(new Vec3{p.x, p.y + off, p.z}).distance - sdf.distance(new Vec3{p.x, p.y - off, p.z}).distance
            z = sdf.distance(new Vec3{p.x, p.y, p.z + off}).distance - sdf.distance(new Vec3{p.x, p.y, p.z - off}).distance
        }
        return n.normalized()
    }
}


/////////////////////////////////////////////////


struct PerspectiveCamera {
    focalLength: double
    sensorWidth: double
    sensorHeight: double
}

impl PerspectiveCamera {
    fn project(ref Self, x: double, y: double) -> Ray {
        let dir = new Vec3 {
            x = (x - 0.5) * sensorWidth
            y = -(y - 0.5) * sensorHeight
            z = -focalLength
        }
        return new Ray {
            origin = new Vec3 {0, 0, 0}
            direction = dir.normalized()
        }
    }
}

struct Film {
    pub width: int
    pub height: int
    pub pixels: []Vec3

    pub antiAliasingSteps: int
}

impl Film {
    fn trigger(ref Self, camera: ref PerspectiveCamera, scene: ref Raymarcher) {

        printf("({}, {})`n", [width, height])

        let fw = 1 / cast(double) width
        let fh = 1 / cast(double) height

        printf("Rendering image with {} anti-aliasing step(s)`n", [antiAliasingSteps])
        if antiAliasingSteps < 1 {
            antiAliasingSteps = 1
        }
        

        let r = new LinearCongruentialGenerator {
            cast get_time_microseconds()
        }

        while let y = 0, y < height, y += 1 {
            if antiAliasingSteps >= 0 {
                let row = y + 1
                printf("Rendering row {}/{}`n", [row, height])
            }

            while let x = 0, x < width, x += 1 {

                let fx = cast(double) x
                let fy = cast(double) y

                let color = new Vec3{0, 0, 0}

                if antiAliasingSteps == 1 {
                    let ray = camera.project((fx + 0.5) * fw, (fy + 0.5) * fh)
                    color= scene.project(ray)
                }
                else {
                    while let i = 0, i < antiAliasingSteps, i += 1 {
                        let ray = camera.project((fx + r.next_double()) * fw, (fy + r.next_double()) * fh)
                        let c = scene.project(ray)
                        color += c
                    }
                    color = color * (1 / cast(double) antiAliasingSteps)
                }

                pixels[x + y * width] = color
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////

struct SDFAllocator {
    allocator: StackAllocator
}

impl SDFAllocator {
    fn create() -> Self {
        return new {
            StackAllocator::create(1024 * 2)
        }
    }

    fn allocate(ref Self, $T: type) -> &T {
        let t = cast(&T) allocator.allocate(1, @sizeof(T), @alignof(T))
        // printf("{}`n", [allocator])
        return t
    }

    fn sphere(ref Self, radius: double, shader: Shader) -> SDF {
        let s = alloc(Sphere, allocator)
        s.radius = radius
        s.shader = shader
        return cast(SDF) ref <<s
    }

    fn sphereT(ref Self, position: Vec3, radius: double, shader: Shader) -> SDF {
        return self.translate(self.sphere(radius, shader), position)
    }

    fn planeY(ref Self, location: double, shader: Shader) -> SDF {
        let s = alloc(PlaneY, allocator)
        s.location = location
        s.shader = shader
        return cast(SDF) ref <<s
    }

    fn cube(ref Self, radius: double, shader: Shader) -> SDF {
        let s = alloc(Cube, allocator)
        s.radius = radius
        s.shader = shader
        return cast(SDF) ref <<s
    }

    fn cubeT(ref Self, position: Vec3, radius: double, shader: Shader) -> SDF {
        return self.translate(self.cube(radius, shader), position)
    }

    fn translate(ref Self, sdf: SDF, translation: Vec3) -> SDF {
        let t = alloc(TranslatedSDF, allocator)
        t.sdf = sdf
        t.translation = translation
        return cast(SDF) ref <<t
    }

    fn rotateX(ref Self, sdf: SDF, angle: double) -> SDF {
        let t = alloc(RotatedXSDF, allocator)
        t.sdf = sdf
        t.angle = angle
        return cast(SDF) ref <<t
    }

    fn rotateY(ref Self, sdf: SDF, angle: double) -> SDF {
        let t = alloc(RotatedYSDF, allocator)
        t.sdf = sdf
        t.angle = angle
        return cast(SDF) ref <<t
    }

    fn rotateZ(ref Self, sdf: SDF, angle: double) -> SDF {
        let t = alloc(RotatedZSDF, allocator)
        t.sdf = sdf
        t.angle = angle
        return cast(SDF) ref <<t
    }

    fn scale(ref Self, sdf: SDF, x: double = 1, y: double = 1, z: double = 1) -> SDF {
        let t = alloc(ScaledSDF, allocator)
        t.sdf = sdf
        t.scale = new {x, y, z}
        return cast(SDF) ref <<t
    }

    fn add(ref Self, sdf1: SDF, sdf2: SDF) -> SDF {
        let t = alloc(UnionSDF, allocator)
        t.sdf1 = sdf1
        t.sdf2 = sdf2
        return cast(SDF) ref <<t
    }

    fn intersect(ref Self, sdf1: SDF, sdf2: SDF) -> SDF {
        let t = alloc(IntersectionSDF, allocator)
        t.sdf1 = sdf1
        t.sdf2 = sdf2
        return cast(SDF) ref <<t
    }

    fn subtract(ref Self, sdf1: SDF, sdf2: SDF) -> SDF {
        let t = alloc(SubtractionSDF, allocator)
        t.sdf1 = sdf1
        t.sdf2 = sdf2
        return cast(SDF) ref <<t
    }
}

fn renderImage(film: ref Film)
{
    while let i = 0, i < film.pixels.length, i += 1 {
        film.pixels[i] = new Vec3 { 0, 0, 0 }
    }

    let as = (cast(double) film.width) / (cast(double) film.height)
    let camera = new PerspectiveCamera {
        focalLength = 50
        sensorWidth = as * 24
        sensorHeight = 24
    }

    let bg = new Background{}

    let all = SDFAllocator::create()

    //
    let sChecker1    = new LambertianShader{new Vec3{0.9, 0.8, 0.8}}
    let sChecker2    = new LambertianShader{new Vec3{0.2, 0.1, 0.1}}
    let sChecker  = new CheckerBoardShader{1, sChecker1, sChecker2}

    let sWhite    = new LambertianShader{new Vec3{1, 1, 1}}
    let sBlack    = new LambertianShader{new Vec3{0, 0, 0}}
    let sRed    = new LambertianShader{new Vec3{1, 0, 0}}
    let sGreen  = new LambertianShader{new Vec3{1, 1, 0}}
    let sBlue   = new LambertianShader{new Vec3{0, 0, 1}}

    //
    let ground = all.planeY(-1.25, sWhite)
    let s1 = all.sphereT(new Vec3{0, 0.5, 0}, 1, sRed)
    let s2 = all.sphereT(new Vec3{0, 0, 0}, 0.3, sGreen)
    let c1 = all.cubeT(new Vec3{0, 0.5, 0}, 0.8, sBlue)

    let sdf = {
        let sdf = {
            let sdf: SDF
            {
                sdf = c1
                sdf = all.subtract(sdf, s1)
                sdf = all.add(sdf, s2)

                sdf = all.rotateX(sdf, -20.0)
                sdf = all.rotateY(sdf, 20)
            }
            
            // cube
            // {
            //     sdf = s1
            //     sdf = all.subtract(sdf, all.sphereT(new Vec3{-1, 0, 1}, 1.2, sWhite))
            // }

            all.add(sdf, ground)
        }
        sdf
    }
    
    let finalSDF = all.translate(sdf, new Vec3{0, 0, -7.5})

    let raymarcher = new Raymarcher {
        sdf = finalSDF
        background = bg
        backgroundDistance = 15
    }

    film.trigger(camera, raymarcher)
}

fn Main()
{
    //
    let scale: int = 2
    let width: int = 192 * scale
    let height: int = 128 * scale
    let antiAliasingSteps: int = 1

    let imageArr = Array(Vec3)::create()

    imageArr.resize(width * height)

    let film = new Film { width, height, imageArr.slice(), antiAliasingSteps }

    let start = get_time_milliseconds()
    renderImage(film)
    let end = get_time_milliseconds()
    let dur = (cast(double) end - start) / 1000.0

    printf("Rendering took {} seconds`n", [dur])

    // store image as bmp
    write_bmp(cast(i32) width, cast(i32) height, cast(&double) imageArr.get_raw(), "sdfr.bmp")
}
