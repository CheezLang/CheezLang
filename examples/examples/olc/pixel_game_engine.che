#load("pixel.che")
#load("key.che")
#load("sprite.che")
#load("olc_win.che")

#load("std:hash_table")

trait Game {

}

enum OptionPGE {
    Some: &PixelGameEngine
    None
}

struct PixelGameEngine {
    game                : Game


    default_draw_target : &Sprite   = null
    draw_target         : &Sprite   = null

    // windows specific
    olc_hWnd            : HWND      = null

    // other stuff
    nMousePosXcache     : int
    nMousePosYcache     : int
    nMouseWheelDeltaCache : int

    window_width        : int       = -1
    window_height       : int       = -1
    screen_width        : int
    screen_height       : int
    pixel_width         : int
    pixel_height        : int
    pixel_x             : float     = 1.0f
    pixel_y             : float     = 1.0f

    bHasMouseFocus      : bool      = false
    bHasInputFocus      : bool      = false

    pKeyNewState        : [256]bool
    pKeyOldState        : [256]bool
    pKeyboardState      : [256]HWButton

    pMouseState         : [5]HWButton
    pMouseOldState      : [5]bool
    pMouseNewState      : [5]bool

    mapKeys             : Table(int, Key)
}

fn compare_ints(a: int, b: int) -> bool {
    return b == a
}


impl PixelGameEngine {
    fn create(game: Game, screen_w: int, screen_h: int, pixel_w: int = 1, pixel_h: int = 1) -> OptionPGE {
        if screen_w <= 0 or screen_h <= 0 or pixel_w <= 0 or pixel_h <= 0 {
            return OptionPGE.None
        }

        let pge = alloc(PixelGameEngine)

        <<pge = new PixelGameEngine {
            game = game
            screen_width = screen_w
            screen_height = screen_h
            pixel_width = pixel_w
            pixel_height = pixel_h
            pixel_x = 2.0f / cast(float) screen_w
            pixel_y = 2.0f / cast(float) screen_h
            mapKeys = Table(int, Key)::create(compare_ints)
        }

        pge.default_draw_target = alloc(Sprite)
        <<pge.default_draw_target = Sprite::create(screen_w, screen_h)
        pge.set_draw_target(null)

        return OptionPGE.Some(pge)
    }

    fn dispose(ref Self) {
        default_draw_target.dispose()
        free(default_draw_target)
        default_draw_target = null

        mapKeys.dispose()
    }

    fn start(ref Self) {
        // pixel_game_engine_ptr = &self

        let wnd = self.olc_window_create()
        if wnd == null {
            return
        }

        let msg: MSG
        while GetMessageA(&msg, null, 0, 0) > 0 {
            TranslateMessage(&msg)
            DispatchMessageA(&msg)
        }
    }

    fn set_draw_target(ref Self, target: &Sprite) {
        draw_target = if target == null { default_draw_target } else { target }
    }

    //
    fn olc_update_window_size(ref Self, x: int, y: int) {
        window_width = x
        window_height = y
    }
    
    fn olc_update_mouse_wheel(ref Self, delta: int) {
        nMouseWheelDeltaCache += delta
    }
    
    fn olc_update_mouse(ref Self, x: int, y: int) {
        nMousePosXcache = cast(int) (cast(float)x) / (cast(float) window_width) * (cast(float)screen_width)
        nMousePosYcache = cast(int) (cast(float)y) / (cast(float) window_height) * (cast(float)screen_height)

        if nMousePosXcache >= screen_width { nMousePosXcache = screen_width - 1 }
        if nMousePosYcache >= screen_height { nMousePosYcache = screen_height - 1 }

        if nMousePosXcache < 0 { nMousePosXcache = 0 }
        if nMousePosYcache < 0 { nMousePosYcache = 0 }
    }

    // hardware interfaces
    fn is_focused(ref Self) -> bool {
        return false
    }

    fn get_key(ref Self, key: Key) -> HWButton {
        return (false, false, false)
    }

    fn get_mouse(ref Self, b: int) -> HWButton {
        return (false, false, false)
    }

    fn get_mouse_pos(ref Self) -> (x: int, y: int) {
        return (0, 0)
    }

    fn get_mouse_wheel(ref Self) -> int {
        return 0
    }
}
