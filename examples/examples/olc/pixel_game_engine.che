#load("pixel.che")
#load("key.che")
#load("sprite.che")
#load("olc_win.che")

trait Game {

}

enum OptionPGE {
    Some: PixelGameEngine
    None
}

struct PixelGameEngine {
    game: Game


    default_draw_target: &Sprite = null
    draw_target: &Sprite = null

    // windows specific
    olc_hWnd: HWND = null

    // other stuff
    nMousePosXcache: int
    nMousePosYcache: int
    window_width: int = -1
    window_height: int = -1
    screen_width: int
    screen_height: int
    pixel_width: int
    pixel_height: int
    pixel_x: float = 1.0f
    pixel_y: float = 1.0f
}

impl PixelGameEngine {
    fn create(game: Game, screen_w: int, screen_h: int, pixel_w: int = 1, pixel_h: int = 1) -> OptionPGE {
        if screen_w <= 0 or screen_h <= 0 or pixel_w <= 0 or pixel_h <= 0 {
            return OptionPGE.None
        }

        let pge = new PixelGameEngine {
            game = game
            screen_width = screen_w
            screen_height = screen_h
            pixel_width = pixel_w
            pixel_height = pixel_h
            pixel_x = 2.0f / cast(float) screen_w
            pixel_y = 2.0f / cast(float) screen_h
        }

        pge.default_draw_target = alloc(Sprite)
        <<pge.default_draw_target = Sprite::create(screen_w, screen_h)
        pge.set_draw_target(null)

        return OptionPGE.Some(pge)
    }

    fn dispose(ref Self) {
        default_draw_target.dispose()
        free(default_draw_target)
        default_draw_target = null
    }

    fn start(ref Self) {
        pixel_game_engine_ptr = &self

        let wnd = self.olc_window_create()
        if wnd == null {
            return
        }
        println("window created")

        let msg: MSG
        while GetMessageA(&msg, null, 0, 0) > 0 {
            TranslateMessage(&msg)
            DispatchMessageA(&msg)
        }

        println("done")
    }

    fn set_draw_target(ref Self, target: &Sprite) {
        draw_target = if target == null { default_draw_target } else { target }
    }

    //
    fn olc_update_window_size(ref Self, x: int, y: int) {
        window_width = x
        window_height = y
    }
    
    fn olc_update_mouse(ref Self, x: int, y: int) {
        nMousePosXcache = cast(int) (cast(float)x) / (cast(float) window_width) * (cast(float)screen_width)
        nMousePosYcache = cast(int) (cast(float)y) / (cast(float) window_height) * (cast(float)screen_height)

        if nMousePosXcache >= screen_width { nMousePosXcache = screen_width - 1 }
        if nMousePosYcache >= screen_height { nMousePosYcache = screen_height - 1 }

        if nMousePosXcache < 0 { nMousePosXcache = 0 }
        if nMousePosYcache < 0 { nMousePosYcache = 0 }
    }

    // hardware interfaces
    fn is_focused(ref Self) -> bool {
        return false
    }

    fn get_key(ref Self, key: Key) -> HWButton {
        return (false, false, false)
    }

    fn get_mouse(ref Self, b: int) -> HWButton {
        return (false, false, false)
    }

    fn get_mouse_pos(ref Self) -> (x: int, y: int) {
        return (0, 0)
    }

    fn get_mouse_wheel(ref Self) -> int {
        return 0
    }
}
