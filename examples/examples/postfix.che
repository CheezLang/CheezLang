#load("compiler/lexer")

#load("std:stack")

impl TokenType {
    fn get_precedence(Self) -> int {
        use TokenType
        return match self {
            Plus        -> 5
            Minus       -> 5
            Asterisk    -> 10
            ForwardSlash -> 10
            OpenParen   -> 2

            $_          -> {
                @panic("called with non operator")
                -1
            }
        }
    }
}

impl Token {
    fn get_text(ref Self) -> String {
        use TokenType
        return match self.ttype {
            Plus        -> String.from_string("+")
            Minus       -> String.from_string("-")
            Asterisk    -> String.from_string("*")
            ForwardSlash -> String.from_string("/")

            NumberLiteral -> {
                match data {
                    TokenData.Integer($val) -> String.format("{}", [val])
                    TokenData.Double($val) -> String.format("{}", [val])
                    $_ -> {
                        @panic("TokenData was neither Integer nor Double")
                        String.empty()
                    }
                }
            }

            $_          -> String.from_string("?")
        }
    }
}

fn pop_ops_while(new_order: ref Array(Token), stack: ref Stack(Token), precedence: int = -1) {
    while !stack.empty() and stack.peek().ttype.get_precedence() >= precedence {
        new_order.add(stack.pop())
    }
}

fn infix_to_postfix(str: String, calculate: bool) -> (postfix: String, result: double) {
    string_db := StringDatabase.create()
    lexer := Lexer.from_string(str, string_db)

    stack := Stack[Token].create()
    new_order := Array[Token].create()

    while true {
        token := lexer.next_token()

        use TokenType
        match token.ttype {
            NumberLiteral -> {
                new_order.add(token)
            }

            Plus -> {
                pop_ops_while(new_order, stack, token.ttype.get_precedence())
                stack.push(token)
            }

            Minus -> {
                pop_ops_while(new_order, stack, token.ttype.get_precedence())
                stack.push(token)
            }

            Asterisk -> {
                pop_ops_while(new_order, stack, token.ttype.get_precedence())
                stack.push(token)
            }

            ForwardSlash -> {
                pop_ops_while(new_order, stack, token.ttype.get_precedence())
                stack.push(token)
            }

            OpenParen -> {
                stack.push(token)
            }

            ClosingParen -> {
                while !stack.empty() and int(stack.peek().ttype) != int(OpenParen) {
                    new_order.add(stack.pop())
                }
                stack.pop()
            }

            EOF -> { 
                break
            }
        }
    }
    pop_ops_while(new_order, stack)

    postfix = String.empty()
    for i : 0..new_order.length {
        tok := new_order[i]
        txt := tok.get_text()
        postfix.appendf("{} ", txt)
        txt.dispose()
    }

    result = 0

    if calculate {
        numbers := Stack[double].create()
        //foreach! t in new_order.iterator() {
        for t : new_order {
            use TokenType
            match t.ttype {
                NumberLiteral -> {
                    use TokenData
                    match t.data {
                        Integer($val) -> numbers.push(double(val))
                        Double($val) -> numbers.push(val)
                        $_ -> @panic("not a number")
                    }
                }

                Plus -> {
                    b := numbers.pop()
                    a := numbers.pop()
                    numbers.push(a + b)
                }

                Minus -> {
                    b := numbers.pop()
                    a := numbers.pop()
                    numbers.push(a - b)
                }

                Asterisk -> {
                    b := numbers.pop()
                    a := numbers.pop()
                    numbers.push(a * b)
                }

                ForwardSlash -> {
                    b := numbers.pop()
                    a := numbers.pop()
                    numbers.push(a / b)
                }
            }
        }

        result = numbers.peek()

        numbers.dispose()
    }

    new_order.dispose()
    stack.dispose()
    lexer.dispose()
    string_db.dispose()
}

impl Printable for &u16 {
    fn print(ref Self, str: ref String, format: string) {
        while i := 0; self[i] != 0; i += 1 {
            str += char(self[i])
        }
    }
}

fn to_ascii_strings(argv: &&u16, argc: int) -> Array[String] {
    array := Array[String].create(argc)
    for i : 0..argc {
        str := String.empty()
        while k := 0; argv[i][k] != 0; k += 1 {
            str += char(argv[i][k])
        }

        array.add(str)
    }
    return array
}

fn get_cmd_args() -> Array(String) {
    cmdLineArgs := GetCommandLineW()
    count := 0i32
    args := CommandLineToArgvW(cmdLineArgs, &count)
    return to_ascii_strings(args, int(count))
}

fn Main() {
    args := get_cmd_args()

    let (start_index, calculate) = if streq(args[1], "-e") { (2, true) } else { (1, false) }

    for infix : args {
        if it_index < start_index then continue
        print(infix)
        let (postfix, result) = infix_to_postfix(infix, calculate)
        printf(" -> {}", postfix)
        if calculate {
            printfln(" = {}", result)
        } else {
            println("")
        }

        postfix.dispose()
    }

    // printfln("argc: {:x}, argv: {}", (int(args), count))


    // println(infix_to_postfix(String.from_string("1 + 2 * 3"))
    // println(infix_to_postfix(String.from_string("(1 + 2) * 3"))
    // println(infix_to_postfix(String.from_string("1 * (2 + 3)"))
    // println(infix_to_postfix(String.from_string("1 * 2 + 3"))
}