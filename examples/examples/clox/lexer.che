enum TokenKind {
    // Single-character tokens.
    LeftParen, RightParen,
    LeftBrace, RightBrace,
    Comma, Dot, Minus, Plus,
    Semicolon, Slash, Star,

    // One or two character tokens.
    Bang, BangEqual,
    Equal, EqualEqual,
    Greater, GreaterEqual,
    Less, LessEqual,

    // Literals.
    Identifier, String, Number,

    // Keywords.
    And, Class, Else, False,
    For, Fun, If, Nil, Or,
    Print, Return, Super, This,
    True, Var, While,

    Error,
    Eof
}

struct Token {
    pub kind    : TokenKind
    pub text    : string
    pub line    : int
}

struct Lexer {
    source  : string
    current : int
    line    : int
}

impl Lexer {
    fn create(source: string) -> Lexer {
        return new {
            source = source
            current = 0
            line = 1
        }
    }

    fn next_char(ref Self) -> char {
        current += 1
        return source[current - 1]
    }

    fn peek_char(ref Self) -> char {
        return if is_at_end() { char(0) } else { source[current] }
    }

    fn peek_next_char(ref Self) -> char {
        return if current >= source.length - 1 { char(0) } else { source[current + 1] }
    }

    fn is_at_end(ref Self) -> bool {
        return current >= source.length
    }

    fn skip_whitespace(ref Self) {
        while true {
            let c = peek_char()
            match c {
                ' '     -> next_char()
                '`r'    -> next_char()
                '`t'    -> next_char()

                '`n'    -> {
                    line += 1
                    next_char()
                }

                '/' if peek_next_char() == '/' -> {
                    while !is_at_end() and peek_char() != '`n' {
                        next_char()
                    }
                }

                $_ -> {
                    break
                }
            }
        }
    }

    fn make_token(ref Self, kind: TokenKind, length: int = 1) -> Token {
        return new {kind, source::slice(current - 1, length), line}
    }

    fn make_string(ref Self) -> Token {
        let start = current - 1
        let l = line
        while !is_at_end() and peek_char() != '"' {
            if peek_char() == '`n' {
                line += 1
            }
            next_char()
        }

        if is_at_end() {
            return new {TokenKind.Error, "Unterminated string.", l}
        }

        // eat closing ".
        next_char()

        return new {TokenKind.String, source::slice(start, current - start), l}
    }

    fn make_number(ref Self) -> Token {
        let start = current - 1

        while !is_at_end() and is_digit(peek_char()) {
            next_char()
        }

        // look for a fractional part
        if peek_char() == '.' and is_digit(peek_next_char()) {
            next_char()

            while !is_at_end() and is_digit(peek_char()) {
                next_char()
            }
        }

        return new {TokenKind.Number, source::slice(start, current - start), line}
    }

    fn make_identifier(ref Self) -> Token {
        let start = current - 1
        while !is_at_end() and (is_alpha(peek_char()) or is_alpha(peek_char())) {
            next_char()
        }

        return check_keywords(new {TokenKind.Identifier, source::slice(start, current - start), line})
    }

    fn check_keywords(ref Self, token: Token) -> Token {
        token.kind = match token.text {
            $txt if streq(txt, "and")       -> TokenKind.And
            $txt if streq(txt, "var")       -> TokenKind.Var
            $txt if streq(txt, "And")       -> TokenKind.And
            $txt if streq(txt, "Class")     -> TokenKind.Class
            $txt if streq(txt, "Else")      -> TokenKind.Else
            $txt if streq(txt, "False")     -> TokenKind.False
            $txt if streq(txt, "For")       -> TokenKind.For
            $txt if streq(txt, "Fun")       -> TokenKind.Fun
            $txt if streq(txt, "If")        -> TokenKind.If
            $txt if streq(txt, "Nil")       -> TokenKind.Nil
            $txt if streq(txt, "Or")        -> TokenKind.Or
            $txt if streq(txt, "Print")     -> TokenKind.Print
            $txt if streq(txt, "Return")    -> TokenKind.Return
            $txt if streq(txt, "Super")     -> TokenKind.Super
            $txt if streq(txt, "This")      -> TokenKind.This
            $txt if streq(txt, "True")      -> TokenKind.True
            $txt if streq(txt, "Var")       -> TokenKind.Var
            $txt if streq(txt, "While")     -> TokenKind.While

            $_ -> token.kind
        }
        return token
    }

    fn is_digit(c: char) -> bool {
        return c >= '0' and c <= '9'
    }

    fn is_alpha(c: char) -> bool {
        return  (c >= 'a' and c <= 'z') or
                (c >= 'A' and c <= 'Z') or
                (c == '_')
    }

    fn next_token(ref Self) -> Token {
        skip_whitespace()
        if is_at_end() {
            return new {TokenKind.Eof, "", line}
        }

        let c = next_char()
        let n = peek_char()
        // printfln("checking chars '{}', '{}'", [c, n])

        return match (c, n) {
            ('!', '=')  -> make_token(TokenKind.BangEqual, 2)
            ('=', '=')  -> make_token(TokenKind.EqualEqual, 2)
            ('<', '=')  -> make_token(TokenKind.LessEqual, 2)
            ('>', '=')  -> make_token(TokenKind.GreaterEqual, 2)

            ('!', $_)   -> make_token(TokenKind.Bang)
            ('=', $_)   -> make_token(TokenKind.Equal)
            ('<', $_)   -> make_token(TokenKind.Less)
            ('>', $_)   -> make_token(TokenKind.Greater)

            ('(', $_)   -> make_token(TokenKind.LeftParen)
            (')', $_)   -> make_token(TokenKind.RightParen)
            ('{', $_)   -> make_token(TokenKind.LeftBrace)
            ('}', $_)   -> make_token(TokenKind.RightBrace)
            (';', $_)   -> make_token(TokenKind.Semicolon)
            (',', $_)   -> make_token(TokenKind.Comma)
            ('.', $_)   -> make_token(TokenKind.Dot)
            ('-', $_)   -> make_token(TokenKind.Minus)
            ('+', $_)   -> make_token(TokenKind.Plus)
            ('/', $_)   -> make_token(TokenKind.Slash)
            ('*', $_)   -> make_token(TokenKind.Star)

            ('"', $_)   -> make_string()
            ($c, $_) if is_alpha(c) -> make_identifier()
            ($c, $_) if is_digit(c) -> make_number()

            $_ -> new {TokenKind.Error, "Unexpected charactor.", line}
        }
    }
}

impl Printable for TokenKind {
    fn print(ref Self, str: ref String, format: string) {
        str.append_string(match self {
            TokenKind.LeftParen -> "LeftParen"
            TokenKind.RightParen -> "RightParen"
            TokenKind.LeftBrace -> "LeftBrace"
            TokenKind.RightBrace -> "RightBrace"
            TokenKind.Comma -> "Comma"
            TokenKind.Dot -> "Dot"
            TokenKind.Minus -> "Minus"
            TokenKind.Plus -> "Plus"
            TokenKind.Semicolon -> "Semicolon"
            TokenKind.Slash -> "Slash"
            TokenKind.Star -> "Star"
            TokenKind.Bang -> "Bang"
            TokenKind.BangEqual -> "BangEqual"
            TokenKind.Equal -> "Equal"
            TokenKind.EqualEqual -> "EqualEqual"
            TokenKind.Greater -> "Greater"
            TokenKind.GreaterEqual -> "GreaterEqual"
            TokenKind.Less -> "Less"
            TokenKind.LessEqual -> "LessEqual"
            TokenKind.Identifier -> "Identifier"
            TokenKind.String -> "String"
            TokenKind.Number -> "Number"
            TokenKind.And -> "And"
            TokenKind.Class -> "Class"
            TokenKind.Else -> "Else"
            TokenKind.False -> "False"
            TokenKind.For -> "For"
            TokenKind.Fun -> "Fun"
            TokenKind.If -> "If"
            TokenKind.Nil -> "Nil"
            TokenKind.Or -> "Or"
            TokenKind.Print -> "Print"
            TokenKind.Return -> "Return"
            TokenKind.Super -> "Super"
            TokenKind.This -> "This"
            TokenKind.True -> "True"
            TokenKind.Var -> "Var"
            TokenKind.While -> "While"
            TokenKind.Error -> "Error"
            TokenKind.Eof -> "Eof"
        })
    }
}










































