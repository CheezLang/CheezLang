#load("object")
#load("lexer")


Precedence :: enum {
    None
    Assignment
    Or
    And
    Equality
    Comparison
    Term
    Factor
    Unary
    Call
    Primary
}

ParseFn :: fn(bool)

ParseRule :: struct {
    prefix      : ParseFn
    infix       : ParseFn
    precedence  : Precedence
}

Local :: struct {
    name        : Token
    depth       : int
    is_upvalue  : bool
}

Upvalue :: struct {
    index   : u8
    is_local: bool
}

FunctionType :: enum {
    Function
    Initializer
    Method
    Script
}

Compiler :: struct {
    enclosing   : &Compiler
    function    : &ObjFunction
    kind        : FunctionType
    locals      : [256]Local
    local_count : int
    upvalues    : [256]Upvalue
    scope_depth : int
}

impl Compiler {
    create :: (kind: FunctionType) -> Self {
        // return Compiler(
        //     enclosing = parent
        //     function = null
        //     kind = kind
        //     local_count = 0
        //     scope_depth = 0
        // )
    }
}

ClassCompiler :: struct {
    enclosing   : &ClassCompiler
    name        : Token
    has_super   : bool
}



compile :: (source: string) -> &ObjFunction {
    lexer := Lexer.create(source)
    compiler := Compiler.create(FunctionType.Script)

    had_error := false
    panic_mode := false

    advance()
    while !match_token(TokenKind.Eof) {
        declaration()
    }

    function := end_compiler()
    return if had_error {null} else {function}

    // print tokens
    // while true {
    //     token := lexer.next_token()

    //     printfln("{}> ({}) '{}'", (token.line, token.kind, token.text))

    //     if int(token.kind) == int(TokenKind.Eof) {
    //         break
    //     }
    // }
    return null
}