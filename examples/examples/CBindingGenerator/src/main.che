use import std.printable
use import std.string
io  :: import std.io
C   :: import std.c
fs  :: import std.io.fs
fmt :: import std.fmt

use import clap.clap
use import libclang.clang

impl Printable for CXString {
    print :: (ref Self, str: ref String, format: string) {
        c_str := clang_getCStringHelper(&self)
        str.appendf("{}", string(cast c_str, C.strlen(c_str)))
    }
}

impl CXString {
    get_length :: (ref Self) -> int {
        return C.strlen(clang_getCStringHelper(&self))
    }
}

impl Drop for CXString {
    drop :: (ref Self) {
        clang_disposeStringHelper(&self)
    }
}

GenOptions :: struct {
    input    : String
    out_path : String
    name     : String
}

GenContext :: struct {
    cheez_file        : String
    c_file            : String
    buffer            : String
    requires_wrapper  : bool   = false
    param_index       : int    = 0
    return_type_is_struct := false
}

Main :: () {
    args := get_cmd_args()
    options := parse_arguments(GenOptions, args.sliceF(1))

    if options == null {
        io.println(get_help_message(@type_info(GenOptions)))
        return
    }
    options.input.append_char(char(0))

    cx_index := clang_createIndex(0, 0)
    if cx_index == null {
        io.println("[ERROR] Failed to clang index")
        return
    }
    defer clang_disposeIndex(cx_index)

    io.printfln("reading file {} ...", options.input.slice())
    cx_translation_unit := clang_parseTranslationUnit(cx_index, cast options.input.get_raw(), null, 0, null, 0, CXTranslationUnit_Flags.None)
    if cx_translation_unit == null {
        io.println("[ERROR] Failed to parse header file")
        return
    }
    defer clang_disposeTranslationUnit(cx_translation_unit)

    cursor : CXCursor = default
    clang_getTranslationUnitCursor(&cursor, cx_translation_unit)

    ctx := GenContext(
        cheez_file = String.empty()
        c_file     = String.empty()
        buffer     = String.empty()
    )

    {
        // std::string header(header_file_path);
        // size_t last_slash = header.find_last_of('/');
        // size_t last_backslash = header.find_last_of('\\');
        // size_t last = -1;
        // if (last_slash == std::string::npos) last = last_backslash;
        // if (last_backslash == std::string::npos) last = last_slash;
        // if (last == std::string::npos) last = 0;
        // else last += 1;
        // std::string header_name = header.substr(last);
        // c_file << "#include \"" << header_name << "\"\n\n";
        ctx.c_file.appendf("#include `"{}`"`n", options.input.sliceL(options.input.get_length() - 1))
    }

    visitor :: (c: &CXCursor, parent: &CXCursor, client_data: CXClientData) -> CXChildVisitResult {
        ctx := cast(&GenContext) client_data

        c_kind := clang_getCursorKindHelper(c)
        
        match c_kind {
            CXCursorKind.FunctionDecl -> emit_function_decl(<<ctx, c)
            CXCursorKind.StructDecl   -> {
                name := clang_getCursorSpelling(c)
                if name.get_length() != 0 {
                    emit_struct_decl(<<ctx, c, clang_getCursorSpelling(c))
                }
            }
            CXCursorKind.TypedefDecl  -> emit_typedef_decl(<<ctx, c)
            CXCursorKind.EnumDecl     -> emit_enum_decl(<<ctx, c)

            _ -> {
                c_spelling := clang_getCursorSpelling(c)
                c_kind_spelling := clang_getCursorKindSpelling(c_kind)
                io.printfln("[ERROR] Unhandled cursor '{}' of kind '{}'", (c_spelling, c_kind_spelling))
            }
        }

        return CXChildVisitResult.Continue
    }
    clang_visitChildrenHelper(&cursor, visitor, &ctx)

    {
        fs.create_directory(options.out_path.slice())

        // cheez file
        cheez_file_name := fmt.format("{}/{}.che", [options.out_path.slice(), options.name.slice()]);
        io.printfln("writing file {} ...", cheez_file_name.slice())
        try_with(fs.write_file(cheez_file_name.slice(), ctx.cheez_file.slice()), {
            io.printfln("writing file {} failed", cheez_file_name.slice())
        })

        // c file
        c_file_name := fmt.format("{}/{}.cpp", [options.out_path.slice(), options.name.slice()]);
        io.printfln("writing file {} ...", c_file_name.slice())
        try_with(fs.write_file(c_file_name.slice(), ctx.c_file.slice()), {
            io.printfln("writing file {} failed", cheez_file_name.slice())
        })
    }
}

emit_struct_decl :: (ctx: ref GenContext, cursor: &CXCursor, name: CXString) {
    // io.printfln("[ERROR] Unhandled cursor '{}' of kind '{}'", (name, clang_getCursorKindSpelling(cursor.kind)))

    ctx.cheez_file.appendf("{} :: struct ``{`n", name)

    visit_struct_members(cursor, ctx, {
        member_name := clang_getCursorSpelling(c)
        member_type := clang_getCursorType(c)

        ctx.cheez_file.appendf("    {} : ", member_name)
        emit_c_type(ctx, member_type, false, false)
        ctx.cheez_file.append_string("`n")
    })

    ctx.cheez_file.appendf("}`n", ())
}

emit_typedef_decl :: (ctx: ref GenContext, cursor: &CXCursor) {
    elo          := clang_getTypedefDeclUnderlyingType(<<cursor)
    actual_type  := clang_Type_getNamedType(elo)
    type_decl    := clang_getTypeDeclaration(actual_type)

    match type_decl.kind {
        CXCursorKind.StructDecl -> {
            struct_name := clang_getCursorSpelling(&type_decl)

            if struct_name.get_length() == 0{
                emit_struct_decl(ctx, &type_decl, clang_getCursorSpelling(cursor))
            }
        }
    }
}

emit_enum_decl :: (ctx: ref GenContext, cursor: &CXCursor) {

}

emit_function_decl :: (ctx: ref GenContext, cursor: &CXCursor) {
    ctx.requires_wrapper = false

    function_type := clang_getCursorType(cursor)
    return_type   := clang_getResultType(function_type)

    // check if return type or any param is struct
    ctx.return_type_is_struct = check_type_struct(ctx, return_type)
    if ctx.return_type_is_struct {
        ctx.requires_wrapper = true
    }
    visit_parameters(cursor, ctx, {
        if check_type_struct(ctx, clang_getCursorType(c)) {
            ctx.requires_wrapper = true
        }
    })

    // bind func
    {
        if ctx.requires_wrapper {
            ctx.cheez_file.append_string("__bind__")
        }
        ctx.cheez_file.appendf("{} :: (", clang_getCursorSpelling(cursor))
        if ctx.return_type_is_struct {
            ctx.cheez_file.append_string("ret: &")
            emit_c_type(ctx, return_type, true, true)
        }

        visit_parameters(cursor, ctx, {
            if ctx.param_index > 0 or ctx.return_type_is_struct {
                ctx.cheez_file.append_string(", ")
            }

            ctx.cheez_file.appendf("p{}: ", ctx.param_index)
            emit_c_type(ctx, clang_getCursorType(c), true)
        })

        ctx.cheez_file.append_string(")")

        if !ctx.return_type_is_struct {
            ctx.cheez_file.appendf(" -> ", ())
            emit_c_type(ctx, return_type, true)
        }

        ctx.cheez_file.append_string(";`n")
    }
    
    // wrapper
    if ctx.requires_wrapper {
        ctx.cheez_file.appendf("{} :: (", clang_getCursorSpelling(cursor))

        // generate param list
        visit_parameters(cursor, ctx, {
            if ctx.param_index > 0 {
                ctx.cheez_file.append_string(", ")
            }

            ctx.cheez_file.appendf("p{}: ", ctx.param_index)
            emit_c_type(ctx, clang_getCursorType(c), true, true)
        })

        ctx.cheez_file.append_string(") -> ")
        emit_c_type(ctx, return_type, true, true)
        ctx.cheez_file.append_string(" {`n")

        // generate body
        if ctx.return_type_is_struct {
            ctx.cheez_file.append_string("    ret: ")
            emit_c_type(ctx, return_type, true, true)
            ctx.cheez_file.append_string("`n    ")
        } else if int(return_type.kind) != int(CXTypeKind.Void) {
            ctx.cheez_file.append_string("    return ")
        } else {
            ctx.cheez_file.append_string("    ")
        }

        // call bind func
        ctx.cheez_file.appendf("__bind__{}(", clang_getCursorSpelling(cursor))

        if ctx.return_type_is_struct {
            ctx.cheez_file.append_string("&ret")
        }

        visit_parameters(cursor, ctx, {
            if ctx.param_index > 0 or ctx.return_type_is_struct {
                ctx.cheez_file.append_string(", ")
            }

            if check_type_struct(ctx, clang_getCursorType(c)) {
                ctx.cheez_file.append_string("&")
            }

            ctx.cheez_file.appendf("p{}", ctx.param_index)
        })

        // return result
        if ctx.return_type_is_struct {
            ctx.cheez_file.append_string(")`n    return ret")
        } else {
            ctx.cheez_file.append_string(")")
        }

        ctx.cheez_file.append_string("`n}`n")
    }

    if ctx.requires_wrapper {
        emit_function_c_decl(ctx, cursor)
    }
}

emit_function_c_decl :: (ctx: ref GenContext, cursor: &CXCursor) {
    function_type := clang_getCursorType(cursor)
    return_type   := clang_getResultType(function_type)

    visit_parameters(cursor, ctx, {
        ctx.c_file.appendf("using {}_p{}_t = {};`n", (
            clang_getCursorSpelling(parent),
            ctx.param_index,
            clang_getTypeSpelling(clang_getCursorType(c))))
    })

    ctx.c_file.append_string("extern `"C`" ");

    // return type
    if ctx.return_type_is_struct {
        ctx.c_file.append_string("void")
    } else {
        ctx.c_file.appendf("{}", clang_getTypeSpelling(return_type))
    }

    // function name
    ctx.c_file.appendf(" __bind__{}(", clang_getCursorSpelling(cursor))

    // return param
    if ctx.return_type_is_struct {
        ctx.c_file.appendf("{}* ret", clang_getTypeSpelling(return_type))
    }

    visit_parameters(cursor, ctx, {
        if ctx.param_index > 0 or ctx.return_type_is_struct {
            ctx.c_file.append_string(", ")
        }

        // param type
        ctx.c_file.appendf("{}_p{}_t", (
            clang_getCursorSpelling(parent),
            ctx.param_index))

        if check_type_struct(ctx, clang_getCursorType(c)) {
            ctx.c_file.append_string("*")
        }

        ctx.c_file.appendf(" p{}", ctx.param_index)
    })

    ctx.c_file.append_string(") {`n")

    // call original function
    if ctx.return_type_is_struct {
        ctx.c_file.append_string("    *ret = ")
    } else if int(return_type.kind) != int(CXTypeKind.Void) {
        ctx.c_file.append_string("    return ")
    } else {
        ctx.c_file.append_string("    ")
    }

    ctx.c_file.appendf("{}(", clang_getCursorSpelling(cursor))

    // args
    visit_parameters(cursor, ctx, {
        if ctx.param_index > 0 {
            ctx.c_file.append_string(", ")
        }

        if check_type_struct(ctx, clang_getCursorType(c)) {
            ctx.c_file.append_string("*")
        }

        ctx.c_file.appendf("p{}", ctx.param_index)
    })

    ctx.c_file.append_string(");`n}`n")
}

check_type_struct :: (ctx: ref GenContext, typ: CXType) -> bool {
    return match typ.kind {
        CXTypeKind.Typedef -> {
            typedef_decl := clang_getTypeDeclaration(typ)
            elo          := clang_getTypedefDeclUnderlyingType(typedef_decl)
            actual_type  := clang_Type_getNamedType(elo)
            type_decl    := clang_getTypeDeclaration(actual_type)

            match type_decl.kind {
                CXCursorKind.StructDecl -> true
                _ -> false
            }
        }

        _ -> false
    }
}

emit_c_type :: (ctx: ref GenContext, typ: CXType, is_func_param: bool, behind_pointer: bool = false) {
    size := clang_Type_getSizeOf(typ)
    // io.printfln("emit_c_type({}, {})", (clang_getTypeSpelling(typ), clang_getTypeKindSpelling(typ.kind)))

    use CXTypeKind
    match typ.kind {
        Void      -> ctx.cheez_file.appendf("void", ())

        UChar     -> ctx.cheez_file.appendf("u{}", size * 8)
        UShort    -> ctx.cheez_file.appendf("u{}", size * 8)
        UInt      -> ctx.cheez_file.appendf("u{}", size * 8)
        ULong     -> ctx.cheez_file.appendf("u{}", size * 8)
        ULongLong -> ctx.cheez_file.appendf("u{}", size * 8)
        Char_S    -> ctx.cheez_file.appendf("i{}", size * 8)
        Short     -> ctx.cheez_file.appendf("i{}", size * 8)
        Int       -> ctx.cheez_file.appendf("i{}", size * 8)
        Long      -> ctx.cheez_file.appendf("i{}", size * 8)
        LongLong  -> ctx.cheez_file.appendf("i{}", size * 8)

        Float     -> ctx.cheez_file.appendf("f{}", size * 8)
        Double    -> ctx.cheez_file.appendf("f{}", size * 8)

        // TODO: not working?
        Bool      -> ctx.cheez_file.appendf("bool", ())

        ConstantArray -> {
            target_type := clang_getArrayElementType(typ)

            if is_func_param {
                ctx.cheez_file.append_string("&")
            } else {
                target_type_size := clang_getArraySize(typ)
                ctx.cheez_file.appendf("[{}]", target_type_size)
            }
            emit_c_type(ctx, target_type, is_func_param, true)
        }

        IncompleteArray -> {
            target_type := clang_getArrayElementType(typ)

            if is_func_param {
                ctx.cheez_file.append_string("&")
            } else {
                ctx.cheez_file.append_string("[0]")
            }
            emit_c_type(ctx, target_type, is_func_param, true)
        }

        Pointer -> {
            target_type := clang_getPointeeType(typ)
            ctx.cheez_file.append_string("&")
            emit_c_type(ctx, target_type, is_func_param, true)
        }

        Elaborated -> {
            actual_type := clang_Type_getNamedType(typ)
            type_decl   := clang_getTypeDeclaration(actual_type)
            ctx.cheez_file.appendf("{}", clang_getCursorSpelling(&type_decl))
        }

        Typedef -> {
            typedef_decl := clang_getTypeDeclaration(typ)
            elo          := clang_getTypedefDeclUnderlyingType(typedef_decl)
            actual_type  := clang_Type_getNamedType(elo)
            type_decl    := clang_getTypeDeclaration(actual_type)

            match type_decl.kind {
                CXCursorKind.StructDecl if is_func_param and !behind_pointer -> {
                    ctx.cheez_file.appendf("&{}", clang_getTypeSpelling(typ))
                }

                _ -> {
                    ctx.cheez_file.appendf("{}", clang_getTypeSpelling(typ))
                }
            }
        }

        _ -> {
            io.printfln("[ERROR] Failed to translate type '{}' ({})", (clang_getTypeSpelling(typ), clang_getTypeKindSpelling(typ.kind)))
        }
    }
}

visit_parameters :: (cursor: Code, ctx: Code, code: Code) #macro {
    @insert(ctx).param_index = 0
    clang_visitChildrenHelper(@insert(cursor),
        (c, parent, client_data) => {
            if int(c.kind) == int(CXCursorKind.ParmDecl) {
                ctx := ref <<cast(&GenContext) client_data
                @insert(code, link=[c, parent, ctx])
                ctx.param_index += 1
            }
            CXChildVisitResult.Continue
        },
        &@insert(ctx))
}

visit_struct_members :: (cursor: Code, ctx: Code, code: Code) #macro {
    @insert(ctx).param_index = 0
    clang_visitChildrenHelper(@insert(cursor),
        (c, parent, client_data) => {
            if int(c.kind) == int(CXCursorKind.FieldDecl) {
                ctx := ref <<cast(&GenContext) client_data
                @insert(code, link=[c, parent, ctx])
                ctx.param_index += 1
            }
            CXChildVisitResult.Continue
        },
        &@insert(ctx))
}
