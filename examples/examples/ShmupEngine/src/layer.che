use import std.array
use import std.string
use import std.rc
use import std.math
fs   :: import std.io.fs
mem  :: import std.mem.allocator
util :: import std.util
fmt  :: import std.fmt
io   :: import std.io
C    :: import std.c

use import compiler.lexer
use import compiler.string_database
use import compiler.error_handler
use import glfw.glfw_binding
serpa :: import serpa.serpa
ImGui :: import imgui.imgui_binding

use import math
use import entity
use import components
use import input
use import renderer
use import shmup_engine

#export_scope

EntityLayerCallbacks :: trait {
    init         :: (ref Self, layer: ref EntityLayer) -> bool;
    update       :: (ref Self, dt: float);
    render       :: (ref Self, renderer: ref Renderer);
    imgui_render :: (ref Self);
}


Layer :: trait {
    get_name        :: (ref Self) -> c_string;
    get_base        :: (ref Self) -> ref LayerBase;
    get_input       :: (ref Self) -> ref Input;
    init            :: (ref Self) -> bool;
    update          :: (ref Self, dt: float);
    render          :: (ref Self, renderer: ref Renderer);
    imgui_render    :: (ref Self);
    on_key_event    :: (ref Self, key: int, action: int) -> bool;
    clone           :: (ref Self) -> Option[&Layer];
    load_from_file  :: (ref Self, file: string);
    save_to_file    :: (ref Self, file: ref String);
}

LayerBase :: struct #extendable {
    name        : String
    engine      : ref ShmupEngine
    input       : ref Input
    callbacks   : &EntityLayerCallbacks
}

DebugLayer :: struct #extend(LayerBase) {
    show_layer_output := false
    show_light_map    := false
    layer_index       := 0
}

impl DebugLayer {
    new :: (name: String, engine: ref ShmupEngine, input: ref Input) -> DebugLayer {
        return DebugLayer(name, engine, input, null)
    }
}

impl Layer for DebugLayer {
    get_name :: (ref Self) -> c_string {
        return name.as_cstring()
    }

    get_base :: (ref Self) -> ref LayerBase {
        return self
    }

    get_input :: (ref Self) -> ref Input {
        return input
    }

    init :: (ref Self) -> bool {
        return true
    }

    update :: (ref Self, dt: float) {

    }

    render :: (ref Self, renderer: ref Renderer) {
        // bind stuff
        target := ref renderer.targets().color_map.get()

        if !show_layer_output {
            renderer.targets(1).color_map.get().copy_to(target)
        } else {
            data := engine.current_mode_data()
            index := clamp(layer_index, 0, data.layer_stack.count() - 1)
            if show_light_map {
                renderer.targets(data.layer_stack.count() - 1 - index).light_map.get().copy_to(target)
            } else {
                renderer.targets(data.layer_stack.count() - 1 - index).color_map.get().copy_to(target)
            }
        }
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int) -> bool {
        return false
    }

    clone :: (ref Self) -> Option[&Layer] {
        result := mem.alloc(DebugLayer)
        <<result = DebugLayer.new(name.clone(), engine, input)
        return Some(result)
    }

    load_from_file :: (ref Self, file: string) {

    }

    save_to_file :: (ref Self, file: ref String) {

    }

}

LightingLayer :: struct #extend(LayerBase) {
    exposure := 1.0f
    disabled := false
}

impl LightingLayer {
    new :: (name: String, engine: ref ShmupEngine, input: ref Input) -> LightingLayer {
        return LightingLayer(name, engine, input, null)
    }
}

impl Layer for LightingLayer {
    get_name :: (ref Self) -> c_string {
        return name.as_cstring()
    }

    get_base :: (ref Self) -> ref LayerBase {
        return self
    }

    get_input :: (ref Self) -> ref Input {
        return input
    }

    init :: (ref Self) -> bool {
        return true
    }

    update :: (ref Self, dt: float) {

    }

    render :: (ref Self, renderer: ref Renderer) {
        if disabled {
            renderer.targets(1).color_map.get().copy_to(renderer.targets().color_map.get())
            return
        }

        // apply lighting
        renderer.apply_light_shader.bind()
        renderer.apply_light_shader.set_uniform_float("uExposure", self.exposure)
        renderer.render_effect(renderer.apply_light_shader)
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int) -> bool {
        return false
    }

    clone :: (ref Self) -> Option[&Layer] {
        result := mem.alloc(LightingLayer)
        <<result = LightingLayer.new(name.clone(), engine, input)
        return Some(result)
    }

    load_from_file :: (ref Self, file: string) {

    }

    save_to_file :: (ref Self, file: ref String) {

    }

}

EntityLayer :: struct #extend(LayerBase) {
    entities        := Array[Rc[Entity]].create()
    next_entity_id  := 0
}

impl EntityLayer {
    new :: (name: String, callbacks: &EntityLayerCallbacks, engine: ref ShmupEngine, input: ref Input) -> EntityLayer {
        return EntityLayer(name, engine, input, callbacks)
    }

    find_entity :: (ref Self, id: int) -> Option[Rc[Entity]] {
        for e : entities {
            if e.get().id == id {
                return Some(e.clone())
            }
        }
        return None
    }

    new_entity :: (ref Self) -> Rc[Entity] {
        return new_entity_with_id(next_entity_id)
    }

    new_entity_with_id :: (ref Self, id: int) -> Rc[Entity] {
        if next_entity_id <= id {
            next_entity_id = id + 1
        }

        ptr := Rc[Entity].new(Entity(id, fmt.format("Entity {}", [id])))
        entities.add(ptr.clone())
        return ptr
    }

    new_component :: (ref Self, value: $T) -> Rc[Component] {
        return Rc[Component].new(value)
    }

    new_component2 :: (ref Self, ti: &TypeInfo, vtable: &void) -> Rc[Component] {
        ptr := mem.alloc_raw(u8, cast ti.size)
        C.memset(ptr, 0, cast ti.size)
        return Rc[Component].from_pointer(Traits.from_vtable_and_pointer(Component, vtable, ptr), false)
    }

    alloc_component :: (ti: &TypeInfo, vtable: &void) -> Rc[Component] {
        ptr := mem.alloc_raw(u8, cast ti.size)
        C.memset(ptr, 0, cast ti.size)
        return Rc[Component].from_pointer(Traits.from_vtable_and_pointer(Component, vtable, ptr), false)
    }

    remove_dead_entities :: (ref Self) {
        while i := 0, i < entities.get_length(), i += 1 {
            e := ref entities[i].get()
            if !e.dead then continue

            // try to delete e
            rc_count := entities[i].count()
            if rc_count != 1 {
                // there are more rc pointing to this entity
                // so don't actually destroy it, just deactivate it
                e.active = false
                io.printfln("[ERROR] Trying destroy entity {}, but there are still {} references to it", (e.id, rc_count - 1))
            } else {
                // io.printfln("i: {}, cei: {}, e.len: {}", (i, current_entity_index, entities.get_length()))
                if i == entities.get_length() - 1 {
                    // deleting last entity
                    entities.pop()
                } else {
                    // deleting entity somewhere in the middle
                    last := entities.pop()
                    // entities[i].drop()a
                    entities[i] = last
                }

                // next iteration of loop on same index
                i -= 1
            }
        }
    }

    swap_entities :: (ref Self, i0: int, i1: int) {
        @assert(i0 != i1 and i0 >= 0 and i0 < entities.get_length() and i1 >= 0 and i1 < entities.get_length())
        e0 := entities[i0].clone()
        e1 := entities[i1].clone()
        entities[i1] = e0
        entities[i0] = e1
    }
}

impl Layer for EntityLayer {
    get_name :: (ref Self) -> c_string {
        return name.as_cstring()
    }

    get_base :: (ref Self) -> ref LayerBase {
        return self
    }

    get_input :: (ref Self) -> ref Input {
        return input
    }

    init :: (ref Self) -> bool {
        ok := callbacks.init(self)
        if !ok {
            return false
        }

        for e : entities {
            e.get().init()
        }

        return true
    }

    update :: (ref Self, dt: float) {
        callbacks.update(dt)

        while i := 0, i < entities.get_length(), i += 1 {
            e := ref entities[i].get()
            if e.active {
                e.update(self, dt)
            }

            if e.dead {
                // try to delete e
                rc_count := entities[i].count()
                if rc_count != 1 {
                    // there are more rc pointing to this entity
                    // so don't actually destroy it, just deactivate it
                    e.active = false
                    io.printfln("[ERROR] Trying destroy entity {}, but there are still {} references to it", (e.id, rc_count - 1))
                } else {
                    // io.printfln("i: {}, cei: {}, e.len: {}", (i, current_entity_index, entities.get_length()))
                    if i == entities.get_length() - 1 {
                        // deleting last entity
                        entities.pop()
                    } else {
                        // deleting entity somewhere in the middle
                        last := entities.pop()
                        // entities[i].drop()a
                        entities[i] = last
                    }

                    // next iteration of loop on same index
                    i -= 1
                }
            }
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        // io.println(fmt.format("{}", [engine.game_viewport.projection_matrix]))
        callbacks.render(renderer)

        for e : entities {
            if e.get().active {
                e.get().render(engine, renderer)
            }
        }
    }

    imgui_render :: (ref Self) {
        callbacks.imgui_render()
    }

    on_key_event :: (ref Self, key: int, action: int) -> bool {
        match (action, key) {
            (GLFW_PRESS, $keycode) -> {
                input.set_key_state(keycode, true)
            }
            (GLFW_RELEASE, $keycode) -> {
                input.set_key_state(keycode, false)
            }
        }

        return false
    }

    clone :: (ref Self) -> Option[&Layer] {
        result := mem.alloc(EntityLayer)
        <<result = EntityLayer.new(name.clone(), callbacks, engine, input)

        for e : entities {
            e_new := result.clone_entity_with_id(e.clone(), e.get().id)
        }

        return Some(result)
    }

    clone_entity :: (ref Self, template: Rc[Entity]) -> Rc[Entity] {
        return clone_entity_with_id(template, next_entity_id)
    }

    clone_entity_with_id :: (ref Self, template: Rc[Entity], id: int) -> Rc[Entity] {
        e_new := self.new_entity_with_id(id)
        e_new.get().name        = template.get().name.clone()
        e_new.get().active      = template.get().active
        e_new.get().position    = template.get().position
        e_new.get().size        = template.get().size
        e_new.get().angle       = template.get().angle

        for template.get().components {
            template := ref it.get()
            component := self.new_component2(template.get_type_info(), @vtable_of_trait(template))
            C.memcpy(@ptr_of_trait(component.get()), @ptr_of_trait(template), cast template.get_type_info().size)
            e_new.get().add_component(component)
        }

        return e_new
    }

    load_from_file :: (ref Self, file: string) {
        console_error_handler := ConsoleErrorHandler.new(null)
        string_db := StringDatabase.new()

        lexer := try_with(
            Lexer.from_file(file, string_db)
            {
                io.println("Failed to read layer from file")
                return
            })
        console_error_handler.text_provider = &lexer

        parser := serpa.Parser(expect_struct_name=false)
        result := parser.parse(Array[Rc[Entity]], lexer, &console_error_handler)

        match result {
            Some($entities) -> {
                self.entities = entities

                // find max entity id
                self.next_entity_id = 0
                for e : self.entities {
                    self.next_entity_id = max(self.next_entity_id, e.get().id + 1)

                    // set entity pointer in components
                    for c : e.get().components {
                        c.get().base().entity = &e.get()
                    }
                }
            }
            None -> {
                io.println("[ERROR] Failed to parse layer file")
            }
        }
    }

    save_to_file :: (ref Self, file: ref String) {
        file.append_string("[`n")
        for rc : entities {
            e := ref rc.get()
            file.append_string("    {`n")
            file.appendf("        id          = {}`n", e.id)
            file.appendf("        name        = `"{}`"`n", e.name.slice())
            file.appendf("        dead        = {}`n", e.dead)
            file.appendf("        active      = {}`n", e.active)
            file.appendf("        position    = ``{x={}, y={}, z={}}`n", (e.position.x, e.position.y, e.position.z))
            file.appendf("        size        = ``{x={}, y={}, z={}}`n", (e.size.x, e.size.y, e.size.z))
            file.appendf("        angle       = {}`n", e.angle)
            file.appendf("        components  = [`n", ())

            for cd : e.components {
                file.appendf("            {} ``{`n", cd.get().get_type_info().kind.Struct.name)
                cd.get().serialize(file)
                file.append_string("            }`n")
            }

            file.appendf("        ]`n", ())
            file.append_string("    }`n")
        }
        file.append_string("]")
    }
}
