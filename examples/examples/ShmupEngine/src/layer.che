use import std.array
use import std.string
use import std.rc
use import std.math
mem  :: import std.mem.allocator
util :: import std.util
fmt  :: import std.fmt
io   :: import std.io
C    :: import std.c

use import glfw.glfw3
ImGui :: import imgui.imgui_binding

use import math
use import entity
use import components
use import input
use import renderer
use import shmup_engine

#export_scope

EntityLayerCallbacks :: trait {
    init         :: (ref Self, layer: ref EntityLayer) -> bool;
    update       :: (ref Self, dt: float);
    render       :: (ref Self, renderer: ref Renderer);
    imgui_render :: (ref Self);
}


Layer :: trait {
    get_name     :: (ref Self) -> c_string;
    get_base     :: (ref Self) -> ref LayerBase;
    get_input    :: (ref Self) -> ref Input;
    init         :: (ref Self) -> bool;
    update       :: (ref Self, dt: float);
    render       :: (ref Self, renderer: ref Renderer);
    imgui_render :: (ref Self);
    on_key_event :: (ref Self, key: int, action: int) -> bool;
    clone        :: (ref Self) -> Option[Layer];
}

LayerBase :: struct #extendable {
    name        : String
    engine      : ref ShmupEngine
    input       : ref Input
    callbacks   : EntityLayerCallbacks
}

EntityLayer :: struct #extend(LayerBase) {
    entities        := Array[Rc[Entity]].create()
    next_entity_id  := 0
}

impl EntityLayer {
    new :: (name: String, callbacks: EntityLayerCallbacks, engine: ref ShmupEngine, input: ref Input) -> EntityLayer {
        return EntityLayer(name, engine, input, callbacks)
    }

    find_entity :: (ref Self, id: int) -> Option[Rc[Entity]] {
        for e : entities {
            if e.get().id == id {
                return Some(e.clone())
            }
        }
        return None
    }

    new_entity :: (ref Self) -> Rc[Entity] {
        return new_entity_with_id(next_entity_id)
    }

    new_entity_with_id :: (ref Self, id: int) -> Rc[Entity] {
        // io.printfln("new_entity_with_id {}", id)
        if next_entity_id <= id {
            next_entity_id = id + 1
        }

        ptr := Rc[Entity].new(Entity(id))
        entities.add(ptr.clone())
        return ptr
    }

    new_component :: (ref Self, value: $T) -> Rc[T] {
        return Rc[T].new(value)
    }

    new_component2 :: (ref Self, ti: &TypeInfo) -> Rc[()] {
        ptr := mem.alloc_raw(u8, cast ti.size)
        C.memset(ptr, 0, cast ti.size)
        return Rc[()].from_pointer(cast ptr, false)
    }
}

impl Layer for EntityLayer {
    get_name :: (ref Self) -> c_string {
        return name.as_cstring()
    }

    get_base :: (ref Self) -> ref LayerBase {
        return self
    }

    get_input :: (ref Self) -> ref Input {
        return input
    }

    init :: (ref Self) -> bool {
        return callbacks.init(self)
    }

    update :: (ref Self, dt: float) {
        callbacks.update(dt)

        while i := 0, i < entities.get_length(), i += 1 {
            e := ref entities[i].get()
            if e.active {
                e.update(self, dt)
            }

            if e.dead {
                // try to delete e
                rc_count := entities[i].count()
                if rc_count != 1 {
                    // there are more rc pointing to this entity
                    // so don't actually destroy it, just deactivate it
                    e.active = false
                    io.printfln("[ERROR] Trying destroy entity {}, but there are still {} references to it", (e.id, rc_count - 1))
                } else {
                    // io.printfln("i: {}, cei: {}, e.len: {}", (i, current_entity_index, entities.get_length()))
                    if i == entities.get_length() - 1 {
                        // deleting last entity
                        entities.pop()
                    } else {
                        // deleting entity somewhere in the middle
                        last := entities.pop()
                        // entities[i].drop()a
                        entities[i] = last
                    }

                    // next iteration of loop on same index
                    i -= 1
                }
            }
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        callbacks.render(renderer)

        for e : entities {
            if e.get().active {
                e.get().render(engine, renderer)
            }
        }
    }

    imgui_render :: (ref Self) {
        callbacks.imgui_render()
    }

    on_key_event :: (ref Self, key: int, action: int) -> bool {
        match (action, key) {
            (GLFW_PRESS, $keycode) -> {
                input.set_key_state(keycode, true)
            }
            (GLFW_RELEASE, $keycode) -> {
                input.set_key_state(keycode, false)
            }
        }

        return false
    }

    clone :: (ref Self) -> Option[Layer] {
        result := mem.alloc(EntityLayer)
        <<result = EntityLayer.new(name.clone(), callbacks, engine, input)

        for e : entities {
            e_new := result.new_entity_with_id(e.get().id)
            e_new.get().active      = e.get().active
            e_new.get().position    = e.get().position
            e_new.get().size        = e.get().size
            e_new.get().angle       = e.get().angle

            for e.get().components {
                type_info := it.component.get_type_info()
                vtable    := Traits.get_trait_object_vtable(it.component)
                rc        := self.new_component2(type_info)
                C.memcpy(&rc.get(), &it.value.get(), cast type_info.size)
                e_new.get().add_component3(vtable, rc)
            }
        }

        return Some(<<result)
    }
}