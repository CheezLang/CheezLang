use import std.string
use import std.array
use import std.math
mem  :: import std.mem.allocator
fmt  :: import std.fmt
io   :: import std.io
C    :: import std.c
util :: import std.util

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding
glfw  :: import glfw.glfw3

use import shmup_engine
use import opengl_utils
use import shader
use import math
use import matrix
use import renderer
use import opengl_buffers
use import input

max_entities :: 1024

Behaviour :: trait {
    update          :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input);
    render          :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer);
    get_type_info   :: (ref Self) -> &TypeInfo;
}

Entity :: struct {
    id          : int
    dead        : bool
    active      : bool
    position    : vec3
    size        : vec3
    angle       : float
    behaviours  : Array[Behaviour]
}

impl Entity {
    update :: (ref Self, engine: ref ShmupEngine, dt: float, input: ref Input) {
        for b : behaviours {
            b.update(self, engine, dt, input)
        }
    }

    render :: (ref Self, engine: ref ShmupEngine, renderer: ref Renderer) {
        for b : behaviours {
            b.render(self, engine, renderer)
        }
    }

    add_behaviour :: (ref Self, b: $T) {
        ptr := mem.alloc(T)
        <<ptr = b
        behaviours.add(<<ptr)
    }

    free :: (ref Self) {
        for b : behaviours {
            mem.free(&b)
        }
    }
}

BasicMoveBehaviour :: struct {
    velocity : vec3
    speed    : float
}

impl Behaviour for BasicMoveBehaviour {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        engine.edit_property(PropertyEdit.EditVec3(&entity.position, "pos"))
        engine.edit_property(PropertyEdit.EditVec3(&velocity, "vol"))
        engine.edit_property(PropertyEdit.EditFloat(&speed, "speed", 0.1))

        entity.position += velocity * speed * dt
    }

    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {}
    
    get_type_info   :: (ref Self) -> &TypeInfo {
        return @type_info(Self)
    }
}

QuadBehaviour :: struct {
    #color
    color : vec3
}

impl Behaviour for QuadBehaviour {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        engine.edit_property(PropertyEdit.EditColor3(&color, "Color"))
    }
    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {
        renderer.fill_quad(entity.position, entity.size, entity.angle / 360.0f * (3.1415f * 2.0f), color)
    }
    get_type_info   :: (ref Self) -> &TypeInfo {
        return @type_info(Self)
    }
}

Test :: struct {
    engine : &ShmupEngine = null


    color := vec3(0, 1, 0)
    alpha := 0.5f
    count := 2

    offset := vec3(0, 0, 0)
    scale  := 0.9f
    angle  := 0.0f

    quad_pos  := vec3(0, 0, 0)
    quad_size := vec3(1, 1, 0)
    speed     := 3.5f


    entities        := Array[Entity].create()
    next_entity     := 0
    first_entity    := 0
    last_entity     := 0
}

impl Test {
    new_entity :: (ref Self) -> &Entity {
        // io.printfln("new_entity {}, {}, {}", (next_entity, first_entity, last_entity))
        if next_entity >= max_entities {
            @assert(false)
            return null
        }

        if next_entity < first_entity {
            first_entity = next_entity
        }

        if next_entity >= last_entity {
            last_entity = next_entity + 1
        }
        // io.printfln("           {}, {}, {}", (next_entity, first_entity, last_entity))

        if next_entity >= entities.get_length() {
            entities.add(Entity(
                id          = entities.get_length()
                active      = false
                dead        = false
                position    = vec3()
                size        = vec3(1, 1, 1)
                angle       = 0
                behaviours  = Array[Behaviour].create()
            ))
        }
        entity := &entities[next_entity]
        entity.active   = true
        entity.position = vec3()
        entity.size     = vec3(1, 1, 1)
        entity.angle    = 0
        entity.behaviours.clear()

        while next_entity < entities.get_length() and entities[next_entity].active {
            next_entity += 1
        }

        return entity
    }
}

impl ShmupCallbacks for Test {
    init :: (ref Self, engine: ref ShmupEngine) -> bool {
        self.engine = &engine
        entities.reserve(max_entities)

        e := self.new_entity()
        e.add_behaviour(BasicMoveBehaviour(vec3(1, 0, 0), 1.0f))
        e.add_behaviour(QuadBehaviour(vec3(1, 1, 1)))

        e2 := self.new_entity()
        e2.position.x = -5
        e2.add_behaviour(QuadBehaviour(vec3(0, 0, 1)))

        return true
    }

    update :: (ref Self, dt: float, input: ref Input) {
        for i : first_entity .. last_entity {
            if !entities[i].dead {
                render_entity_inspector(entities[i])
            }
        }

        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].update(<<engine, dt, input)
            }
        }

        if input.key_down(glfw.GLFW_KEY_LEFT) {
            quad_pos += vec3(-1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_RIGHT) {
            quad_pos += vec3(1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_UP) {
            quad_pos += vec3(0, 1) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_DOWN) {
            quad_pos += vec3(0, -1) * speed * dt
        }

        // if input.key_pressed(glfw.GLFW_KEY_SPACE)  then io.print("v")
        // if input.key_down(glfw.GLFW_KEY_SPACE)     then io.print(".")
        // if input.key_released(glfw.GLFW_KEY_SPACE) then io.println("^")
    }

    render_entity_inspector :: (ref Self, entity: ref Entity) {
        ImGui.PushIDInt(cast entity.id)
        if ImGui.Begin(if entity.id == 0 then "Inspector1" else "Inspector2") {
            id_str := fmt.format_any(entity.id)
            ImGui.LabelText("ID", id_str.as_cstring())

            ImGui.Separator()

            // transform
            ImGui.InputFloat3("Position", &entity.position.x)
            ImGui.InputFloat3("Size", &entity.size.x)
            ImGui.InputFloat("angle", &entity.angle, 1, 5)

            ImGui.Separator()

            for b : entity.behaviours {
                render_behaviour_inspector(b)
                ImGui.Separator()
            }

            if ImGui.SmallButton("Add Behaviour") {
                io.println("adding behaviour")
            }
        }
        ImGui.End()
        ImGui.PopID()
    }

    render_behaviour_inspector :: (ref Self, b: Behaviour) {
        Trait :: struct {
            v_table : &void
            value   : &void
        }
        t := <<cast(&Trait)&b
        ti := b.get_type_info()

        // name of behaviour
        name := String.with_capacity(ti.kind.Struct.name.bytes.length + 1)
        name.append_string(ti.kind.Struct.name)

        ImGui.Text(name.as_cstring())

        for(by_ref=true) m : ti.kind.Struct.members {
            imgui_input_property(util.pointer_add(t.value, m.offset), &m)
        }
    }

    imgui_input_property :: (ref Self, ptr: &void, m: &TypeInfoStructMember) {
        name := String.with_capacity(m.name.bytes.length + 1)
        name.append_string(m.name)

        match m.typ.kind {
            TypeInfoKind.Float -> {
                match m.typ.size {
                    4 -> {
                        ImGui.InputFloat(name.as_cstring(), cast ptr)
                    }
                    8 -> {
                        f := <<cast(&float)ptr
                        ImGui.InputFloat(name.as_cstring(), &f)
                        <<cast(&float)ptr = f
                    }
                }
            }

            _ if m.typ == @type_info(vec3) -> {
                if m.has_attribute("color") {
                    ImGui.ColorEdit3(name.as_cstring(), cast ptr)
                } else {
                    ImGui.InputFloat3(name.as_cstring(), cast ptr)
                }
            }
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        // set aspect_ratio_axis so that the game world always fits on screen
        if (float(engine.viewport_size.x) / float(engine.viewport_size.y)) > (engine.world_size.x / engine.world_size.y) {
            engine.aspect_ratio_axis = 1
        } else {
            engine.aspect_ratio_axis = 0
        }

        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].render(<<engine, renderer)
            }
        }

        renderer.fill_quad(quad_pos, quad_size, 0, vec3(1, 0, 0))

        for(inclusive=true) y : 0 .. count {
            for(inclusive=true) x : 0 .. count {
                rotation := mat4.from_rotation_z(angle / 360.0f * (3.1415f * 2.0f))

                renderer.draw_quad(vec3i(x - count / 2, y - count / 2, 0).change_type(f32) + offset, vec3(scale, scale, 0), angle / 360.0f * (3.1415f * 2.0f), 0.1, color)
            }
        }
    }
}

Main :: () {
    test := Test()

    shmup_engine := ShmupEngine.new()
    shmup_engine.push_layer(test)
    shmup_engine.start()
}
