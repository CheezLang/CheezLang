use import std.string
use import std.array
use import std.math
mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding
glfw  :: import glfw.glfw3

use import shmup_engine
use import opengl_utils
use import shader
use import math
use import matrix
use import renderer
use import opengl_buffers
use import input

max_entities :: 1024

Behaviour :: trait {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input);
    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer);
}

Entity :: struct {
    id          : int
    dead        : bool
    active      : bool
    position    : vec3
    size        : vec3
    angle       : float
    behaviours  : Array[Behaviour]
}

impl Entity {
    update :: (ref Self, engine: ref ShmupEngine, dt: float, input: ref Input) {
        for b : behaviours {
            b.update(self, engine, dt, input)
        }
    }

    render :: (ref Self, engine: ref ShmupEngine, renderer: ref Renderer) {
        for b : behaviours {
            b.render(self, engine, renderer)
        }
    }

    add_behaviour :: (ref Self, b: $T) {
        ptr := mem.alloc(T)
        <<ptr = b
        behaviours.add(<<ptr)
    }

    free :: (ref Self) {
        for b : behaviours {
            mem.free(&b)
        }
    }
}

BasicMoveBehaviour :: struct {
    velocity : vec3
    speed    : float
}

impl Behaviour for BasicMoveBehaviour {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        engine.edit_property(PropertyEdit.EditVec3(&entity.position, "pos"))
        engine.edit_property(PropertyEdit.EditVec3(&velocity, "vol"))
        engine.edit_property(PropertyEdit.EditFloat(&speed, "speed", 0.1))

        entity.position += velocity * speed * dt
    }

    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {}
}

QuadBehaviour :: struct {
    color : vec3
}

impl Behaviour for QuadBehaviour {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        engine.edit_property(PropertyEdit.EditColor3(&color, "Color"))
    }
    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {
        renderer.fill_quad(entity.position, entity.size, entity.angle, color)
    }
}

Test :: struct {
    engine : &ShmupEngine = null


    color := vec3(0, 1, 0)
    alpha := 0.5f
    count := 2

    offset := vec3(0, 0, 0)
    scale  := 0.9f
    angle  := 0.0f

    quad_pos  := vec3(0, 0, 0)
    quad_size := vec3(1, 1, 0)
    speed     := 3.5f


    entities        := Array[Entity].create()
    next_entity     := 0
    first_entity    := 0
    last_entity     := 0
}

impl Test {
    new_entity :: (ref Self) -> &Entity {
        // io.printfln("new_entity {}, {}, {}", (next_entity, first_entity, last_entity))
        if next_entity >= max_entities {
            @assert(false)
            return null
        }

        if next_entity < first_entity {
            first_entity = next_entity
        }

        if next_entity >= last_entity {
            last_entity = next_entity + 1
        }
        // io.printfln("           {}, {}, {}", (next_entity, first_entity, last_entity))

        if next_entity >= entities.get_length() {
            entities.add(Entity(
                id          = entities.get_length()
                active      = false
                dead        = false
                position    = vec3()
                size        = vec3(1, 1, 1)
                angle       = 0
                behaviours  = Array[Behaviour].create()
            ))
        }
        entity := &entities[next_entity]
        entity.active   = true
        entity.position = vec3()
        entity.size     = vec3(1, 1, 1)
        entity.angle    = 0
        entity.behaviours.clear()

        while next_entity < entities.get_length() and entities[next_entity].active {
            next_entity += 1
        }

        return entity
    }
}

impl ShmupCallbacks for Test {
    init :: (ref Self, engine: ref ShmupEngine) -> bool {
        self.engine = &engine
        entities.reserve(max_entities)

        e := self.new_entity()

        e.add_behaviour(BasicMoveBehaviour(vec3(1, 0, 0), 1.0f))
        e.add_behaviour(QuadBehaviour(vec3(1, 1, 1)))

        return true
    }

    update :: (ref Self, dt: float, input: ref Input) {
        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].update(<<engine, dt, input)
            }
        }

        ImGui.Begin("Test")
        ImGui.InputFloat3("quad pos",  &quad_pos.x)
        ImGui.InputFloat3("quad siez", &quad_size.x)
        ImGui.Separator()
        ImGui.InputFloat3("Position", &offset.x)
        ImGui.InputFloat("Angle", &angle, 1, 5)
        ImGui.InputFloat("Size", &scale, 0.1, 0.5)
        ImGui.ColorEdit3("Color", &color.x)

        step      := 1
        step_fast := 10
        ImGui.InputScalar("Count", ImGui.ImGuiDataType_.S64, cast &count, &step, &step_fast)
        ImGui.End()

        // engine.edit_property(PropertyEdit.EditFloat((&offset.x, "Offset X", 0.5)))
        // engine.edit_property(PropertyEdit.EditFloat((&offset.y, "Offset Y", 0.5)))
        // engine.edit_property(PropertyEdit.EditFloat((&speed, "Speed", 0.1)))

        if input.key_down(glfw.GLFW_KEY_LEFT) {
            quad_pos += vec3(-1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_RIGHT) {
            quad_pos += vec3(1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_UP) {
            quad_pos += vec3(0, 1) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_DOWN) {
            quad_pos += vec3(0, -1) * speed * dt
        }

        // if input.key_pressed(glfw.GLFW_KEY_SPACE)  then io.print("v")
        // if input.key_down(glfw.GLFW_KEY_SPACE)     then io.print(".")
        // if input.key_released(glfw.GLFW_KEY_SPACE) then io.println("^")


    }

    render :: (ref Self, renderer: ref Renderer) {
        // set aspect_ratio_axis so that the game world always fits on screen
        if (float(engine.viewport_size.x) / float(engine.viewport_size.y)) > (engine.world_size.x / engine.world_size.y) {
            engine.aspect_ratio_axis = 1
        } else {
            engine.aspect_ratio_axis = 0
        }

        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].render(<<engine, renderer)
            }
        }

        renderer.fill_quad(quad_pos, quad_size, 0, vec3(1, 0, 0))

        for(inclusive=true) y : 0 .. count {
            for(inclusive=true) x : 0 .. count {
                rotation := mat4.from_rotation_z(angle / 360.0f * (3.1415f * 2.0f))

                renderer.draw_quad(vec3i(x - count / 2, y - count / 2, 0).change_type(f32) + offset, vec3(scale, scale, 0), angle / 360.0f * (3.1415f * 2.0f), 0.1, color)
            }
        }
    }
}

Main :: () {
    test := Test()

    shmup_engine := ShmupEngine.new()
    shmup_engine.push_layer(test)
    shmup_engine.start()
}
