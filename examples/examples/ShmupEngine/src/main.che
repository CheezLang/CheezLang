use import std.string
use import std.math
mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding
glfw  :: import glfw.glfw3

use import shmup_engine
use import opengl_utils
use import shader
use import math
use import matrix
use import renderer
use import opengl_buffers
use import input

Test :: struct {
    engine : &ShmupEngine = null

    color := vec3(0, 1, 0)
    alpha := 0.5f
    count := 2

    offset := vec3(0, 0, 0)
    scale  := 0.9f
    angle  := 0.0f

    quad_pos  := vec3(0, 0, 0)
    quad_size := vec3(1, 1, 0)
    speed     := 3.5f
}

impl ShmupCallbacks for Test {
    init :: (ref Self, engine: ref ShmupEngine) -> bool {
        self.engine = &engine

        return true
    }

    update :: (ref Self, dt: float, input: ref Input) {
        ImGui.Begin("Test")
        ImGui.InputFloat3("quad pos",  &quad_pos.x)
        ImGui.InputFloat3("quad siez", &quad_size.x)
        ImGui.Separator()
        ImGui.InputFloat3("Position", &offset.x)
        ImGui.InputFloat("Angle", &angle, 1, 5)
        ImGui.InputFloat("Size", &scale, 0.1, 0.5)
        ImGui.ColorEdit3("Color", &color.x)

        step      := 1
        step_fast := 10
        ImGui.InputScalar("Count", ImGui.ImGuiDataType_.S64, cast &count, &step, &step_fast)
        ImGui.End()

        engine.edit_property(PropertyEdit.EditFloat((&offset.x, "Offset X", 0.5)))
        engine.edit_property(PropertyEdit.EditFloat((&offset.y, "Offset Y", 0.5)))
        engine.edit_property(PropertyEdit.EditFloat((&speed, "Speed", 0.1)))


        in := engine.game_input
        if in.key_down(glfw.GLFW_KEY_LEFT) {
            quad_pos += vec3(-1, 0) * speed * dt
        }
        if in.key_down(glfw.GLFW_KEY_RIGHT) {
            quad_pos += vec3(1, 0) * speed * dt
        }
        if in.key_down(glfw.GLFW_KEY_UP) {
            quad_pos += vec3(0, 1) * speed * dt
        }
        if in.key_down(glfw.GLFW_KEY_DOWN) {
            quad_pos += vec3(0, -1) * speed * dt
        }

        // if input.key_pressed(glfw.GLFW_KEY_SPACE)  then io.print("v")
        // if input.key_down(glfw.GLFW_KEY_SPACE)     then io.print(".")
        // if input.key_released(glfw.GLFW_KEY_SPACE) then io.println("^")
    }

    render :: (ref Self, renderer: ref Renderer) {
        // set aspect_ratio_axis so that the game world always fits on screen
        if (float(engine.viewport_size.x) / float(engine.viewport_size.y)) > (engine.world_size.x / engine.world_size.y) {
            engine.aspect_ratio_axis = 1
        } else {
            engine.aspect_ratio_axis = 0
        }

        renderer.fill_quad(quad_pos, quad_size, 0, vec3(1, 0, 0))

        for(inclusive=true) y : 0 .. count {
            for(inclusive=true) x : 0 .. count {
                rotation := mat4.from_rotation_z(angle / 360.0f * (3.1415f * 2.0f))

                renderer.draw_quad(vec3i(x - count / 2, y - count / 2, 0).change_type(f32) + offset, vec3(scale, scale, 0), angle / 360.0f * (3.1415f * 2.0f), 0.1, color)
            }
        }
    }
}

Main :: () {
    test := Test()

    shmup_engine := ShmupEngine.new()
    shmup_engine.push_layer(test)
    shmup_engine.start()
}
