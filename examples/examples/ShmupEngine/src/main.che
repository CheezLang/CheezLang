use import std.string
use import std.array
use import std.math
mem  :: import std.mem.allocator
fmt  :: import std.fmt
io   :: import std.io
C    :: import std.c
util :: import std.util

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding
glfw  :: import glfw.glfw3

use import shmup_engine
use import opengl_utils
use import shader
use import math
use import matrix
use import renderer
use import opengl_buffers
use import input

max_entities :: 1024

Component :: trait {
    update          :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input);
    render          :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer);
    get_type_info   :: (ref Self) -> &TypeInfo;
}

Entity :: struct {
    id          : int
    dead        : bool
    active      : bool
    position    : vec3
    size        : vec3
    angle       : float
    components  : Array[Component]
}

impl Entity {
    update :: (ref Self, engine: ref ShmupEngine, dt: float, input: ref Input) {
        for b : components {
            b.update(self, engine, dt, input)
        }
    }

    render :: (ref Self, engine: ref ShmupEngine, renderer: ref Renderer) {
        for b : components {
            b.render(self, engine, renderer)
        }
    }

    add_component :: (ref Self, b: $T) {
        ptr := mem.alloc(T)
        <<ptr = b
        components.add(<<ptr)
    }

    add_component2 :: (ref Self, b: Component) {
        components.add(b)
    }

    free :: (ref Self) {
        for b : components {
            mem.free(&b)
        }
    }
}

BasicMoveComponent :: struct {
    velocity : vec3
    speed    : float
}

impl Component for BasicMoveComponent {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        entity.position += velocity * speed * dt
    }

    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {}
    
    get_type_info   :: (ref Self) -> &TypeInfo {
        return @type_info(Self)
    }
}

PlayerControlComponent :: struct {
    speed : float
}

impl Component for PlayerControlComponent {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
        if input.key_down(glfw.GLFW_KEY_LEFT) {
            entity.position += vec3(-1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_RIGHT) {
            entity.position += vec3(1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_UP) {
            entity.position += vec3(0, 1) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_DOWN) {
            entity.position += vec3(0, -1) * speed * dt
        }
    }

    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {}
    
    get_type_info   :: (ref Self) -> &TypeInfo {
        return @type_info(Self)
    }
}

QuadComponent :: struct {
    #color
    color : vec3
}

impl Component for QuadComponent {
    update :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, dt: float, input: ref Input) {
    }
    render :: (ref Self, entity: ref Entity, engine: ref ShmupEngine, renderer: ref Renderer) {
        renderer.fill_quad(entity.position, entity.size, entity.angle / 360.0f * (3.1415f * 2.0f), color)
    }
    get_type_info   :: (ref Self) -> &TypeInfo {
        return @type_info(Self)
    }
}

ComponentInfo :: struct {
    type_info   : &TypeInfo
    value       : &void
}

Test :: struct {
    engine : &ShmupEngine = null


    color := vec3(0, 1, 0)
    alpha := 0.5f
    count := 2

    offset := vec3(0, 0, 0)
    scale  := 0.9f
    angle  := 0.0f

    quad_pos  := vec3(0, 0, 0)
    quad_size := vec3(1, 1, 0)
    speed     := 3.5f


    entities        := Array[Entity].create()
    next_entity     := 0
    first_entity    := 0
    last_entity     := 0

    current_entity_index        : i32     = 0
    current_entity              : &Entity = null
    current_selected_component  : i32     = 0
    component_infos             := Array[ComponentInfo].create()
}

impl Test {
    new_entity :: (ref Self) -> &Entity {
        // io.printfln("new_entity {}, {}, {}", (next_entity, first_entity, last_entity))
        if next_entity >= max_entities {
            @assert(false)
            return null
        }

        if next_entity < first_entity {
            first_entity = next_entity
        }

        if next_entity >= last_entity {
            last_entity = next_entity + 1
        }
        // io.printfln("           {}, {}, {}", (next_entity, first_entity, last_entity))

        if next_entity >= entities.get_length() {
            entities.add(Entity(
                id          = entities.get_length()
                active      = false
                dead        = false
                position    = vec3()
                size        = vec3(1, 1, 1)
                angle       = 0
                components  = Array[Component].create()
            ))
        }
        entity := &entities[next_entity]
        entity.active   = true
        entity.position = vec3()
        entity.size     = vec3(1, 1, 1)
        entity.angle    = 0
        entity.components.clear()

        while next_entity < entities.get_length() and entities[next_entity].active {
            next_entity += 1
        }

        return entity
    }

    register_component_info :: (ref Self, default_value: $T) {
        ptr := mem.alloc(T)
        <<ptr = default_value
        component_infos.add(ComponentInfo(@type_info(T), ptr))
    }

    render_entity_list :: (ref Self) {
        ImGui.Begin("Inspector")
        ImGui.End()

        if current_entity_index >= 0 and current_entity_index < i32(entities.get_length()) {
            current_entity = &entities.access(current_entity_index)
            self.render_entity_inspector(<<current_entity)
        }

        // render list of entities
        if ImGui.Begin("Hierachy") {
            for i : first_entity .. last_entity {
                e := ref entities[i]
                if !e.dead {
                    ImGui.PushIDInt(i32(i))
                    name := fmt.format("Entity {}", [e.id])

                    list_entry_size := ImGui.ImVec2(0, 0)
                    if ImGui.Selectable(name.as_cstring(), i32(i) == current_entity_index, 0, list_entry_size) {
                        current_entity_index = i32(i)
                    }
                    ImGui.PopID()
                }
            }
        }
        ImGui.End()
    }

    render_entity_inspector :: (ref Self, entity: ref Entity) {
        if ImGui.Begin("Inspector") {
            id_str := fmt.format_any(entity.id)
            ImGui.LabelText("ID", id_str.as_cstring())

            ImGui.Separator()

            // transform
            ImGui.InputFloat3("Position", &entity.position.x)
            ImGui.InputFloat3("Size", &entity.size.x)
            ImGui.InputFloat("angle", &entity.angle, 1, 5)

            ImGui.Separator()

            // render component ui and remove component
            while i := 0, i < entity.components.get_length() {
                index := i

                ImGui.PushIDInt(i32(i))
                b := entity.components[i]
                if !render_component_inspector(b) {
                    ImGui.OpenPopup("Delete Component")
                } else {
                    i += 1
                }

                if ImGui.BeginPopupModal("Delete Component") {
                    ImGui.Text("Are you sure you want to remove this component?")
                    ImGui.Separator()
                    button_size := ImGui.ImVec2(120, 0)
                    if ImGui.Button("Yes", button_size) {
                        ImGui.CloseCurrentPopup()

                        // remove current component
                        // move all following components one slot down
                        for k : index .. entity.components.get_length() - 1 {
                            io.println("ok")
                            entity.components[k] = entity.components[k + 1]
                        }
                        // pop last component which is now in the second last slot
                        entity.components.pop()
                    }
                    ImGui.SameLine()
                    if ImGui.Button("Cancel", button_size) {
                        ImGui.CloseCurrentPopup()
                    }
                    ImGui.EndPopup()
                }
                ImGui.PopID()
                ImGui.Separator()
            }

            { // add component
                button_size := ImGui.ImVec2(0, 0)
                if ImGui.Button("Add Component", button_size) {
                    ImGui.OpenPopup("Add Component")
                }

                popup_size := ImGui.ImVec2(500, 440)
                ImGui.SetNextWindowSize(popup_size, ImGui.ImGuiCond_.FirstUseEver)
                if ImGui.BeginPopupModal("Add Component") {
                    { // list of components
                        list_size := ImGui.ImVec2(150, 0)
                        list_entry_size := ImGui.ImVec2(0, 0)
                        ImGui.BeginChildStr("component list", list_size, true)
                        for bi : component_infos {
                            ImGui.PushIDInt(i32(it_index))
                            name := String.from_string(bi.type_info.kind.Struct.name)

                            if ImGui.Selectable(name.as_cstring(), i32(it_index) == current_selected_component, 0, list_entry_size) {
                                current_selected_component = i32(it_index)
                            }
                            ImGui.PopID()
                        }
                        ImGui.EndChild()
                    }

                    ImGui.SameLine()

                    ImGui.BeginGroup()
                    { // info about selected component
                        info_size := ImGui.ImVec2(0, -ImGui.GetFrameHeightWithSpacing())
                        ImGui.BeginChildStr("component info", info_size, true)

                        if current_selected_component >= 0 and current_selected_component < i32(component_infos.get_length()) {
                            bi := ref component_infos.access(current_selected_component)
                            name := String.from_string(bi.type_info.kind.Struct.name)
                            ImGui.Text(name.as_cstring())
                            ImGui.Separator()

                            for(by_ref=true) m : bi.type_info.kind.Struct.members {
                                imgui_input_property(util.pointer_add(bi.value, m.offset), &m)
                            }
                        }

                        ImGui.EndChild()
                    }

                    { // ok - cancel - buttons
                        button_size := ImGui.ImVec2(120, 0)
                        if ImGui.Button("Ok", button_size) {
                            if current_selected_component >= 0 and current_selected_component < i32(component_infos.get_length()) {
                                // add component
                                bi := ref component_infos.access(current_selected_component)
                                ptr := cast(&void) mem.alloc_raw(u8, cast bi.type_info.size)
                                C.memcpy(ptr, bi.value, cast bi.type_info.size)

                                Trait :: struct {
                                    v_table : &void
                                    value   : &void
                                }
                                b := Trait(bi.type_info.kind.Struct.get_trait_impl(Component).vtable, ptr)

                                entity.add_component2(<<cast(&Component)&b)
                            }

                            ImGui.CloseCurrentPopup()
                        }
                        ImGui.SameLine()
                        if ImGui.Button("Cancel", button_size) {
                            ImGui.CloseCurrentPopup()
                        }
                    }
                    ImGui.EndGroup()
                    ImGui.EndPopup()
                }
            }
        }
        ImGui.End()
    }

    render_component_inspector :: (ref Self, b: Component) -> bool {
        Trait :: struct {
            v_table : &void
            value   : &void
        }
        t := <<cast(&Trait)&b
        ti := b.get_type_info()

        // name of component
        name := String.with_capacity(ti.kind.Struct.name.bytes.length + 1)
        name.append_string(ti.kind.Struct.name)

        open := true
        ImGui.SetNextItemOpen(true, ImGui.ImGuiCond_.Once)
        if ImGui.CollapsingHeader_2(name.as_cstring(), &open) {
            for(by_ref=true) m : ti.kind.Struct.members {
                imgui_input_property(util.pointer_add(t.value, m.offset), &m)
            }
        }

        if !open {
            return false
        }

        return true
    }

    imgui_input_property :: (ref Self, ptr: &void, m: &TypeInfoStructMember) {
        name := String.with_capacity(m.name.bytes.length + 1)
        name.append_string(m.name)

        match m.typ.kind {
            TypeInfoKind.Float -> {
                match m.typ.size {
                    4 -> {
                        ImGui.InputFloat(name.as_cstring(), cast ptr)
                    }
                    8 -> {
                        f := <<cast(&float)ptr
                        ImGui.InputFloat(name.as_cstring(), &f)
                        <<cast(&float)ptr = f
                    }
                }
            }

            _ if m.typ == @type_info(vec3) -> {
                if m.has_attribute("color") {
                    ImGui.ColorEdit3(name.as_cstring(), cast ptr)
                } else {
                    ImGui.InputFloat3(name.as_cstring(), cast ptr)
                }
            }
        }
    }
}

impl ShmupCallbacks for Test {
    init :: (ref Self, engine: ref ShmupEngine) -> bool {
        self.engine = &engine
        entities.reserve(max_entities)

        e := self.new_entity()
        e.add_component(BasicMoveComponent(vec3(1, 0, 0), 1.0f))
        e.add_component(QuadComponent(vec3(1, 1, 1)))

        e2 := self.new_entity()
        e2.position.x = -5
        e2.add_component(QuadComponent(vec3(0, 0, 1)))

        self.register_component_info(BasicMoveComponent(vec3(), 0))
        self.register_component_info(QuadComponent(vec3(1, 1, 1)))
        self.register_component_info(PlayerControlComponent(1))

        return true
    }

    update :: (ref Self, dt: float, input: ref Input) {
        self.render_entity_list()

        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].update(<<engine, dt, input)
            }
        }

        if input.key_down(glfw.GLFW_KEY_LEFT) {
            quad_pos += vec3(-1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_RIGHT) {
            quad_pos += vec3(1, 0) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_UP) {
            quad_pos += vec3(0, 1) * speed * dt
        }
        if input.key_down(glfw.GLFW_KEY_DOWN) {
            quad_pos += vec3(0, -1) * speed * dt
        }

        // if input.key_pressed(glfw.GLFW_KEY_SPACE)  then io.print("v")
        // if input.key_down(glfw.GLFW_KEY_SPACE)     then io.print(".")
        // if input.key_released(glfw.GLFW_KEY_SPACE) then io.println("^")
    }

    render :: (ref Self, renderer: ref Renderer) {
        // set aspect_ratio_axis so that the game world always fits on screen
        if (float(engine.viewport_size.x) / float(engine.viewport_size.y)) > (engine.world_size.x / engine.world_size.y) {
            engine.aspect_ratio_axis = 1
        } else {
            engine.aspect_ratio_axis = 0
        }

        for i : first_entity .. last_entity {
            if entities[i].active {
                entities[i].render(<<engine, renderer)
            }
        }

        renderer.fill_quad(quad_pos, quad_size, 0, vec3(1, 0, 0))

        for(inclusive=true) y : 0 .. count {
            for(inclusive=true) x : 0 .. count {
                rotation := mat4.from_rotation_z(angle / 360.0f * (3.1415f * 2.0f))

                renderer.draw_quad(vec3i(x - count / 2, y - count / 2, 0).change_type(f32) + offset, vec3(scale, scale, 0), angle / 360.0f * (3.1415f * 2.0f), 0.1, color)
            }
        }
    }
}

Main :: () {
    test := Test()

    shmup_engine := ShmupEngine.new()
    shmup_engine.push_layer(test)
    shmup_engine.start()
}
