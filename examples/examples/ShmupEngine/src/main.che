use import std.string
use import std.array
use import std.math
use import std.rc
rand :: import std.random
mem  :: import std.mem.allocator
fmt  :: import std.fmt
io   :: import std.io
C    :: import std.c
util :: import std.util

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding
glfw  :: import glfw.glfw3

use import shmup_engine
use import opengl_utils
use import shader
use import math
use import matrix
use import renderer
use import opengl_buffers
use import input
use import layer
use import entity
use import components

max_entities :: 1024

Test :: struct {
    entities_per_second : int
    color : vec3

    layer : &EntityLayer = null

    alpha := 0.5f
    count := 2

    offset := vec3(0, 0, 0)
    scale  := 0.9f
    angle  := 0.0f

    entities        := Array[Rc[Entity]].create()
    next_entity_id  := 0

    current_entity_index        : i32     = 0
    current_entity              : &Entity = null
    current_selected_component  : i32     = 0
    component_infos             := Array[ComponentInfo].create()
}

impl EntityLayerCallbacks for Test {
    init :: (ref Self, layer: ref EntityLayer) -> bool {
        self.layer = &layer

        e := layer.new_entity()

        e.get().add_component(layer.new_component(KillRandomEntityComponent()))
        // e.get().add_component(KillRandomEntityComponent())
        // e.get().add_component(CreateEntityComponent(color = color, entities_per_second = cast entities_per_second))
        for 0..15 {
            e := layer.new_entity()

            e.get().add_component(layer.new_component(QuadComponent(color)))

            dir := vec3(
                f32(rand.PseudoRandom.next_double() - 0.5)
                f32(rand.PseudoRandom.next_double() - 0.5)
            ).normalized()
            speed := f32(rand.PseudoRandom.next_double())
            e.get().add_component(layer.new_component(BasicMoveComponent(dir, speed)))
        }


        return true
    }

    update :: (ref Self, dt: float) {
        // if input.key_pressed(glfw.GLFW_KEY_SPACE)  then io.print("v")
        // if input.key_down(glfw.GLFW_KEY_SPACE)     then io.print(".")
        // if input.key_released(glfw.GLFW_KEY_SPACE) then io.println("^")
    }

    render :: (ref Self, renderer: ref Renderer) {
        // set aspect_ratio_axis so that the game world always fits on screen
        if (float(layer.engine.viewport_size.x) / float(layer.engine.viewport_size.y)) > (layer.engine.world_size.x / layer.engine.world_size.y) {
            layer.engine.aspect_ratio_axis = 1
        } else {
            layer.engine.aspect_ratio_axis = 0
        }

        for(inclusive=true) y : 0 .. count {
            for(inclusive=true) x : 0 .. count {
                rotation := mat4.from_rotation_z(angle / 360.0f * (3.1415f * 2.0f))

                renderer.draw_quad(vec3i(x - count / 2, y - count / 2, 0).change_type(f32) + offset, vec3(scale, scale, 0), angle / 360.0f * (3.1415f * 2.0f), 0.1, color)
            }
        }
    }

    imgui_render :: (ref Self) {
    }
}

impl Drop for Test {
    drop :: (ref Self) {
        io.printfln("dropping test, {} entities", entities.get_length())
    }
}

Main :: () {
    rand.PseudoRandom.init()

    test  := Test(5, vec3(1, 0, 0))
    test2 := Test(10, vec3(0, 1, 0))

    shmup_engine := ShmupEngine.new()
    shmup_engine.push_entity_layer(String.from_string("test layer"), test)
    // shmup_engine.push_entity_layer(String.from_string("layer 2"), test2)
    shmup_engine.start()
}
