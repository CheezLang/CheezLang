use import std.array
use import std.string
use import std.rc
mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import serpa.serpa
use import compiler.lexer
use import compiler.error_handler

use import shmup_engine
use import math
use import layer
use import input
use import renderer
use import components

#export_scope

Entity :: struct {
    id          : int
    name        : String
    dead        := false
    active      := true
    position    := vec3(0, 0, 0)
    size        := vec3(1, 1, 1)
    angle       := 0.0f
    components  := Array[Rc[Component]].create()
}

impl Entity {
    update :: (ref Self, layer: ref EntityLayer, dt: float) {
        for components {
            it.get().update(self, layer, dt)
        }
    }

    render :: (ref Self, engine: ref ShmupEngine, renderer: ref Renderer) {
        for components {
            it.get().render(self, engine, renderer)
        }
    }

    add_component :: (ref Self, component: Rc[Component]) {
        components.add(component)
    }
}

impl Drop for Entity {
    drop :: (ref Self) {
        // io.printfln("dropping entity {}", id)

        // @todo: drop components
        // for c : components {
        //     value := cast(&void)
        // }
    }
}

impl IParser[Rc[Entity]] for Rc[Entity] {
    parse :: (parser: ref Parser, lexer: ref Lexer, error_handler: &ErrorHandler) -> Option[Self] {
        return match parser.parse(Entity, lexer, error_handler) {
            Some($i) -> Some(Rc[Entity].new(i))
            None -> None
        }
    }
}