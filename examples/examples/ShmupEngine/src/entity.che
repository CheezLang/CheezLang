use import std.array
use import std.rc
mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import shmup_engine
use import math
use import layer
use import input
use import renderer
use import components

#export_scope

Entity :: struct {
    id          : int
    dead        := false
    active      := true
    position    := vec3(0, 0, 0)
    size        := vec3(1, 1, 1)
    angle       := 0.0f
    components  := Array[ComponentData].create()
}

impl Entity {
    update :: (ref Self, layer: ref EntityLayer, dt: float) {
        for components {
            it.component.update(self, layer, dt)
        }
    }

    render :: (ref Self, engine: ref ShmupEngine, renderer: ref Renderer) {
        for components {
            it.component.render(self, engine, renderer)
        }
    }

    add_component :: (ref Self, component: Rc[$T]) {
        entry := ComponentData(
            component = Component(component.get())
            value     = component.change_type(())
            type_info = @type_info(T)
        )
        components.add(entry)
    }

    add_component2 :: (ref Self, c: Component) {
        ptr     := Traits.get_trait_object_value(c, ())
        entry := ComponentData(
            component = c
            value     = Rc[()].from_pointer(ptr, false)
            type_info = c.get_type_info()
        )
        components.add(entry)
    }

    add_component3 :: (ref Self, vtable: &void, rc: Rc[()], type_info: &TypeInfo) {
        entry := ComponentData(
            component = Traits.from_vtable_and_pointer(Component, vtable, &rc.get())
            value     = rc
            type_info = type_info
        )
        components.add(entry)
    }
}

impl Drop for Entity {
    drop :: (ref Self) {
        // io.printfln("dropping entity {}", id)

        // @todo: drop components
        // for c : components {
        //     value := cast(&void)
        // }
    }
}