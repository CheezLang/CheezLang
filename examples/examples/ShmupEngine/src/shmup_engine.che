use import std.string
use import std.array
use import std.math
use import std.time
use import std.rc
use import std.mem.std_heap_allocator
mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
fs  :: import std.io.fs
C   :: import std.c

use import glfw.glfw3
use import opengl.glad_binding
ImGui :: import imgui.imgui_binding

use import opengl_utils
use import layer
use import matrix
use import math
use import renderer
use import input
use import entity
use import components
use import command
use import viewport
use import editor.inspector
use import editor.hierarchy
use import editor.console

#export_scope
EnabledEditors :: struct {
    editor      := true
    stats       := false
    demo_window := true
}

PropertyEdit :: enum #copy {
    EditFloat   : (ptr: &float, name: c_string, step: float)
    EditVec3    : (ptr: &vec3, name: c_string)
    EditColor3  : (ptr: &vec3, name: c_string)
}

EngineMode :: trait {
    reset_input     :: (ref Self);
    release_input   :: (ref Self);
    init            :: (ref Self) -> bool;
    update          :: (ref Self, dt: float);
    render          :: (ref Self, renderer: ref Renderer);
    imgui_render    :: (ref Self);
    on_key_event    :: (ref Self, key: int, action: int, modifiers: int);
    on_enable       :: (ref Self);
}

EngineModeBase :: struct #extendable {
    engine              : &ShmupEngine = null
    layer_stack         := Array[Layer].create()
    projection_matrix   := mat4.id()
}

EditMode :: struct #extend(EngineModeBase) {
}

impl EngineMode for EditMode {
    reset_input :: (ref Self) {

    }

    release_input :: (ref Self) {

    }

    init :: (ref Self) -> bool {
        for layer : layer_stack {
            if !layer.init() {
                io.println("[ERROR] failed to init layer")
                return false
            }
        }

        return true
    }

    update :: (ref Self, dt: float) {
        //
        for view : engine.active_game_views {
            view.update(false, engine.world_size)
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        for view : engine.active_game_views {
            render_gizmos := view.begin_render(false, engine.world_size, renderer)
            for layer : layer_stack {
                layer.render(render_gizmos, renderer)
            }
            if render_gizmos {
                for layer : layer_stack {
                    layer.render_gizmos(renderer)
                }
            }
            view.end_render()
        }
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int, modifiers: int) {
        match key, action, modifiers {
            (GLFW_KEY_L, GLFW_PRESS, GLFW_MOD_CONTROL) -> {
                match ref engine.save_file {
                    Some($file) -> {
                        for layer : layer_stack {
                            layer.load_from_file(file.slice())
                        }
                        engine.console.get().log("Loading layers")
                    }

                    None -> {
                        engine.console.get().log_error("[ERROR] Trying to load layers from file but no file name was specified")
                        io.println("[ERROR] Trying to load layers from file but no file name was specified")
                    }
                }
            }
            (GLFW_KEY_S, GLFW_PRESS, GLFW_MOD_CONTROL) -> {
                match ref engine.save_file {
                    Some($file_name) -> {
                        file_content := String.empty()
                        for layer : layer_stack {
                            layer.save_to_file(ref file_content)
                        }
                        fs.write_file(file_name.slice(), file_content.slice())

                        engine.console.get().log("Saving layers")
                    }

                    None -> {
                        engine.console.get().log_error("[ERROR] Trying to save layers to file but no file name was specified")
                        io.println("[ERROR] Trying to save layers to file but no file name was specified")
                    }
                }
            }
        }
    }

    on_enable :: (ref Self) {

    }
}

PlayMode :: struct #extend(EngineModeBase) {
    paused := false
}

impl PlayMode {
    initialize :: (ref Self, edit_mode: ref EditMode) {
        layer_stack.clear()
        for l : edit_mode.layer_stack {
            match l.clone() {
                Some($l) -> {
                    layer_stack.add(l)
                }
            }
        }
        self.init()
    }
}

impl EngineMode for PlayMode {
    reset_input :: (ref Self) {
        for layer : layer_stack do layer.get_input().reset()
    }

    release_input :: (ref Self) {
        for layer : layer_stack do layer.get_input().release_all_keys()
    }

    init :: (ref Self) -> bool {
        for layer : layer_stack {
            if !layer.init() {
                return false
            }
        }

        return true
    }

    update :: (ref Self, dt: float) {
        if engine.global_input.key_pressed(GLFW_KEY_F6) {
            paused = !paused
        }

        //
        update_layers := false
        for view : engine.active_game_views {
            if view.update(!paused, engine.world_size) {
                update_layers = true
            }
        }

        if update_layers {
            for layer : layer_stack {
                layer.update(dt)
            }
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        for view : engine.active_game_views {
            render_gizmos := view.begin_render(!paused, engine.world_size, renderer)
            for layer : layer_stack {
                layer.render(render_gizmos, renderer)
            }
            if render_gizmos {
                for layer : layer_stack {
                    layer.render_gizmos(renderer)
                }
            }
            view.end_render()
        }
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int, modifiers: int) {
        if engine.game_viewport.is_focused {
            match (action, key) {
                (GLFW_PRESS, $keycode) -> {
                    engine.game_input.set_key_state(keycode, true)
                }
                (GLFW_RELEASE, $keycode) -> {
                    engine.game_input.set_key_state(keycode, false)
                }
            }

            match (action, key) {
                ($action, $keycode) -> {
                    for(reverse=true) layer : layer_stack {
                        if layer.on_key_event(int(key), int(action)) {
                            break
                        }
                    }
                }
            }
        }
    }

    on_enable :: (ref Self) {
        paused = false
    }
}

Editor :: struct {
}

ShmupEngine :: struct {
    // engine stuff
    projection_matrix   := mat4.id()
    aspect_ratio_axis   := 1.0f
    world_size          := vec3(10, 10, 0)

    current_engine_mode : EngineMode = null
    current_mode_base   : &EngineModeBase = null
    edit_mode           := EditMode()
    play_mode           := PlayMode()

    // io stuff
    global_input        : &Input = null
    game_input          : &Input = null

    // editor stuff
    editor              : Editor = default
    enabled_editors     : EnabledEditors = default
    current_fps         := 0
    current_frame_time  := 0.0
    clear_color         := vec4(0, 0, 0, 1)
    properties_to_edit  := Array[PropertyEdit].create()
    inspector           : EntityInspector = default
    hierarchy           : Hierarchy = default
    current_layer_index : i32 = 0
    console             := Rc[Console].empty()
    editor_edit_mode_color := vec3()
    editor_play_mode_color := vec3(0.027f, 0.2f, 0.047f)
    save_file           := Option[String].None

    game_and_editor_window  : GameAndEditorWindow = default
    game_window             : GameWindow          = default
    editor_window           : EditorWindow        = default
    game_viewport           : &Viewport           = null
    editor_viewport         : &Viewport           = null

    game_views              : [3]GameView = default
    active_game_views       : []GameView  = default

    // window stuff
    glfw_window         : &GLFWwindow = null
    vsync_enabled       := true
    window_size         := vec2i(0, 0)

    // rendering stuff
    renderer : &Renderer = null

    viewport_size_max : vec2i = default
}

impl ShmupEngine {
    new :: () -> &ShmupEngine {
        ptr := mem.alloc(ShmupEngine)
        <<ptr = ShmupEngine()

        // setup modes
        ptr.edit_mode.engine = ptr
        ptr.play_mode.engine = ptr
        ptr.current_engine_mode = ptr.edit_mode
        ptr.current_mode_base = cast &ptr.edit_mode

        return ptr
    }

    start :: (ref Self) {
        on_framebuffer_resize :: (window: &GLFWwindow, w: i32, h: i32) {
            engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)
            engine.window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        glfwSetErrorCallback(glfw_error_callback)

        // initialize glfw
        if !glfwInit() {
            io.println("[ERROR] Failed to initialize GLFW")
            return
        }
        defer glfwTerminate()

        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)
        glfwWindowHint(GLFW_VISIBLE, 0)
        glfwWindowHint(GLFW_MAXIMIZED, 1)
        glfwWindowHint(GLFW_RESIZABLE, 1)

        vidmode := glfwGetVideoMode(glfwGetPrimaryMonitor())
        io.printfln("[LOG] primary monitor size: {} x {}", (vidmode.width, vidmode.height))
        glfw_window = glfwCreateWindow(vidmode.width, vidmode.height, "Hello World", null, null)
        // glfw_window = glfwCreateWindow(1280, 720, "Hello World", null, null)
        if glfw_window == null {
            io.println("[ERROR] Failed to create window")
            return
        }
        defer glfwDestroyWindow(glfw_window)

        glfwMakeContextCurrent(glfw_window)
        glfwSetWindowUserPointer(glfw_window, &self)
        glfwSwapInterval(if vsync_enabled then 1 else 0)

        // initialize glad
        if gladLoadGL() != 1 {
            return
        }
        { // get opengl version
            opengl_version := glGetString(GL_VERSION)
            io.printfln("[LOG] OpenGL version: {}", string(opengl_version, cast C.strlen(cast opengl_version)))
        }

        glfwShowWindow(glfw_window)

        // get initial size
        {
            w : i32 = 0
            h : i32 = 0
            glfwGetFramebufferSize(glfw_window, &w, &h)
            window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        // register callbacks
        glfwSetKeyCallback(glfw_window, glfw_key_callback)
        glfwSetFramebufferSizeCallback(glfw_window, on_framebuffer_resize)

        // initialize imgui
        if !init_imgui(glfw_window) {
            return
        }
        defer shutdown_imgui()

        viewport_size_max.x = int(vidmode.width)
        viewport_size_max.y = int(vidmode.height)
        if !initialize_viewport() {
            io.println("[ERROR] Failed to create frame buffer for viewport")
            return
        }

        // setup renderer
        global_input = Input.new()
        game_input   = Input.new()
        renderer     = Renderer.create()

        // setup editors
        hierarchy.engine = &self
        console = Rc[Console].new(Console.new(cast self.on_command))
        
        {
            bg := ImGui.GetStyle().Colors[int(ImGui.ImGuiCol_.WindowBg)]
            editor_edit_mode_color = vec3(bg.x, bg.y, bg.z)
            self.set_editor_background_color(editor_edit_mode_color)
        }

        render_loop()
    }

    initialize_viewport :: (ref Self) -> bool {
        game_and_editor_window.engine = &self
        game_window.engine            = &self
        editor_window.engine          = &self
        game_views[0] = game_and_editor_window
        game_views[1] = game_window
        game_views[2] = editor_window
        game_viewport = &game_window.viewport

        active_game_views = @cast([]GameView, game_views)[0..3]

        for view : @cast([]GameView, game_views) {
            if !view.initialize(viewport_size_max) {
                return false
            }
        }

        return true
    }

    glfw_key_callback :: (window: &GLFWwindow, key: i32, scancode: i32, action: i32, mods: i32) {
        engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)

        match (action, key, mods) {
            (GLFW_PRESS, GLFW_KEY_F12, _) -> {
                engine.enabled_editors.editor = !engine.enabled_editors.editor
                return
            }

            (GLFW_PRESS, GLFW_KEY_F5, _) -> {
                engine.toggle_play_mode()
                return
            }

            (GLFW_PRESS, $keycode, _) -> {
                engine.global_input.set_key_state(keycode, true)
            }
            (GLFW_RELEASE, $keycode, _) -> {
                engine.global_input.set_key_state(keycode, false)
            }
        }

        engine.current_engine_mode.on_key_event(int(key), int(action), int(mods))
    }

    render_loop :: (ref Self) {
        self.register_builtin_components()
        if !current_engine_mode.init() {
            io.println("[ERROR] Failed to initialize edit/play mode")
            return
        }

        self.push_gizmos_layer(String.from_string("Gizmos"))

        last_frame_time := get_time_microseconds()

        frame_timer := 0.0
        fps_counter := 0

        loop {
            if glfwWindowShouldClose(glfw_window) then break
            // handle time
            this_frame_time     := get_time_microseconds()
            last_frame_duration := this_frame_time - last_frame_time
            last_frame_time = this_frame_time

            // convert time from microseconds to seconds
            delta_time := float(double(last_frame_duration) * 0.000001)
            current_frame_time = delta_time
            frame_timer += delta_time
            fps_counter += 1

            if frame_timer >= 1 {
                current_fps = fps_counter
                frame_timer -= 1
                fps_counter = 0
            }

            // start rendering
            if enabled_editors.editor {
                frame_with_editor(delta_time)
            } else {
                frame_without_editor(delta_time)
            }
            
            glfwSwapBuffers(glfw_window)
        }
    }

    frame_without_editor :: (ref Self, delta_time: float) {
        // // handle events and input
        // global_input.reset()
        // game_input.reset()
        // current_engine_mode.reset_input()
        // glfwPollEvents()

        // viewport_size = window_size
        // GL(glViewport(0, 0, cast viewport_size.x, cast viewport_size.y))

        // glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w)
        // glClear(GL_COLOR_BUFFER_BIT)

        // self.update_projection_matrix(viewport_size.change_type(f32))
        
        // // update mode
        // current_engine_mode.update(delta_time)

        // // render mode
        // renderer.begin_scene(projection_matrix)
        // current_engine_mode.render(<<renderer)
        // renderer.draw_quad(vec3(0, 0, 0), world_size, 0, 0.1)
        // // renderer.end_scene()
    }

    frame_with_editor :: (ref Self, delta_time: float) {
        glClearColor(1, 0, 1, 1)
        glClear(GL_COLOR_BUFFER_BIT)
        imgui_begin_frame()

        create_dock_space()

        // handle events and input
        global_input.reset()
        game_input.reset()
        current_engine_mode.reset_input()
        glfwPollEvents()
        if game_viewport.lost_focused {
            // release all keys in all layers
            game_input.release_all_keys()
            current_engine_mode.release_input()
        }

        // render imgui gui
        render_menu_bar()
        render_editor()

        current_engine_mode.update(delta_time)
        current_engine_mode.render(<<renderer)

        // for view : active_game_views {
        //     // io.println(fmt.format("{}", [game_viewport.projection_matrix]))
        //     if view.update(true, world_size, aspect_ratio_axis) {
        //         current_engine_mode.update(delta_time)
        //     }
        //     view.begin_render(world_size, <<renderer)
        //     // renderer.begin_scene(projection_matrix)
        //     current_engine_mode.render(<<renderer)
        //     view.end_render()
        // }

        // end frame
        imgui_end_frame()
    }

    render_menu_bar :: (ref Self) {
        if ImGui.BeginMainMenuBar() {
            if ImGui.BeginMenu("File") {
                // ShowExampleMenuFile()
                ImGui.EndMenu()
            }
            if ImGui.BeginMenu("Edit") {
                if (ImGui.MenuItem("Undo", "CTRL+Z")) {}
                if (ImGui.MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item
                ImGui.Separator()
                if (ImGui.MenuItem("Cut", "CTRL+X")) {}
                if (ImGui.MenuItem("Copy", "CTRL+C")) {}
                if (ImGui.MenuItem("Paste", "CTRL+V")) {}
                ImGui.EndMenu()
            }

            if ImGui.BeginMenu("Debug") {
                if ImGui.MenuItem_2("Show Stats", null, &enabled_editors.stats, true) {}
                if ImGui.MenuItem_2("Show Demo Menu", null, &enabled_editors.demo_window, true) {}
                ImGui.EndMenu()
            }

            ImGui.EndMainMenuBar()
        }
    }

    render_editor :: (ref Self) {
        if enabled_editors.demo_window {
            ImGui.ShowDemoWindow(&enabled_editors.demo_window)
        }

        if enabled_editors.stats {
            ImGui.SetNextWindowBgAlpha(0.35f) // Transparent background
            overlay_flags := @bin_or(
                // ImGui.ImGuiWindowFlags_.NoTitleBar,
                // ImGui.ImGuiWindowFlags_.NoSavedSettings,
                ImGui.ImGuiWindowFlags_.NoCollapse,
                ImGui.ImGuiWindowFlags_.NoDocking,
                ImGui.ImGuiWindowFlags_.NoResize,
                ImGui.ImGuiWindowFlags_.AlwaysAutoResize,
                ImGui.ImGuiWindowFlags_.NoFocusOnAppearing,
                ImGui.ImGuiWindowFlags_.NoNav)
            if ImGui.Begin("Stats", &enabled_editors.stats, overlay_flags) {
                // viewport dimensions
                dimensions := fmt.format("{} x {}", [game_viewport.size.x, game_viewport.size.y])
                ImGui.LabelText("Viewport Dimensions", dimensions.as_cstring())
                ImGui.LabelText("Viewport focused", if game_viewport.is_focused then "true" else "false")
                ImGui.Separator()

                // show fps
                delta_time_str := fmt.format_any(current_frame_time)
                ImGui.LabelText("Frame duration", delta_time_str.as_cstring())
                fps_counted_str := fmt.format_any(current_fps)
                ImGui.LabelText("FPS", fps_counted_str.as_cstring())

            }
            ImGui.End()
        }

        { // general game properties
            if ImGui.Begin("Game Settings") {
                // render settings
                ImGui.Text("Render Settings")
                if ImGui.Checkbox("VSync", &vsync_enabled) {
                    glfwSwapInterval(if vsync_enabled then 1 else 0)
                }
                ImGui.ColorEdit3("clear color", &clear_color.x, 0)
                ImGui.ColorEdit3("play mode editor background", &editor_play_mode_color.x, 0)
                ImGui.Separator()

                // camera settings
                ImGui.Text("Camera Settings")
                ImGui.InputFloat2("World Size", &world_size.x)
                ImGui.SliderFloat("Camera Aspect Ratio Axis", &aspect_ratio_axis, 0, 1)
            }
            ImGui.End()
        }

        if ImGui.Begin("Values") {
            for p : properties_to_edit {
                match p {
                    PropertyEdit.EditFloat($e) -> {
                        ImGui.InputFloat(e.name, e.ptr, e.step, e.step * 5)
                    }
                    PropertyEdit.EditVec3($e) -> {
                        ImGui.InputFloat3(e.name, cast e.ptr)
                    }
                    PropertyEdit.EditColor3($e) -> {
                        ImGui.ColorEdit3(e.name, cast e.ptr)
                    }
                }
            }
        }

        { // layers
            if ImGui.Begin("Layers") {
                for l : current_mode_base.layer_stack {
                    list_entry_size := ImGui.ImVec2(0, 0)
                    if ImGui.Selectable(l.get_name(), current_layer_index == i32(it_index), 0, list_entry_size) {
                        current_layer_index = i32(it_index)
                    }
                }
            }
            ImGui.End()
        }

        if current_layer_index >= 0 and current_layer_index < i32(current_mode_base.layer_stack.get_length()) {
            hierarchy.set_layer(current_mode_base.layer_stack[int(current_layer_index)])
        }

        inspector.render()
        hierarchy.render()
        console.get().render()

        ImGui.End()
    }

    edit_property :: (ref Self, edit: PropertyEdit) {
        properties_to_edit.add(edit)
    }
}

impl ShmupEngine {
    register_builtin_components :: (ref Self) {
        self.inspector.register_component_info(PathFollowComponent())
        self.inspector.register_component_info(BasicMoveComponent(vec3(), 0))
        self.inspector.register_component_info(QuadComponent(vec3(1, 1, 1)))
        self.inspector.register_component_info(PlayerControlComponent(1))
    }

    push_entity_layer :: (ref Self, name: String, callbacks: EntityLayerCallbacks) {
        ptr := mem.alloc(EntityLayer)
        <<ptr = EntityLayer.new(name, callbacks, self, <<Input.new())
        current_mode_base.layer_stack.add(<<ptr)
    }

    push_gizmos_layer :: (ref Self, name: String) {
        ptr := mem.alloc(GizmosLayer)
        <<ptr = GizmosLayer.new(name, null, self, <<Input.new())
        current_mode_base.layer_stack.add(<<ptr)
    }

    update_projection_matrix :: (ref Self, viewport_size: vec2) {
        size    := viewport_size.change_type(f32)

        height1 := world_size.y
        width1  := height1 * size.x / size.y

        width2  := world_size.x
        height2 := width2 * size.y / size.x

        width   := aspect_ratio_axis * width1  + (1 - aspect_ratio_axis) * width2
        height  := aspect_ratio_axis * height1 + (1 - aspect_ratio_axis) * height2

        projection_matrix = mat4.orthographic(-width * 0.5, width * 0.5, -height * 0.5, height * 0.5, -10, 10)
    }

    on_command :: (ref Self, cmd: ref Command) {
        match cmd {
            Command.Quit -> {
                glfwSetWindowShouldClose(glfw_window, 1)
            }

            Command.EnterPlayMode -> {
                enter_play_mode()
            }

            Command.StopPlayMode -> {
                exit_play_mode()
            }

            $c -> {
                io.println(fmt.format("Can't execute command {}", [c]))
            }
        }
    }

    toggle_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&play_mode) {
            exit_play_mode()
        } else {
            enter_play_mode()
        }
    }

    enter_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&play_mode) {
            console.get().log("Already in play mode")
            return
        }
        console.get().log("Entering play mode")

        play_mode.initialize(edit_mode)
        current_engine_mode = play_mode
        current_mode_base = cast &play_mode
        current_engine_mode.on_enable()

        set_editor_background_color(editor_play_mode_color)
    }

    exit_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&edit_mode) {
            console.get().log("Already in edit mode")
            return
        }

        console.get().log("Exiting play mode")
        current_engine_mode = edit_mode
        current_mode_base = cast &edit_mode
        current_engine_mode.on_enable()

        set_editor_background_color(editor_edit_mode_color)
    }

    set_editor_background_color :: (ref Self, col: vec3) {
        ImGui.GetStyle().Colors[int(ImGui.ImGuiCol_.WindowBg)] = ImGui.ImVec4(col.x, col.y, col.z, 1)
    }
}

#file_scope

imgui_begin_frame :: () {
    ImGui.ImGui_ImplOpenGL3_NewFrame()
    ImGui.ImGui_ImplGlfw_NewFrame()
    ImGui.NewFrame()
}

imgui_end_frame :: () {
    io := ImGui.GetIO()

    // rendering
    ImGui.EndFrame()
    ImGui.Render()
    ImGui.ImGui_ImplOpenGL3_RenderDrawData(ImGui.GetDrawData())

    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.ViewportsEnable)) != 0 {	
        backup_current_context := glfwGetCurrentContext()
        ImGui.UpdatePlatformWindows()
        ImGui.RenderPlatformWindowsDefault()
        glfwMakeContextCurrent(backup_current_context)
    }
}

init_imgui :: (window: &GLFWwindow) -> bool {
    context := ImGui.CreateContext(null)

    if context == null {
        io.println("[ERROR] ImGui.CreateContext failed")
        return false
    }

    imgui_io := ref ImGui.GetIO()
    imgui_io.ConfigWindowsMoveFromTitleBarOnly = true
    imgui_io.ConfigFlags = @bin_or(
        imgui_io.ConfigFlags,
        i32(ImGui.ImGuiConfigFlags_.DockingEnable),
        i32(ImGui.ImGuiConfigFlags_.ViewportsEnable))

    ImGui.StyleColorsDark(null)

    // change corners so they are right angles instead of rounded
    style := ref ImGui.GetStyle()	
    style.WindowRounding = 0.0	

    //
    if !ImGui.ImGui_ImplGlfw_InitForOpenGL(window, true) {
        io.println("[ERROR] ImGui.ImGui_ImplGlfw_InitForOpenGL failed")
        return false
    }
    if !ImGui.ImGui_ImplOpenGL3_Init("#version 330") {
        io.println("[ERROR] ImGui.ImGui_ImplOpenGL3_Init failed")
        return false
    }

    return true
}

shutdown_imgui :: () {
    ImGui.ImGui_ImplOpenGL3_Shutdown()
    ImGui.ImGui_ImplGlfw_Shutdown()
    ImGui.DestroyContext(null)
}

create_dock_space :: () {
    dockspace_flags := ImGui.ImGuiDockNodeFlags_.None
    window_flags    := @bin_or(ImGui.ImGuiWindowFlags_.MenuBar, ImGui.ImGuiWindowFlags_.NoDocking)

    opt_fullscreen := true
    if opt_fullscreen {
        pivot := ImGui.ImVec2(0, 0)

        viewport := ImGui.GetMainViewport()
        ImGui.SetNextWindowPos(viewport.Pos, 0, pivot)
        ImGui.SetNextWindowSize(viewport.Size)
        ImGui.SetNextWindowViewport(viewport.ID)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowRounding, 0.0f)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowBorderSize, 0.0f)
        window_flags = @bin_or(
            window_flags,
            ImGui.ImGuiWindowFlags_.NoTitleBar,
            ImGui.ImGuiWindowFlags_.NoCollapse,
            ImGui.ImGuiWindowFlags_.NoResize,
            ImGui.ImGuiWindowFlags_.NoMove,
            ImGui.ImGuiWindowFlags_.NoBringToFrontOnFocus,
            ImGui.ImGuiWindowFlags_.NoNavFocus
        )
    }

    // When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background 
    // and handle the pass-thru hole, so we ask Begin() to not render a background.
    if int(@bin_and(dockspace_flags, ImGui.ImGuiDockNodeFlags_.PassthruCentralNode)) != 0 {
        window_flags = @bin_or(window_flags, ImGui.ImGuiWindowFlags_.NoBackground)
    }

    // Important: note that we proceed even if Begin() returns false (aka window is collapsed).
    // This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,
    // all active windows docked into it will lose their parent and become undocked.
    // We cannot preserve the docking relationship between an active window and an inactive docking, otherwise
    // any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
    window_padding := ImGui.ImVec2(0.0f, 0.0f)
    ImGui.PushStyleVarVec(ImGui.ImGuiStyleVar_.WindowPadding, window_padding)

    open := true
    ImGui.Begin("DockSpace Demo", &open, window_flags)
    ImGui.PopStyleVar()

    if opt_fullscreen then ImGui.PopStyleVar(2)

    // DockSpace
    io := ref ImGui.GetIO()
    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.DockingEnable)) != 0 {
        dockspace_id := ImGui.GetID("MyDockSpace")
        size := ImGui.ImVec2(0.0f, 0.0f)
        ImGui.DockSpace(dockspace_id, size, dockspace_flags)
    } else {
        @assert(false)
    }

    ImGui.End()
}

ShowExampleMenuFile :: () {
    //     ImGui.MenuItem("(dummy menu)", null, false, false)
    //     if ImGui.MenuItem("New") {}
    //     if ImGui.MenuItem("Open", "Ctrl+O") {}
    //     if ImGui.BeginMenu("Open Recent") {
    //         ImGui.MenuItem("fish_hat.c")
    //         ImGui.MenuItem("fish_hat.inl")
    //         ImGui.MenuItem("fish_hat.h")
    //         if ImGui.BeginMenu("More..") {
    //             ImGui.MenuItem("Hello")
    //             ImGui.MenuItem("Sailor")
    //             if ImGui.BeginMenu("Recurse..") {
    //                 ShowExampleMenuFile()
    //                 ImGui.EndMenu()
    //             }
    //             ImGui.EndMenu()
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.MenuItem("Save", "Ctrl+S")) {}
    //     if (ImGui.MenuItem("Save As..")) {}
    //     ImGui.Separator()
    //     if ImGui.BeginMenu("Options") {
    //         enabled := true #static
    //         ImGui.MenuItem_2("Enabled", "", &enabled)

    //         size := ImGui.ImVec2(0, 60)
    //         ImGui.BeginChild("child", size, true)

    //         for i : 0..10 {
    //             text := fmt.format("Scrolling Text {}", [i])
    //             ImGui.Text(text.as_cstring())
    //         }
    //         ImGui.EndChild()
    //         f := 0.5f #static
    //         n := 0i32 #static
    //         b := true #static
    //         ImGui.SliderFloat("Value", &f, 0.0f, 1.0f)
    //         ImGui.InputFloat("Input", &f, 0.1f)
    //         ImGui.Combo_2("Combo", &n, "Yes\0No\0Maybe\0\0")
    //         ImGui.Checkbox("Check", &b)
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Colors"))
    //     {
    //         sz := ImGui.GetTextLineHeight()
    //         for i : 0..int(ImGui.ImGuiCol_.COUNT) {
    //             name := ImGui.GetStyleColorName(cast i)
    //             p := ImGui.GetCursorScreenPos()
    //             // ImGui.GetWindowDrawList().AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui.GetColorU32((ImGuiCol)i))
    //             size := ImGui.ImVec2(sz, sz)
    //             ImGui.Dummy(size)
    //             ImGui.SameLine()
    //             ImGui.MenuItem(name)
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Disabled", false)) {
    //         @assert(false)
    //     }
    //     if (ImGui.MenuItem("Checked", null, true)) {}
    //     if (ImGui.MenuItem("Quit", "Alt+F4")) {}
}