use import std.string
use import std.array
use import std.math
use import std.time
use import std.rc
use import std.mem.std_heap_allocator
mem :: import std.mem.allocator
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c

use import glfw.glfw3
use import opengl.glad_binding
ImGui :: import imgui.imgui_binding

use import opengl_utils
use import layer
use import math
use import renderer
use import input
use import entity
use import components
use import command
use import editor.inspector
use import editor.hierarchy
use import editor.console

#export_scope
EnabledEditors :: struct {
    editor      := true
    stats       := true
    demo_window := true
}

PropertyEdit :: enum #copy {
    EditFloat   : (ptr: &float, name: c_string, step: float)
    EditVec3    : (ptr: &vec3, name: c_string)
    EditColor3  : (ptr: &vec3, name: c_string)
}

EngineMode :: trait {
    reset_input     :: (ref Self);
    release_input   :: (ref Self);
    init            :: (ref Self);
    update          :: (ref Self, dt: float);
    render          :: (ref Self, renderer: ref Renderer);
    imgui_render    :: (ref Self);
    on_key_event    :: (ref Self, key: int, action: int);
}

EngineModeBase :: struct #extendable {
    engine              : &ShmupEngine = null
    layer_stack         := Array[Layer].create()
    projection_matrix   := mat4.id()
    aspect_ratio_axis   := 1.0f
}

EditMode :: struct #extend(EngineModeBase) {
}

impl EngineMode for EditMode {
    reset_input :: (ref Self) {

    }

    release_input :: (ref Self) {

    }

    init :: (ref Self) {
        for layer : layer_stack {
            if !layer.init() {
                return
            }
        }
    }

    update :: (ref Self, dt: float) {

    }

    render :: (ref Self, renderer: ref Renderer) {
        for layer : layer_stack {
            layer.render(renderer)
        }
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int) {
    }
}

PlayMode :: struct #extend(EngineModeBase) {
}

impl PlayMode {
    initialize :: (ref Self, edit_mode: ref EditMode) {
        layer_stack.clear()
        for l : edit_mode.layer_stack {
            match l.clone() {
                Some($l) -> {
                    layer_stack.add(l)
                }
            }
        }
        self.init()
    }
}

impl EngineMode for PlayMode {
    reset_input :: (ref Self) {
        for layer : layer_stack do layer.get_input().reset()
    }

    release_input :: (ref Self) {
        for layer : layer_stack do layer.get_input().release_all_keys()
    }

    init :: (ref Self) {
        for layer : layer_stack {
            if !layer.init() {
                return
            }
        }
    }

    update :: (ref Self, dt: float) {
        for layer : layer_stack {
            layer.update(dt)
        }
    }

    render :: (ref Self, renderer: ref Renderer) {
        for layer : layer_stack {
            layer.render(renderer)
        }
    }

    imgui_render :: (ref Self) {

    }

    on_key_event :: (ref Self, key: int, action: int) {
        if engine.viewport_is_focused {
            match (action, key) {
                (GLFW_PRESS, $keycode) -> {
                    engine.game_input.set_key_state(keycode, true)
                }
                (GLFW_RELEASE, $keycode) -> {
                    engine.game_input.set_key_state(keycode, false)
                }
            }

            match (action, key) {
                ($action, $keycode) -> {
                    for(reverse=true) layer : layer_stack {
                        if layer.on_key_event(int(key), int(action)) {
                            break
                        }
                    }
                }
            }
        }
    }
}

ShmupEngine :: struct {
    // engine stuff
    // layer_stack         := Array[Layer].create()
    projection_matrix   := mat4.id()
    aspect_ratio_axis   := 1.0f
    world_size          := vec3(10, 10, 0)

    current_engine_mode : EngineMode = null
    current_mode_base   : &EngineModeBase = null
    edit_mode           := EditMode()
    play_mode           := PlayMode()

    // io stuff
    global_input        : &Input = null
    game_input          : &Input = null

    // editor stuff
    enabled_editors     : EnabledEditors = default
    current_fps         := 0
    current_frame_time  := 0.0
    clear_color         := vec4(0, 0, 0, 1)
    properties_to_edit  := Array[PropertyEdit].create()
    inspector           : EntityInspector = default
    hierarchy           : Hierarchy = default
    current_layer_index : i32 = 0
    console             := Rc[Console].empty()
    editor_edit_mode_color := vec3()
    editor_play_mode_color := vec3(0.027f, 0.2f, 0.047f)

    // window stuff
    glfw_window         : &GLFWwindow = null
    vsync_enabled       := true
    window_size         := vec2i(0, 0)

    // viewport stuff
    viewport_size_max       := vec2i(0, 0)
    viewport_size           := vec2i(0, 0)
    viewport_frame_buffer   : u32 = 0
    viewport_render_texture : u32 = 0
    viewport_depth_texture  : u32 = 0
    viewport_is_focused     := false
    viewport_lost_focused   := false

    // rendering stuff
    renderer : &Renderer = null
}

impl ShmupEngine {
    new :: () -> &ShmupEngine {
        ptr := mem.alloc(ShmupEngine)
        <<ptr = ShmupEngine()

        // setup modes
        ptr.edit_mode.engine = ptr
        ptr.play_mode.engine = ptr
        ptr.current_engine_mode = ptr.edit_mode
        ptr.current_mode_base = cast &ptr.edit_mode

        return ptr
    }

    start :: (ref Self) {
        on_framebuffer_resize :: (window: &GLFWwindow, w: i32, h: i32) {
            engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)
            engine.window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        glfwSetErrorCallback(glfw_error_callback)

        // initialize glfw
        if !glfwInit() {
            io.println("[ERROR] Failed to initialize GLFW")
            return
        }
        defer glfwTerminate()

        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)
        glfwWindowHint(GLFW_VISIBLE, 0)
        glfwWindowHint(GLFW_MAXIMIZED, 0)
        glfwWindowHint(GLFW_RESIZABLE, 1)

        vidmode := glfwGetVideoMode(glfwGetPrimaryMonitor())
        io.printfln("[LOG] primary monitor size: {} x {}", (vidmode.width, vidmode.height))
        // glfw_window = glfwCreateWindow(vidmode.width, vidmode.height, "Hello World", null, null)
        glfw_window = glfwCreateWindow(1280, 720, "Hello World", null, null)
        if glfw_window == null {
            io.println("[ERROR] Failed to create window")
            return
        }
        defer glfwDestroyWindow(glfw_window)

        glfwMakeContextCurrent(glfw_window)
        glfwSetWindowUserPointer(glfw_window, &self)
        glfwSwapInterval(if vsync_enabled then 1 else 0)

        // initialize glad
        if gladLoadGL() != 1 {
            return
        }
        { // get opengl version
            opengl_version := glGetString(GL_VERSION)
            io.printfln("[LOG] OpenGL version: {}", string(opengl_version, cast C.strlen(cast opengl_version)))
        }

        glfwShowWindow(glfw_window)

        // get initial size
        {
            w : i32 = 0
            h : i32 = 0
            glfwGetFramebufferSize(glfw_window, &w, &h)
            window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        // register callbacks
        glfwSetKeyCallback(glfw_window, glfw_key_callback)
        glfwSetFramebufferSizeCallback(glfw_window, on_framebuffer_resize)

        // initialize imgui
        if !init_imgui(glfw_window) {
            return
        }
        defer shutdown_imgui()

        viewport_size_max.x = int(vidmode.width)
        viewport_size_max.y = int(vidmode.height)
        if !initialize_viewport() {
            io.println("[ERROR] Failed to create frame buffer for viewport")
            return
        }

        // setup renderer
        global_input = Input.new()
        game_input   = Input.new()
        renderer     = Renderer.create()

        // setup editors
        hierarchy.engine = &self
        console = Rc[Console].new(Console.new(cast self.on_command))
        
        {
            bg := ImGui.GetStyle().Colors[int(ImGui.ImGuiCol_.WindowBg)]
            editor_edit_mode_color = vec3(bg.x, bg.y, bg.z)
            self.set_editor_background_color(editor_edit_mode_color)
        }

        render_loop()
    }

    initialize_viewport :: (ref Self) -> bool {
        texture_width := i32(viewport_size_max.x)
        texture_height := i32(viewport_size_max.y)

        // The framebuffer, which regroups 0, 1, or more textures, and 0 or 1 depth buffer.
        GL(glGenFramebuffers(1, &viewport_frame_buffer))
        GL(glBindFramebuffer(GL_FRAMEBUFFER, viewport_frame_buffer))

        // The texture we're going to render to
        GL(glGenTextures(1, &viewport_render_texture))

        // "Bind" the newly created texture : all future texture functions will modify this texture
        GL(glBindTexture(GL_TEXTURE_2D, viewport_render_texture))

        // Give an empty image to OpenGL ( the last "null" )
        GL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, texture_width, texture_height, 0, GL_RGB, GL_UNSIGNED_BYTE, null))

        // Poor filtering. Needed !
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST))
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST))

        // The depth buffer
        GL(glGenRenderbuffers(1, &viewport_depth_texture))
        GL(glBindRenderbuffer(GL_RENDERBUFFER, viewport_depth_texture))
        GL(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, texture_width, texture_height))
        GL(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, viewport_depth_texture))

        // Set "viewport_render_texture" as our colour attachement #0
        GL(glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, viewport_render_texture, 0))

        // Set the list of draw buffers.
        draw_buffers := [u32(GL_COLOR_ATTACHMENT0)]
        GL(glDrawBuffers(1, draw_buffers.data)) // "1" is the size of draw_buffers

        // Always check that our framebuffer is ok
        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE {
            return false
        }

        glBindTexture(GL_TEXTURE_2D, 0)
        glBindRenderbuffer(GL_RENDERBUFFER, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        return true
    }

    glfw_key_callback :: (window: &GLFWwindow, key: i32, scancode: i32, action: i32, mods: i32) {
        engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)

        match (action, key, mods) {
            (GLFW_PRESS, GLFW_KEY_F12, _) -> {
                engine.enabled_editors.editor = !engine.enabled_editors.editor
                return
            }

            (GLFW_PRESS, GLFW_KEY_F5, _) -> {
                engine.toggle_play_mode()
                return
            }

            (GLFW_PRESS, $keycode, _) -> {
                engine.global_input.set_key_state(keycode, true)
            }
            (GLFW_RELEASE, $keycode, _) -> {
                engine.global_input.set_key_state(keycode, false)
            }
        }

        engine.current_engine_mode.on_key_event(int(key), int(action))
    }

    render_loop :: (ref Self) {
        current_engine_mode.init()

        last_frame_time := get_time_microseconds()

        frame_timer := 0.0
        fps_counter := 0

        loop {
            if glfwWindowShouldClose(glfw_window) then break
            // handle time
            this_frame_time     := get_time_microseconds()
            last_frame_duration := this_frame_time - last_frame_time
            last_frame_time = this_frame_time

            // convert time from microseconds to seconds
            delta_time := float(double(last_frame_duration) * 0.000001)
            current_frame_time = delta_time
            frame_timer += delta_time
            fps_counter += 1

            if frame_timer >= 1 {
                current_fps = fps_counter
                frame_timer -= 1
                fps_counter = 0
            }

            // start rendering
            if enabled_editors.editor {
                frame_with_editor(delta_time)
            } else {
                frame_without_editor(delta_time)
            }
            
            glfwSwapBuffers(glfw_window)
        }
    }

    frame_without_editor :: (ref Self, delta_time: float) {
        // handle events and input
        global_input.reset()
        game_input.reset()
        current_engine_mode.reset_input()
        glfwPollEvents()

        viewport_size = window_size
        GL(glViewport(0, 0, cast viewport_size.x, cast viewport_size.y))

        glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w)
        glClear(GL_COLOR_BUFFER_BIT)

        self.update_projection_matrix(viewport_size.change_type(f32))
        
        // update mode
        current_engine_mode.update(delta_time)

        // render mode
        renderer.begin_scene(projection_matrix)
        current_engine_mode.render(<<renderer)
        renderer.draw_quad(vec3(0, 0, 0), world_size, 0, 0.1)
        // renderer.end_scene()
    }

    frame_with_editor :: (ref Self, delta_time: float) {
        glClearColor(1, 0, 1, 1)
        glClear(GL_COLOR_BUFFER_BIT)
        imgui_begin_frame()

        create_dock_space()

        // set window properties of viewport
        ImGui.Begin("Viewport", null, @bin_or(
            ImGui.ImGuiWindowFlags_.NoScrollbar,
            ImGui.ImGuiWindowFlags_.NoScrollWithMouse,
            ImGui.ImGuiWindowFlags_.NoCollapse
        ))
        { // calculate focused state
            was_focused := viewport_is_focused
            viewport_is_focused = ImGui.IsWindowFocused()
            viewport_lost_focused = was_focused and !viewport_is_focused
            // @todo: send focus event to layer_stack
        }
        ImGui.End()

        // handle events and input
        global_input.reset()
        game_input.reset()
        current_engine_mode.reset_input()
        glfwPollEvents()
        if viewport_lost_focused {
            // release all keys in all layers
            game_input.release_all_keys()
            current_engine_mode.release_input()
        }

        // render imgui gui
        render_menu_bar()
        render_editor()

        { // get size of viewport window
            ImGui.Begin("Viewport")
            min := ImGui.GetWindowContentRegionMin()
            max := ImGui.GetWindowContentRegionMax()
            ImGui.End()
            size := ImGui.ImVec2(max.x - min.x, max.y - min.y)
            viewport_size = vec2i(int(size.x), int(size.y)).clamped(0, int.max)
        }

        // render game
        {
            size := viewport_size.change_type(i32)
            GL(glBindFramebuffer(GL_FRAMEBUFFER, viewport_frame_buffer))
            GL(glViewport(0, 0, size.x, size.y))

            glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w)
            glClear(GL_COLOR_BUFFER_BIT)

            self.update_projection_matrix(viewport_size.change_type(f32))
            
            properties_to_edit.clear()

            // update mode
            current_engine_mode.update(delta_time)

            // render mode
            renderer.begin_scene(projection_matrix)
            current_engine_mode.render(<<renderer)
            renderer.draw_quad(vec3(0, 0, 0), world_size, 0, 0.1)
            // renderer.end_scene()

            glBindFramebuffer(GL_FRAMEBUFFER, 0)
        }

        // for layer : layer_stack {
        //     layer.imgui_render()
        // }

        { // draw viewport window
            ImGui.Begin("Viewport")
            if viewport_size.x > 0 and viewport_size.y > 0 {
                size    := ImGui.ImVec2(f32(viewport_size.x), f32(viewport_size.y))
                uv0     := ImGui.ImVec2(0, size.y / f32(viewport_size_max.y))
                uv1     := ImGui.ImVec2(size.x / f32(viewport_size_max.x), 0)
                tint    := ImGui.ImVec4(1, 1, 1, 1)
                border  := ImGui.ImVec4(0, 0, 0, 0)
                ImGui.Image(cast viewport_render_texture, size, uv0, uv1, tint, border)
            }
            ImGui.End()
        }

        // end frame
        imgui_end_frame()
    }

    render_menu_bar :: (ref Self) {
        if ImGui.BeginMainMenuBar() {
            if ImGui.BeginMenu("File") {
                // ShowExampleMenuFile()
                ImGui.EndMenu()
            }
            if ImGui.BeginMenu("Edit") {
                if (ImGui.MenuItem("Undo", "CTRL+Z")) {}
                if (ImGui.MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item
                ImGui.Separator()
                if (ImGui.MenuItem("Cut", "CTRL+X")) {}
                if (ImGui.MenuItem("Copy", "CTRL+C")) {}
                if (ImGui.MenuItem("Paste", "CTRL+V")) {}
                ImGui.EndMenu()
            }

            if ImGui.BeginMenu("Debug") {
                if ImGui.MenuItem_2("Show Stats", null, &enabled_editors.stats, true) {}
                if ImGui.MenuItem_2("Show Demo Menu", null, &enabled_editors.demo_window, true) {}
                ImGui.EndMenu()
            }

            ImGui.EndMainMenuBar()
        }
    }

    render_editor :: (ref Self) {
        if enabled_editors.demo_window {
            ImGui.ShowDemoWindow(&enabled_editors.demo_window)
        }

        if enabled_editors.stats {
            ImGui.SetNextWindowBgAlpha(0.35f) // Transparent background
            overlay_flags := @bin_or(
                // ImGui.ImGuiWindowFlags_.NoTitleBar,
                // ImGui.ImGuiWindowFlags_.NoSavedSettings,
                ImGui.ImGuiWindowFlags_.NoCollapse,
                ImGui.ImGuiWindowFlags_.NoDocking,
                ImGui.ImGuiWindowFlags_.NoResize,
                ImGui.ImGuiWindowFlags_.AlwaysAutoResize,
                ImGui.ImGuiWindowFlags_.NoFocusOnAppearing,
                ImGui.ImGuiWindowFlags_.NoNav)
            if ImGui.Begin("Stats", &enabled_editors.stats, overlay_flags) {
                // viewport dimensions
                dimensions := fmt.format("{} x {}", [viewport_size.x, viewport_size.y])
                ImGui.LabelText("Viewport Dimensions", dimensions.as_cstring())
                ImGui.LabelText("Viewport focused", if viewport_is_focused then "true" else "false")
                ImGui.Separator()

                // show fps
                delta_time_str := fmt.format_any(current_frame_time)
                ImGui.LabelText("Frame duration", delta_time_str.as_cstring())
                fps_counted_str := fmt.format_any(current_fps)
                ImGui.LabelText("FPS", fps_counted_str.as_cstring())

            }
            ImGui.End()
        }

        { // general game properties
            if ImGui.Begin("Game Settings") {
                // render settings
                ImGui.Text("Render Settings")
                if ImGui.Checkbox("VSync", &vsync_enabled) {
                    glfwSwapInterval(if vsync_enabled then 1 else 0)
                }
                ImGui.ColorEdit3("clear color", &clear_color.x, 0)
                ImGui.ColorEdit3("play mode editor background", &editor_play_mode_color.x, 0)
                ImGui.Separator()

                // camera settings
                ImGui.Text("Camera Settings")
                ImGui.InputFloat2("World Size", &world_size.x)
                ImGui.SliderFloat("Camera Aspect Ratio Axis", &aspect_ratio_axis, 0, 1)
            }
            ImGui.End()
        }

        if ImGui.Begin("Values") {
            for p : properties_to_edit {
                match p {
                    PropertyEdit.EditFloat($e) -> {
                        ImGui.InputFloat(e.name, e.ptr, e.step, e.step * 5)
                    }
                    PropertyEdit.EditVec3($e) -> {
                        ImGui.InputFloat3(e.name, cast e.ptr)
                    }
                    PropertyEdit.EditColor3($e) -> {
                        ImGui.ColorEdit3(e.name, cast e.ptr)
                    }
                }
            }
        }

        { // layers
            if ImGui.Begin("Layers") {
                for l : current_mode_base.layer_stack {
                    list_entry_size := ImGui.ImVec2(0, 0)
                    if ImGui.Selectable(l.get_name(), current_layer_index == i32(it_index), 0, list_entry_size) {
                        current_layer_index = i32(it_index)
                    }
                }
            }
            ImGui.End()
        }

        if current_layer_index >= 0 and current_layer_index < i32(current_mode_base.layer_stack.get_length()) {
            hierarchy.set_layer(current_mode_base.layer_stack[int(current_layer_index)])
        }

        inspector.render()
        hierarchy.render()
        console.get().render()

        ImGui.End()
    }

    edit_property :: (ref Self, edit: PropertyEdit) {
        properties_to_edit.add(edit)
    }
}

impl ShmupEngine {
    push_entity_layer :: (ref Self, name: String, callbacks: EntityLayerCallbacks) {
        ptr := mem.alloc(EntityLayer)
        <<ptr = EntityLayer.new(name, callbacks, self, <<Input.new())
        current_mode_base.layer_stack.add(<<ptr)
    }

    update_projection_matrix :: (ref Self, viewport_size: vec2) {
        size    := viewport_size.change_type(f32)

        height1 := world_size.y
        width1  := height1 * size.x / size.y

        width2  := world_size.x
        height2 := width2 * size.y / size.x

        width   := aspect_ratio_axis * width1  + (1 - aspect_ratio_axis) * width2
        height  := aspect_ratio_axis * height1 + (1 - aspect_ratio_axis) * height2

        projection_matrix = mat4.orthographic(-width * 0.5, width * 0.5, -height * 0.5, height * 0.5, -10, 10)
    }

    on_command :: (ref Self, cmd: ref Command) {
        match cmd {
            Command.Quit -> {
                glfwSetWindowShouldClose(glfw_window, 1)
            }

            Command.EnterPlayMode -> {
                enter_play_mode()
            }

            Command.StopPlayMode -> {
                exit_play_mode()
            }

            $c -> {
                io.println(fmt.format("Can't execute command {}", [c]))
            }
        }
    }

    toggle_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&play_mode) {
            exit_play_mode()
        } else {
            enter_play_mode()
        }
    }

    enter_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&play_mode) {
            console.get().log(String.from_string("Already in play mode"))
            return
        }
        console.get().log(String.from_string("Entering play mode"))

        play_mode.initialize(edit_mode)
        current_engine_mode = play_mode
        current_mode_base = cast &play_mode

        set_editor_background_color(editor_play_mode_color)
    }

    exit_play_mode :: (ref Self) {
        if int(current_mode_base) == int(&edit_mode) {
            console.get().log(String.from_string("Already in edit mode"))
            return
        }

        console.get().log(String.from_string("Exiting play mode"))
        current_engine_mode = edit_mode
        current_mode_base = cast &edit_mode

        set_editor_background_color(editor_edit_mode_color)
    }

    set_editor_background_color :: (ref Self, col: vec3) {
        ImGui.GetStyle().Colors[int(ImGui.ImGuiCol_.WindowBg)] = ImGui.ImVec4(col.x, col.y, col.z, 1)
    }
}

#file_scope

imgui_begin_frame :: () {
    ImGui.ImGui_ImplOpenGL3_NewFrame()
    ImGui.ImGui_ImplGlfw_NewFrame()
    ImGui.NewFrame()
}

imgui_end_frame :: () {
    io := ImGui.GetIO()

    // rendering
    ImGui.EndFrame()
    ImGui.Render()
    ImGui.ImGui_ImplOpenGL3_RenderDrawData(ImGui.GetDrawData())

    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.ViewportsEnable)) != 0 {	
        backup_current_context := glfwGetCurrentContext()
        ImGui.UpdatePlatformWindows()
        ImGui.RenderPlatformWindowsDefault()
        glfwMakeContextCurrent(backup_current_context)
    }
}

init_imgui :: (window: &GLFWwindow) -> bool {
    context := ImGui.CreateContext(null)

    if context == null {
        io.println("[ERROR] ImGui.CreateContext failed")
        return false
    }

    imgui_io := ref ImGui.GetIO()
    imgui_io.ConfigFlags = @bin_or(
        imgui_io.ConfigFlags,
        i32(ImGui.ImGuiConfigFlags_.DockingEnable),
        i32(ImGui.ImGuiConfigFlags_.ViewportsEnable))

    ImGui.StyleColorsDark(null)

    // change corners so they are right angles instead of rounded
    style := ref ImGui.GetStyle()	
    style.WindowRounding = 0.0	

    //
    if !ImGui.ImGui_ImplGlfw_InitForOpenGL(window, true) {
        io.println("[ERROR] ImGui.ImGui_ImplGlfw_InitForOpenGL failed")
        return false
    }
    if !ImGui.ImGui_ImplOpenGL3_Init("#version 330") {
        io.println("[ERROR] ImGui.ImGui_ImplOpenGL3_Init failed")
        return false
    }

    return true
}

shutdown_imgui :: () {
    ImGui.ImGui_ImplOpenGL3_Shutdown()
    ImGui.ImGui_ImplGlfw_Shutdown()
    ImGui.DestroyContext(null)
}

create_dock_space :: () {
    dockspace_flags := ImGui.ImGuiDockNodeFlags_.None
    window_flags    := @bin_or(ImGui.ImGuiWindowFlags_.MenuBar, ImGui.ImGuiWindowFlags_.NoDocking)

    opt_fullscreen := true
    if opt_fullscreen {
        pivot := ImGui.ImVec2(0, 0)

        viewport := ImGui.GetMainViewport()
        ImGui.SetNextWindowPos(viewport.Pos, 0, pivot)
        ImGui.SetNextWindowSize(viewport.Size)
        ImGui.SetNextWindowViewport(viewport.ID)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowRounding, 0.0f)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowBorderSize, 0.0f)
        window_flags = @bin_or(
            window_flags,
            ImGui.ImGuiWindowFlags_.NoTitleBar,
            ImGui.ImGuiWindowFlags_.NoCollapse,
            ImGui.ImGuiWindowFlags_.NoResize,
            ImGui.ImGuiWindowFlags_.NoMove,
            ImGui.ImGuiWindowFlags_.NoBringToFrontOnFocus,
            ImGui.ImGuiWindowFlags_.NoNavFocus
        )
    }

    // When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background 
    // and handle the pass-thru hole, so we ask Begin() to not render a background.
    if int(@bin_and(dockspace_flags, ImGui.ImGuiDockNodeFlags_.PassthruCentralNode)) != 0 {
        window_flags = @bin_or(window_flags, ImGui.ImGuiWindowFlags_.NoBackground)
    }

    // Important: note that we proceed even if Begin() returns false (aka window is collapsed).
    // This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,
    // all active windows docked into it will lose their parent and become undocked.
    // We cannot preserve the docking relationship between an active window and an inactive docking, otherwise
    // any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
    window_padding := ImGui.ImVec2(0.0f, 0.0f)
    ImGui.PushStyleVarVec(ImGui.ImGuiStyleVar_.WindowPadding, window_padding)

    open := true
    ImGui.Begin("DockSpace Demo", &open, window_flags)
    ImGui.PopStyleVar()

    if opt_fullscreen then ImGui.PopStyleVar(2)

    // DockSpace
    io := ref ImGui.GetIO()
    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.DockingEnable)) != 0 {
        dockspace_id := ImGui.GetID("MyDockSpace")
        size := ImGui.ImVec2(0.0f, 0.0f)
        ImGui.DockSpace(dockspace_id, size, dockspace_flags)
    } else {
        @assert(false)
    }

    ImGui.End()
}

ShowExampleMenuFile :: () {
    //     ImGui.MenuItem("(dummy menu)", null, false, false)
    //     if ImGui.MenuItem("New") {}
    //     if ImGui.MenuItem("Open", "Ctrl+O") {}
    //     if ImGui.BeginMenu("Open Recent") {
    //         ImGui.MenuItem("fish_hat.c")
    //         ImGui.MenuItem("fish_hat.inl")
    //         ImGui.MenuItem("fish_hat.h")
    //         if ImGui.BeginMenu("More..") {
    //             ImGui.MenuItem("Hello")
    //             ImGui.MenuItem("Sailor")
    //             if ImGui.BeginMenu("Recurse..") {
    //                 ShowExampleMenuFile()
    //                 ImGui.EndMenu()
    //             }
    //             ImGui.EndMenu()
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.MenuItem("Save", "Ctrl+S")) {}
    //     if (ImGui.MenuItem("Save As..")) {}
    //     ImGui.Separator()
    //     if ImGui.BeginMenu("Options") {
    //         enabled := true #static
    //         ImGui.MenuItem_2("Enabled", "", &enabled)

    //         size := ImGui.ImVec2(0, 60)
    //         ImGui.BeginChild("child", size, true)

    //         for i : 0..10 {
    //             text := fmt.format("Scrolling Text {}", [i])
    //             ImGui.Text(text.as_cstring())
    //         }
    //         ImGui.EndChild()
    //         f := 0.5f #static
    //         n := 0i32 #static
    //         b := true #static
    //         ImGui.SliderFloat("Value", &f, 0.0f, 1.0f)
    //         ImGui.InputFloat("Input", &f, 0.1f)
    //         ImGui.Combo_2("Combo", &n, "Yes\0No\0Maybe\0\0")
    //         ImGui.Checkbox("Check", &b)
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Colors"))
    //     {
    //         sz := ImGui.GetTextLineHeight()
    //         for i : 0..int(ImGui.ImGuiCol_.COUNT) {
    //             name := ImGui.GetStyleColorName(cast i)
    //             p := ImGui.GetCursorScreenPos()
    //             // ImGui.GetWindowDrawList().AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui.GetColorU32((ImGuiCol)i))
    //             size := ImGui.ImVec2(sz, sz)
    //             ImGui.Dummy(size)
    //             ImGui.SameLine()
    //             ImGui.MenuItem(name)
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Disabled", false)) {
    //         @assert(false)
    //     }
    //     if (ImGui.MenuItem("Checked", null, true)) {}
    //     if (ImGui.MenuItem("Quit", "Alt+F4")) {}
}