use import std.mem.allocator
use import std.string
use import std.array
use import std.math
use import std.time
fmt :: import std.fmt
io  :: import std.io
C   :: import std.c

use import glfw.glfw3
use import opengl.glad_binding
// use import opengl.opengl
// use import opengl.constants
// use import opengl.types
// use import opengl.functions
ImGui :: import imgui.imgui_binding

use import opengl_utils

vec2i :: Vector2[int]
vec2 :: Vector2[float]
vec3 :: Vector3[float]
vec4 :: Vector4[float]

#export_scope

ShmupCallbacks :: trait {
    init :: (ref Self) -> bool;
    update :: (ref Self);
}

EnabledEditors :: struct {
    editor      := true
    stats       := true
    demo_window := false
}

ShmupEngine :: struct {
    //

    // game stuff
    callbacks : ShmupCallbacks

    // editor stuff
    enabled_editors     : EnabledEditors = default
    current_fps         := 0
    current_frame_time  := 0.0
    clear_color         := vec4(1, 0, 1, 1)

    // window stuff
    glfw_window         : &GLFWwindow = null
    vsync_enabled       := true
    window_size         := vec2i(0, 0)

    // viewport stuff
    viewport_size_max       := vec2i(0, 0)
    viewport_size           := vec2i(0, 0)
    viewport_frame_buffer   : u32 = 0
    viewport_render_texture : u32 = 0
    viewport_depth_texture  : u32 = 0
}

impl ShmupEngine {
    new :: (callbacks: ShmupCallbacks) -> ShmupEngine {
        return ShmupEngine(
            callbacks = callbacks
        )
    }

    start :: (ref Self) {
        on_framebuffer_resize :: (window: &GLFWwindow, w: i32, h: i32) {
            engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)
            engine.window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        glfwSetErrorCallback(glfw_error_callback)

        // initialize glfw
        if !glfwInit() {
            io.println("[ERROR] Failed to initialize GLFW")
            return
        }
        defer glfwTerminate()

        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)
        glfwWindowHint(GLFW_VISIBLE, 0)
        glfwWindowHint(GLFW_MAXIMIZED, 0)
        glfwWindowHint(GLFW_RESIZABLE, 1)

        vidmode := glfwGetVideoMode(glfwGetPrimaryMonitor())
        io.printfln("[LOG] primary monitor size: {} x {}", (vidmode.width, vidmode.height))
        // glfw_window = glfwCreateWindow(vidmode.width, vidmode.height, "Hello World", null, null)
        glfw_window = glfwCreateWindow(1280, 720, "Hello World", null, null)
        if glfw_window == null {
            io.println("[ERROR] Failed to create window")
            return
        }
        defer glfwDestroyWindow(glfw_window)

        glfwSetWindowUserPointer(glfw_window, &self)
        glfwMakeContextCurrent(glfw_window)
        glfwSwapInterval(if vsync_enabled then 1 else 0)

        // initialize glad
        if gladLoadGL() != 1 {
            return
        }

        glfwShowWindow(glfw_window)

        // get initial size
        {
            w : i32 = 0
            h : i32 = 0
            glfwGetFramebufferSize(glfw_window, &w, &h)
            window_size = vec2i(int(w), int(h))
            glViewport(0, 0, w, h)
        }

        // register callbacks
        glfwSetKeyCallback(glfw_window, glfw_key_callback)
        glfwSetFramebufferSizeCallback(glfw_window, on_framebuffer_resize)

        // initialize imgui
        if !init_imgui(glfw_window) {
            return
        }
        defer shutdown_imgui()

        viewport_size_max.x = int(vidmode.width)
        viewport_size_max.y = int(vidmode.height)
        if !initialize_viewport() {
            io.println("[ERROR] Failed to create frame buffer for viewport")
            return
        }

        render_loop()
    }

    initialize_viewport :: (ref Self) -> bool {
        texture_width := i32(viewport_size_max.x)
        texture_height := i32(viewport_size_max.y)

        // The framebuffer, which regroups 0, 1, or more textures, and 0 or 1 depth buffer.
        GL(glGenFramebuffers(1, &viewport_frame_buffer))
        GL(glBindFramebuffer(GL_FRAMEBUFFER, viewport_frame_buffer))

        // The texture we're going to render to
        GL(glGenTextures(1, &viewport_render_texture))

        // "Bind" the newly created texture : all future texture functions will modify this texture
        GL(glBindTexture(GL_TEXTURE_2D, viewport_render_texture))

        // Give an empty image to OpenGL ( the last "null" )
        GL(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, texture_width, texture_height, 0, GL_RGB, GL_UNSIGNED_BYTE, null))

        // Poor filtering. Needed !
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST))
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST))

        // The depth buffer
        GL(glGenRenderbuffers(1, &viewport_depth_texture))
        GL(glBindRenderbuffer(GL_RENDERBUFFER, viewport_depth_texture))
        GL(glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, texture_width, texture_height))
        GL(glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, viewport_depth_texture))

        // Set "viewport_render_texture" as our colour attachement #0
        GL(glFramebufferTexture(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, viewport_render_texture, 0))

        // Set the list of draw buffers.
        draw_buffers := [u32(GL_COLOR_ATTACHMENT0)]
        GL(glDrawBuffers(1, draw_buffers.data)) // "1" is the size of draw_buffers

        // Always check that our framebuffer is ok
        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE {
            return false
        }

        glBindTexture(GL_TEXTURE_2D, 0)
        glBindRenderbuffer(GL_RENDERBUFFER, 0)
        glBindFramebuffer(GL_FRAMEBUFFER, 0)
        return true
    }

    glfw_key_callback :: (window: &GLFWwindow, key: i32, scancode: i32, action: i32, mods: i32) {
        engine := cast(&ShmupEngine) glfwGetWindowUserPointer(window)

        match (action, key) {
            (GLFW_PRESS, GLFW_KEY_F12) -> {
                engine.enabled_editors.editor = !engine.enabled_editors.editor
            }
        }
    }

    render_loop :: (ref Self) {
        if !callbacks.init() {
            return
        }

        last_frame_time := get_time_microseconds()

        frame_timer := 0.0
        fps_counter := 0

        loop {
            if glfwWindowShouldClose(glfw_window) then break
            glfwPollEvents()

            // handle time
            this_frame_time     := get_time_microseconds()
            last_frame_duration := this_frame_time - last_frame_time
            last_frame_time = this_frame_time

            // convert time from microseconds to seconds
            delta_time := double(last_frame_duration) * 0.000001
            current_frame_time = delta_time
            frame_timer += delta_time
            fps_counter += 1

            if frame_timer >= 1 {
                current_fps = fps_counter
                frame_timer -= 1
                fps_counter = 0
            }

            // start rendering
            glClearColor(1, 0, 1, 1)
            glClear(GL_COLOR_BUFFER_BIT)
            imgui_begin_frame()


            // render imgui gui
            if enabled_editors.editor {
                create_dock_space()
                render_menu_bar()
                render_editor()
            }

            // render game
            { // get size of viewport window
                ImGui.Begin("Viewport")
                min := ImGui.GetWindowContentRegionMin()
                max := ImGui.GetWindowContentRegionMax()
                ImGui.End()
                size := ImGui.ImVec2(max.x - min.x, max.y - min.y)
                viewport_size = vec2i(int(size.x), int(size.y))
            }
            if viewport_size.x > 0 and viewport_size.y > 0 {
                GL(glBindFramebuffer(GL_FRAMEBUFFER, viewport_frame_buffer))
                GL(glViewport(0, 0, i32(viewport_size.x), i32(viewport_size.y)))

                glClearColor(clear_color.x, clear_color.y, clear_color.z, clear_color.w)
                glClear(GL_COLOR_BUFFER_BIT)

                callbacks.update()
                glBindFramebuffer(GL_FRAMEBUFFER, 0)
            }
            { // draw viewport window
                ImGui.Begin("Viewport")
                if viewport_size.x > 0 and viewport_size.y > 0 {
                    size    := ImGui.ImVec2(f32(viewport_size.x), f32(viewport_size.y))
                    uv0     := ImGui.ImVec2(0, size.y / f32(viewport_size_max.y))
                    uv1     := ImGui.ImVec2(size.x / f32(viewport_size_max.x), 0)
                    tint    := ImGui.ImVec4(1, 1, 1, 1)
                    border  := ImGui.ImVec4(0, 0, 0, 0)
                    ImGui.Image(cast viewport_render_texture, size, uv0, uv1, tint, border)
                }
                ImGui.End()
            }

            // end frame
            imgui_end_frame()
            glfwSwapBuffers(glfw_window)
        }
    }

    render_menu_bar :: (ref Self) {
        if ImGui.BeginMainMenuBar() {
            if ImGui.BeginMenu("File") {
                // ShowExampleMenuFile()
                ImGui.EndMenu()
            }
            if ImGui.BeginMenu("Edit") {
                if (ImGui.MenuItem("Undo", "CTRL+Z")) {}
                if (ImGui.MenuItem("Redo", "CTRL+Y", false, false)) {}  // Disabled item
                ImGui.Separator()
                if (ImGui.MenuItem("Cut", "CTRL+X")) {}
                if (ImGui.MenuItem("Copy", "CTRL+C")) {}
                if (ImGui.MenuItem("Paste", "CTRL+V")) {}
                ImGui.EndMenu()
            }

            if ImGui.BeginMenu("Debug") {
                if ImGui.MenuItem_2("Show Stats", null, &enabled_editors.stats, true) {}
                if ImGui.MenuItem_2("Show Demo Menu", null, &enabled_editors.demo_window, true) {}
                ImGui.EndMenu()
            }

            ImGui.EndMainMenuBar()
        }
    }

    render_editor :: (ref Self) {
        if enabled_editors.demo_window {
            ImGui.ShowDemoWindow(&enabled_editors.demo_window)
        }

        if enabled_editors.stats {
            ImGui.SetNextWindowBgAlpha(0.35f) // Transparent background
            overlay_flags := @bin_or(
                // ImGui.ImGuiWindowFlags_.NoTitleBar,
                // ImGui.ImGuiWindowFlags_.NoSavedSettings,
                ImGui.ImGuiWindowFlags_.NoCollapse,
                ImGui.ImGuiWindowFlags_.NoDocking,
                ImGui.ImGuiWindowFlags_.NoResize,
                ImGui.ImGuiWindowFlags_.AlwaysAutoResize,
                ImGui.ImGuiWindowFlags_.NoFocusOnAppearing,
                ImGui.ImGuiWindowFlags_.NoNav)
            if ImGui.Begin("Stats", &enabled_editors.stats, overlay_flags) {
                // show fps
                delta_time_str := fmt.format_any(current_frame_time)
                ImGui.LabelText("Frame duration", delta_time_str.as_cstring())
                fps_counted_str := fmt.format_any(current_fps)
                ImGui.LabelText("FPS", fps_counted_str.as_cstring())

                // enable/disable vsync
                if ImGui.Checkbox("VSync", &vsync_enabled) {
                    glfwSwapInterval(if vsync_enabled then 1 else 0)
                }

                // clear color
                ImGui.ColorEdit3("clear color", cast(&float)&clear_color, 0)
            }
            ImGui.End()
        }
    }
}

#file_scope

imgui_begin_frame :: () {
    ImGui.ImGui_ImplOpenGL3_NewFrame()
    ImGui.ImGui_ImplGlfw_NewFrame()
    ImGui.NewFrame()
}

imgui_end_frame :: () {
    io := ImGui.GetIO()

    // rendering
    ImGui.EndFrame()
    ImGui.Render()
    ImGui.ImGui_ImplOpenGL3_RenderDrawData(ImGui.GetDrawData())

    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.ViewportsEnable)) != 0 {	
        backup_current_context := glfwGetCurrentContext()
        ImGui.UpdatePlatformWindows()
        ImGui.RenderPlatformWindowsDefault()
        glfwMakeContextCurrent(backup_current_context)
    }
}

init_imgui :: (window: &GLFWwindow) -> bool {
    context := ImGui.CreateContext(null)

    if context == null {
        io.println("[ERROR] ImGui.CreateContext failed")
        return false
    }

    imgui_io := ref ImGui.GetIO()
    imgui_io.ConfigFlags = @bin_or(
        imgui_io.ConfigFlags,
        i32(ImGui.ImGuiConfigFlags_.DockingEnable),
        i32(ImGui.ImGuiConfigFlags_.ViewportsEnable))

    ImGui.StyleColorsDark(null)

    // change corners so they are right angles instead of rounded
    style := ref ImGui.GetStyle()	
    style.WindowRounding = 0.0	

    //
    if !ImGui.ImGui_ImplGlfw_InitForOpenGL(window, true) {
        io.println("[ERROR] ImGui.ImGui_ImplGlfw_InitForOpenGL failed")
        return false
    }
    if !ImGui.ImGui_ImplOpenGL3_Init("#version 330") {
        io.println("[ERROR] ImGui.ImGui_ImplOpenGL3_Init failed")
        return false
    }

    return true
}

shutdown_imgui :: () {
    ImGui.ImGui_ImplOpenGL3_Shutdown()
    ImGui.ImGui_ImplGlfw_Shutdown()
    ImGui.DestroyContext(null)
}

create_dock_space :: () {
    dockspace_flags := ImGui.ImGuiDockNodeFlags_.None
    window_flags    := @bin_or(ImGui.ImGuiWindowFlags_.MenuBar, ImGui.ImGuiWindowFlags_.NoDocking)

    opt_fullscreen := true
    if opt_fullscreen {
        pivot := ImGui.ImVec2(0, 0)

        viewport := ImGui.GetMainViewport()
        ImGui.SetNextWindowPos(viewport.Pos, 0, pivot)
        ImGui.SetNextWindowSize(viewport.Size)
        ImGui.SetNextWindowViewport(viewport.ID)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowRounding, 0.0f)
        ImGui.PushStyleVar(ImGui.ImGuiStyleVar_.WindowBorderSize, 0.0f)
        window_flags = @bin_or(
            window_flags,
            ImGui.ImGuiWindowFlags_.NoTitleBar,
            ImGui.ImGuiWindowFlags_.NoCollapse,
            ImGui.ImGuiWindowFlags_.NoResize,
            ImGui.ImGuiWindowFlags_.NoMove,
            ImGui.ImGuiWindowFlags_.NoBringToFrontOnFocus,
            ImGui.ImGuiWindowFlags_.NoNavFocus
        )
    }

    // When using ImGuiDockNodeFlags_PassthruCentralNode, DockSpace() will render our background 
    // and handle the pass-thru hole, so we ask Begin() to not render a background.
    if int(@bin_and(dockspace_flags, ImGui.ImGuiDockNodeFlags_.PassthruCentralNode)) != 0 {
        window_flags = @bin_or(window_flags, ImGui.ImGuiWindowFlags_.NoBackground)
    }

    // Important: note that we proceed even if Begin() returns false (aka window is collapsed).
    // This is because we want to keep our DockSpace() active. If a DockSpace() is inactive,
    // all active windows docked into it will lose their parent and become undocked.
    // We cannot preserve the docking relationship between an active window and an inactive docking, otherwise
    // any change of dockspace/settings would lead to windows being stuck in limbo and never being visible.
    window_padding := ImGui.ImVec2(0.0f, 0.0f)
    ImGui.PushStyleVarVec(ImGui.ImGuiStyleVar_.WindowPadding, window_padding)

    open := true
    ImGui.Begin("DockSpace Demo", &open, window_flags)
    ImGui.PopStyleVar()

    if opt_fullscreen then ImGui.PopStyleVar(2)

    // DockSpace
    io := ref ImGui.GetIO()
    if @bin_and(io.ConfigFlags, i32(ImGui.ImGuiConfigFlags_.DockingEnable)) != 0 {
        dockspace_id := ImGui.GetID("MyDockSpace")
        size := ImGui.ImVec2(0.0f, 0.0f)
        ImGui.DockSpace(dockspace_id, size, dockspace_flags)
    } else {
        @assert(false)
    }

    ImGui.End()
}

ShowExampleMenuFile :: () {
    //     ImGui.MenuItem("(dummy menu)", null, false, false)
    //     if ImGui.MenuItem("New") {}
    //     if ImGui.MenuItem("Open", "Ctrl+O") {}
    //     if ImGui.BeginMenu("Open Recent") {
    //         ImGui.MenuItem("fish_hat.c")
    //         ImGui.MenuItem("fish_hat.inl")
    //         ImGui.MenuItem("fish_hat.h")
    //         if ImGui.BeginMenu("More..") {
    //             ImGui.MenuItem("Hello")
    //             ImGui.MenuItem("Sailor")
    //             if ImGui.BeginMenu("Recurse..") {
    //                 ShowExampleMenuFile()
    //                 ImGui.EndMenu()
    //             }
    //             ImGui.EndMenu()
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.MenuItem("Save", "Ctrl+S")) {}
    //     if (ImGui.MenuItem("Save As..")) {}
    //     ImGui.Separator()
    //     if ImGui.BeginMenu("Options") {
    //         enabled := true #static
    //         ImGui.MenuItem_2("Enabled", "", &enabled)

    //         size := ImGui.ImVec2(0, 60)
    //         ImGui.BeginChild("child", size, true)

    //         for i : 0..10 {
    //             text := fmt.format("Scrolling Text {}", [i])
    //             ImGui.Text(text.as_cstring())
    //         }
    //         ImGui.EndChild()
    //         f := 0.5f #static
    //         n := 0i32 #static
    //         b := true #static
    //         ImGui.SliderFloat("Value", &f, 0.0f, 1.0f)
    //         ImGui.InputFloat("Input", &f, 0.1f)
    //         ImGui.Combo_2("Combo", &n, "Yes\0No\0Maybe\0\0")
    //         ImGui.Checkbox("Check", &b)
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Colors"))
    //     {
    //         sz := ImGui.GetTextLineHeight()
    //         for i : 0..int(ImGui.ImGuiCol_.COUNT) {
    //             name := ImGui.GetStyleColorName(cast i)
    //             p := ImGui.GetCursorScreenPos()
    //             // ImGui.GetWindowDrawList().AddRectFilled(p, ImVec2(p.x+sz, p.y+sz), ImGui.GetColorU32((ImGuiCol)i))
    //             size := ImGui.ImVec2(sz, sz)
    //             ImGui.Dummy(size)
    //             ImGui.SameLine()
    //             ImGui.MenuItem(name)
    //         }
    //         ImGui.EndMenu()
    //     }
    //     if (ImGui.BeginMenu("Disabled", false)) {
    //         @assert(false)
    //     }
    //     if (ImGui.MenuItem("Checked", null, true)) {}
    //     if (ImGui.MenuItem("Quit", "Alt+F4")) {}
}