use import std.array
use import std.rc
use import std.string
mem :: import std.mem.allocator
io  :: import std.io

use import opengl.glad_binding
use import stb.stb_binding

use import opengl_utils
use import math

#export_scope

ShaderDataType :: enum #copy {
    None = 0, Float, Float2, Float3, Float4, Mat3, Mat4, Int, Int2, Int3, Int4, Bool
}

BufferElement :: struct {
    name        : string
    typ         : ShaderDataType
    normalized  : bool = false
    offset      : int  = 0
}

impl BufferElement {
    get_component_count :: (ref Self) -> i32 {
        return match typ {
            ShaderDataType.Float  -> 1
            ShaderDataType.Float2 -> 2
            ShaderDataType.Float3 -> 3
            ShaderDataType.Float4 -> 4
            ShaderDataType.Mat3   -> 3 * 3
            ShaderDataType.Mat4   -> 4 * 4
            ShaderDataType.Int    -> 1
            ShaderDataType.Int2   -> 2
            ShaderDataType.Int3   -> 3
            ShaderDataType.Int4   -> 4
            ShaderDataType.Bool   -> 1

            _ -> {@assert(false); 0}
        }
    }

    get_size :: (ref Self) -> i32 {
        return match typ {
            ShaderDataType.Float  -> 4
            ShaderDataType.Float2 -> 4 * 2
            ShaderDataType.Float3 -> 4 * 3
            ShaderDataType.Float4 -> 4 * 4
            ShaderDataType.Mat3   -> 4 * 3 * 3
            ShaderDataType.Mat4   -> 4 * 4 * 4
            ShaderDataType.Int    -> 4
            ShaderDataType.Int2   -> 4 * 2
            ShaderDataType.Int3   -> 4 * 3
            ShaderDataType.Int4   -> 4 * 4
            ShaderDataType.Bool   -> 1

            _ -> {@assert(false); 0}
        }
    }
}

BufferLayout :: struct {
    stride : i32 = 0
    elements := Array[BufferElement].create()
}

impl BufferLayout {
    new :: (elements: []BufferElement) -> BufferLayout {
        arr     := Array[BufferElement].create(elements.length)
        stride  : i32 = 0

        for e : elements {
            arr.add(e)
        }

        { // calculate offsets and stride
            offset := 0
            for e : arr {
                size := e.get_size()
                e.offset = offset
                offset += int(size)
                stride += size
            }
        }

        return BufferLayout(stride, arr)
    }
}

//////////////////////////////////////////////

VertexBuffer :: struct {
    vbo    : u32
    layout : BufferLayout
}

impl VertexBuffer {
    create :: (vertices: []f32, static: bool = true) -> &VertexBuffer {
        vbo : u32 = 0
        GL(glGenBuffers(1, &vbo))
        GL(glBindBuffer(GL_ARRAY_BUFFER, vbo))
        GL(glBufferData(GL_ARRAY_BUFFER, @sizeof(f32) * vertices.length, vertices.data, if static then GL_STATIC_DRAW else GL_DYNAMIC_DRAW))
        GL(glBindBuffer(GL_ARRAY_BUFFER, 0))

        buff := mem.alloc(VertexBuffer)
        <<buff = VertexBuffer(vbo, BufferLayout())
        return buff
    }

    dynamic :: (size_in_bytes: int) -> &VertexBuffer {
        vbo : u32 = 0
        GL(glGenBuffers(1, &vbo))
        GL(glBindBuffer(GL_ARRAY_BUFFER, vbo))
        GL(glBufferData(GL_ARRAY_BUFFER, cast size_in_bytes, null, GL_DYNAMIC_DRAW))
        GL(glBindBuffer(GL_ARRAY_BUFFER, 0))

        buff := mem.alloc(VertexBuffer)
        <<buff = VertexBuffer(vbo, BufferLayout())
        return buff
    }

    sub_data :: (ref Self, offset: int, bytes: int, data: &void) {
        GL(glBindBuffer(GL_ARRAY_BUFFER, vbo))
        GL(glBufferSubData(GL_ARRAY_BUFFER, cast offset, cast bytes, data))
        GL(glBindBuffer(GL_ARRAY_BUFFER, 0))
    }

    bind :: (ref Self) {
        GL(glBindBuffer(GL_ARRAY_BUFFER, vbo))
    }

    unbind :: (ref Self) {
        GL(glBindBuffer(GL_ARRAY_BUFFER, 0))
    }
}

impl Drop for VertexBuffer {
    drop :: (ref Self) {
        glDeleteBuffers(1, &vbo)
    }
}

IndexBuffer :: struct {
    vbo   : u32
    count : i32
}

impl IndexBuffer {
    create :: (indices: []u32) -> &IndexBuffer {
        vbo : u32 = 0
        glGenBuffers(1, &vbo)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, @sizeof(u32) * indices.length, indices.data, GL_STATIC_DRAW)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)

        buff := mem.alloc(IndexBuffer)
        <<buff = IndexBuffer(vbo, i32(indices.length))
        return buff
    }

    bind :: (ref Self) {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vbo)
    }

    unbind :: (ref Self) {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0)
    }
}

impl Drop for IndexBuffer {
    drop :: (ref Self) {
        glDeleteBuffers(1, &vbo)
    }
}

////////////////////////////////

VertexArray :: struct {
    vao                       : u32
    index_buffer              : &IndexBuffer = null
    vertex_buffers            := Array[&VertexBuffer].create()
    vertex_attrib_array_index : u32 = 0
}

impl VertexArray {
    new :: () -> &VertexArray {
        vao : u32 = 0
        glGenVertexArrays(1, &vao)

        buff := mem.alloc(VertexArray)
        <<buff = VertexArray(vao)
        return buff
    }

    bind :: (ref Self) {
        glBindVertexArray(vao)
    }

    unbind :: (ref Self) {
        glBindVertexArray(0)
    }

    set_index_buffer :: (ref Self, ib: &IndexBuffer) {
        glBindVertexArray(vao)
        ib.bind()
        index_buffer = ib
    }

    add_vertex_buffer :: (ref Self, vb: &VertexBuffer) {
        glBindVertexArray(vao)
        vb.bind()

        for element : vb.layout.elements {
            glEnableVertexAttribArray(vertex_attrib_array_index)
            glVertexAttribPointer(
                vertex_attrib_array_index
                element.get_component_count()
                GL_FLOAT
                if element.normalized then GL_TRUE else GL_FALSE
                vb.layout.stride
                cast(&void) element.offset)

            vertex_attrib_array_index += 1
        }

        vertex_buffers.add(vb)
    }
}

impl Drop for VertexArray {
    drop :: (ref Self) {
        glDeleteVertexArrays(1, &vao)
    }
}

///////////////////////////////////////////////
Texture :: struct {
    id      : u32
    width   : int
    height  : int
    internal_format : GLenum
    data_format     : GLenum
}

impl Texture {
    from_file :: (path: string) -> Result[Rc[Texture], ()] {
        io.println("creating texture from file")
        // load data from file
        width    : i32 = 0
        height   : i32 = 0
        channels : i32 = 0
        stbi_set_flip_vertically_on_load(1)
        data : &stbi_uc = null
        {
            str := String.from_string(path)
            data = stbi_load(str.as_cstring(), &width, &height, &channels, 0)
        }

        if data == null {
            return Err(())
        }

        defer stbi_image_free(data)

        internal_format : GLenum = 0
        data_format     : GLenum = 0
        match channels {
            3 -> {
                internal_format = GL_RGB8
                data_format     = GL_RGB
            }
            4 -> {
                internal_format = GL_RGBA8
                data_format     = GL_RGBA
            }
        }

        id : u32 = 0
        GL(glGenTextures(1, &id))
        GL(glBindTexture(GL_TEXTURE_2D, id))

        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR))
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST))
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT))
        GL(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT))
        GL(glTexImage2D(GL_TEXTURE_2D, 0, cast internal_format, width, height, 0, data_format, GL_UNSIGNED_BYTE, data))

        return Ok(Rc[Texture].new(Texture(id, cast width, cast height, internal_format, data_format)))
    }

    bind :: (ref Self, slot: int) {
        // glBindTextureUnit(cast slot, id)
        GL(glActiveTexture(GL_TEXTURE0))
        GL(glBindTexture(GL_TEXTURE_2D, id))
    }
}

impl Drop for Texture {
    drop :: (ref Self) {
        glDeleteTextures(1, &id)
    }
}