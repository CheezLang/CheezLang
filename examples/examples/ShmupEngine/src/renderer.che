use import std.math
use import std.rc
use import std.array
use import std.hash_table
mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt

use import opengl.glad_binding
ImGui :: import imgui.imgui_binding

use import math
use import matrix
use import opengl_buffers
use import shader

#export_scope

quad_cache_size :: 5000
line_cache_size :: 5000

// @todo: read this value from OpenGL
max_texture_slots :: 16

Origin :: enum #copy {
    Center, TopLeft, BottomLeft, TopRight, BottomRight
}

QuadVertex :: struct #copy {
    position    : vec3
    color       : vec4
    uv          : vec2
    tex_index   : i32
}

LineVertex :: struct #copy {
    position    : vec3
    color       : vec4
}

int_compare :: (a: int, b: int) -> bool {
    return a == b
}

Renderer :: struct {
    quad_va         : &VertexArray
    quad_cache      := Array[QuadVertex].create(quad_cache_size * 4)

    line_va         : &VertexArray
    line_cache      := Array[LineVertex].create(line_cache_size * 2)

    white_tex       := Rc[Texture].empty()
    texture_map     := Table[int, i32].create(int_compare)
    used_textures   := Array[Rc[Texture]].create(max_texture_slots)

    color_shader    : &Shader = null
    line_shader     : &Shader = null

    projection_matrix_stack := Array[mat4].create()
    projection_matrix       : mat4 = mat4()
}

impl Renderer {
    create :: () -> &Renderer {
        // white texture
        white_tex := Texture.from_bytes(1, 1, 3, [255, 255, 255])

        // create line va
        line_va := {
            line_va := VertexArray.new()

            vertex_buffer := VertexBuffer.dynamic(line_cache_size * 2 * @sizeof(LineVertex))
            vertex_buffer.layout = BufferLayout.new([
                BufferElement("aPos", ShaderDataType.Float3)
                BufferElement("aColor", ShaderDataType.Float4)
            ])
            line_va.add_vertex_buffer(vertex_buffer)

            // create index buffer
            indices := mem.alloc_n(u32, line_cache_size * 2)
            defer mem.free_n(indices)
            for i : 0..line_cache_size {
                indices[i * 2 + 0] = u32(i * 2 + 0)
                indices[i * 2 + 1] = u32(i * 2 + 1)
            }

            index_buffer := IndexBuffer.create(indices)
            line_va.set_index_buffer(index_buffer)

            line_va
        }

        // create vertex array for quad
        vertex_array := {
            vertex_array := VertexArray.new()

            vertex_buffer := VertexBuffer.dynamic(quad_cache_size * 4 * @sizeof(QuadVertex))
            vertex_buffer.layout = BufferLayout.new([
                BufferElement("aPos", ShaderDataType.Float3)
                BufferElement("aColor", ShaderDataType.Float4)
                BufferElement("aTexCoord", ShaderDataType.Float2)
                BufferElement("aTexIndex", ShaderDataType.Int)
            ])
            vertex_array.add_vertex_buffer(vertex_buffer)

            indices := mem.alloc_n(u32, quad_cache_size * 6)
            defer mem.free_n(indices)
            for i : 0..quad_cache_size {
                indices[i * 6 + 0] = u32(i * 4 + 0)
                indices[i * 6 + 1] = u32(i * 4 + 1)
                indices[i * 6 + 2] = u32(i * 4 + 2)
                indices[i * 6 + 3] = u32(i * 4 + 2)
                indices[i * 6 + 4] = u32(i * 4 + 3)
                indices[i * 6 + 5] = u32(i * 4 + 0)
            }

            index_buffer := IndexBuffer.create(indices)
            vertex_array.set_index_buffer(index_buffer)

            vertex_array
        }

        //
        r := mem.alloc(Renderer)
        <<r = Renderer(
            quad_va     = vertex_array
            line_va     = line_va
            white_tex   = white_tex
        )
        r.reload_shaders()
        return r
    }

    reload_shaders :: (ref Self) {
        if color_shader != null {
            Memory.drop(<<color_shader)
            mem.free(color_shader)
            color_shader = null
        }
        // load shader
        color_shader = match Shader.from_file("../data/test_shader.shader") {
            Ok($shader) -> {
                shader_program := mem.alloc(Shader)
                <<shader_program = shader
                shader_program
            }

            Err($msg) -> {
                io.formatln("[ERROR] Failed to load 'test_shader.shader' from file: {}", [msg.slice()])
                return
            }
        }
        color_shader.bind()

        uTextures : [16]i32 = default
        for i : 0..16 {
            uTextures[i] = i32(i)
        }
        color_shader.set_uniform_ints("uTextures", uTextures)
        color_shader.unbind()

        // line shader
        if line_shader != null {
            Memory.drop(<<line_shader)
            mem.free(line_shader)
            line_shader = null
        }
        line_shader = match Shader.from_file("../data/line_shader.shader") {
            Ok($shader) -> {
                shader_program   := mem.alloc(Shader)
                <<shader_program = shader
                shader_program
            }

            Err($msg) -> {
                io.formatln("[ERROR] Failed to load 'line_shader.shader' from file: {}", [msg.slice()])
                return
            }
        }
    }

    set_projection_matrix :: (ref Self, projection_matrix: ref mat4) {
        color_shader.bind()
        color_shader.set_uniform_mat4("m_projection", projection_matrix)
        line_shader.bind()
        line_shader.set_uniform_mat4("m_projection", projection_matrix)
    }

    push_proj   :: (ref Self, projection_matrix: ref mat4) {
        projection_matrix_stack.push(self.projection_matrix)
        set_projection_matrix(projection_matrix)
    }

    pop_proj    :: (ref Self) {
        projection_matrix = projection_matrix_stack.pop()
        set_projection_matrix(projection_matrix)
    }

    begin_scene :: (ref Self, projection_matrix: ref mat4) {
        // @todo: <<& is a hack
        self.projection_matrix = <<&projection_matrix
        self.projection_matrix_stack.clear()

        set_projection_matrix(projection_matrix)
    }

    fill_quad :: (ref Self, pos: vec3, size: vec3,
                    angle: float = 0,
                    color: vec3 = vec3(1, 1, 1),
                    texture: Option[Rc[Texture]] = None,
                    uv: vec4 = vec4(0, 0, 1, 1)) {

        if quad_cache.get_length() + 4 >= quad_cache_size * 4 {
            flush_quads()
        }

        // calculate texture index
        tex_index : i32 = match texture {
            Some($tex) -> match texture_map.get(int(&tex.get())) {
                Some($idx) -> idx
                None -> {
                    if used_textures.get_length() >= max_texture_slots {
                        flush_quads()
                    }
                    idx := i32(used_textures.get_length())
                    texture_map[int(&tex.get())] = idx
                    used_textures.add(tex.clone())
                    idx
                }
            }

            None -> 0
        }

        // calculate rotation
        offset_x, offset_y := {
            sa := sinf(angle)
            ca := cosf(angle)
            vec3(ca, sa) * size.x * 0.5f, vec3(-sa, ca) * size.y * 0.5f
        }

        // emit vertices into buffer
        quad_cache.add(QuadVertex(
            position    = pos - offset_x - offset_y
            color       = vec4(color.x, color.y, color.z, 1.0f)
            uv          = vec2(uv.x, uv.y)
            tex_index   = tex_index
        ))
        quad_cache.add(QuadVertex(
            position    = pos + offset_x - offset_y
            color       = vec4(color.x, color.y, color.z, 1.0f)
            uv          = vec2(uv.z, uv.y)
            tex_index   = tex_index
        ))
        quad_cache.add(QuadVertex(
            position    = pos + offset_x + offset_y
            color       = vec4(color.x, color.y, color.z, 1.0f)
            uv          = vec2(uv.z, uv.w)
            tex_index   = tex_index
        ))
        quad_cache.add(QuadVertex(
            position    = pos - offset_x + offset_y
            color       = vec4(color.x, color.y, color.z, 1.0f)
            uv          = vec2(uv.x, uv.w)
            tex_index   = tex_index
        ))
    }

    draw_line :: (ref Self, pos0: vec3, pos1: vec3, color: vec3 = vec3(1, 1, 1), thickness: float = 0.0f) {
        if thickness == 0.0f {
            // 0 thickness means draw line 1 pixel wide
            if line_cache.get_length() + 2 >= line_cache_size {
                flush_lines()
            }

            line_cache.add(LineVertex(
                position    = pos0
                color       = vec4(color.x, color.y, color.z, 1.0f)
            ))
            line_cache.add(LineVertex(
                position    = pos1
                color       = vec4(color.x, color.y, color.z, 1.0f)
            ))
        } else {
            // non zero thickness means draw lines as quads with specified thickness
            if quad_cache.get_length() + 4 >= quad_cache_size {
                flush_quads()
            }

            dir := pos1 - pos0
            right := vec3(dir.y, -dir.x).normalized() * thickness * 0.5f

            quad_cache.add(QuadVertex(
                position    = pos0 - right
                color       = vec4(color.x, color.y, color.z, 1.0f)
                uv          = vec2(0, 0)
                tex_index   = 0
            ))
            quad_cache.add(QuadVertex(
                position    = pos0 + right
                color       = vec4(color.x, color.y, color.z, 1.0f)
                uv          = vec2(1, 0)
                tex_index   = 0
            ))
            quad_cache.add(QuadVertex(
                position    = pos1 + right
                color       = vec4(color.x, color.y, color.z, 1.0f)
                uv          = vec2(1, 1)
                tex_index   = 0
            ))
            quad_cache.add(QuadVertex(
                position    = pos1 - right
                color       = vec4(color.x, color.y, color.z, 1.0f)
                uv          = vec2(0, 1)
                tex_index   = 0
            ))
        }
    }

    draw_quad :: (ref Self, pos: vec3, size: vec3, angle: float = 0.0f, thickness: float = 0.0f, color: vec3 = vec3(1, 1, 1)) {
        offset_x, offset_y := {
            sa := sinf(angle)
            ca := cosf(angle)
            vec3(ca, sa) * size.x * 0.5f, vec3(-sa, ca) * size.y * 0.5f
        }

        draw_line(pos - offset_x - offset_y, pos + offset_x - offset_y, color, thickness)
        draw_line(pos + offset_x - offset_y, pos + offset_x + offset_y, color, thickness)
        draw_line(pos + offset_x + offset_y, pos - offset_x + offset_y, color, thickness)
        draw_line(pos - offset_x + offset_y, pos - offset_x - offset_y, color, thickness)
    }

    draw_text :: (ref Self, pos: vec3, text: string, color: vec3 = vec3(1, 1, 1), size: float = 16) {
        pos : ImGui.ImVec2 = pos.into()
        font := ImGui.GetFont()
        ImGui.GetForegroundDrawList().AddText_2(font, size, pos, color.to_color32(), text)
    }

    flush_quads :: (ref Self) {
        // upload data
        vb := quad_va.vertex_buffers[0]
        vb.sub_data(0, quad_cache.get_length() * @sizeof(QuadVertex), quad_cache.get_raw())

        // bind stuff
        color_shader.bind()
        quad_va.bind()
        quad_va.index_buffer.bind()

        for tex : used_textures {
            tex.get().bind(it_index)
        }

        // draw buffer
        glDrawElements(GL_TRIANGLES, cast quad_cache.get_length() * 6, GL_UNSIGNED_INT, null)
        glBindVertexArray(0)

        // clear textures
        texture_map.clear()
        used_textures.clear()

        // set white tex as texture 0
        texture_map[int(&white_tex.get())] = 0i32
        used_textures.add(white_tex.clone())

        quad_cache.clear()
    }

    flush_lines :: (ref Self) {
        vb := line_va.vertex_buffers[0]
        vb.sub_data(0, line_cache.get_length() * @sizeof(LineVertex), line_cache.get_raw())

        line_shader.bind()
        line_va.bind()
        line_va.index_buffer.bind()
        glDrawElements(GL_LINES, cast line_cache.get_length() * 2, GL_UNSIGNED_INT, null)
        glBindVertexArray(0)

        line_cache.clear()
    }

    flush :: (ref Self) {
        flush_quads()
        flush_lines()
    }
}
