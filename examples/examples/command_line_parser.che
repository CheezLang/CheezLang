use import std.array
use import std.string
use import std.os.windows_functions
use import std.mem.allocator
use import std.util
io  :: import std.io
fmt :: import std.fmt

// use import print_any

Main :: () {
    args := get_cmd_args()

    io.println("welcome to my awesome new command line argument parser")
    io.println("args:")
    for arg : args {
        io.printfln("[{}] '{}'", (it_index, arg.slice()))
    }
    io.println("==============")
    my_args := parse_arguments(MyArgsEnum, args.sliceF(1))

    if my_args != null {
        io.println("==============")
        io.println(fmt.format_any(<<my_args))
    }
}

log_args :: (args: []String) {
    io.println("=== args ===")
    for arg : args {
        io.printfln("[{}] '{}'", (it_index, arg.slice()))
    }
    io.println("============")
}

MyArgsEnum :: enum {
    help
    build
    project : Project
}

Project :: enum {
    new : ProjectNew
}

ProjectNew :: struct {
    name : String
    typ  : ProjectType
}

ProjectType :: enum {
    Program
    DynamicLibrary
    StaticLibrary
}

LibraryType :: enum {
    Dynamic
    Static
}

MyArguments :: struct {
    name : String
    age  : int
}

parse_arguments :: ($T: type, args: []String) -> &T {
    result := alloc(T)
    ok := parse_arguments_help(@type_info(T), args, result, args)

    if !ok {
        free(result)
        return null
    }
    return result
}

parse_arguments_help :: (type_info: &TypeInfo, args: []String, result: &$T, args_out: ref []String) -> bool {
    args_out = args
    return match type_info.kind {
        TypeInfoKind.Struct($info) if streq(info.name, "StringBase") -> {
            <<cast(&String) result = args[0].clone()
            true
        }

        TypeInfoKind.Enum($info)   -> parse_arguments_enum(&info, args, result, args)
        TypeInfoKind.Struct($info) -> parse_arguments_struct(&info, args, result, args)
        TypeInfoKind.Int($into)    -> {
            <<cast(&int) result = fmt.parse_int(args[0].slice())
            true
        }
        $_ -> {
            io.printfln("Can't parse into type {}", @typename(T))
            false
        }
    }
}

parse_arguments_enum :: (type_info: &TypeInfoEnum, args: []String, result: &void, args_out: ref []String) -> bool {
    args_out = args
    io.printfln("parsing into enum {}", type_info.name)
    log_args(args)

    if args.length == 0 {
        io.println("Missing command. Possible commands:")
        for(by_ref=true) type_info.members {
            io.printfln("  {}", it.name)
        }
        return false
    }

    command := ref args[0]
    for(by_ref=true) type_info.members {
        if streq(command.slice(), it.name) {
            // first store the tag
            tag_ptr := cast(&int) result
            <<tag_ptr = it.tag

            if it.typ != null {
                // parse remaining arguments into associated value
                tag_size := type_info.tag_type.size
                value_ptr := pointer_add(result, tag_size)
                parse_arguments_help(it.typ, args[1..args.length], value_ptr, args_out)
            }
            return true
        }
    }

    io.printfln("Unknown command: {}", command.slice())
    return false
}

parse_arguments_struct :: (type_info: &TypeInfoStruct, args: []String, result: &void, args_out: ref []String) -> bool {
    args_out = args
    io.printfln("parsing into struct {}", type_info.name)
    log_args(args)
    while i := 0, i < args.length, i += 1 {
        arg := ref args[i]
        @assert(arg.length > 0)

        if arg[0] == '-' {
            name := arg.sliceF(1)
            mem := type_info.get_member(name)

            if mem == null {
                io.printfln("[CLP] Error: unknown argument '{}'", name)
                return false
            }

            parse_arguments_help(mem.typ, args[(i + 1)..args.length], pointer_add(result, mem.offset), ref args)
        } else {
            @assert(false, "Not implemented")
            io.printfln("[CLP] Error: not implemented", ())
            return false
        }

        io.printfln("parsing '{}'", arg.slice())
    }

    return true
}

// helper functions
to_ascii_strings :: (argv: &&u16, argc: int) -> Array[String] {
    array := Array[String].create(argc)
    for i : 0..argc {
        str := String.empty()
        while k := 0, argv[i][k] != 0, k += 1 {
            str += char(argv[i][k])
        }

        array.add(str)
    }
    return array
}

get_cmd_args :: () -> Array[String] {
    cmdLineArgs := GetCommandLineW()
    count := 0i32
    args := CommandLineToArgvW(cmdLineArgs, &count)
    return to_ascii_strings(args, int(count))
}