use import std.array
use import std.string
use import std.os.windows_functions
use import std.mem.allocator
use import std.util
io :: import std.io

use import print_any

Main :: () {
    args := get_cmd_args()

    io.println("welcome to my awesome new command line argument parser")
    io.println("args:")
    for arg : args {
        io.printfln("[{}] '{}'", (it_index, arg.slice()))
    }
    io.println("==============")
    my_args := parse_arguments(MyArguments, args)
    io.println("==============")
    io.println(my_args.name.slice())
    io.println(my_args.age)

    println_any(<<my_args)
}

MyArguments :: struct {
    name : String
    age  : int
}

parse_arguments :: ($T: type, args: Array[String]) -> &T {
    result := alloc(T)

    use TypeInfoKind

    typ_base := @type_info(T)
    typ := match typ_base.kind {
        Struct($info) -> info
        $_ -> {
            io.printfln("Can't use non-struct type {}", @typename(T))
            return null
        }
    }

    while i := 0, i < args.get_length(), i += 1 {
        if i == 0 then continue
        arg := ref args[i]
        @assert(arg.get_length() > 0)

        if arg[0] == '-' {
            name := arg.sliceF(1)
            mem := typ.get_member(name)

            if mem == null {
                io.printfln("[CLP] Error: unknown argument '{}'", name)
                continue
            }

            match mem.typ.kind {
                Struct($tstr) if streq(tstr.name, "StringBase") -> {
                    @assert(i < args.get_length() - 1)
                    value := args[i + 1].clone()
                    ptr := cast(&String) pointer_add(result, mem.offset)
                    <<ptr = value
                    i += 1
                }

                Int($tint) -> {
                    value := io.parse_int(args[i + 1].slice())
                    <<cast(&int) pointer_add(result, mem.offset) = value
                    i += 1
                }

                $_ -> {
                    @assert(false, "Not implemented")
                }
            }
        } else {
            @assert(false, "Not implemented")
            io.println("[CLP] Error: not implemented")
        }

        io.printfln("parsing '{}'", arg.slice())
    }

    // <<result = T(String.from_string("lol"))
    // <<&result.name = String.from_string("wassup")
    // result.name = 456
    return result
}

// helper functions
to_ascii_strings :: (argv: &&u16, argc: int) -> Array[String] {
    array := Array[String].create(argc)
    for i : 0..argc {
        str := String.empty()
        while k := 0, argv[i][k] != 0, k += 1 {
            str += char(argv[i][k])
        }

        array.add(str)
    }
    return array
}

get_cmd_args :: () -> Array[String] {
    cmdLineArgs := GetCommandLineW()
    count := 0i32
    args := CommandLineToArgvW(cmdLineArgs, &count)
    return to_ascii_strings(args, int(count))
}