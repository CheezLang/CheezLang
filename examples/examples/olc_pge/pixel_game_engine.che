#load("pixel.che")
#load("key.che")
#load("sprite.che")
#load("olc_win.che")
#load("pge_render_functions.che")
#load("pge_helper_functions.che")

#load("std:hash_table")
#load("std:util")
#load("opengl:opengl")

trait Game {
    fn on_create(ref Self, pge: &PixelGameEngine) -> bool;
    fn on_destroy(ref Self) -> bool;
    fn on_update(ref Self, dt: float) -> bool;
}

enum OptionPGE {
    Some: &PixelGameEngine
    None
}

struct PixelGameEngine {
    game                : Game


    default_draw_target : &Sprite   = null
    draw_target         : &Sprite   = null

    // windows specific
    olc_hWnd            : HWND      = null

    // other stuff
    nMousePosX          : int
    nMousePosY          : int
    nMousePosXcache     : int
    nMousePosYcache     : int

    nMouseWheelDelta    : int
    nMouseWheelDeltaCache : int

    window_width        : int       = -1
    window_height       : int       = -1
    screen_width        : int
    screen_height       : int
    pixel_width         : int
    pixel_height        : int

    pixel_x             : float     = 1.0f
    pixel_y             : float     = 1.0f
    fSubPixelOffsetX    : float     = 0.0f
    fSubPixelOffsetY    : float     = 0.0f

    nPixelMode          : PixelMode = PixelMode.Normal
    fBlendFactor        : float     = 1.0f

    bHasMouseFocus      : bool      = false
    bHasInputFocus      : bool      = false

    pKeyNewState        : [256]bool
    pKeyOldState        : [256]bool
    pKeyboardState      : [256]HWButton

    pMouseState         : [5]HWButton
    pMouseOldState      : [5]bool
    pMouseNewState      : [5]bool

    fFrameTimer         : float
    nFrameCount         : int

    mapKeys             : Table(int, Key)

    active              : bool

    // gl stuff
    glBuffer            : GLuint
    glDeviceContext     : HDC   = null
    glRenderContext     : HGLRC = null
}

fn compare_ints(a: int, b: int) -> bool {
    return b == a
}


impl PixelGameEngine {
    fn create(game: Game, screen_w: int, screen_h: int, pixel_w: int = 1, pixel_h: int = 1) -> OptionPGE {
        if screen_w <= 0 or screen_h <= 0 or pixel_w <= 0 or pixel_h <= 0 {
            return OptionPGE.None
        }

        let pge = alloc(PixelGameEngine)

        <<pge = new PixelGameEngine {
            game = game
            screen_width = screen_w
            screen_height = screen_h
            pixel_width = pixel_w
            pixel_height = pixel_h
            pixel_x = 2.0f / cast(float) screen_w
            pixel_y = 2.0f / cast(float) screen_h
            mapKeys = Table(int, Key)::create(compare_ints)
        }

        pge.default_draw_target = alloc(Sprite)
        <<pge.default_draw_target = Sprite::create(screen_w, screen_h)

        pge.set_draw_target(null)

        return OptionPGE.Some(pge)
    }

    fn dispose(ref Self) {
        default_draw_target.dispose()
        free(default_draw_target)
        default_draw_target = null

        mapKeys.dispose()
    }

    fn start(ref Self) {
        let wnd = self.olc_window_create()
        if wnd == null {
            return
        }

        active = true
        engine_thread()
    }

    fn engine_thread(ref Self) {
        // Start OpenGL, the context is owned by the game thread
        olc_OpenGLCreate()

        // Create Screen Texture - disable filtering
        glEnable(GL_TEXTURE_2D)
        glGenTextures(1, &glBuffer)
        glBindTexture(GL_TEXTURE_2D, glBuffer)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, cast GL_NEAREST)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, cast GL_NEAREST)
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, cast GL_DECAL) // glTexEnvf?
        gl_check_error()

        glTexImage2D(GL_TEXTURE_2D, 0, cast GL_RGBA, cast screen_width, cast screen_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, default_draw_target.get_data())
        gl_check_error()


        // Create user resources as part of this thread
        if !game.on_create(&self) {
            active = false
        }

        let tp1 = getCurrentTimeInMicroseconds()
        let tp2 = getCurrentTimeInMicroseconds()

        let fps_string = String::empty()

        while active {
            // Run as fast as possible
            while active {
                let msg: MSG
                while PeekMessageA(&msg, null, 0, 0, 0x0001) > 0 {
                    TranslateMessage(&msg)
                    DispatchMessageA(&msg)
                }
                // Handle Timing
                tp2 = getCurrentTimeInMicroseconds()
                let fElapsedTime = cast(float) (cast(double) tp2 - tp1) * 0.000001
                tp1 = tp2

                // Handle User Input - Keyboard
                while let i = 0; i < 256; i += 1 {
                    pKeyboardState[i].pressed = false
                    pKeyboardState[i].released = false

                    if pKeyNewState[i] != pKeyOldState[i] {
                        if (pKeyNewState[i]) {
                            pKeyboardState[i].pressed = !pKeyboardState[i].held
                            pKeyboardState[i].held = true
                        } else {
                            pKeyboardState[i].released = true
                            pKeyboardState[i].held = false
                        }
                    }

                    pKeyOldState[i] = pKeyNewState[i]
                }

                // Handle User Input - Mouse
                while let i = 0; i < 5; i += 1 {
                    pMouseState[i].pressed = false
                    pMouseState[i].released = false

                    if (pMouseNewState[i] != pMouseOldState[i])
                    {
                        if (pMouseNewState[i])
                        {
                            pMouseState[i].pressed = !pMouseState[i].held
                            pMouseState[i].held = true
                        }
                        else
                        {
                            pMouseState[i].released = true
                            pMouseState[i].held = false
                        }
                    }

                    pMouseOldState[i] = pMouseNewState[i]
                }

                // Cache mouse coordinates so they remain
                // consistent during frame
                nMousePosX = nMousePosXcache
                nMousePosY = nMousePosYcache

                nMouseWheelDelta = nMouseWheelDeltaCache
                nMouseWheelDeltaCache = 0

                // Handle Frame Update
                if !game.on_update(fElapsedTime) {
                    active = false
                }

                // Display Graphics
                glClear(GL_COLOR_BUFFER_BIT)

                // TODO: This is a bit slow (especially in debug, but 100x faster in release mode???)
                // Copy pixel array into texture
                glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, cast screen_width, cast screen_height, GL_RGBA, GL_UNSIGNED_BYTE, default_draw_target.get_data())


                // Display texture on screen
                glBegin(GL_QUADS)
                    glTexCoord2f(0.0f, 1.0f)
                    glVertex3f(-1.0f + (fSubPixelOffsetX), -1.0f + (fSubPixelOffsetY), 0.0f)
                    glTexCoord2f(0.0f, 0.0f)
                    glVertex3f(-1.0f + (fSubPixelOffsetX),  1.0f + (fSubPixelOffsetY), 0.0f)
                    glTexCoord2f(1.0f, 0.0f)
                    glVertex3f( 1.0f + (fSubPixelOffsetX),  1.0f + (fSubPixelOffsetY), 0.0f)
                    glTexCoord2f(1.0f, 1.0f)
                    glVertex3f( 1.0f + (fSubPixelOffsetX), -1.0f + (fSubPixelOffsetY), 0.0f)
                glEnd()

                // Present Graphics to screen
                SwapBuffers(glDeviceContext)

                // Update Title Bar
                fFrameTimer += fElapsedTime
                nFrameCount += 1
                if fFrameTimer >= 1.0f {
                    fFrameTimer -= 1.0f

                    fps_string.length = 0
                    fps_string.appendf("OneLoneCoder.com - Pixel Game Engine - FPS: {}", [nFrameCount])
                    fps_string += cast(char) 0

                    SetWindowTextA(olc_hWnd, fps_string.get_raw())
                    nFrameCount = 0
                }
            }

            // Allow the user to free resources if they have overrided the destroy function
            if !game.on_destroy() {
                // User denied destroy for some reason, so continue running
                active = true
            }
        }

        // wglDeleteContext(glRenderContext);
        PostMessageA(olc_hWnd, WM_DESTROY, 0, 0)
    }

    fn olc_OpenGLCreate(ref Self) -> bool {
        glDeviceContext = GetDC(olc_hWnd)

        let pfd = new PIXELFORMATDESCRIPTOR {
            @sizeof(PIXELFORMATDESCRIPTOR), 1,
            @bin_or(PFD_DRAW_TO_WINDOW, PFD_SUPPORT_OPENGL, PFD_DOUBLEBUFFER),
            PFD_TYPE_RGBA, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            PFD_MAIN_PLANE, 0, 0, 0, 0
        }

        let pf = ChoosePixelFormat(glDeviceContext, &pfd)
        if pf == 0 {
            return false
        }
        SetPixelFormat(glDeviceContext, pf, &pfd)

        glRenderContext = wglCreateContext(glDeviceContext)
        if glRenderContext == null {
            return false
        }
        wglMakeCurrent(glDeviceContext, glRenderContext)

        // Remove Frame cap
        let wglSwapInterval = cast(fn(i32) #stdcall {})wglGetProcAddress("wglSwapIntervalEXT")
        if wglSwapInterval {
            wglSwapInterval(0)
        }
        return true
    }
}
