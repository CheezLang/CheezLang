#load("std:mem/allocator")
#load("std:math")

struct Sprite {
    pub const width: int
    pub const height: int
    pub const mode : SpriteMode = SpriteMode.Normal
    pub const data: &Pixel = null
}

enum SpriteMode {
    Normal,
    Periodic
}

impl Sprite {
    fn create(w: int, h: int) -> Self {
        return new {
            width = w
            height = h
            data = {
                let ptr = alloc_raw(Pixel, cast(uint) (w * h))
                while let i = 0; i < w * h; i += 1 {
                    ptr[i] = new Pixel{}
                }
                ptr
            }
        }
    }

    fn dispose(ref Self) {
        free(data)

        width = 0
        height = 0
        data = null
    }

    fn set_sample_mode(ref Self, mode: SpriteMode) {
        self.mode = mode
    }

    fn get_pixel(ref Self, x: int, y: int) -> Pixel {
        return match mode {
            SpriteMode.Normal -> {
                if x >= 0 and x < width and y >= 0 and y < height {
                    data[x + y * width]
                } else {
                    new Pixel{0, 0, 0, 0}
                }
            }
            SpriteMode.Periodic -> {
                data[mod_pos(x, width) + mod_pos(y, height) * width]
            }
        }
    }

    fn set_pixel(ref Self, x: int, y: int, p: Pixel) -> bool {
        if x >= 0 and x < width and y >= 0 and y < height {
            data[x + y * width] = p
            return true
        } else {
            return false
        }
    }

    fn acc_pixel_op(ref Self, p: (int, int)) -> ref Pixel #operator("[]") {
        return data[mod_pos(p[0], width) + mod_pos(p[1], height) * width]
    }

    fn sample(ref Self, x: float, y: float) -> Pixel {
        let sx = cast(int) fminf(x * cast(float)width, cast width - 1)
        let sy = cast(int) fminf(y * cast(float)height, cast height - 1)
        return get_pixel(sx, sy)
    }

    fn get_data(ref Self) -> &Pixel {
        return data
    }
}
