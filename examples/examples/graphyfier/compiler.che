use import std.mem.allocator
use import std.array
use import std.string
use import std.compiler.string_database
use import std.profiling
use import std.compiler.lexer
use import std.compiler.token
use import evaluator
io :: import std.io
C :: import std.c

get_precedence :: (op: OpCode) -> int {
    return match op {
        OpCode.Grp -> 0
        OpCode.Neg -> 1
        OpCode.Sin -> 1
        OpCode.Cos -> 1
        OpCode.Log -> 1
        OpCode.Pow -> 2
        OpCode.Mul -> 3
        OpCode.Div -> 3
        OpCode.Add -> 4
        OpCode.Sub -> 4
        $_ -> {
            @assert(false)
            -1
        }
    }
}

compile :: (expr: string, var_name_allocator: Allocator) -> Option[Array[OpCode]] {
    res := Array[OpCode].create()
    
    string_db := StringDatabase.create()
    lexer := Lexer.from_raw_string(expr, string_db)

    op_stack := Array[OpCode].create()

    last_was_expression := false

    while true {
        tok := lexer.next_token()

        match tok.ttype {
            TokenType.EOF -> break
            TokenType.NewLine -> break
        }

        if last_was_expression {
            last_was_expression = false
            match tok.ttype {
                TokenType.Plus -> {
                    p := get_precedence(OpCode.Add)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) <= p {
                        if int(op_stack.peek_last()) == int(OpCode.Grp) then break
                        res.add(op_stack.pop())
                    }
                    op_stack.push(OpCode.Add)
                }
                TokenType.Minus -> {
                    p := get_precedence(OpCode.Sub)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) <= p {
                        if int(op_stack.peek_last()) == int(OpCode.Grp) then break
                        res.add(op_stack.pop())
                    }
                    op_stack.push(OpCode.Sub)
                }
                TokenType.Asterisk -> {
                    p := get_precedence(OpCode.Mul)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) <= p {
                        if int(op_stack.peek_last()) == int(OpCode.Grp) then break
                        res.add(op_stack.pop())
                    }
                    op_stack.push(OpCode.Mul)
                }
                TokenType.ForwardSlash -> {
                    p := get_precedence(OpCode.Div)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) <= p {
                        if int(op_stack.peek_last()) == int(OpCode.Grp) then break
                        res.add(op_stack.pop())
                    }
                    op_stack.push(OpCode.Div)
                }
                TokenType.Caret -> {
                    p := get_precedence(OpCode.Pow)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) <= p {
                        if int(op_stack.peek_last()) == int(OpCode.Grp) then break
                        res.add(op_stack.pop())
                    }
                    op_stack.push(OpCode.Pow)
                }
                TokenType.ClosingParen -> {
                    p := get_precedence(OpCode.Grp)
                    while op_stack.get_length() > 0 and get_precedence(op_stack.peek_last()) > p {
                        res.add(op_stack.pop())
                    }
                    if op_stack.get_length() == 0 {
                        io.println("[ERROR] Mismatched parenthesis")
                        return None
                    }
                    op_stack.pop()
                    last_was_expression = true
                }

                $_ -> {
                    io.printfln("[ERROR] {}: Unexpected token '{}'", (tok.location, tok.ttype))
                    return None
                }
            }
        } else {
            last_was_expression = true

            match tok.ttype {
                TokenType.NumberLiteral -> {
                    is_real := match tok.suffix {
                        Some($s) -> {
                            if streq(s, "i") {
                                false
                            } else {
                                io.printfln("[ERROR] {}: Invalid suffix '{}'", (tok.location, s))
                                return None
                            }
                        }
                        None -> true
                    }

                    match tok.data {
                        TokenData.Integer($v) -> {
                            if is_real then
                                res.add(OpCode.Real(double(v)))
                            else
                                res.add(OpCode.Im(double(v)))
                        }

                        TokenData.Double($v) -> {
                            if is_real then
                                res.add(OpCode.Real(v))
                            else
                                res.add(OpCode.Im(v))
                        }

                        $_ -> @assert(false)
                    }
                }

                TokenType.Identifier -> {
                    match tok.data {
                        TokenData.String($v) -> {
                            if streq(v, "i") {
                                res.add(OpCode.Im(1.0))
                            } else if streq(v, "sin") {
                                op_stack.push(OpCode.Sin)
                                last_was_expression = false
                            } else if streq(v, "cos") {
                                op_stack.push(OpCode.Cos)
                                last_was_expression = false
                            } else if streq(v, "ln") {
                                op_stack.push(OpCode.Log)
                                last_was_expression = false
                            } else {
                                name_copy := alloc_n(char, cast v.length, var_name_allocator)
                                C.memcpy(name_copy.data, v.data, cast @sizeof(char) * v.length)
                                res.add(OpCode.Var(name_copy))
                            }
                        }

                        $_ -> @assert(false)
                    }
                }

                TokenType.Minus -> {
                    op_stack.push(OpCode.Neg)
                    last_was_expression = false
                }

                TokenType.OpenParen -> {
                    op_stack.push(OpCode.Grp)
                    last_was_expression = false
                }

                $_ -> {
                    io.printfln("[ERROR] {}: Unexpected token '{}'", (tok.location, tok.ttype))
                    return None
                }
            }
        }
    }

    while op_stack.get_length() > 0 {
        if int(op_stack.peek_last()) == int(OpCode.Grp) {
            io.println("[ERROR] Mismatched parenthesis")
            return None
        }
        res.add(op_stack.pop())
    }

    if res.get_length() == 0 {
        io.println("[ERROR] Empty input")
        return None
    }

    if !last_was_expression {
        io.println("[ERROR] Invalid expression")
        return None
    }

    return Some(res)
}