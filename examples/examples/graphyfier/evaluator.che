#load("std:math")
#load("std:printable")
#load("std:hash_table")

typedef Variables = Table[string, Complex]

fn evaluate(code: []OpCode, vars: ref Variables) -> Option[Complex] {
    let stack = @alloca(Complex, 128)
    let sp = 0

    for op : code {
        match op {
            OpCode.Real($val) -> {
                stack[sp] = Complex(val, 0.0)
                sp += 1
            }
            OpCode.Im($val) -> {
                stack[sp] = Complex(0.0, val)
                sp += 1
            }
            OpCode.Var($name) -> {
                match vars.get(name) {
                    Some($v) -> {
                        stack[sp] = <<&v
                        sp += 1
                    }
                    None -> {
                        return None
                    }
                }
            }
            OpCode.Neg -> {
                stack[sp - 1] = Complex::neg(stack[sp - 1])
            }
            OpCode.Con -> {
                stack[sp - 1] = Complex::conj(stack[sp - 1])
            }
            OpCode.Add -> {
                stack[sp - 2] = stack[sp - 2] + stack[sp - 1]
                sp -= 1
            }
            OpCode.Sub -> {
                stack[sp - 2] = stack[sp - 2] - stack[sp - 1]
                sp -= 1
            }
            OpCode.Mul -> {
                stack[sp - 2] = stack[sp - 2] * stack[sp - 1]
                sp -= 1
            }
            OpCode.Div -> {
                let x = stack[sp - 1]

                if (x.r * x.r + x.i * x.i) < 0.0001 {
                    return None
                }

                stack[sp - 2] = stack[sp - 2] / x
                sp -= 1
            }
            OpCode.Pow -> {
                let u = stack[sp - 2]
                let v = stack[sp - 1]

                if u.r != 0 or u.i != 0 {
                    let (r, p) = u.polar()

                    let ln_r = log(r)
                    let res_r = exp(v.r * ln_r - v.i * p)
                    let res_p = v.i * ln_r + v.r * p

                    stack[sp - 2] = Complex::from_polar(res_r, res_p)
                }

                sp -= 1
            }
            OpCode.Log -> {
                let (r, p) = stack[sp - 1].polar()
                if r == 0 {
                    return None
                }
                stack[sp - 1] = Complex(log(r), p)
            }
            OpCode.Sin -> {
                let u = stack[sp - 1]
                stack[sp - 1] = Complex(
                    r = sin(u.r) * cosh(u.i)
                    i = cos(u.r) * sinh(u.i)
                )
            }
            OpCode.Cos -> {
                let u = stack[sp - 1]
                stack[sp - 1] = Complex(
                    r =  cos(u.r) * cosh(u.i)
                    i = -sin(u.r) * sinh(u.i)
                )
            }

            $_ -> {
                @assert(false, "not implemented")
            }
        }
    }

    @assert(sp == 1)

    return Some(stack[0])
}

enum OpCode {
    Real    : double
    Im      : double
    Var     : string
    Neg
    Con
    Add
    Sub
    Mul
    Div
    Pow
    Log
    Sin
    Cos
    Grp
}

impl Printable for OpCode {
    fn print(ref Self, str: ref String, format: string) {
        use OpCode
        match self {
            Real($v)    -> str.appendf("Real({})", v)
            Im($v)      -> str.appendf("Im({})", v)
            Var($name)  -> str.appendf("Var({})", name)
            Neg         -> str.append_string("Neg")
            Con         -> str.append_string("Con")
            Add         -> str.append_string("Add")
            Sub         -> str.append_string("Sub")
            Mul         -> str.append_string("Mul")
            Div         -> str.append_string("Div")
            Pow         -> str.append_string("Pow")
            Log         -> str.append_string("Log")
            Sin         -> str.append_string("Sin")
            Cos         -> str.append_string("Cos")
            Grp         -> str.append_string("Grp")
        }
    }
}
