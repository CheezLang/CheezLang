#load("token.che")

enum OptionalToken {
    Some : Token
    None
}

struct Lexer {
    text: String
    location: TokenLocation
    peek: OptionalToken
}

fn isIdentBegin(c: char) -> bool {    
    return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')
}

fn isIdentChar(c: char) -> bool {
    return isIdentBegin(c) or (c >= '0' and c <= '9')
}

impl Lexer {
    fn from_file(filename: string) -> Self {
        
    }

    ref fn init(filename: c_string) -> bool {
        text = newString()
        if loadFile(filename, &text) == false { return false }

        location = new TokenLocation {
            filename, 1, 0, 0
        }

        hasPeeked = false

        return true
    }

    ref fn cleanup() {
        text.dispose()
    }

    ref fn nextToken() -> Token {
        if hasPeeked {
            peek = self.readToken()
            hasPeeked = false
            return peek
        }

        let loc: TokenLocation
        if self.skipNewlinesAndComments(&loc) {
            loc.end = loc.start
            let tok: Token
            tok.location = loc
            tok.type = TokenType.NewLine
            return tok
        }

        return self.readToken()
    }

    ref fn readToken() -> Token {
        let token = new Token {
            TokenType.Unknown
            location.clone()
        }

        if location.start >= text.length {
            token.type = TokenType.EOF
            return token
        }

        let c = self.peekChar(0)
        
        match c {
            ':' -> self.makeSimpleToken(&token, TokenType.Colon),
            ';' -> self.makeSimpleToken(&token, TokenType.Semicolon),
            '.' -> self.makeSimpleToken(&token, TokenType.Period),
            '=' -> self.makeSimpleToken(&token, TokenType.Equal),
            '(' -> self.makeSimpleToken(&token, TokenType.OpenParen),
            ')' -> self.makeSimpleToken(&token, TokenType.ClosingParen),
            '{' -> self.makeSimpleToken(&token, TokenType.OpenBrace),
            '}' -> self.makeSimpleToken(&token, TokenType.ClosingBrace),
            '[' -> self.makeSimpleToken(&token, TokenType.OpenBracket),
            ']' -> self.makeSimpleToken(&token, TokenType.ClosingBracket),
            ',' -> self.makeSimpleToken(&token, TokenType.Comma),
            '&' -> self.makeSimpleToken(&token, TokenType.Ampersand),
            '*' -> self.makeSimpleToken(&token, TokenType.Asterisk),
            '/' -> self.makeSimpleToken(&token, TokenType.ForwardSlash),
            '+' -> self.makeSimpleToken(&token, TokenType.Plus),
            '%' -> self.makeSimpleToken(&token, TokenType.Percent),
            '-' -> self.makeSimpleToken(&token, TokenType.Minus),
            '<' -> self.makeSimpleToken(&token, TokenType.Less),
            '>' -> self.makeSimpleToken(&token, TokenType.Greater),
            '!' -> self.makeSimpleToken(&token, TokenType.Bang),
        }

        if token.type == TokenType.Unknown {
            if isIdentBegin(c) {
                self.parseIdentifier(&token, TokenType.Identifier)
            }
            else if c == '$' {
                location.start = location.start + 1
                self.parseIdentifier(&token, TokenType.DollarIdentifier)
            }
            else if c == '#' {
                location.start = location.start + 1
                self.parseIdentifier(&token, TokenType.HashIdentifier)
            }
            else if c == '@' {
                location.start = location.start + 1
                self.parseIdentifier(&token, TokenType.AtSignIdentifier)
            }
            else if c == '"' {
                self.parseStringLiteral(&token, TokenType.StringLiteral, '"')
            }
            else if c == '`'' {
                self.parseStringLiteral(&token, TokenType.CharLiteral, '`'')
            }
            else {
                location.start = location.start + 1
            }
        }

        token.location.end = location.start

        return token
    }

    ref fn parseStringLiteral(token: Token&, type: TokenType, end: char) {
        token.type = TokenType.StringLiteral
        location.start = location.start + 1
        let start = location.start

        let foundEnd = false
        while location.start < text.length {
            let c = self.peekChar(0)
            location.start += 1

            if c == end {
                foundEnd = true
                break
            }
            else if c == '``' {
                if location.start >= text.length {
                    break
                }

                location.start += 1
            }
        }

        
        token.data.stringValue = &text.data[start]
        token.data.stringValue.length = location.start - start - 1
    }

    ref fn parseIdentifier(token: Token&, type: TokenType) {
        token.type = type
        let start = location.start

        while location.start < text.length and isIdentChar(self.peekChar(0)) {
            location.start += 1
        }

        token.data.stringValue = &text.data[start]
        token.data.stringValue.length = location.start - start
    }

    ref fn makeSimpleToken(token: Token&, type: TokenType) {
        location.start += 1

        token.type = type
        token.location.end = token.location.start + 1
    }

    ref fn peekChar(offset: i32) -> char {
        let index = location.start + offset
        if index >= text.length {
            return '`0'
        }

        return text.data[index]
    }

    ref fn skipNewlinesAndComments(loc: TokenLocation&) -> bool {
        let locExists = false

        while location.start < text.length {
            let c = self.peekChar(0)
            let next = self.peekChar(1)
            

            if c == '/' and next == '*' {
                //parseMultiLineComment()
            }

            else if c == '/' and next == '/' {
                self.parseSingleLineComment()
            }

            else if c == ' ' or c == '`t' {
                location.start += 1
            }

            else if c == '`r' {
                location.start += 1
            }

            else if c == '`n' {
                if !locExists {
                    <<loc = location.clone()
                    locExists = true
                }

                location.line += 1
                location.start += 1
            }

            else {
                break
            }
        }

        if locExists {
            loc.end = location.start
            return true
        }

        return false
    }

    ref fn parseSingleLineComment() {
        while location.start < text.length {
            if self.peekChar(0) == '`n' {
                break
            }

            location.start += 1
        }
    }
}
