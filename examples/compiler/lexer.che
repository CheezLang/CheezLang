#load("../string.che")
#load("token.che")

struct Lexer {
    text: String
    location: TokenLocation
}

fn IsIdentBegin(c: char) -> bool {    
    return (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z')
}

fn IsIdentChar(c: char) -> bool {
    return IsIdentBegin(c) or (c >= '0' and c <= '9')
}

impl Lexer {
    ref fn Init(filename: string) -> bool {
        text = NewString()
        if LoadFile(filename, &text) == false { return false }

        location = new TokenLocation {
            filename, 1, 0, 0
        }

        return true
    }

    ref fn Cleanup() {
        text.Dispose()
    }

    ref fn NextToken() -> Token {
        let token = new Token {
            TokenType.Unknown
            location.Clone()
        }

        self.SkipNewlinesAndComments()

        if location.start >= text.length {
            token.type = TokenType.EOF
            return token
        }

        let c = self.PeekChar(0)

        
        match c {
            ':' -> self.MakeSimpleToken(&token, TokenType.Colon),
            ';' -> self.MakeSimpleToken(&token, TokenType.Semicolon),
            '.' -> self.MakeSimpleToken(&token, TokenType.Period),
            '=' -> self.MakeSimpleToken(&token, TokenType.Equal),
            '(' -> self.MakeSimpleToken(&token, TokenType.OpenParen),
            ')' -> self.MakeSimpleToken(&token, TokenType.ClosingParen),
            '{' -> self.MakeSimpleToken(&token, TokenType.OpenBrace),
            '}' -> self.MakeSimpleToken(&token, TokenType.ClosingBrace),
            '[' -> self.MakeSimpleToken(&token, TokenType.OpenBracket),
            ']' -> self.MakeSimpleToken(&token, TokenType.ClosingBracket),
            ',' -> self.MakeSimpleToken(&token, TokenType.Comma),
            '&' -> self.MakeSimpleToken(&token, TokenType.Ampersand),
            '*' -> self.MakeSimpleToken(&token, TokenType.Asterisk),
            '/' -> self.MakeSimpleToken(&token, TokenType.ForwardSlash),
            '+' -> self.MakeSimpleToken(&token, TokenType.Plus),
            '%' -> self.MakeSimpleToken(&token, TokenType.Percent),
            '-' -> self.MakeSimpleToken(&token, TokenType.Minus),
            '<' -> self.MakeSimpleToken(&token, TokenType.Less),
            '>' -> self.MakeSimpleToken(&token, TokenType.Greater),
            '!' -> self.MakeSimpleToken(&token, TokenType.Bang),
        }

        if token.type == TokenType.Unknown {
            if IsIdentBegin(c) {
                self.ParseIdentifier(&token, TokenType.Identifier)
            }
            else if c == '$' {
                location.start = location.start + 1
                self.ParseIdentifier(&token, TokenType.DollarIdentifier)
            }
            else if c == '#' {
                location.start = location.start + 1
                self.ParseIdentifier(&token, TokenType.HashIdentifier)
            }
            else if c == '@' {
                location.start = location.start + 1
                self.ParseIdentifier(&token, TokenType.AtSignIdentifier)
            }
            else if c == '"' {
                self.ParseStringLiteral(&token, TokenType.StringLiteral, '"')
            }
            else if c == '`'' {
                self.ParseStringLiteral(&token, TokenType.CharLiteral, '`'')
            }
            else {
                location.start = location.start + 1
            }
        }

        token.location.end = location.start

        return token
    }

    ref fn ParseStringLiteral(token: Token&, type: TokenType, end: char) {
        token.type = TokenType.StringLiteral
        location.start = location.start + 1
        let start = location.start

        token.data.stringLiteral = "".ToString()

        let foundEnd = false
        let cond = true
        while cond and location.start < text.length {
            let c = self.PeekChar(0)
            location.start = location.start + 1

            if c == end {
                foundEnd = true
                cond = false
            }
            else if c == '``' {
                if location.start >= text.length {
                    cond = false
                }
                else {
                    let c = self.PeekChar(0)

                    if c == 'n' {
                        token.data.stringLiteral.AppendChar('`n')
                    } else if c == '0' {
                        token.data.stringLiteral.AppendChar('`0')
                    } else {
                        token.data.stringLiteral.AppendChar(c)
                    }

                    location.start = location.start + 1
                }
            }
            else {
                token.data.stringLiteral.AppendChar(c)
            }
        }
    }

    ref fn ParseIdentifier(token: Token&, type: TokenType) {
        token.type = type
        let start = location.start

        while location.start < text.length and IsIdentChar(self.PeekChar(0)) {
            location.start = location.start + 1
        }

        token.data.identifier = &text.data[start]
        token.data.identifier.length = location.start - start
    }

    ref fn MakeSimpleToken(token: Token&, type: TokenType) {
        location.start = location.start + 1

        token.type = type
        token.location.end = token.location.start + 1
    }

    ref fn PeekChar(offset: int) -> char {
        let index = location.start + offset
        if index >= text.length {
            return '`0'
        }

        return text.data[index]
    }

    ref fn SkipNewlinesAndComments() {

    }
}
