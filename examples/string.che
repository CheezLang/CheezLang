#load("memory.che")
#load("allocator.che")

fn strlen(s: string) -> int {
    let len: int = 0
    while s[len] != '`0' {
        len += 1
    }
    return len
}

fn streql(a: $T, b: $T2, len: ulong) -> bool {
    let alen: ulong = (ulong)a.GetLength()
    let blen: ulong = (ulong)b.GetLength()
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    let i: ulong = 0
    while i < len {
        defer i += 1
        if a.GetChar(i) != b.GetChar(i) {
            return false
        }
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len: ulong = (ulong)a.GetLength()
    let blen: ulong = (ulong)b.GetLength()

    if len != blen {
        return false
    }

    if len > blen {
        len = blen
    }

    let i: ulong = 0
    while (i < len) {
        defer i += 1
        if a.GetChar(i) != b.GetChar(i) {
            return false
        }
    }
    return true
}

impl string {
    fn GetLength() -> int {
        return strlen(self)
    }

    fn GetChar(i: $T) -> char {
        return self[i]
    }
}

struct StringBase(CharType: type) {
    data: CharType&
    length: int
    capacity: int
    allocator: Allocator
}

let String = StringBase(char)
let Utf32String = StringBase(int)

impl StringBase($CharType) {
    ref fn GetLength() -> int {
        return length
    }

    ref fn GetChar(i: $T) -> char {
        return data[i]
    }

    ref fn Init(alloc: Allocator) {
        allocator = alloc
        data = null
        length = 0
        capacity = 0
        self.Reserve(10)
    }

    ref fn Reserve(size: int) {
        capacity = size
        if data == null {
            length = 0
            data = Malloc((uint)capacity)
        }
        else {
            data = Realloc(data, (uint)capacity)
            if length > capacity {
                length = capacity
            }
        }
    }
    
    ref fn Resize(size: int) {
        length = size
        capacity = size
        if data == null {
            data = Malloc((uint)capacity)
        }
        else {
            data = Realloc(data, (uint)capacity)
        }
    }

    ref fn FromString(str: string) -> StringBase(CharType)& {
        if (ulong)data != 0 {
            // @Todo:
            //self.Dispose()
            Free(data)
            data = null
            length = 0
            capacity = 0
        }

        length = strlen(str)
        capacity = length
        data = Malloc((uint)capacity)

        if @sizeof(CharType) == 1 {
            memcpy(data, (any&)str, length)
        } else {
            let i = 0
            while i < length {
                defer i += 1
                data[i] = (CharType)str[i]
            }
        }

        return &self
    }

    ref fn Append(other: StringBase(CharType)) -> StringBase(CharType)& {
        let newLength = length + other.length

        if newLength >= capacity {
            capacity = newLength * 2
            data = Realloc(data, (uint)capacity)
        }
        
        let end = &data[length]
        memcpy(end, other.data, other.length * @sizeof(CharType))

        length = newLength

        return &self
    }

    ref fn AppendString(other: string) -> StringBase(CharType)& {
        let otherLength = strlen(other)
        let newLength = length + otherLength
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = Realloc(data, (uint)capacity)
        }
        
        let end = &data[length]
        memcpy(end, (any&)other, otherLength)

        length = newLength

        return &self
    }

    ref fn AppendChars(other: char[]) -> StringBase(CharType)& {
        let newLength = length + other.length
                
        if newLength >= capacity {
            capacity = newLength * 2
            data = Realloc(data, (uint)capacity)
        }
        
        let end = &data[length]
        memcpy(end, (any&)other, other.length)

        length = newLength

        return &self
    }

    ref fn AppendChar(ch: CharType) -> StringBase(CharType)& {
        let newLength = length + 1
        
        if newLength >= capacity {
            capacity = newLength * 2
            data = Realloc(data, (uint)capacity)
        }
        
        
        data[length] = ch
        length = newLength

        return &self
    }

    ref fn Equals(other: $T) -> bool {
        if @isstring(T) { 
            let len: @typeof(length) = strlen(other)
            if len != length {
                return false
            }
            
            let i: @typeof(length) = 0
            while i < len {
                defer i += 1

                if data[i] != other[i] {
                    return false
                }
            }
            return true
        }
        else {
            @error("Not implemented")
        }
    }

    ref fn Dispose() {
        Free(data)
        data = null
        length = 0
    }

    ref fn Slice(from: int, len: int) -> CharType[] {
        let slice: CharType[] = &data[from]
        slice.length = len
        return slice
    }
}

fn NewString() -> String {
    let t = new String {
        null, 0, 0
    }
    t.Reserve(10)
    return t
}

impl string {
    fn ToString() -> String {
        let s = NewString()
        s.FromString(self)
        return s
    }
}
