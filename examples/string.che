#load("memory.che")

fn strlen(s: $T) -> int {
    let len: int = 0
    while s[len] != '`0' {
        len = len + 1
    }
    return len
}

fn streql(a: $T, b: $T2, len: ulong) -> bool {
    let alen: ulong = (ulong)strlen(a)
    let blen: ulong = (ulong)strlen(b)
    if len > alen {
        len = alen
    }
    if len > blen {
        len = blen
    }

    let i: ulong = 0
    while i < len {
        if a[i] != b[i] {
            return false
        }

        i = i + 1
    }
    return true
}

fn streq(a: $T, b: $T2) -> bool {
    let len: ulong = (ulong)strlen(a)
    let blen: ulong = (ulong)strlen(b)
    if len > blen {
        len = blen
    }

    let i: ulong = 0
    while (i < len) {
        if a[i] != b[i] {
            return false
        }

        i = i + 1
    }
    return true
}

struct StringBase(CharType: type) {
    data: CharType&
    length: int
    capacity: int
}

let String = StringBase(char)
let Utf32String = StringBase(int)

impl StringBase($CharType) {
    ref fn Reserve(size: int) {
        capacity = size
        if (ulong)data == 0 {
            length = 0
            data = Malloc((uint)capacity)
        }
        else {
            data = Realloc(data, (uint)capacity)
            if length > capacity {
                length = capacity
            }
        }
    }
    
    ref fn Resize(size: int) {
        length = size
        capacity = size
        if (ulong)data == 0 {
            data = Malloc((uint)capacity)
        }
        else {
            data = Realloc(data, (uint)capacity)
        }
    }

    ref fn FromString(str: string) -> StringBase(CharType)& {
        if (ulong)data != 0 {
            // @Todo:
            //self.Dispose()
            Free((void&)data)
            data = (CharType&)0
            length = 0
            capacity = 0
        }

        length = strlen(str)
        capacity = length
        data = Malloc((uint)capacity)

        if @sizeof(CharType) == 1 {
            memcpy((void&)data, (void&)str, length)
        } else {
            let i = 0
            while i < length {
                data[i] = (CharType)str[i]
                i = i + 1
            }
        }

        return &self
    }

    ref fn Append(other: StringBase(CharType)) -> StringBase(CharType)& {
        let newLength = length + other.length

        if newLength >= capacity {
            while newLength >= capacity {
                capacity = capacity * 2
            }
            data = Realloc(data, (uint)capacity)
        }
        
        let end = &data[length]
        memcpy((void&)end, (void&)other.data, other.length * @sizeof(CharType))

        length = newLength

        return &self
    }

    ref fn AppendString(other: string) -> StringBase(CharType)& {
        let otherLength = strlen(other)
        let newLength = length + otherLength
                
        if newLength >= capacity {
            while newLength >= capacity {
                capacity = capacity * 2
            }
            data = Realloc(data, (uint)capacity)
        }
        
        let end = &data[length]
        memcpy((void&)end, (void&)other, otherLength)

        length = newLength

        return &self
    }

    ref fn AppendChar(ch: CharType) -> StringBase(CharType)& {
        let newLength = length + 1
        
        if newLength >= capacity {
            while newLength >= capacity {
                capacity = capacity * 2
            }
            data = Realloc(data, (uint)capacity)
        }
        
        
        data[length] = ch
        length = newLength

        return &self
    }

    ref fn Equals(other: $T) -> bool {
        if @isstring(T) { 
            let len: @typeof(length) = strlen(other)
            if len != length {
                return false
            }
            
            let i: @typeof(length) = 0
            while i < len {
                if data[i] != other[i] {
                    return false
                }

                i = i + 1
            }
            return true
        }
        else {
            @error("Not implemented")
        }
    }

    ref fn Dispose() {
        Free((void&)data)
        data = (CharType&)0
        length = 0
    }

    fn Slice(from: int, len: int) -> CharType[] {
        let slice: CharType[] = &data[from]
        slice.length = len
        return slice
    }
}

fn NewString() -> String {
    return new String {
        null, 0, 0
    }
}

impl string {
    fn ToString() -> String {
        let s = NewString()
        s.FromString(self)
        return s
    }
}
