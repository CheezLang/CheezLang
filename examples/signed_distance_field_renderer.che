#load("io.che")
#load("array.che")
#load("bmp/bmp.che")

//fn sqrtf(f: float) -> float;
fn sqrt(f: double) -> double;

//fn fabsf(f: float) -> float;
fn fabs(f: double) -> double;

fn fmax(f1: double, f2: double) -> double;

struct Vec3 {
    x: double
    y: double
    z: double
}

impl Vec3 {
    fn mul(f: double) -> Vec3 {
        return new Vec3 { x * f, y * f, z * f }
    }

    fn mul3(v: Vec3) -> Vec3 {
        return new Vec3 { x * v.x, y * v.y, z * v.z }
    }

    fn add(v: Vec3) -> Vec3 {
        return new Vec3 { x + v.x, y + v.y, z + v.z }
    }

    fn sub(v: Vec3) -> Vec3 {
        return new Vec3 { x - v.x, y - v.y, z - v.z }
    }

    fn mag() -> double {
        let sum = x * x + y * y + z * z
        return sqrt(sum)
    }

    fn normaziled() -> Vec3 {
        let m = self.mag()
        return self.mul(1 / m)
    }
    
    fn dot(v: Vec3) -> double {
        return x * v.x + y * v.y + z * v.z
    }
}

struct Ray {
    origin: Vec3
    direction: Vec3
}

impl Ray {
    ref fn normalize() {
        direction = direction.normaziled()
    }
}

struct PerspectiveCamera {
    focalLength: double
    sensorWidth: double
    sensorHeight: double
}

impl PerspectiveCamera {
    ref fn project(x: double, y: double) -> Ray {
        return new Ray {
            origin = new Vec3 {0, 0, 0}
            direction = new Vec3 {
                x = (x - 0.5) * sensorWidth
                y = -(y - 0.5) * sensorHeight
                z = -focalLength
            }.normaziled()
        }
    }
}

struct Film {
    width: uint
    height: uint
    pixels: Vec3[]
}

impl Film {
    ref fn trigger(camera: PerspectiveCamera, scene: Raymarcher) {

        Printfn("({i32}, {i32})`n", [(any)width, height])

        let fw = 1 / (double)width
        let fh = 1 / (double)height

        let y: uint = 0
        while y < height {
            defer y += 1

            let x: uint = 0
            while x < width {
                defer x += 1

                let fx = (double)x + 0.5
                let fy = (double)y + 0.5
                let ray = camera.project(fx * fw, fy * fh)
                let color = scene.project(ray)

                pixels[x + y * width] = color
            }
        }
    }
}

trait Scene {
    fn project(ray: Ray) -> Vec3;
}

struct Background {

}

impl Scene for Background {
    fn project(ray: Ray) -> Vec3 {
        if (ray.direction.y < 0) {
            return new Vec3 { 0.1, 0.4, 0.1 }
        }
        else {
            return new Vec3 { ray.direction.y * 2, ray.direction.y * 4, 1 }
        }
    }
}

trait Shader {
    fn shade(ray: Ray, raymarcher: Raymarcher&) -> Vec3;
}

trait SDF {
    fn distance(v: Vec3) -> DistanceShaderPair;
}

struct DistanceShaderPair {
    distance: double
    shader: Shader
}

struct Raymarcher {
    sdf: SDF
    background: Background
    backgroundDistance: double // = 1000
}

impl Raymarcher {
    ref fn project(ray: Ray) -> Vec3 {
        let ds = sdf.distance(ray.origin)

        while fabs(ds.distance) > 0.0001 {
            ray.origin = ray.origin.add(ray.direction.mul(ds.distance))
            ds = sdf.distance(ray.origin)


            if ray.origin.mag() >= backgroundDistance {
                // Println("ok")
                return background.project(ray)
            }
        }

        return ds.shader.shade(ray, &self)
    }

    ref fn sampleLightDirection(dir: Vec3&, col: Vec3&) {
        <<dir = new Vec3 {
            -1, 1, 1
        }.normaziled()
        <<col = new Vec3 {1, 1, 1}
    }

    ref fn normal(p: Vec3) -> Vec3 {
        let off: double = 0.001

        let n = new Vec3 {
            x = sdf.distance(new Vec3{p.x + off, p.y, p.z}).distance - sdf.distance(new Vec3{p.x - off, p.y, p.z}).distance
            y = sdf.distance(new Vec3{p.x, p.y + off, p.z}).distance - sdf.distance(new Vec3{p.x, p.y - off, p.z}).distance
            z = sdf.distance(new Vec3{p.x, p.y, p.z + off}).distance - sdf.distance(new Vec3{p.x, p.y, p.z - off}).distance
        }
        return n.normaziled()
    }
}

struct Sphere {
    radius: double
    shader: Shader
}

impl SDF for Sphere {
    fn distance(v: Vec3) -> DistanceShaderPair {
        return new DistanceShaderPair {
            distance = v.mag() - radius
            shader = shader
        }
    }
}

struct TranslatedSDF {
    sdf: SDF
    translation: Vec3
}

impl SDF for TranslatedSDF {
    fn distance(v: Vec3) -> DistanceShaderPair {
        return sdf.distance(v.sub(translation))
    }
}

struct UnionSDF {
    sdf1: SDF
    sdf2: SDF
}

impl SDF for UnionSDF {
    fn distance(v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)
        if a.distance < b.distance {
            return a
        } else {
            return b
        }
    }
}

struct IntersectionSDF {
    sdf1: SDF
    sdf2: SDF
}

impl SDF for IntersectionSDF {
    fn distance(v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)
        if a.distance > b.distance {
            return a
        } else {
            return b
        }
    }
}

struct SubtractionSDF {
    sdf1: SDF
    sdf2: SDF
}

impl SDF for SubtractionSDF {
    fn distance(v: Vec3) -> DistanceShaderPair {
        let a = sdf1.distance(v)
        let b = sdf2.distance(v)

        b.distance = -b.distance
        if a.distance > b.distance {
            return a
        } else {
            return b
        }
    }
}

struct ConstantColorShader {
    color: Vec3
}

impl Shader for ConstantColorShader {
    fn shade(ray: Ray, raymarcher: Raymarcher&) -> Vec3 {
        return color
    }
}

struct LambertianShader {
    color: Vec3
}

impl Shader for LambertianShader {
    fn shade(ray: Ray, raymarcher: Raymarcher&) -> Vec3 {
        let ld: Vec3
        let lc: Vec3
        raymarcher.sampleLightDirection(&ld, &lc)
        let normal = raymarcher.normal(ray.origin)

        let i = normal.dot(ld)
        let c = color.mul3(lc)
        return c.mul(fmax(i, 0.1))
    }
}

/////////////////////////////

/////////////////////////////

fn RenderImage(film: Film&)
{
    let i = 0
    while i < film.pixels.length {
        defer i += 1

        film.pixels[i] = new Vec3 { 0, 0, 0 }
    }

    let camera = new PerspectiveCamera {
        focalLength = 50
        sensorWidth = 32
        sensorHeight = 18
    }

    let bg = new Background{}

    //
    let sRed    = new LambertianShader{new Vec3{1, 0, 0}}
    let sGreen  = new LambertianShader{new Vec3{0, 1, 0}}
    let sBlue   = new LambertianShader{new Vec3{0, 0, 1}}

    //
    let sdf: SDF = new TranslatedSDF {
        sdf = new SubtractionSDF {
            sdf1 = new TranslatedSDF {
                new Sphere{1, sRed}
                new Vec3{0.25, -0.25, -0.5}
            }
            sdf2 = new UnionSDF {
                sdf1 = new TranslatedSDF {
                    new Sphere{0.8, sBlue}
                    new Vec3{0.5, 0, 0}
                }
                sdf2 = new TranslatedSDF {
                    new Sphere{0.8, sGreen}
                    new Vec3{-0.5, 0, 0}
                }
            }
        }
        translation = new Vec3{-0.5, 0, -10}
    }

    let raymarcher = new Raymarcher {
        sdf = sdf
        background = bg
        backgroundDistance = 1000
    }

    film.trigger(camera, raymarcher)
}

fn Main()
{
    //
    let width: uint = (uint)(320*3)
    let height: uint = (uint)(180*3)

    let imageArr: Array(Vec3) = NewArray()
    defer imageArr.Dispose()

    imageArr.Resize(width * height)

    let film = new Film { width, height, imageArr.Slice() }

    RenderImage(&film)

    // store image as bmp

    write_bmp((int)width, (int)height, (double&)imageArr.data, "test.bmp")
}
