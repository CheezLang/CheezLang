// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.print_any
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test

// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// import tests.language.loop2
// import tests.library.all_include
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//*
#test_expect_output("")

use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
use import std.io.file
use import std.io.fs
use import std.string
use import std.array
use import std.hash_table
use import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c

use import compiler.type
use import compiler.ast

EvalContext :: struct {
    variables : Table[string, int]
}

impl Expr {
    evaluate :: (ref Self, ctx: ref EvalContext) -> int {
        return match self {
            IdExpr($expr) -> match ctx.variables.get(expr.name) {
                Some($val) -> val
                None -> {@assert(false, "Unknown variable"); 0}
            }
            NumberExpr($expr) -> expr.value
            BinaryExpr($expr) -> match expr.op {
                BinaryExpr.Operator.Add -> expr.left.evaluate(ctx) + expr.right.evaluate(ctx)
                BinaryExpr.Operator.Sub -> expr.left.evaluate(ctx) - expr.right.evaluate(ctx)
                BinaryExpr.Operator.Mul -> expr.left.evaluate(ctx) * expr.right.evaluate(ctx)
                BinaryExpr.Operator.Div -> expr.left.evaluate(ctx) / expr.right.evaluate(ctx)
            }
            UnaryExpr($expr) -> match expr.op {
                UnaryExpr.Operator.Neg -> -expr.sub.evaluate(ctx)
                _ -> {@assert(false, "Unary operator not implemented"); 0}
            }

            _ -> {@assert(false, "Expression not implemented"); 0}
        }
    }
}

Main :: () {
    num1   := IdExpr(id = 1, name = "foo")
    num2   := NumberExpr(id = 2, value = 2)
    num3   := NumberExpr(id = 3, value = 3)
    six    := BinaryExpr(id = 6, op = BinaryExpr.Operator.Mul, left = num2, right = num3)
    seven  := BinaryExpr(id = 7, op = BinaryExpr.Operator.Add, left = num1, right = six)
    result := UnaryExpr(id = 8, op = UnaryExpr.Operator.Neg, sub = seven)
    

    io.println(ref num1)
    io.println(ref num2)
    io.println(ref num3)
    io.println(ref six)
    io.println(ref seven)
    io.println(ref result)

    ctx := EvalContext(Table[string, int].create((a, b) => streq(a, b)))
    ctx.variables["foo"] = 69
    io.println(result.evaluate(ctx))
}
// */