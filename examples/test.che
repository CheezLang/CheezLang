// #load("tests/language\operator_overloading.che")

struct Num(T: type) {
    pub val: T
}

impl(T: type) Num(T) {
    fn add(a: Num(T), b: Num(T)) -> Num(T) #operator("+") {
        return new {a.val + b.val}
    }
}

fn Main() {
    let a = new Num(int){1}
    let b = new Num(int){2}
    // let c = Num(int)::add(a, b)
    let d = a + b
}

// //#load("examples/clox/main")
// // #load("std:io/io")

// #load("std:preload")
// #load("std:c")

// #load("std:string")
// #load("std:array")

// struct Range(T: type) {
//     start   : T
//     end     : T
// }

// impl(T: type) Iterator(T) for Range(T) {
//     fn next(ref Self) -> Option(T) {
//         if start > end {
//             return None
//         }
//         start += 1
//         return Some(start - 1)
//     }
// }

// impl(It: type, T: type) It if It : Iterator(T) {
//     fn sum(ref Self) -> T {
//         let s: T = 0
//         while let i = self.next(); int(i) == int(Option(T).Some); i = self.next() {
//             s += i.Some
//         }
//         return s
//     }
// }

// fn Main() {
//     let r = new Range(int){1, 5}
//     let r2 = new Range(double){1, 10}
//     // r.next()
//     // r2.next()
//     // while let i = r.next(); int(i) == int(Option(int).Some); i = r.next() {
//     //     c_printf("%d`n", i.Some)
//     // }

//     println(r.sum())
//     println(r2.sum())
// }