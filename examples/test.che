#load("examples/trait_function_call_performance")
// #load("examples/graphyfier/graphyfier")
// #load("examples/pathtracer2/main")
// #load("examples/geometry_draw_thingy")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/snake/snake")
// #load("examples/pathtracer")

// #load("tests/language/match3")
// #load("tests/library/arena_allocator1")
// #load("tests/other/test1")
// #load("examples/project_euler/005_smallest_multiple")



// Drop :: trait{}

// for_ext :: (b: bool, code: Code) #for {
//     it       := b
//     while it_index := 0, b, it_index += 1 {
//         @insert(code, link=[it, it_index], _continue=continue)
//     }
// }

// Main :: () {
//     for true {
//         continue
//     }
// }

/*
#load("std:io/io")
#load("std:fiber")
#load("std:thread")
#load("std:c")
#load("std:time")

Expr :: struct {
    id      : int
    depend  : &Expr = null
    done    := false
}

CompileFiber :: struct {
    compiler: &Compiler
    fiber   : &Fiber
    expr    : &Expr = null
    state   := 0
}

Compiler :: struct {
    exprs   := Array[Expr].create()
    fibers  := Array[&CompileFiber].create()
}

impl Drop for Compiler {
    drop :: (ref Self) {
        for f : fibers {
            Memory.drop(f.fiber)
        }
    }
}

wait_for_expr :: (expr: &Expr, wait_for: &Expr) {
    while true {
        if wait_for != null and !wait_for.done {
            // printfln("[{}] waiting for {}", (int(expr.id), wait_for.id))
            Fiber.yield()
            // printfln("[{}] resuming", int(expr.id))
        } else {
            break
        }
    }

    current_fiber := Fiber.current()
    compiler_fiber := cast(&CompileFiber) current_fiber.user_data
    compiler_fiber.state += 1
}

compile_expr :: (expr: &Expr) {
    printfln("[{}] starting", int(expr.id))
    wait_for_expr(expr, expr.depend)
    expr.done = true
    printfln("[{}] done", int(expr.id))
}

compiler_fiber :: (fiber : &CompileFiber) {
    while true {
        fiber.state = 0
        while fiber.expr == null {
            Fiber.yield()
        }
        compile_expr(fiber.expr)
        fiber.expr = null
    }
}

impl Compiler {
    compile_all :: (ref Self) {
        println("[compiler] starting compilation")
        for expr : exprs {
            fiber := find_free_fiber()
            fiber.expr = &expr
            fiber.fiber.resume()

            // fiber is waiting for something
            // so update all previous fibers
            if fiber.expr != null {
                run_current_fibers()
            }
        }

        // wait for remaining fibers
        println("[compiler] waiting for remaining fibers")
        run_current_fibers()

        printfln("[compiler] finished compilation with {} fibers", fibers.get_length())

        for expr : exprs {
            if !expr.done {
                printfln("err: expr [{}] is not done", expr.id)
            }
        }
    }

    run_current_fibers :: (ref Self) {
        while true {
            progress := false
            for fib : fibers {
                if fib.expr == null {
                    continue
                }

                prev_state := fib.state
                fib.fiber.resume()
                if fib.state > prev_state or fib.expr == null {
                    progress = true
                }
            }

            if !progress then break
        }
    }

    find_free_fiber :: (ref Self) -> &CompileFiber {
        for f : fibers {
            if f.expr == null {
                return f
            }
        }

        new_fiber   := alloc(CompileFiber)
        <<new_fiber = CompileFiber(&self, Fiber.new(compiler_fiber, new_fiber))
        fibers.add(new_fiber)
        return new_fiber
    }
}

Main :: () {
    Fiber.init()

    compiler := Compiler()

    for(inclusive=true) id : 1..15 {
        compiler.exprs.add(Expr(id))
    }

    // no dependencies
    //

    // 5:4, 4:3, 3:2, 2:1
    // for i : 1..compiler.exprs.get_length() {
    //     compiler.exprs[i].depend = &compiler.exprs[i-1]
    // }

    // 1:2, 2:3, 3:4, 4:5
    for i : 0..compiler.exprs.get_length()-1 {
        compiler.exprs[i].depend = &compiler.exprs[i+1]
    }

    start := get_time_milliseconds()
    compiler.compile_all()
    end := get_time_milliseconds()
    dur := end - start
    printfln("Compilation took {} ms", dur)
}

// */