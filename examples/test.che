// #load("examples/geometry_draw_thingy")
// #load("examples/trait_function_call_performance")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/library/stack_allocator")
// #load("tests/language/tuple")
#load("std:random")
#load("std:io/io")

//*
fn test_random() #main {
    let prng = LinearCongruentialGenerator::create()
    let dist = StandardContinuousUniform(LinearCongruentialGenerator)::create(&prng)

    for :IDistribution(double)(dist) {
        println(it)
        if it > 0.95 {
            continue
        }
        if it > 0.94 {
            break
        }
    }
}
// */

/*

#load("std:io/io")
#load("std:array")

// fn for_array(array: ref Array($T), $body: Code, $reverse: bool = false, $reference: bool = false, count: int = -1) #for {
//     if count < 0 or count > array.get_length() {
//         count = array.get_length()
//     }

//     while let i = 0; i < count; i += 1 {
//         let it #export #for_var = const if reference then ref array[i] else array[i]
//         let it_index #export #for_index = i
//         #insert body
//     }
// }

fn macro_test(a: int) #macro {
    // printfln("macro, a = {}, link(x) = {}", [a, @link(x)])
}

fn macro_test2() #macro {
    @link({
        let uiae = 10
    })
}

fn for_extension(arr: []$T, $code: Code, $reverse: bool = false) #macro #for {
    while let it_index = 0; it_index < arr.length; it_index += 1 {
        if const reverse {
            let it_index_rev = arr.length - it_index - 1
            let it = arr[it_index_rev]
            @insert(code, link=[it_index_rev])
        } else {
            let it = arr[it_index]
            @insert(code)
        }
    }
}

fn test() #main {
    let arr = Array(string)::create()
    arr.add("Hello")
    arr.add(" ")
    arr.add("world")
    arr.add("!")

    for(by_reference=false) :arr {
        print(it)
    }
    println("")

    for(by_reference=false, reverse=true) word :arr {
        print(word)
        word = "lol "
    }
    println("")

    for(by_reference=true) :arr {
        print(it)
        it = "bruh "
    }
    println("")

    for :arr print(it)
    println("")

    /*
    let arr: []int = [9, 8, 7, 6, 5]

    for v, i :arr {
        printfln("[{}] = {}", [i, v])
    }
    println("")

    for :arr {
        printfln("[{}] = {}", [it_index, it])
    }
    println("")

    for(reverse = true) v, i :arr {
        printfln("[{0}/{2}] = {1}", [i, v, it_index_rev])
    }
    println("")

    for(reverse = true) :arr {
        printfln("[{0}/{2}] = {1}", [it_index, it, it_index_rev])
    }
    println("")
    // */

    // let uiae = "lol"
    // {
    //     let arr = [5, 3, 2]
    //     for_extension(arr, println(@sizeof(@link(T))))
    //     // macro_test3(arr, {
    //     //     printfln("arr[{}] = {}", [@link(it_index), @link(it)])
    //     //     // println(uiae)
    //     //     // println("test")
    //     // }, reverse = false)
    //     println("")
    // }

    // {
    //     let x = 123
    //     macro_test(x)
    //     macro_test(2 + 3 * x)
    // }

    // {
    //     macro_test2()
    //     println(uiae)
    // }

    // for i : arr {
    //     println(i)
    // }

    // for(count = 5) i, index : arr {
    //     println(i)
    //     println(index)
    // }

    // for #odd (count = 5) i, index : arr {
    //     println(i)
    //     println(index)
    // }
}

// */