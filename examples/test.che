// #load("examples/glfw3_example")
// #load("examples/trait_function_call_performance")
// #load("examples/graphyfier/graphyfier")
// #load("examples/pathtracer2/main")
// #load("examples/geometry_draw_thingy")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/snake/snake")
// #load("examples/pathtracer")
// #load("compiler/compiler_test")

// #load("tests/language/match3")
// #load("tests/library/arena_allocator1")
// #load("tests/other/test1")
// #load("examples/project_euler/005_smallest_multiple")

//*

#load("std:io/io")
#load("std:io/stdio")
#load("std:math")
#load("std:time")
#load("std:thread")

Function1 :: () {
    profile_scope("Function1")
    for 0..1000 {
        printfln("Hello World #{}", it)
    }
}

Function2 :: () {
    profile_scope("Function2")
    for 0..1000 {
        printfln("Hello World #{}", sqrt(double(it)))
    }
}

run_benchmarks :: () {
    profile_scope("run_benchmarks")
    Sleep(10)
    Function1()
    Sleep(10)
    Function2()
    Sleep(10)
}

Main :: () {
    Instrumentor.get().begin_session("test_session", "test_session.json")
    run_benchmarks()
    Instrumentor.get().end_session()
}

// instrumentor
profile_scope :: (name: string) #macro #export_symbols(_) {
    _ := Timer.start(name)
}

// profile_function :: () #macro {
//     profile_scope(@function_name())
// }

ProfileResult :: struct {
    name      : string
    start     : int
    end       : int
    thread_id : int
}

Instrumentor :: struct {
    current_session : string
    output_file     : &FILE
    profile_count   : int
}

global_instrumantor : &Instrumentor = null

impl Instrumentor {
    new :: () -> Instrumentor {
        return Instrumentor(null, null, 0)
    }

    get :: () -> &Instrumentor {
        if global_instrumantor == null {
            global_instrumantor = alloc(Instrumentor)
            <<global_instrumantor = new()
        }

        return global_instrumantor
    }

    begin_session :: (ref Self, name: string, filepath: string = "results.json") {
        current_session = name
        filepath_c := filepath.to_cstring()
        defer free(filepath_c)
        err := fopen_s(&output_file, filepath_c, "w")
        if err != 0 {
            println("failed to open file")
            output_file = null
            return
        }

        write_header()
    }

    end_session :: (ref Self) {
        write_footer()
        fclose(output_file)

        current_session = null
        output_file     = null
        profile_count   = 0
    }

    write_header :: (ref Self) {
        fprintf(output_file, "{`n    `"otherData`": {},`n    `"traceEvents`": [")
        fflush(output_file)
    }

    write_footer :: (ref Self) {
        fprintf(output_file, "`n    ]`n}")
        fflush(output_file)
    }

    write_profile :: (ref Self, result: ProfileResult) {
        profile_count += 1
        if profile_count > 1 then fprintf(output_file, ",")

        fprintf(output_file, "`n")
        fprintf(output_file, "        {`n")
        fprintf(output_file, "            `"cast`": `"function`",`n")
        fprintf(output_file, "            `"dur`" : %lld,`n", result.end - result.start)
        fprintf(output_file, "            `"name`": `"%.*s`",`n", result.name)
        fprintf(output_file, "            `"ph`"  : `"X`",`n")
        fprintf(output_file, "            `"pid`" : 0,`n")
        fprintf(output_file, "            `"tid`" : %lld,`n", result.thread_id)
        fprintf(output_file, "            `"ts`"  : %lld`n", result.start)
        fprintf(output_file, "        }")

        fflush(output_file)
    }
}

// timer
Timer :: struct {
    name    : string
    start   : int
    stopped := false
}

impl Timer {
    start :: (name: string) -> Timer {
        return Timer(name, get_time_microseconds())
    }

    stop :: (ref Self) {
        end := get_time_microseconds()
        dur := end - start

        // printfln("{}: {}ms", (name, double(dur) * 0.001))
        thread_id := Thread.current().id
        Instrumentor.get().write_profile(ProfileResult(name, start, end, thread_id))

        stopped = true
    }
}

impl Drop for Timer {
    drop :: (ref Self) {
        if !stopped then self.stop()
    }
}

// */

/*
// #define IMGUI_IMPL_OPENGL_LOADER_GLAD
#load("std:c")
#load("std:util")
#load("std:alloca")

Foo :: struct #copy {
    num : int
    bar : Bar
    baz : Baz
}

Bar :: struct #copy {
    str : string
    boo : bool
}

Baz :: enum #copy {
    A           = 353
    B : int     = 46
    C : &int    = 96
}

print_any :: (data: &void, typ: &TypeInfo) {
    match typ.kind {
        TypeInfoKind.Int($tint) -> {
            if tint.signed {
                ptr := cast(&int) data
                c_printf("%lld", <<ptr)
            } else {
                ptr := cast(&uint) data
                c_printf("%llu", <<ptr)
            }
        }

        TypeInfoKind.Float -> {
            if typ.size == 4 {
                ptr := cast(&float) data
                c_printf("%g", double(<<ptr))
            } else if typ.size == 8 {
                ptr := cast(&double) data
                c_printf("%g", <<ptr)
            } else {
                c_printf("<float: invalid size %lld>", typ.size)
            }
        }

        TypeInfoKind.Bool -> {
            ptr := cast(&bool) data
            if <<ptr then c_printf("true") else c_printf("false")
        }

        TypeInfoKind.Char -> {
            ptr := cast(&char) data
            c_printf("'%c'", <<ptr)
        }

        TypeInfoKind.Pointer($target) -> {
            ptr := cast(&&void) data
            c_printf("0x%llX", <<ptr)
        }

        TypeInfoKind.Slice($target) -> {
            if int(target.kind) == int(TypeInfoKind.Char) {
                if data == null {
                    c_printf("null")
                } else {
                    ptr := <<cast(&[]char) data
                    c_printf("`"%.*s`"", ptr.length, ptr.data)
                }
            } else {
                ptr := <<cast(&[]void) data
                c_printf("[")
                for i : 0..ptr.length {
                    if i > 0 then c_printf(", ")

                    elem := pointer_add(ptr.data, i * target.size)
                    print_any(elem, target)
                }
                c_printf("]")
            }
        }

        TypeInfoKind.Struct($tstruct) -> {
            ptr := cast(&void) data
            c_printf("%.*s", i32(tstruct.name.length), tstruct.name.data)

            c_printf("(")
            if tstruct.members.data != null {
                for i : 0..tstruct.members.length {
                    if i > 0 then c_printf(", ")
                    member_info := &tstruct.members[i]
                    member_ptr  := pointer_add(ptr, member_info.offset)
                    member_type := member_info.typ
                    c_printf("%.*s = ", i32(member_info.name.length), member_info.name.data)
                    print_any(member_ptr, member_type)
                }
            }
            c_printf(")")
        }

        TypeInfoKind.Enum($tenum) -> {
            ptr := cast(&void) data
            c_printf("%.*s.", i32(tenum.name.length), tenum.name.data)

            tag := match tenum.tag_type.size {
                1  -> int(<<cast(&u8) ptr)
                2  -> int(<<cast(&u16) ptr)
                4  -> int(<<cast(&u32) ptr)
                8  -> int(<<cast(&u64) ptr)
                $_ -> {
                    @panic("Unsupported tag size")
                    0
                }
            }

            for(by_ref=true) mem : tenum.members {
                if mem.tag == tag {
                    c_printf("%.*s", i32(mem.name.length), mem.name.data)

                    if mem.typ != null {
                        mem_val_ptr := pointer_add(ptr, tenum.tag_type.size)

                        c_printf("(")
                        print_any(mem_val_ptr, mem.typ)
                        c_printf(")")
                    }
                }
            }
        }

        $_ -> {
            c_printf("<unknown>")
        }
    }
}

print :: (data: any) {
    print_any(data.val, data.typ)
}

println :: (data: any) {
    print_any(data.val, data.typ)
    c_puts("")
}

Main :: () {
    bar := Bar("lol", true)
    foo := Foo(12345, bar, Baz.A)

    a := 123
    b := true
    s : []int = [a, 353, 987]
    w := "lol"

    println(a)
    println(b)
    println(s)
    println(w)

    println(bar)
    println(foo)
    println(Foo(654, bar, Baz.B(420)))
    println(Foo(741, bar, Baz.C(&a)))

    println((struct{
        num       : int
        word      : string
        boolean   : bool
        floater   : double
        character : char
    })(1, "hi", false, 5.3, 'x'))
}
// */