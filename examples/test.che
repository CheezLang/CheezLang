// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import examples.ShmupEngine.src.main
// import compiler.cli
// import compiler.compiler_test

// examples which are not working currently
// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*

use import std.string
use import std.printable
use import std.array
io  :: import std.io
fmt :: import std.fmt
mem :: import std.mem.allocator

// clap :: import clap.clap

autocomplete :: ($T: type, args: []string) -> Array[String] {
    result := Array[String].create()
    autocomplete_type_info(@type_info(T), args, result)
    return result
}

autocomplete_type_info :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.printfln("auto {}", args.length)
    if args.length == 0 {
        autocomplete_type_members(ti, "", result)
    } else if args.length == 1 {
        autocomplete_type_members(ti, args[0], result)
    } else {
        current := args[0]

        match ti.kind {
            TypeInfoKind.Enum($info) -> {
                io.println("auto enum")
                for(by_ref=true) mem : info.members {
                    if mem.typ != null and streq(mem.name, current) {
                        autocomplete_type_info(mem.typ, args[1..args.length], result)
                    }
                }
            }

            TypeInfoKind.Struct($info) -> {
                autocomplete_struct(ti, args, result)
            }
        }
    }
}

autocomplete_struct :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.println("auto struct")
    info := ti.kind.Struct
    
    current := args[0]
    if current.bytes.length == 0 {
        // todo
        // empty string, what now?
    } else if current[0] == u8('-') {
        current := current.sub_string(1)
        for(by_ref=true) mem : info.members {
            if streq(mem.name, current) {
                autocomplete_type_info(mem.typ, args[1..args.length], result)
            }
        }
    } else {
        // current doesn't start with '-'
        // do nothing
    }
}

autocomplete_type_members :: (ti: &TypeInfo, prefix: string, result: ref Array[String]) {
    match ti.kind {
        TypeInfoKind.Enum($info) -> {
            for(by_ref=true) mem : info.members {
                if mem.typ != null and streq(mem.name, prefix) {
                    autocomplete_type_members(mem.typ, "", result)
                } else if mem.name.bytes.length != prefix.bytes.length and mem.name.starts_with(prefix) {
                    remainder := mem.name.sub_string(prefix.bytes.length)
                    result.add(String.from_string(remainder))
                }
            }
        }

        TypeInfoKind.Struct($info) -> {
            if prefix.bytes.length == 0 {
                for(by_ref=true) mem : info.members {
                    result.add(fmt.format("-{}", [mem.name]))
                }
            } else if prefix[0] == u8('-') {
                prefix := prefix.sub_string(1)
                for(by_ref=true) mem : info.members {
                    is_prefix := mem.name.starts_with(prefix)
                    if !is_prefix then continue
                    if mem.name.bytes.length == prefix.bytes.length {
                        // prefix == name
                        autocomplete_type_members(mem.typ, "", result)
                    } else {
                        // prefix < name
                        remainder := mem.name.sub_string(prefix.bytes.length)
                        result.add(String.from_string(remainder))
                    }
                }
            } else {
                // prefix doesn't start with '-'
                // do nothing
            }
        }
    }
}

Test :: (a: int, b: int) const a + b
Foo  :: (T: type) struct {

}

Command :: enum {
    Start
    Stop
    Test    : Foo
    Switch  : Mode
}
Foo :: struct {
    banana : int
    bazaza : Baz
    baz    : Baz
}
Baz :: struct {
    name : string
    age  : int
}
Mode :: enum { On, Off }


/*
Test -bazaza -name Joe -age 57 -banana 123 -baz -name Jane 
enum(
    typ = Command
    loc = 0..66
    mem = Command.Test
    sub = struct(
        typ = Foo
        loc = 5..66
        sub = [
            field(
                loc = 5..30
                mem = Foo.bazaza
                sub = struct(
                    typ = Baz
                    loc = 13..30
                    sub = [
                        field(
                            loc = ..
                            mem = Baz.name
                            sub = string("Joe")
                        )
                        field(
                            loc = ..
                            mem = Baz.age
                            sub = int(57)
                        )
                    ]
                )
            )
            
            field(
                loc = ..
                mem = Foo.banana
                sub = int(123)
            )
            
            field(
                loc = ..
                mem = Foo.baz
                sub = struct(
                    typ = Baz
                    loc = ..
                    sub = [
                        field(
                            loc = ..
                            mem = Baz.name
                            sub = string("Jane")
                        )
                    ]
                )
            )
        ]
    )
)

Start
enum(typ = Command, loc = 0..5, mem = Command.Start, sub = null)

Stop
enum(typ = Command, loc = 0..4, mem = Command.Stop, sub = null)

Switch On
enum(
    typ = Command
    loc = 0..9
    mem = Command.Switch
    sub = enum(
        typ = Mode
        loc = 7..9
        mem = Mode.On
        sub = null
    )
)

Switch Off
enum(
    typ = Command
    loc = 0..10
    mem = Switch
    sub = enum(
        typ = Mode
        loc = 7..10
        mem = Off
        sub = null
    )
)
 */

Location :: struct #copy {
    start   : int
    end     : int
}

Expr :: struct #extendable {
    typ : &TypeInfo
    loc : Location
}

EnumExpr :: struct #extend(Expr) {
    mem : &TypeInfoEnumMember = null
    sub : &Expr = null
}

StructExpr :: struct #extend(Expr) {
    sub := Array[StructMember].create()
}

StructMember :: struct {
    loc : Location
    mem : &TypeInfoStructMember
    sub : &Expr
}

ValueExpr :: struct #extend(Expr) {
    raw : String
}

parse_args :: (ti: &TypeInfo, args: []string) -> &Expr {
    return match ti.kind {
        TypeInfoKind.Enum($info)    -> parse_args_enum(ti, args)
        TypeInfoKind.Struct($info)  -> parse_args_struct(ti, args)
        _ -> null
    }
}

length_of_args :: (args: []string) -> int {
    len := 0
    for a : args {
        if it_index > 0 {
            len += 1
        }
        len += a.bytes.length
    }
    return len
}

parse_args_enum :: (ti: &TypeInfo, args: []string) -> &Expr {
    result := mem.alloc(EnumExpr)
    <<result = EnumExpr(ti, Location(0, length_of_args(args)))
    io.println(int(result.typ))

    if args.length == 0 {
        return cast result
    }

    current := args[0]

    for(by_ref=true) mem : ti.kind.Enum.members {
        if streq(mem.name, current) {
            result.mem = &mem

            if mem.typ != null {
                result.sub = parse_args(mem.typ, args[1..args.length])
            }
            break
        }
    }

    return cast result
}

parse_args_struct :: (ti: &TypeInfo, args: []string) -> &Expr {
    return null
}

Main :: () {
    result := parse_args(@type_info(Command), [])

    if result != null {
        io.println("===")
        io.println(int(result.typ))
        io.println(fmt.format_any(<<result))
        io.println("===")
    }

    // strs := autocomplete(Command, ["Test", "-banana", "5"])

    // for str : strs {
    //     io.println(str.slice())
    // }
    // io.println("===")
}

impl Printable for Expr {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            EnumExpr($v)   -> v.print(str, format)
            StructExpr($v) -> ()
            ValueExpr($v)  -> ()
        }
    }
}

impl Printable for EnumExpr {
    print :: (ref Self, str: ref String, format: string) {
        // str.appendf("{}", int(typ))
        sub_str := if sub == null then String.from_string("null") else fmt.format_any(<<sub)
        result := fmt.format("enum(typ={}, loc={}, mem={}, sub={})", [int(typ), loc, int(mem), sub_str.slice()])
        str.append(result)
    }
}

impl Printable for Location {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{}..{}", (start, end))
    }
}

// */