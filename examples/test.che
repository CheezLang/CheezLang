#load("examples/olc_pge/pixel_game_engine")
#load("std:io/io")
#load("std:mem/arena_allocator")
#load("std:array")
#load("std:math")
#load("std:random")
#load("std:random/mt")

typedef Vec3 = Vector3(double)
let const scale : int = 1
let const width : int = 800 / scale
let const height: int = 450 / scale
let const max_depth: int = 4
let const pi: double = 3.14159265359

let const thread_count: int = 4

fn clamp(value: double, min: double, max: double) -> double {
    if value < min { return min }
    if value > max { return max }
    return value
}

fn create(val: $T, allocator: Allocator) -> &T {
    let ptr = alloc(T, allocator)
    <<ptr = val
    return ptr
}

impl double {
    fn to_radians(Self) -> Self {
        return self / 180.0 * pi
    }
}

impl Printable for Vec3 {
    fn print(ref Self, str: ref String, format: string) {
        str.appendf("{}, {}, {}", [x, y, z])
    }
}

struct Ray {
    pub pos: Vec3
    pub dir: Vec3
}

impl Ray {
    fn from_pos_and_dir(pos: Vec3, dir: Vec3) -> Self {
        return new {pos, dir}
    }
}

struct HitInfo {
    pub distance: double
    pub pos     : Vec3
    pub normal  : Vec3
    pub material: &Material
}

struct Material {
    pub diffuse     : Vec3
    pub emission    : Vec3
    pub reflection  : Vec3
}

trait Object {
    fn intersect(ref Self, ray: Ray) -> Option(HitInfo);
}

struct Sphere {
    pos: Vec3
    rad: double
    mat: &Material
}

impl Object for Sphere {
    fn intersect(ref Self, ray: Ray) -> Option(HitInfo) {
        let op = pos - ray.pos
        let r2 = rad * rad
        let b = op.dot(ray.dir)
        let det = b * b - op.magsq() + r2
        if det < 0 {
            return None
        }

        let epsilon = 0.0001
        det = sqrt(det)
        let minusT = b - det
        let plusT = b + det
        if minusT < epsilon and plusT < epsilon {
            return None
        }

        let t = if minusT > epsilon {minusT} else {plusT}
        let hitPos = ray.pos + ray.dir * t
        let normal = (hitPos - pos).normalized()
        return Some(new HitInfo{t, hitPos, normal, mat})
    }
}

struct PathTracer(PRNG: type) {
    pge         : &PixelGameEngine
    allocator   : ArenaAllocator
    objects     : Array(Object)
    cam_fov     : double
    pub cam_pos     : Vec3
    pub cam_dir     : Vec3
    pub cam_right   : Vec3
    pub cam_up      : Vec3
    sample_t    : double
    total_t     : double
    scene       : Object
    pub buffer  : []Vec3
    pub prngs   : []PRNG
    threads     : [thread_count]HANDLE
    pub thread_datas: [thread_count](id: int, pt: &PathTracer(PRNG), samples: int)
}

impl PathTracer($PRNG) {
    fn create() -> Self {
        let b = alloc_n(Vec3, u64(width * height))
        c_memset(b.data, 0, u64(b.length * @sizeof(Vec3)))

        let prngs = alloc_n(PRNG, u64(width * height))
        loop! i in 0 -> (width * height) {
            prngs[i] = PRNG::create(u32(i * 123456))
        }

        return new {
            allocator   = ArenaAllocator::create(1024)
            objects     = Array(Object)::create()
            buffer      = b
            prngs       = prngs
        }
    }

    fn dispose(ref Self) {
        allocator.dispose()
        objects.dispose()
        free_n(buffer)
    }

    fn add_object(ref Self, obj: $T) {
        let dyn = alloc(T, allocator)
        <<dyn = obj
        objects.add(ref <<dyn)
    }

    fn intersect(ref Self, ray: Ray) -> Option(HitInfo) {
        let nearest: Option(HitInfo) = None

        loop! n in 0 -> objects.get_length() {
            let hit = objects[n].intersect(ray)
            nearest = match (nearest, hit) {
                (None, Some($hit)) -> Some(hit)
                (Some($n), Some($hit)) if hit.distance < n.distance -> Some(hit)
                $_ -> nearest
            }
        }

        return nearest
    }

    fn calc_color(ref Self, ray: Ray, prng: &PRNG, depth: int = 0) -> Vec3 {
        if depth >= max_depth {
            return new{}
        }

        return match self.intersect(ray) {
            None -> new{}
            Some($hit) -> {
                let result = new Vec3{}

                // emission
                result += hit.material.emission

                // diffuse
                if hit.material.diffuse.max_component() > 0 {
                    let rand = new StandardContinuousUniform(PRNG) { prng }
                    let r1 = rand.sample() * 2.0 * pi
                    let r2 = rand.sample()
                    let r2s = sqrt(r2)

                    let w = hit.normal
                    let u = if abs(w.x) > abs(w.z) {new Vec3{-w.y, w.x, 0}} else {new Vec3{0, -w.z, w.y}}
                    u.normalize()
                    let v = u.cross(w)
                    let newDir = u * cos(r1) * r2s + v * sin(r1) * r2s + w * sqrt(1 - r2)
                    let newRay = new Ray{hit.pos, newDir}

                    result += hit.material.diffuse * calc_color(newRay, prng, depth + 1)
                }

                // reflection
                if hit.material.reflection.max_component() > 0 {
                    let newDir = hit.normal * 2.0 + ray.dir
                    let newRay = new Ray{hit.pos, newDir}
                    result += hit.material.reflection * calc_color(newRay, prng, depth + 1)
                }

                result
            }
        }
    }
}

fn pathtracer_thread(_data: &any) -> u32 #stdcall {
    let data = @cast(&(index: int, pt: &PathTracer(MTwister)), _data)

    let y_range = height / thread_count
    let start_y = data.index * y_range
    let end_y   = (data.index + 1) * y_range - 1
    if height - end_y < y_range {
        end_y = height - 1
    }

    printfln("{}: {} -> {}", [data.index, start_y, end_y])

    while true {
        loop! current_y in start_y ->> end_y {
            // loop through current line
            loop! current_x in 0 -> width {
                let index = current_x + current_y * width
                let prng = &data.pt.prngs[index]

                // x coordinate in range [-1; 1]
                // y coordinate in range [-1; 1]
                let blur_radius: double = 0.5
                let x = (double(current_x) + prng.next_double() * blur_radius * 2 - blur_radius) / double(width) * 2 - 1
                let y = (double(height - current_y - 1) + prng.next_double() * blur_radius * 2 - blur_radius) / double(height) * 2 - 1



                // calculate ray for current pixel
                let dir = data.pt.cam_dir + data.pt.cam_right * x + data.pt.cam_up * y
                dir.normalize()

                // shoot ray into scene and calculate color
                let color = data.pt.calc_color(new{data.pt.cam_pos, dir}, prng)
                data.pt.buffer[index] += color
            }
        }

        data.pt.thread_datas[data.index].samples += 1
    }
    return 0
}

impl Game for PathTracer($PRNG) {
    fn on_create(ref Self, pge: &PixelGameEngine) -> bool {
        self.pge = pge

        self.cam_fov = 60.0::to_radians()
        let aspect_ratio = double(width) / double(height)

        let size = 10.0

        // calculate cam rays (forward, right, up)
        self.cam_pos = new{0, 3, 0}
        self.cam_dir = new{0, 0, 1}

        self.cam_right = new Vec3{0, 1, 0}.cross(self.cam_dir)
        self.cam_up    = self.cam_dir.cross(self.cam_right)

        let up_mag = tan(self.cam_fov / 2)
        let right_mag = up_mag * aspect_ratio

        self.cam_up     = self.cam_up.normalized() * up_mag
        self.cam_right  = self.cam_right.normalized() * right_mag

        printfln("  dir: {}", [self.cam_dir])
        printfln("   up: {}", [self.cam_up])
        printfln("right: {}", [self.cam_right])

        // create objects
        let m_red   = create(new Material{new{0.9, 0.2, 0.2}, new{}}, allocator)
        let m_green = create(new Material{new{0.2, 0.9, 0.2}, new{}}, allocator)
        let m_blue  = create(new Material{new{0.2, 0.2, 0.9}, new{}}, allocator)
        let m_mirror  = create(new Material{new{}, new{}, new{1, 1, 1}}, allocator)
        let m_grey  = create(new Material{new{0.75, 0.75, 0.75}, new{}}, allocator)
        let m_light = create(new Material{new{1, 1, 1}, new{10, 10, 10}}, allocator)

        self.add_object(new Sphere{new{-1000.0 - size / 2, 0, 0}, 1000, m_red}) // left
        self.add_object(new Sphere{new{1000.0 + size / 2, 0, 0}, 1000, m_green}) // right

        self.add_object(new Sphere{new{0, 0, 1000.0 + size / 2 + 10}, 1000, m_grey}) // back
        self.add_object(new Sphere{new{0, 0, -1000.0 - size / 2 * 5}, 1000, m_grey}) // front

        self.add_object(new Sphere{new{0, -1000.0, 0}, 1000, m_grey}) // bot
        self.add_object(new Sphere{new{0, 1000.0 + size, 0}, 1000, m_grey}) // top

        // spheres
        self.add_object(new Sphere{new{3, 2, 13}, 2, m_mirror})
        self.add_object(new Sphere{new{-2.5, 1, 10}, 1, m_green})
        self.add_object(new Sphere{new{1, 1, 10}, 1, m_blue})

        // light
        self.add_object(new Sphere{new{0, size + 9.75, 10}, 10, m_light})

        // create threads
        loop! i in 0 -> thread_count {
            thread_datas[i] = (i, &self, 0)
            threads[i] = CreateThread(null, 0, pathtracer_thread, &thread_datas[i], 0, null)
        }
        return true
    }

    fn on_destroy(ref Self) -> bool {
        loop! i in 0 -> thread_count {
            TerminateThread(threads[i], 0)
            CloseHandle(threads[i])
        }
        return true
    }

    fn on_update(ref Self, dt: float) -> bool {
        if pge.get_key(Key.Escape).pressed {
            return false
        }

        //
        loop! current_y in 0 -> height {
            loop! current_x in 0 -> width {
                let index = current_x + current_y * width
                let thread_id = current_y / thread_count
                if thread_id >= thread_count {
                    thread_id = thread_count - 1
                }

                let sample = thread_datas[thread_id].samples

                // calculate color of pixel by taking the average of the color
                // in the buffer
                let pixel = {
                    let bufferColor = buffer[index] / double(sample + 1)
                    let c = Vec3::change_type(
                        bufferColor.clamped(0.0, 1.0) * 255.0,
                        u8)
                    Pixel::rgba(c.x, c.y, c.z)
                }

                pge.draw(current_x, current_y, pixel)
            }
        }

        sample_t += double(dt)
        if sample_t >= 1 {
            total_t += 1

            let sps = double(thread_datas[0].samples) / total_t

            let s = String::format("Samples: {}, Total: {}s, Samples per second: {}", [thread_datas[0].samples, int(total_t + 0.1), sps])
            pge.set_window_title(s)
            s.free()

            sample_t -= 1
        }

        return true
    }
}

fn test_thread(data: &any) -> u32 #stdcall {
    let index = int(data)
    println(index)

    return 0
}

fn test() {
    let t1 = CreateThread(null, 0, test_thread, @cast(&any, 123), CREATE_SUSPENDED, null)
    let t2 = CreateThread(null, 0, test_thread, @cast(&any, 456), CREATE_SUSPENDED, null)
    let t3 = CreateThread(null, 0, test_thread, @cast(&any, 789), CREATE_SUSPENDED, null)

    ResumeThread(t1)
    ResumeThread(t2)
    ResumeThread(t3)

    while true {}

    CloseHandle(t1)
    CloseHandle(t2)
    CloseHandle(t3)
}

fn Main() {
    let game = PathTracer(MTwister)::create()
    // let game = PathTracer(LinearCongruentialGenerator)::create()
    let pge = PixelGameEngine::create(game, width, height, 1, 1)
    if pge != null {
        pge.start()
    }
    game.dispose()
}