// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test
import examples.ShmupEngine.src.main

// examples which are not working currently
// import examples.image_processing
// import examples.postfix
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*

use import std.string
use import std.printable
use import std.array
use import std.box
use import std.math
io   :: import std.io
fmt  :: import std.fmt
mem  :: import std.mem.allocator
util :: import std.util
C    :: import std.c

use import clap.clap2
use import clap.clap_printable

Command :: enum {
    #name("star")   Star
    #name("start")  Start
    #name("stop")   Stop
    #name("test")   Test    : Foo
    #name("switch") Switch  : Mode
}
Foo :: struct {
    mode   : Mode
    banana : int
    bazaza : String
    baz    : Baz
    array  := Array[string].create()
}
Baz :: struct {
    name : String
    age  : int
}
Mode :: enum {
    #name("on") On
    #name("off") Off
}

Main :: () {
    command := "test -mode of -baz -nam "
    args := Clap.tokenize(command)

    io.println("Arguments`n==========")
    for(by_ref=true) a : args {
        io.formatln(a)
    }
    io.println("==========")

    result := parse_args(@type_info(Command), args.slice())
    io.println("===")
    io.println(fmt.format_any(result))
    io.println("===")

    match ref result {
        Some($result) -> {
            match get_value(Command, result.get()) {
                Ok($result) -> io.formatln(result)
                Err($err)   -> print_error_message(command, err)
            }
        }
    }

    io.println("-------------------`n`n")

    for at : 0 .. (command.bytes.length + 1) {
        io.formatln(command)
        for 0 .. at do io.print(" ")
        io.println("^")
        auto_completions := get_auto_completions_at(@type_info(Command), result, at)
        for completion : auto_completions {
            io.formatln("> {}", [completion.slice()])
        }
        io.println("---`n")
    }
}

impl CustomParser for String {
    parse :: (args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
        // io.println("String.parse")
        result := mem.alloc(CustomExpr)
        <<result = CustomExpr(@type_info(Self), loc, create_empty_expr(null, loc))
        if args.length == 0 {
            return Some(Box[Expr].from_pointer(cast result)), args
        }

        result.sub = create_raw_expr(result.typ, args[0])
        return Some(Box[Expr].from_pointer(cast result)), args[1..args.length]
    }

    validate :: (expr: ref CustomExpr) -> Result[(), ClapError] {
        // io.println("String.validate")
        return match ref expr.sub.get() {
            ValueExpr($v)   -> Ok(())
            EmptyExpr($v)   -> Err(ClapError(v.loc, fmt.format("Missing value for string argument", [])))
            _               -> @assert(false)
        }
    }

    get_value :: (result: &void, expr: ref CustomExpr) {
        // io.println("String.get_value")
        match ref expr.sub.get() {
            ValueExpr($v) -> {
                <<cast(&String)result = v.raw.clone()
            }

            _ -> @assert(false)
        }
    }
}

// */