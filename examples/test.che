// #load("examples/geometry_draw_thingy")
// #load("examples/trait_function_call_performance")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/library/stack_allocator")
// #load("tests/language/match3")
// #load("tests/other/test1")

//*
#load("std:c")
// #load("std:util")

struct Foo #move {
    pub val: int
}

impl Foo {

}

fn take(f: Foo) {

}

fn Main() {
    if const false {
        let a: int
        @log_symbol_status(a)
        match 5 {
            1 -> {
                @log_symbol_status(a)
                a = 5
                @log_symbol_status(a)
            }
            2 -> {
                @log_symbol_status(a)
                a = 6
                @log_symbol_status(a)
            }
            3 -> {
                @log_symbol_status(a)
                // a = 7
                @log_symbol_status(a)
            }
        }
        @log_symbol_status(a)
    }

    if const false {
        let a: int
        @log_symbol_status(a)
        if true {
            @log_symbol_status(a)
            a = 5
            @log_symbol_status(a)
        } else {
            @log_symbol_status(a)
            a = 10
            @log_symbol_status(a)
        }
        @log_symbol_status(a)
    }

    if const false {
        let a: int = 1
        @log_symbol_status(a)
        while false {
            @log_symbol_status(a)
            a = 5
            @log_symbol_status(a)
        }
        @log_symbol_status(a)
    }
}

// fn Main() {
//     let f = new Foo{5}
//     c_printf("%lld`n", f.val)

//     f.val = 10
//     c_printf("%lld`n`n", f.val)

//     {
//         let g = f
//         c_printf("%lld`n", f.val)
//         c_printf("%lld`n`n", g.val)

//         take(g)
//         c_printf("%lld`n", f.val)
//         c_printf("%lld`n", g.val)
//     }
// }
// */


/*
#load("std:io/io")

struct Rc(T: type) {
    pub const count : &int
    pub const data  : &T
}

impl(T: type) Rc(T) {
    fn empty() -> Rc(T) {
        let count = alloc(int)
        let data  = alloc(T)
        <<count = 1
        return new {count, data}
    }

    fn create(value: ref T) -> Rc(T) {
        let count = alloc(int)
        let data  = alloc(T)
        <<count = 1
        <<data = value
        return new {count, data}
    }

    fn clone(ref Self) -> Rc(T) {
        <<count += 1
        return new {count, data}
    }

    fn dispose(ref Self) {
        @assert(<<count > 0)
        <<count -= 1
        if <<count == 0 {
            free(data)
            data = null
        }
    }
}

fn debug_print(rc: ref Rc($T)) {
    printfln("Rc({}): count={}, data={:x}", [@typename(T), <<rc.count, int(rc.data)])
}

fn Main() {
    let test = Rc(int)::create(645)
    debug_print(test)
    println("")

    println(<<test.data)
    <<test.data = 5
    println(<<test.data)
    <<test.data = 123
    println(<<test.data)
    println("")

    let test2 = test.clone()
    debug_print(test)
    debug_print(test2)
    println("")

    let test3 = test.clone()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test2.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test3.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")
}

// */