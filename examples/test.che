// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import examples.ShmupEngine.src.main
// import compiler.cli
// import compiler.compiler_test

// examples which are not working currently
// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

// import "../Tools/Bindings/imgui_binding"

Foo :: enum {
    A, B, C
}

Bar :: enum #flags #copy {
    None
    A
    B
    C
    D = 6
    E = 7
    F = 16
    G
}

io :: import std.io

Main :: () {
    a := Bar.A
    b := Bar.B
    c := Bar.C

    d := Bar.A or b


    x : int = Bar.B or Bar.C
    y : Bar = Bar.B or Bar.C
    io.println(x)
    io.println(int(x))

    io.printfln("00{:b}", int(a))
    io.printfln("0{:b}", int(b))
    io.printfln("{:b}", int(c))
    io.printfln("{:b}", int(d))
    io.println("")
    io.printfln("0{:b}", int(a or b))
    io.printfln("{:b}", int(a or c))
    io.printfln("{:b}", int(b or c))
    io.printfln("{:b}", int(a or b or c))
    io.println("")
    io.printfln("{}", d and a)
    io.printfln("{}", d and b)
    io.printfln("{}", d and c)
}

/*
#test_expect_output("")

// use import std.os.windows_functions
// use import std.os.windows_types
// use import std.os.windows_constants
// use import std.io.file
// use import std.io.fs
use import std.printable
use import std.string
use import std.array
use import std.rc
use import std.math
use import std.hash_table
mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c
util:: import std.util

use import compiler.lexer
use import compiler.error_handler
use import compiler.string_database
serpa :: import serpa.serpa

impl TextProvider for string {
    get_text :: (ref Self, filename: string) -> string {
        return self
    }
}

impl(T: type) serpa.IParser[Rc[T]] for Rc[T] if T : serpa.IParser[T] {
    parse :: (lexer: ref Lexer, error_handler: ErrorHandler) -> Option[Self] {
        return match T.parse(lexer, error_handler) {
            Some($i) -> Some(Rc[T].new(i))
            None -> None
        }
    }
}

impl(T: type) Printable for Rc[T] if T : Printable {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("Rc(count = {}, value = {})", (self.count(), Printable(self.get())))
    }
}

impl Printable for ComponentData {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format_any(any(type_info, &value.get()))
        str.append(msg)
    }
}

impl serpa.IParser[ComponentData] for ComponentData {
    parse :: (parser: ref serpa.Parser, lexer: ref Lexer, error_handler: ErrorHandler) -> Option[ComponentData] {
        eat_token :: (typ: TokenType) #macro {
            if (ok, t) := @link(lexer).expect_token(typ), ok {
                t
            } else {
                @link(error_handler).report_errorf(t.location, "Expected '{}', got {}", [typ, t.ttype])
                return None
            }
        }

        name_token := eat_token(TokenType.Identifier)
        struct_name := name_token.data.String

        // io.printfln("parsing component {}", struct_name)
        @for_trait_impls(Component, (T) => {
            // io.printfln("trying with type {}", @typename(T))
            if streq(@typename(T), struct_name) {
                result := mem.alloc(T)
                if !parser.parse_struct_into(result, lexer, error_handler) {
                    mem.free(result)
                    return None
                }

                ptr := Rc[T].from_pointer(result, true)
                return Some(ComponentData(
                    ptr.get()
                    ptr.change_type(())
                    @type_info(T)
                ))
            }
        })

        error_handler.report_errorf(name_token.location, "'{}' is not a valid component", [struct_name])
        return None
    }
}

vec3 :: Vector3[float]

Component :: trait {
    update :: (ref Self);
}

ComponentData :: struct {
    component : Component
    value     : Rc[()]
    type_info : &TypeInfo
}

Entity :: struct {
    name : string
    pos  : vec3
    coms : Array[ComponentData]
}

QuadComponent   :: struct {
    color : vec3
}
LolComponent    :: struct {
    lol : int
}
StringComponent :: struct {
    str : String
}

impl Component for QuadComponent {
    update :: (ref Self) {
        io.printfln("QuadComponent.update({}, {}, {})", (color.x, color.y, color.z))
    }
}
impl Component for LolComponent {
    update :: (ref Self) {
        io.printfln("LolComponent.update({})", lol)
    }
}
impl Component for StringComponent {
    update :: (ref Self) {
        io.printfln("StringComponent.update({})", str.slice())
    }
}

Main :: () {
    file := "
{
    name = `"entity`"
    pos  = {x = 9, y = 6, z = 3}
    coms = [
        QuadComponent {
            color = {
                x = 4
                y = 5
                z = 6
            }
        }
        LolComponent {lol = 147}
        StringComponent {str = `"wassup`"}
    ]
}
"

    console_error_handler := ConsoleErrorHandler.new(null)
    string_db := StringDatabase.new()
    lexer := Lexer.from_string(String.from_string(file), string_db)
    console_error_handler.text_provider = file

    parser := serpa.Parser(expect_struct_name=false)
    result := parser.parse(Entity, lexer, console_error_handler)

    io.println(@typename(@typeof(result)))
    io.println(fmt.format_any(result))

    match result {
        Some($entity) -> {
            io.println(entity.name)
            io.println(fmt.format_any(entity.pos))
            for cd : entity.coms {
                cd.component.update()
            }
        }
    }

    // loop {
    //     token := lexer.next_token()
    //     if int(token.ttype) == int(TokenType.EOF) then break

        
    // }
}
// */

/*
#test_expect_output("")

// use import std.os.windows_functions
// use import std.os.windows_types
// use import std.os.windows_constants
// use import std.io.file
// use import std.io.fs
// use import std.string
// use import std.array
// use import std.hash_table
// use import std.mem.allocator
io  :: import std.io
// fmt :: import std.fmt
C   :: import std.c

use import compiler.ast
use import compiler.lexer
use import compiler.parser
use import compiler.error_handler
use import compiler.string_database

Main :: () {
    file :: "uiae.che"

    console_error_handler := ConsoleErrorHandler.new(null)
    console_error_handler.code_color_error  = io.ConsoleColor.Green
    console_error_handler.code_color_normal = io.ConsoleColor.White
    string_db := StringDatabase.new()
    lexer := try_with(
        Lexer.from_file(file, string_db),
        {
            io.printfln("Failed to open file '{}'", file)
            return
        })

    pattern := IdExpr(id = 1, name = "foo")
    init    := IdExpr(id = 2, name = "bar")

    move := MoveExpr(id = 1, target = pattern, source = init)
    pipe := PipeExpr(id = 1, left = move, right = pattern)

    decl := DeclStmt(
        id       = 3
        is_const = true
        pattern  = pattern
        typ      = Some(init)
        init     = Some(pipe))
    io.println(pattern)
    io.println(init)
    io.println(decl)

    loop {
        token := lexer.next_token()
        if int(token.ttype) == int(TokenType.EOF) then break

        
    }
}
// */