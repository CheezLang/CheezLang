// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.print_any
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test

// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// import tests.language.loop2
// import tests.library.all_include
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

/*
#test_expect_output("")

use import std.os.windows_functions
use import std.os.windows_types
use import std.os.windows_constants
use import std.io.file
use import std.io.fs
use import std.string
use import std.array
use import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c



// Uft8 :: struct{}

// impl Uft8 {
//     decode :: (bytes: []u8) -> char, i32 {
//         b0 : u32 = cast bytes[0]

//         byte_count : i32 = 0
//         code_point : u32 = 0
//         if @bin_lsr(b0, 7) == 0 {
//             code_point = cast b0
//             byte_count = 1
//         } else if @bin_lsr(b0, 5) == 0b110 {
//             b1 : u32 = cast bytes[1]

//             b0_masked := @bin_and(b0, 0b00011111)
//             b1_masked := @bin_and(b1, 0b00111111)

//             code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
//             byte_count = 2
//         } else if @bin_lsr(b0, 4) == 0b1110 {
//             b1 : u32 = cast bytes[1]
//             b2 : u32 = cast bytes[2]

//             b0_masked := @bin_and(b0, 0b00001111)
//             b1_masked := @bin_and(b1, 0b00111111)
//             b2_masked := @bin_and(b2, 0b00111111)

//             code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
//             code_point = @bin_or(@bin_lsl(code_point, 6), b2_masked)
//             byte_count = 3
//         } else if @bin_lsr(b0, 3) == 0b11110 {
//             b1 : u32 = cast bytes[1]
//             b2 : u32 = cast bytes[2]
//             b3 : u32 = cast bytes[3]

//             b0_masked := @bin_and(b0, 0b00000111)
//             b1_masked := @bin_and(b1, 0b00111111)
//             b2_masked := @bin_and(b2, 0b00111111)
//             b3_masked := @bin_and(b3, 0b00111111)

//             code_point = @bin_or(@bin_lsl(b0_masked, 6), b1_masked)
//             code_point = @bin_or(@bin_lsl(code_point, 6), b2_masked)
//             code_point = @bin_or(@bin_lsl(code_point, 6), b3_masked)
//             byte_count = 4
//         }

//         return char(code_point), byte_count
//     }
// }

// impl string {
//     index_of :: (ref Self, ch: char) -> Option[int] {
//         return None
//     }
// }

impl Into[int] for () {
    into :: (ref Self) -> int {
        return 123
    }
}

Main :: () {
    match test() {
        Ok($succ) -> {
            io.printfln("Ok({})", succ)
        }
        Err($err) -> {
            io.printfln("Err({})", err)
        }
    }
}

test :: () -> Result[(), int] {
    // str := "AöЖ€𝄞(╯°□°）╯︵ ┻━┻ 😂.txt"

    // io.println("")
    // io.println("")

    // test := String.empty()
    // for c : str {
    //     test += c
    //     io.print(c)
    // }
    // io.println("")
    // slc := test.slice()
    // for b : slc.bytes do io.printf("{:x} ", b)
    // io.println("")
    // for b : str.bytes do io.printf("{:x} ", b)
    // io.println("")

    dir := "(╯°□°）╯︵ ┻━┻ 😂😂😂😂"
    io.println(dir.bytes.length)
    try_with(create_directory(dir), io.println("failed to create directory"))

    a := "(╯°□°）╯︵ ┻━┻ 😂😂😂😂.txt"

    str := String.from_string(a)
    str += char(0)

    match write_file(a, "(╯°□°）╯︵ ┻━┻ 😂😂😂😂.txt
🤣«»©®℗™⁝⁀⁐⁁&
(╯°□°）╯︵ ┻━┻ 😂😂😂😂.txt
(╯°□°）╯︵ ┻━┻ 😂😂😂😂.txt
🤣«»©®℗™⁝⁀⁐⁁&
(╯°□°）╯︵ ┻━┻ 😂😂😂😂.txt
🤣«»©®℗™⁝⁀⁐⁁&
🤣«»©®℗™⁝⁀⁐⁁&") {
        Err($err) -> io.println(fmt.format_any(err))
    }

    io.println("==============================")
    match read_file(a) {
        Ok($str) -> io.println(str)
        Err($err) -> io.println(fmt.format_any(err))
    }
    io.println("==============================")


    // bytes := a.bytes
    // ascii := a.ascii

    // io.println(a.bytes.length)
    // io.println(a.ascii.length)

    // io.println(a.bytes.length)
    // io.println(a)

    // for i : 0..a.bytes.length {
    //     io.printf("{:b} ", u32(a[i]))
    // }
    // io.println("")
    // io.println("")
    // io.println("")
    // io.println("")

    // for c : a {
    //     io.printf("{:b} ", u32(c))
    // }
    // io.println("")

    // if !write_file_string("test.out", a) {
    //     io.println("Failed to write to file")
    // }

    return Ok(())
}
// */