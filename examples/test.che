// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test
// import examples.ShmupEngine.src.main

// examples which are not working currently
// import examples.image_processing
// import examples.postfix
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//*

use import std.string
use import std.printable
use import std.array
use import std.box
use import std.math
io   :: import std.io
fmt  :: import std.fmt
mem  :: import std.mem.allocator
util :: import std.util
C    :: import std.c

use import clap.clap

Command :: enum {
    #name("start")  Start
    #name("stop")   Stop
    #name("test")   Test    : Foo
    #name("switch") Switch  : Mode
}
Foo :: struct {
    mode   : Mode
    banana : int
    bazaza : String
    // baz    : Baz
    array  := Array[string].create()
}
Baz :: struct {
    // name : string
    age  : int
}
Mode :: enum {
    #name("on") On
    #name("off") Off
}

Main :: () {
    command := "switch "
    args := Clap.tokenize(command)

    io.println("Arguments`n==========")
    for(by_ref=true) a : args {
        io.formatln(a)
    }
    io.println("==========")

    result, _ := parse_args(@type_info(Command), args.slice())
    io.println("===")
    io.println(fmt.format_any(result))
    io.println("===")

    match result {
        Some($result) -> {
            match get_value(Command, result.get()) {
                Ok($result) -> io.formatln(result)
                Err($err)   -> print_error_message(command, err)
            }

            io.println("------------------")
            auto_completions := get_auto_completions_at(result.get(), command.bytes.length)
            for completion : auto_completions {
                io.println(completion.slice())
            }
            io.println("------------------")
        }
    }
}

impl CustomParser for String {
    parse :: (args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
        // io.println("String.parse")
        result := mem.alloc(CustomExpr)
        <<result = CustomExpr(@type_info(Self), loc, create_empty_expr(null, loc))
        if args.length == 0 {
            return Some(Box[Expr].from_pointer(cast result)), args
        }

        result.sub = create_raw_expr(result.typ, args[0])
        return Some(Box[Expr].from_pointer(cast result)), args[1..args.length]
    }

    validate :: (expr: ref CustomExpr) -> Result[(), ClapError] {
        // io.println("String.validate")
        return match ref expr.sub.get() {
            ValueExpr($v)   -> Ok(())
            EmptyExpr($v)   -> Err(ClapError(v.loc, fmt.format("Missing value for string argument", [])))
            _               -> @assert(false)
        }
    }

    get_value :: (result: &void, expr: ref CustomExpr) {
        // io.println("String.get_value")
        match ref expr.sub.get() {
            ValueExpr($v) -> {
                <<cast(&String)result = v.raw.clone()
            }

            _ -> @assert(false)
        }
    }
}

get_auto_completions_at :: (expr: ref Expr, pos: int) -> Array[String] {
    result := Array[String].create()
    get_auto_completions_at_helper(result, expr, pos)
    return result
}

get_auto_completions_at_helper :: (result: ref Array[String], expr: ref Expr, pos: int) {
    io.formatln("complete at {}: {}", [pos, expr])
    match expr {
        EnumExpr($v) -> {
            match ref v.sub {
                Some($sub) -> {
                    result.add(fmt.format_any(sub))
                }

                None -> {
                    @assert(v.typ != null)
                    @assert(v.typ.kind == TypeInfoKind.Enum)
                    for(by_ref=true) mem : v.typ.kind.Enum.members {
                        result.add(String.from_string(mem.name))
                    }
                }
            }
        }
    }
}

autocomplete :: ($T: type, args: []string) -> Array[String] {
    result := Array[String].create()
    autocomplete_type_info(@type_info(T), args, result)
    return result
}

autocomplete_type_info :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.printfln("auto {}", args.length)
    if args.length == 0 {
        autocomplete_type_members(ti, "", result)
    } else if args.length == 1 {
        autocomplete_type_members(ti, args[0], result)
    } else {
        current := args[0]

        match ti.kind {
            TypeInfoKind.Enum($info) -> {
                io.println("auto enum")
                for(by_ref=true) mem : info.members {
                    if mem.typ != null and streq(mem.name, current) {
                        autocomplete_type_info(mem.typ, args[1..args.length], result)
                    }
                }
            }

            TypeInfoKind.Struct($info) -> {
                autocomplete_struct(ti, args, result)
            }
        }
    }
}

autocomplete_struct :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.println("auto struct")
    info := ti.kind.Struct
    
    current := args[0]
    if current.bytes.length == 0 {
        // todo
        // empty string, what now?
    } else if current[0] == u8('-') {
        current := current.sub_string(1)
        for(by_ref=true) mem : info.members {
            if streq(mem.name, current) {
                autocomplete_type_info(mem.typ, args[1..args.length], result)
            }
        }
    } else {
        // current doesn't start with '-'
        // do nothing
    }
}

autocomplete_type_members :: (ti: &TypeInfo, prefix: string, result: ref Array[String]) {
    match ti.kind {
        TypeInfoKind.Enum($info) -> {
            for(by_ref=true) mem : info.members {
                if mem.typ != null and streq(mem.name, prefix) {
                    autocomplete_type_members(mem.typ, "", result)
                } else if mem.name.bytes.length != prefix.bytes.length and mem.name.starts_with(prefix) {
                    remainder := mem.name.sub_string(prefix.bytes.length)
                    result.add(String.from_string(remainder))
                }
            }
        }

        TypeInfoKind.Struct($info) -> {
            if prefix.bytes.length == 0 {
                for(by_ref=true) mem : info.members {
                    result.add(fmt.format("-{}", [mem.name]))
                }
            } else if prefix[0] == u8('-') {
                prefix := prefix.sub_string(1)
                for(by_ref=true) mem : info.members {
                    is_prefix := mem.name.starts_with(prefix)
                    if !is_prefix then continue
                    if mem.name.bytes.length == prefix.bytes.length {
                        // prefix == name
                        autocomplete_type_members(mem.typ, "", result)
                    } else {
                        // prefix < name
                        remainder := mem.name.sub_string(prefix.bytes.length)
                        result.add(String.from_string(remainder))
                    }
                }
            } else {
                // prefix doesn't start with '-'
                // do nothing
            }
        }
    }
}

Expr :: struct #extendable {
    typ : &TypeInfo
    loc : Location
}

EnumExpr :: struct #extend(Expr) {
    mem := Option[&TypeInfoEnumMember].None
    sub := Option[Box[Expr]].None
}

StructExpr :: struct #extend(Expr) {
    subs := Array[StructMember].create()
}

StructMember :: struct {
    loc : Location
    mem : &TypeInfoStructMember
    sub : Option[Box[Expr]]
}

ValueExpr :: struct #extend(Expr) {
    raw : String
}

EmptyExpr :: struct #extend(Expr) {
}

CustomExpr :: struct #extend(Expr) {
    sub : Box[Expr]
}

CustomParser :: trait {
    parse     :: (args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken;
    validate  :: (ref CustomExpr) -> Result[(), ClapError];
    get_value :: (result: &void, expr: ref CustomExpr);
}

create_empty_expr :: (ti: &TypeInfo, loc: Location) -> Box[Expr] {
    result := mem.alloc(EmptyExpr)
    <<result = EmptyExpr(ti, loc)
    return Box[Expr].from_pointer(cast result)
}

create_raw_expr :: (ti: &TypeInfo, token: ref ClapToken) -> Box[Expr] {
    result := mem.alloc(ValueExpr)
    <<result = ValueExpr(ti, token.loc, token.raw.clone())
    return Box[Expr].from_pointer(cast result)
}

parse_args_enum :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
    result := mem.alloc(EnumExpr)
    <<result = EnumExpr(ti, loc)

    if args.length == 0 {
        return Some(Box[Expr].from_pointer(cast result)), args
    }

    current := ref args[0]
    result.loc = current.loc
    args = args[1..args.length]

    for(by_ref=true) mem : ti.kind.Enum.members {
        display_name := get_display_name_for_member(mem)
        if streq(display_name, current.raw.slice()) {
            result.mem = Some(&mem)
            if mem.typ != null {
                result.sub, args = parse_args_help(mem.typ, args, Location(current.loc.end, current.loc.end))
                //result.loc = Location(result.loc.start, result.sub.loc.end)
            }
            break
        }
    }

    match result.mem {
        None -> {
            // no matching enum member found, so create raw expression used for error reporting/autocomplete later
            result.sub = Some(create_raw_expr(null, current))
        }
    }

    return Some(Box[Expr].from_pointer(cast result)), args
}

parse_args_struct :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
    result := mem.alloc(StructExpr)
    <<result = StructExpr(ti, Location(-1, loc.end))

    while args.length > 0 {
        current := ref args[0]
        result.loc.start = if result.loc.start >= 0 then result.loc.start else current.loc.start
        args = args[1..args.length]

        loc := current.loc
        mem_info : &TypeInfoStructMember = null
        sub := Option[Box[Expr]].None

        // todo: handle these error cases
        if current.raw.get_length() > 0 and current.raw[0] == '-' {
            // at this point current starts with -
            current_raw := current.raw.sliceF(1)

            for(by_ref=true) mem : ti.kind.Struct.members {
                display_name := get_display_name_for_member(mem)
                if streq(display_name, current_raw) {
                    mem_info = &mem
                    sub, args = parse_args_help(mem.typ, args, Location(current.loc.end, current.loc.end))
                    match ref sub {
                        Some($sub) -> {
                            loc.end = sub.get().loc.end
                        }
                    }
                    break
                }
            }
        }

        if mem_info == null {
            // no matching struct member found, so create raw expression used for error reporting/autocomplete later
            sub = Some(create_raw_expr(null, current))
        }

        member := StructMember(loc, mem_info, sub)
        result.loc.end = member.loc.end
        result.subs.add(member)
    }

    return Some(Box[Expr].from_pointer(cast result)), args
}

parse_args_help :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
    return match ti.kind {
        TypeInfoKind.Enum($info)    -> parse_args_enum(ti, args, loc)
        TypeInfoKind.Struct($info)  -> {
            custom_parser := info.get_trait_impl(CustomParser)
            if custom_parser != null {
                func := custom_parser.get_function("parse", fn([]ClapToken, Location) -> (Option[Box[Expr]], []ClapToken))
                @assert(func != null)
                return func(args, loc)
            } else {
                parse_args_struct(ti, args, loc)
            }
        }
        _ -> if args.length == 0 {
            None, args
        } else {
            Some(create_raw_expr(ti, args[0])), args[1..args.length]
        }
    }
}

parse_args :: (ti: &TypeInfo, args: []ClapToken) -> Option[Box[Expr]], []ClapToken {
    return parse_args_help(ti, args, Location(0, 0))
}

get_value :: ($T: type, expr: ref Expr) -> Result[Box[T], ClapError] {
    try(validate(expr))

    result := mem.alloc(T)
    get_value_help(result, expr)
    return Ok(Box[T].from_pointer(result))
}

get_value_raw :: (result: &void, expr: ref ValueExpr) {
    @assert(expr.typ != null)
    match expr.typ.kind {
        TypeInfoKind.Int($info) -> {
            num := fmt.parse_int(expr.raw.slice())
            match info.signed, expr.typ.size {
                true, 1  -> { <<cast(&i8)  result = cast num }
                true, 2  -> { <<cast(&i16) result = cast num }
                true, 4  -> { <<cast(&i32) result = cast num }
                true, 8  -> { <<cast(&i64) result = cast num }
                false, 1 -> { <<cast(&u8)  result = cast num }
                false, 2 -> { <<cast(&u16) result = cast num }
                false, 4 -> { <<cast(&u32) result = cast num }
                false, 8 -> { <<cast(&u64) result = cast num }
            }
        }

        TypeInfoKind.String -> {
            <<cast(&string) result = expr.raw.slice()
        }

        _ -> @assert(false)
    }
}

get_value_help :: (result: &void, expr: ref Expr) {
    match expr {
        EnumExpr($v) -> {
            tag_type := v.typ.kind.Enum.tag_type

            member_info := match v.mem {
                Some($info) -> info
                None        -> @assert(false)
            }

            // copy tag
            tag_ptr := cast(&int) result
            <<tag_ptr = member_info.tag

            if member_info.typ != null {
                sub : ref Expr = match ref v.sub {
                    Some($sub)  -> sub.get()
                    None        -> @assert(false)
                }
                get_value_help(util.pointer_add(result, tag_type.size), sub)
            }
        }
        StructExpr($v) -> {
            // stack allocated array to track which members have been provided
            members_set := @alloca(bool, v.typ.kind.Struct.members.length)
            C.memset(members_set.data, 0, cast members_set.length * @sizeof(bool))

            for mem : v.subs {
                @assert(mem.mem != null)
                offset := mem.mem.offset
                match ref mem.sub {
                    Some($sub)  -> get_value_help(util.pointer_add(result, offset), sub.get())
                    None        -> @assert(false)
                }
                members_set[mem.mem.index] = true
            }

            for set : members_set {
                if set then continue
                mem := ref v.typ.kind.Struct.members[it_index]
                @assert(mem.initializer != null)
                member_ptr := util.pointer_add(result, mem.offset)
                mem.initializer(member_ptr)
            }
        }
        ValueExpr($v) -> {
            get_value_raw(result, v)
        }

        CustomExpr($v) -> {
            custom_parser := v.typ.kind.Struct.get_trait_impl(CustomParser)
            @assert(custom_parser != null)
            get_value_func := custom_parser.get_function("get_value", fn(&void, ref CustomExpr))
            @assert(get_value_func != null)
            get_value_func(result, v)
        }
    }
}

print_error_message :: (command: string, err: ClapError) {
    io.formatln("[ERROR] {}", [err.msg])
    io.formatln("> {}", [command])

    // print location marker, ^----
    marker := String.empty()
    for 0 .. err.loc.start do marker.append_string(" ")
    marker.append_string("^")
    for err.loc.start .. (err.loc.end - 1) do marker.append_string("-")
    io.formatln("  {}", [marker])
}

impl Printable for Expr {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            EnumExpr($v)    -> v.print(str, format)
            StructExpr($v)  -> v.print(str, format)
            ValueExpr($v)   -> v.print(str, format)
            CustomExpr($v)  -> str.append_string("custom()")
            EmptyExpr($v)   -> str.append_string("empty()")
        }
    }
}

impl Printable for EnumExpr {
    print :: (ref Self, str: ref String, format: string) {
        // str.appendf("{}", int(typ))
        sub_str := match ref sub {
            Some($sub)  -> fmt.format_any(sub.get())
            None        -> String.from_string("null")
        }
        mem_name := match ref mem {
            Some($mem)  -> mem.name
            None        -> "?"
        }
        result := fmt.format("enum({}.{}, loc={}, sub={})", [typ.kind.Enum.name, mem_name, loc, sub_str.slice()])
        str.append(result)
    }
}

impl Printable for StructExpr {
    print :: (ref Self, str: ref String, format: string) {
        sub_str := String.empty()
        for mem : subs {
            if it_index > 0 {
                sub_str.append_string(", ")
            }
            sub_str.appendf("member({}, loc={}, sub=", (if mem.mem != null then mem.mem.name else "?", mem.loc))
            match ref mem.sub {
                Some($sub)  -> sub.get().print(sub_str, "")
                None        -> sub_str.append_string("None")
                _           -> @assert(false)
            }
            sub_str.append_string(")")
        }
        result := fmt.format("struct({}, loc={}, subs=[{}])", [typ.kind.Struct.name, loc, sub_str])
        str.append(result)
    }
}

impl Printable for ValueExpr {
    print :: (ref Self, str: ref String, format: string) {
        result := fmt.format("value(typ={}, loc={}, raw='{}')", [int(typ), loc, raw.slice()])
        str.append(result)
    }
}

impl Printable for Location {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{}..{}", (start, end))
    }
}

ClapError :: struct {
    loc : Location
    msg : String
}

impl Printable for ClapError {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format("{}, {}", [loc, msg])
        str.append(msg)
    }
}

validate_raw :: (expr: ref ValueExpr) -> Result[(), ClapError] {
    @assert(expr.typ != null)

    match expr.typ.kind {
        TypeInfoKind.Int($info) -> {
            // todo: check that the raw string is indeed a number
        }
    }
    return Ok(())
}

validate :: (expr: ref Expr) -> Result[(), ClapError] {
    if expr.typ == null {
        return Err(ClapError(expr.loc, String.from_string("Type of expr is null")))
    }

    return match expr {
        EnumExpr($v) -> {
            match ref v.mem {
                Some($mem) -> {
                    if mem.typ != null {
                        match ref v.sub {
                            Some($sub)  -> validate(sub.get())
                            None        -> @assert(false)
                        }
                    } else {
                        Ok(())
                    }
                }

                None -> {
                    match ref v.sub {
                        Some($sub) -> match ref sub.get() {
                            ValueExpr($raw) -> Err(ClapError(raw.loc, fmt.format("Unknown argument {}", [raw.raw.slice()])))
                            _               -> @assert(false)
                        }
                        None -> Err(ClapError(v.loc, fmt.format("Missing argument {}", [v.typ.kind.Enum.name])))
                    }
                }
            }
        }
        StructExpr($v) -> {
            // stack allocated array to track which members have been provided
            members_set := @alloca(bool, v.typ.kind.Struct.members.length)
            C.memset(members_set.data, 0, cast members_set.length * @sizeof(bool))

            for mem : v.subs {
                if mem.mem == null {
                    match ref mem.sub {
                        Some($sub) -> {
                            match sub.get() {
                                ValueExpr($raw) -> {
                                    return Err(ClapError(raw.loc, fmt.format("Unknown argument {}", [raw.raw.slice()])))
                                }
                                _ -> @assert(false)
                            }
                        }
                        None -> @assert(false)
                    }
                }

                match ref mem.sub {
                    Some($sub)  -> try(validate(sub.get()))
                    None        -> {
                        return Err(ClapError(mem.loc, fmt.format("Missing value for argument '{}'", [get_display_name_for_member(mem.mem)])))
                    }
                }

                if members_set[mem.mem.index] {
                    return Err(ClapError(mem.loc, fmt.format("Duplicate argument '{}'", [get_display_name_for_member(mem.mem)])))
                }
                members_set[mem.mem.index] = true
            }

            for set : members_set {
                if set then continue

                mem := ref v.typ.kind.Struct.members[it_index]
                if mem.initializer != null then continue

                return Err(ClapError(v.loc, fmt.format("Missing argument '{}'", [get_display_name_for_member(mem)])))
            }
            Ok(())
        }
        ValueExpr($v) -> validate_raw(v)

        CustomExpr($v) -> {
            custom_parser := v.typ.kind.Struct.get_trait_impl(CustomParser)
            @assert(custom_parser != null)
            validate_func := custom_parser.get_function("validate", fn(ref CustomExpr) -> Result[(), ClapError])
            @assert(validate_func != null)
            validate_func(v)
        }

        _ -> {
            @assert(false)
            Ok(())
        }
    }
}

get_display_name_for_member :: (mem: ref $T) -> string {
    name_att := mem.get_attribute("name")
    if name_att == null {
        return mem.name
    }

    @assert(name_att.args.length == 1)
    @assert(@type_info_of_any(name_att.args[0]) == @type_info(string))
    name := <<cast(&string) @ptr_of_any(name_att.args[0])
    return name
}

// */