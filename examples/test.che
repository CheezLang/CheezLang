// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test
// import examples.ShmupEngine.src.main

// examples which are not working currently
// import examples.postfix
import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*

use import std.string
use import std.printable
use import std.array
use import std.box
use import std.math
io   :: import std.io
fmt  :: import std.fmt
mem  :: import std.mem.allocator
util :: import std.util
C    :: import std.c

use import clap.clap

autocomplete :: ($T: type, args: []string) -> Array[String] {
    result := Array[String].create()
    autocomplete_type_info(@type_info(T), args, result)
    return result
}

autocomplete_type_info :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.printfln("auto {}", args.length)
    if args.length == 0 {
        autocomplete_type_members(ti, "", result)
    } else if args.length == 1 {
        autocomplete_type_members(ti, args[0], result)
    } else {
        current := args[0]

        match ti.kind {
            TypeInfoKind.Enum($info) -> {
                io.println("auto enum")
                for(by_ref=true) mem : info.members {
                    if mem.typ != null and streq(mem.name, current) {
                        autocomplete_type_info(mem.typ, args[1..args.length], result)
                    }
                }
            }

            TypeInfoKind.Struct($info) -> {
                autocomplete_struct(ti, args, result)
            }
        }
    }
}

autocomplete_struct :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.println("auto struct")
    info := ti.kind.Struct
    
    current := args[0]
    if current.bytes.length == 0 {
        // todo
        // empty string, what now?
    } else if current[0] == u8('-') {
        current := current.sub_string(1)
        for(by_ref=true) mem : info.members {
            if streq(mem.name, current) {
                autocomplete_type_info(mem.typ, args[1..args.length], result)
            }
        }
    } else {
        // current doesn't start with '-'
        // do nothing
    }
}

autocomplete_type_members :: (ti: &TypeInfo, prefix: string, result: ref Array[String]) {
    match ti.kind {
        TypeInfoKind.Enum($info) -> {
            for(by_ref=true) mem : info.members {
                if mem.typ != null and streq(mem.name, prefix) {
                    autocomplete_type_members(mem.typ, "", result)
                } else if mem.name.bytes.length != prefix.bytes.length and mem.name.starts_with(prefix) {
                    remainder := mem.name.sub_string(prefix.bytes.length)
                    result.add(String.from_string(remainder))
                }
            }
        }

        TypeInfoKind.Struct($info) -> {
            if prefix.bytes.length == 0 {
                for(by_ref=true) mem : info.members {
                    result.add(fmt.format("-{}", [mem.name]))
                }
            } else if prefix[0] == u8('-') {
                prefix := prefix.sub_string(1)
                for(by_ref=true) mem : info.members {
                    is_prefix := mem.name.starts_with(prefix)
                    if !is_prefix then continue
                    if mem.name.bytes.length == prefix.bytes.length {
                        // prefix == name
                        autocomplete_type_members(mem.typ, "", result)
                    } else {
                        // prefix < name
                        remainder := mem.name.sub_string(prefix.bytes.length)
                        result.add(String.from_string(remainder))
                    }
                }
            } else {
                // prefix doesn't start with '-'
                // do nothing
            }
        }
    }
}

Expr :: struct #extendable {
    typ : &TypeInfo
    loc : Location
}

EnumExpr :: struct #extend(Expr) {
    mem : &TypeInfoEnumMember = null
    sub : &Expr = null
}

StructExpr :: struct #extend(Expr) {
    subs := Array[StructMember].create()
}

StructMember :: struct {
    loc : Location
    mem : &TypeInfoStructMember
    sub : &Expr
}

ValueExpr :: struct #extend(Expr) {
    raw : String
}

CustomExpr :: struct #extend(Expr) {
    sub : &Expr
}

CustomParser :: trait {
    parse     :: (args: []ClapToken, loc: Location) -> (&Expr, []ClapToken);
    validate  :: (ref CustomExpr) -> Result[(), ClapError];
    get_value :: (result: &void, expr: ref CustomExpr);
}

create_raw_expr :: (ti: &TypeInfo, token: ref ClapToken) -> &Expr {
    result := mem.alloc(ValueExpr)
    <<result = ValueExpr(ti, token.loc, token.raw.clone())
    return cast result
}

parse_args_enum :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> &Expr, []ClapToken {
    result := mem.alloc(EnumExpr)
    <<result = EnumExpr(ti, loc)

    if args.length == 0 {
        return cast result, args
    }

    current := ref args[0]
    result.loc = current.loc
    args = args[1..args.length]

    for(by_ref=true) mem : ti.kind.Enum.members {
        display_name := get_display_name_for_member(mem)
        if streq(display_name, current.raw.slice()) {
            result.mem = &mem
            if mem.typ != null {
                result.sub, args = parse_args_help(mem.typ, args, Location(current.loc.end, current.loc.end))
                //result.loc = Location(result.loc.start, result.sub.loc.end)
            }
            break
        }
    }

    if result.mem == null {
        // no matching enum member found, so create raw expression used for error reporting/autocomplete later
        result.sub = create_raw_expr(null, current)
    }

    return cast result, args
}

parse_args_struct :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> &Expr, []ClapToken {
    result := mem.alloc(StructExpr)
    <<result = StructExpr(ti, Location(-1, loc.end))

    while args.length > 0 {
        current := ref args[0]
        result.loc.start = if result.loc.start >= 0 then result.loc.start else current.loc.start
        args = args[1..args.length]

        member := StructMember(current.loc, null, null)

        // todo: handle these error cases
        if current.raw.get_length() > 0 and current.raw[0] == '-' {
            // at this point current starts with -
            current_raw := current.raw.sliceF(1)

            for(by_ref=true) mem : ti.kind.Struct.members {
                display_name := get_display_name_for_member(mem)
                if streq(display_name, current_raw) {
                    member.mem = &mem
                    member.sub, args = parse_args_help(mem.typ, args, Location(current.loc.end, current.loc.end))

                    if member.sub != null {
                        member.loc.end = member.sub.loc.end
                    }
                    break
                }
            }
        }

        if member.mem == null {
            // no matching struct member found, so create raw expression used for error reporting/autocomplete later
            member.sub = create_raw_expr(null, current)
        }

        result.loc.end = member.loc.end
        result.subs.add(member)
    }

    return cast result, args
}

parse_args_help :: (ti: &TypeInfo, args: []ClapToken, loc: Location) -> &Expr, []ClapToken {
    return match ti.kind {
        TypeInfoKind.Enum($info)    -> parse_args_enum(ti, args, loc)
        TypeInfoKind.Struct($info)  -> {
            custom_parser := info.get_trait_impl(CustomParser)
            if custom_parser != null {
                func := custom_parser.get_function("parse", fn([]ClapToken, Location) -> (&Expr, []ClapToken))
                @assert(func != null)
                return func(args, loc)
            } else {
                parse_args_struct(ti, args, loc)
            }
        }
        _ -> if args.length == 0 {
            null, args
        } else {
            create_raw_expr(ti, args[0]), args[1..args.length]
        }
    }
}

parse_args :: (ti: &TypeInfo, args: []ClapToken) -> &Expr, []ClapToken {
    return parse_args_help(ti, args, Location(0, 0))
}

get_value :: ($T: type, expr: ref Expr) -> Result[Box[T], ClapError] {
    try(validate(expr))

    result := mem.alloc(T)
    get_value_help(result, expr)
    return Ok(Box[T].from_pointer(result))
}

get_value_raw :: (result: &void, expr: ref ValueExpr) {
    @assert(expr.typ != null)
    match expr.typ.kind {
        TypeInfoKind.Int($info) -> {
            num := fmt.parse_int(expr.raw.slice())
            match info.signed, expr.typ.size {
                true, 1  -> { <<cast(&i8)  result = cast num }
                true, 2  -> { <<cast(&i16) result = cast num }
                true, 4  -> { <<cast(&i32) result = cast num }
                true, 8  -> { <<cast(&i64) result = cast num }
                false, 1 -> { <<cast(&u8)  result = cast num }
                false, 2 -> { <<cast(&u16) result = cast num }
                false, 4 -> { <<cast(&u32) result = cast num }
                false, 8 -> { <<cast(&u64) result = cast num }
            }
        }

        TypeInfoKind.String -> {
            <<cast(&string) result = expr.raw.slice()
        }

        _ -> @assert(false)
    }
}

get_value_help :: (result: &void, expr: ref Expr) {
    match expr {
        EnumExpr($v) -> {
            tag_type := v.typ.kind.Enum.tag_type

            @assert(v.mem != null)

            // copy tag
            tag_ptr := cast(&int) result
            <<tag_ptr = v.mem.tag

            if v.mem.typ != null {
                @assert(v.sub != null)
                get_value_help(util.pointer_add(result, tag_type.size), <<v.sub)
            }
        }
        StructExpr($v) -> {
            // stack allocated array to track which members have been provided
            members_set := @alloca(bool, v.typ.kind.Struct.members.length)
            C.memset(members_set.data, 0, cast members_set.length * @sizeof(bool))

            for mem : v.subs {
                @assert(mem.mem != null)
                offset := mem.mem.offset
                get_value_help(util.pointer_add(result, offset), <<mem.sub)
                members_set[mem.mem.index] = true
            }

            for set : members_set {
                if set then continue
                mem := ref v.typ.kind.Struct.members[it_index]
                @assert(mem.initializer != null)
                member_ptr := util.pointer_add(result, mem.offset)
                mem.initializer(member_ptr)
            }
        }
        ValueExpr($v) -> {
            get_value_raw(result, v)
        }

        CustomExpr($v) -> {
            custom_parser := v.typ.kind.Struct.get_trait_impl(CustomParser)
            @assert(custom_parser != null)
            get_value_func := custom_parser.get_function("get_value", fn(&void, ref CustomExpr))
            @assert(get_value_func != null)
            get_value_func(result, v)
        }
    }
}

Command :: enum {
    #name("start")  Start
    #name("stop")   Stop
    #name("test")   Test    : Foo
    #name("switch") Switch  : Mode
}
Foo :: struct {
    mode   : Mode
    banana : int
    bazaza : String
    // baz    : Baz
    array  := Array[string].create()
}
Baz :: struct {
    // name : string
    age  : int
}
Mode :: enum {
    #name("on") On
    #name("off") Off
}

impl CustomParser for String {
    parse :: (args: []ClapToken, loc: Location) -> &Expr, []ClapToken {
        // io.println("String.parse")
        result := mem.alloc(CustomExpr)
        <<result = CustomExpr(@type_info(Self), loc, null)
        if args.length == 0 {
            return cast result, args
        }

        result.sub = create_raw_expr(result.typ, args[0])
        return cast result, args[1..args.length]
    }

    validate :: (ref CustomExpr) -> Result[(), ClapError] {
        // io.println("String.validate")
        return Ok(())
    }

    get_value :: (result: &void, expr: ref CustomExpr) {
        // io.println("String.get_value")
        match ref <<expr.sub {
            ValueExpr($v) -> {
                <<cast(&String)result = v.raw.clone()
            }

            _ -> @assert(false)
        }
    }
}

Main :: () {
    command := "test -mode on -banana 123 -bazaza uiae"
    args := Clap.tokenize(command)

    io.println("Arguments`n==========")
    for(by_ref=true) a : args {
        io.formatln(a)
    }
    io.println("==========")

    result, _ := parse_args(@type_info(Command), args.slice())
    if result != null {
        io.println("===")
        io.println(fmt.format_any(<<result))
        io.println("===")

        match get_value(Command, <<result) {
            Ok($result) -> io.formatln(result)
            Err($err)   -> print_error_message(command, err)
        }
    }

    // strs := autocomplete(Command, ["Test", "-banana", "5"])

    // for str : strs {
    //     io.println(str.slice())
    // }
    // io.println("===")
}

print_error_message :: (command: string, err: ClapError) {
    io.formatln("[ERROR] {}", [err.msg])
    io.formatln("> {}", [command])

    // print location marker, ^----
    marker := String.empty()
    for 0 .. err.loc.start do marker.append_string(" ")
    marker.append_string("^")
    for err.loc.start .. (err.loc.end - 1) do marker.append_string("-")
    io.formatln("  {}", [marker])
}

impl Printable for Expr {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            EnumExpr($v)   -> v.print(str, format)
            StructExpr($v) -> v.print(str, format)
            ValueExpr($v)  -> v.print(str, format)
        }
    }
}

impl Printable for EnumExpr {
    print :: (ref Self, str: ref String, format: string) {
        // str.appendf("{}", int(typ))
        sub_str := if sub == null then String.from_string("null") else fmt.format_any(<<sub)
        result := fmt.format("enum({}.{}, loc={}, sub={})", [typ.kind.Enum.name, if mem == null then "?" else mem.name, loc, sub_str.slice()])
        str.append(result)
    }
}

impl Printable for StructExpr {
    print :: (ref Self, str: ref String, format: string) {
        sub_str := String.empty()
        for mem : subs {
            if it_index > 0 {
                sub_str.append_string(", ")
            }
            sub_str.appendf("member({}, loc={}, sub=", (if mem.mem != null then mem.mem.name else "?", mem.loc))
            if mem.sub != null {
                mem.sub.print(sub_str, "")
            }
            sub_str.append_string(")")
        }
        result := fmt.format("struct({}, loc={}, subs=[{}])", [typ.kind.Struct.name, loc, sub_str])
        str.append(result)
    }
}

impl Printable for ValueExpr {
    print :: (ref Self, str: ref String, format: string) {
        result := fmt.format("value(typ={}, loc={}, raw='{}')", [int(typ), loc, raw.slice()])
        str.append(result)
    }
}

impl Printable for Location {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{}..{}", (start, end))
    }
}

ClapError :: struct {
    loc : Location
    msg : String
}

impl Printable for ClapError {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format("{}, {}", [loc, msg])
        str.append(msg)
    }
}

validate_raw :: (expr: ref ValueExpr) -> Result[(), ClapError] {
    @assert(expr.typ != null)

    match expr.typ.kind {
        TypeInfoKind.Int($info) -> {
            // todo: check that the raw string is indeed a number
        }
    }
    return Ok(())
}

validate :: (expr: ref Expr) -> Result[(), ClapError] {
    if expr.typ == null {
        return Err(ClapError(expr.loc, String.from_string("Type of expr is null")))
    }

    return match expr {
        EnumExpr($v) -> {
            if v.mem == null {
                if v.sub == null {
                    return Err(ClapError(v.loc, fmt.format("Missing argument {}", [v.typ.kind.Enum.name])))
                }
                match ref <<v.sub {
                    ValueExpr($raw) -> {
                        return Err(ClapError(raw.loc, fmt.format("Unknown argument {}", [raw.raw.slice()])))
                    }

                    _ -> @assert(false)
                }
            }

            if v.mem.typ != null {
                @assert(v.sub != null)
                validate(<<v.sub)
            } else {
                Ok(())
            }
        }
        StructExpr($v) -> {
            // stack allocated array to track which members have been provided
            members_set := @alloca(bool, v.typ.kind.Struct.members.length)
            C.memset(members_set.data, 0, cast members_set.length * @sizeof(bool))

            for mem : v.subs {
                if mem.mem == null {
                    match ref <<mem.sub {
                        ValueExpr($raw) -> {
                            return Err(ClapError(raw.loc, fmt.format("Unknown argument {}", [raw.raw.slice()])))
                        }

                        _ -> @assert(false)
                    }
                }

                try(validate(<<mem.sub))

                if members_set[mem.mem.index] {
                    return Err(ClapError(mem.loc, fmt.format("Duplicate argument '{}'", [get_display_name_for_member(mem.mem)])))
                }
                members_set[mem.mem.index] = true
            }

            for set : members_set {
                if set then continue

                mem := ref v.typ.kind.Struct.members[it_index]
                if mem.initializer != null then continue

                return Err(ClapError(v.loc, fmt.format("Missing argument '{}'", [get_display_name_for_member(mem)])))
            }
            Ok(())
        }
        ValueExpr($v) -> validate_raw(v)

        CustomExpr($v) -> {
            custom_parser := v.typ.kind.Struct.get_trait_impl(CustomParser)
            @assert(custom_parser != null)
            validate_func := custom_parser.get_function("validate", fn(ref CustomExpr) -> Result[(), ClapError])
            @assert(validate_func != null)
            validate_func(v)
        }

        _ -> {
            @assert(false)
            Ok(())
        }
    }
}

get_display_name_for_member :: (mem: ref $T) -> string {
    name_att := mem.get_attribute("name")
    if name_att == null {
        return mem.name
    }

    @assert(name_att.args.length == 1)
    @assert(@type_info_of_any(name_att.args[0]) == @type_info(string))
    name := <<cast(&string) @ptr_of_any(name_att.args[0])
    return name
}

// */