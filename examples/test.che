#load("examples/trait_function_call_performance")
// #load("examples/geometry_draw_thingy")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/language/local_variables")
// #load("tests/library/allocator2")
//#load("tests/other/test1")

/*
#load("std:preload")
#load("std:c")
// #load("std:util")

let counter: int = 1

struct Foo {
    val: int
    txt: c_string
}

impl Foo {
    fn create(txt: c_string) -> Self {
        counter += 1
        return new {counter-1, txt}
    }
}

// struct Bar {
//     pub foo: Foo
// }

// impl Foo {
//     fn add(Self, other: Self) -> Self #operator("+") {return new{}}
//     fn add_eq(ref Self, other: Self) #operator("+=") {}
// }


impl Drop for Foo {
    fn drop(ref Self) {
        c_printf("drop Foo(%lld, '%s')`n", val, txt)
    }
}

// impl Drop for Bar {
//     fn drop(ref Self) {
//         c_printf("drop Bar`n")
//     }
// }

// fn test(f1: Foo, f2: Foo) {
//     let foo3 = Foo::create("foo3")
//     let foo4 = Foo::create("foo4")
//     {
//         let foo5 = Foo::create("foo5")
//         let foo6 = Foo::create("foo6")
//         if false {
//             let foo7 = Foo::create("foo7")
//             let foo8 = Foo::create("foo8")
//             return
//         }
//         while let k = 0, k < 1, k += 1 #label l1 {
//             let foo9 = Foo::create("foo9")
//             let foo10 = Foo::create("foo10")
//             while let i = 0, i < 1, i += 1 {
//                 let foo11 = Foo::create("foo11")
//                 let foo12 = Foo::create("foo12")
//                 if false {
//                     let foo13 = Foo::create("foo13")
//                     let foo14 = Foo::create("foo14")
//                     continue
//                 }
//                 if false {
//                     let foo15 = Foo::create("foo15")
//                     let foo16 = Foo::create("foo16")
//                     break
//                 }
//                 if true {
//                     let foo17 = Foo::create("foo17")
//                     let foo18 = Foo::create("foo18")
//                     continue l1
//                 }
//                 if true {
//                     let foo19 = Foo::create("foo19")
//                     let foo20 = Foo::create("foo20")
//                     break l1
//                 } else {
//                     return
//                 }

//                 break
//             }

//             break
//         }
//     }
//     let foo21 = Foo::create("foo21")
//     return
// }

fn Main() {
    // test(Foo::create("f1"), Foo::create("f2"))


    // let (c, d) = (a, b)
    // let f = (c, d)
    // let (g, h) = f

    // let n: int = 1
    // n = 1

    // let a: []int = [1, 2, 3]
    // a.length = 1

    // let b: Bar = new{}
    // b.foo = new{}


    // let a: int
    // a = 1
    // a = 2
    // drop(a)
    // a = 3
    // match 1 {
    //     // 1 -> {a = 5}
    //     // 1 -> {a = 5}
    //     // 3 -> {}
    //     // 3 -> {}
    //     // 2 -> {let b = a}
    //     // 2 -> {a = 5; let b = a}
    // }


    // let a: int = 1

    // while false #label l1 {
    //     let b = a

    //     if true {
    //         a = 5

    //         while false {
    //             let f = 1
    //             break l1
    //         }

    //         while false {
    //             let g = 1
    //             break
    //         }

    //         break
    //     } else {
    //         a = 10
    //         break
    //     }
    //     let d = 5
    //     // let x = a

    //     // a = 10
    // }

    // let c = 5
}

// */

/*
fn Main() {
    if const true {
        let a: Foo
        let (foo, bar) = (true, true)
        @log_symbol_status(a)

        while true {
            a = default

            // if bar {
            //     drop(a)
            //     break
            // }
            // else drop(a)


            // drop(a)
        }

        @log_symbol_status(a)
    }



    if const false {
        let a: int
        @log_symbol_status(a)
        match 5 {
            1 -> {
                @log_symbol_status(a)
                a = 5
                @log_symbol_status(a)
            }
            2 -> {
                @log_symbol_status(a)
                a = 6
                @log_symbol_status(a)
            }
            3 -> {
                @log_symbol_status(a)
                // a = 7
                @log_symbol_status(a)
            }
        }
        @log_symbol_status(a)
    }

    if const false {
        let a: int
        @log_symbol_status(a)
        if true {
            @log_symbol_status(a)
            a = 5
            @log_symbol_status(a)
        } else {
            @log_symbol_status(a)
            a = 10
            @log_symbol_status(a)
        }
        @log_symbol_status(a)
    }

    if const false {
        let a: int = 1
        @log_symbol_status(a)
        while false {
            @log_symbol_status(a)
            a = 5
            @log_symbol_status(a)
        }
        @log_symbol_status(a)
    }
}
// */


/*
#load("std:io/io")

struct Rc(T: type) {
    pub const count : &int
    pub const data  : &T
}

impl(T: type) Rc(T) {
    fn empty() -> Rc(T) {
        let count = alloc(int)
        let data  = alloc(T)
        <<count = 1
        return new {count, data}
    }

    fn create(value: ref T) -> Rc(T) {
        let count = alloc(int)
        let data  = alloc(T)
        <<count = 1
        <<data = value
        return new {count, data}
    }

    fn clone(ref Self) -> Rc(T) {
        <<count += 1
        return new {count, data}
    }

    fn dispose(ref Self) {
        @assert(<<count > 0)
        <<count -= 1
        if <<count == 0 {
            free(data)
            data = null
        }
    }
}

fn debug_print(rc: ref Rc($T)) {
    printfln("Rc({}): count={}, data={:x}", [@typename(T), <<rc.count, int(rc.data)])
}

fn Main() {
    let test = Rc(int)::create(645)
    debug_print(test)
    println("")

    println(<<test.data)
    <<test.data = 5
    println(<<test.data)
    <<test.data = 123
    println(<<test.data)
    println("")

    let test2 = test.clone()
    debug_print(test)
    debug_print(test2)
    println("")

    let test3 = test.clone()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test2.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")

    test3.dispose()
    debug_print(test)
    debug_print(test2)
    debug_print(test3)
    println("")
}

// */