// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
// import examples.ShmupEngine.src.main
// import compiler.cli
// import compiler.compiler_test

// examples which are not working currently
// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//*

use import std.string
use import std.printable
use import std.array
use import std.box
io  :: import std.io
fmt :: import std.fmt
mem :: import std.mem.allocator
util :: import std.util

use import clap.clap

autocomplete :: ($T: type, args: []string) -> Array[String] {
    result := Array[String].create()
    autocomplete_type_info(@type_info(T), args, result)
    return result
}

autocomplete_type_info :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.printfln("auto {}", args.length)
    if args.length == 0 {
        autocomplete_type_members(ti, "", result)
    } else if args.length == 1 {
        autocomplete_type_members(ti, args[0], result)
    } else {
        current := args[0]

        match ti.kind {
            TypeInfoKind.Enum($info) -> {
                io.println("auto enum")
                for(by_ref=true) mem : info.members {
                    if mem.typ != null and streq(mem.name, current) {
                        autocomplete_type_info(mem.typ, args[1..args.length], result)
                    }
                }
            }

            TypeInfoKind.Struct($info) -> {
                autocomplete_struct(ti, args, result)
            }
        }
    }
}

autocomplete_struct :: (ti: &TypeInfo, args: []string, result: ref Array[String]) {
    io.println("auto struct")
    info := ti.kind.Struct
    
    current := args[0]
    if current.bytes.length == 0 {
        // todo
        // empty string, what now?
    } else if current[0] == u8('-') {
        current := current.sub_string(1)
        for(by_ref=true) mem : info.members {
            if streq(mem.name, current) {
                autocomplete_type_info(mem.typ, args[1..args.length], result)
            }
        }
    } else {
        // current doesn't start with '-'
        // do nothing
    }
}

autocomplete_type_members :: (ti: &TypeInfo, prefix: string, result: ref Array[String]) {
    match ti.kind {
        TypeInfoKind.Enum($info) -> {
            for(by_ref=true) mem : info.members {
                if mem.typ != null and streq(mem.name, prefix) {
                    autocomplete_type_members(mem.typ, "", result)
                } else if mem.name.bytes.length != prefix.bytes.length and mem.name.starts_with(prefix) {
                    remainder := mem.name.sub_string(prefix.bytes.length)
                    result.add(String.from_string(remainder))
                }
            }
        }

        TypeInfoKind.Struct($info) -> {
            if prefix.bytes.length == 0 {
                for(by_ref=true) mem : info.members {
                    result.add(fmt.format("-{}", [mem.name]))
                }
            } else if prefix[0] == u8('-') {
                prefix := prefix.sub_string(1)
                for(by_ref=true) mem : info.members {
                    is_prefix := mem.name.starts_with(prefix)
                    if !is_prefix then continue
                    if mem.name.bytes.length == prefix.bytes.length {
                        // prefix == name
                        autocomplete_type_members(mem.typ, "", result)
                    } else {
                        // prefix < name
                        remainder := mem.name.sub_string(prefix.bytes.length)
                        result.add(String.from_string(remainder))
                    }
                }
            } else {
                // prefix doesn't start with '-'
                // do nothing
            }
        }
    }
}


/*
Test -bazaza -name Joe -age 57 -banana 123 -baz -name Jane 
enum(
    typ = Command
    loc = 0..66
    mem = Command.Test
    sub = struct(
        typ = Foo
        loc = 5..66
        sub = [
            field(
                loc = 5..30
                mem = Foo.bazaza
                sub = struct(
                    typ = Baz
                    loc = 13..30
                    sub = [
                        field(
                            loc = ..
                            mem = Baz.name
                            sub = string("Joe")
                        )
                        field(
                            loc = ..
                            mem = Baz.age
                            sub = int(57)
                        )
                    ]
                )
            )
            
            field(
                loc = ..
                mem = Foo.banana
                sub = int(123)
            )
            
            field(
                loc = ..
                mem = Foo.baz
                sub = struct(
                    typ = Baz
                    loc = ..
                    sub = [
                        field(
                            loc = ..
                            mem = Baz.name
                            sub = string("Jane")
                        )
                    ]
                )
            )
        ]
    )
)

Start
enum(typ = Command, loc = 0..5, mem = Command.Start, sub = null)

Stop
enum(typ = Command, loc = 0..4, mem = Command.Stop, sub = null)

Switch On
enum(
    typ = Command
    loc = 0..9
    mem = Command.Switch
    sub = enum(
        typ = Mode
        loc = 7..9
        mem = Mode.On
        sub = null
    )
)

Switch Off
enum(
    typ = Command
    loc = 0..10
    mem = Switch
    sub = enum(
        typ = Mode
        loc = 7..10
        mem = Off
        sub = null
    )
)
 */

Expr :: struct #extendable {
    typ : &TypeInfo
    loc : Location
}

EnumExpr :: struct #extend(Expr) {
    mem : &TypeInfoEnumMember = null
    sub : &Expr = null
}

StructExpr :: struct #extend(Expr) {
    sub := Array[StructMember].create()
}

StructMember :: struct {
    loc : Location
    mem : &TypeInfoStructMember
    sub : &Expr
}

ValueExpr :: struct #extend(Expr) {
    raw : String
}

create_raw_expr :: (token: ref ClapToken) -> &Expr {
    result := mem.alloc(ValueExpr)
    <<result = ValueExpr(null, token.loc, token.raw.clone())
    return cast result
}

parse_args_enum :: (ti: &TypeInfo, args: []ClapToken) -> &Expr {
    result := mem.alloc(EnumExpr)
    <<result = EnumExpr(ti, Location(0, 0))

    if args.length == 0 {
        return cast result
    }

    current := ref args[0]

    result.loc = current.loc

    for(by_ref=true) mem : ti.kind.Enum.members {
        if streq(mem.name, current.raw.slice()) {
            result.mem = &mem
            if mem.typ != null {
                result.sub = parse_args(mem.typ, args[1..args.length])
                //result.loc = Location(result.loc.start, result.sub.loc.end)
            }
            break
        }
    }

    if result.mem == null {
        // no matching enum member found
        result.sub = create_raw_expr(current)
    }

    return cast result
}

parse_args_struct :: (ti: &TypeInfo, args: []ClapToken) -> &Expr {
    return null
}

parse_args :: (ti: &TypeInfo, args: []ClapToken) -> &Expr {
    return match ti.kind {
        TypeInfoKind.Enum($info)    -> parse_args_enum(ti, args)
        TypeInfoKind.Struct($info)  -> parse_args_struct(ti, args)
        _ -> null
    }
}

get_value :: ($T: type, expr: ref Expr) -> Result[Box[T], ClapError] {
    try(validate(expr))

    result := mem.alloc(T)
    get_value_help(result, expr)
    return Ok(Box[T].from_pointer(result))
}

get_value_help :: (result: &void, expr: ref Expr) {
    match expr {
        EnumExpr($v) -> {
            tag_type := v.typ.kind.Enum.tag_type

            @assert(v.mem != null)
            
            // copy tag
            tag_ptr := cast(&int) result
            <<tag_ptr = v.mem.tag

            if v.mem.typ != null {
                @assert(v.sub != null)
                get_value_help(util.pointer_add(result, tag_type.size), <<v.sub)
            }
        }
        StructExpr($v) -> {

        }
        ValueExpr($v) -> {

        }
    }
}

Main :: () {
    args := Clap.tokenize("Switch Of")

    io.println("Arguments`n==========")
    for(by_ref=true) a : args {
        io.formatln(a)
    }
    io.println("==========")

    result := parse_args(@type_info(Command), args.slice())
    if result != null {
        io.println("===")
        io.println(fmt.format_any(<<result))
        io.println("===")

        io.formatln(get_value(Command, <<result))
    }

    // strs := autocomplete(Command, ["Test", "-banana", "5"])

    // for str : strs {
    //     io.println(str.slice())
    // }
    // io.println("===")
}

Command :: enum {
    Start
    Stop
    Test    : Foo
    Switch  : Mode
}
Foo :: struct {
    banana : int
    bazaza : Baz
    baz    : Baz
}
Baz :: struct {
    name : string
    age  : int
}
Mode :: enum { On, Off }

impl Printable for Expr {
    print :: (ref Self, str: ref String, format: string) {
        match self {
            EnumExpr($v)   -> v.print(str, format)
            StructExpr($v) -> v.print(str, format)
            ValueExpr($v)  -> v.print(str, format)
        }
    }
}

impl Printable for EnumExpr {
    print :: (ref Self, str: ref String, format: string) {
        // str.appendf("{}", int(typ))
        sub_str := if sub == null then String.from_string("null") else fmt.format_any(<<sub)
        result := fmt.format("enum(typ={}, loc={}, mem={}, sub={})", [int(typ), loc, int(mem), sub_str.slice()])
        str.append(result)
    }
}

impl Printable for StructExpr {
    print :: (ref Self, str: ref String, format: string) {
        sub_str := "..."
        result := fmt.format("struct(typ={}, loc={}, sub={})", [int(typ), loc, sub_str])
        str.append(result)
    }
}

impl Printable for ValueExpr {
    print :: (ref Self, str: ref String, format: string) {
        result := fmt.format("value(typ={}, loc={}, raw='{}')", [int(typ), loc, raw.slice()])
        str.append(result)
    }
}

impl Printable for Location {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{}..{}", (start, end))
    }
}

ClapError :: struct {
    loc : Location
    msg : String
}

impl Printable for ClapError {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format("{}, {}", [loc, msg])
        str.append(msg)
    }
}

validate :: (expr: ref Expr) -> Result[(), ClapError] {
    if expr.typ == null {
        return Err(ClapError(expr.loc, String.from_string("Type of expr is null")))
    }

    return match expr {
        EnumExpr($v) -> {
            if v.mem == null {
                if v.sub == null {
                    return Err(ClapError(v.loc, fmt.format("Missing argument {}", [v.typ.kind.Enum.name])))
                }
                match ref <<v.sub {
                    ValueExpr($raw) -> {
                        return Err(ClapError(raw.loc, fmt.format("Unknown argument {}", [raw.raw.slice()])))
                    }

                    _ -> @assert(false)
                }
            }

            if v.mem.typ != null {
                @assert(v.sub != null)
                validate(<<v.sub)
            } else {
                Ok(())
            }
        }
        StructExpr($v) -> {
            Err(ClapError(v.loc, String.from_string("StructExpr")))
        }
        ValueExpr($v) -> {
            Err(ClapError(v.loc, String.from_string("ValueExpr")))
        }
    }
}

// */