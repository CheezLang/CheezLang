// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.pathtracer2.main
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.command_line_parser
import examples.ShmupEngine.src.main
// import compiler.cli
// import compiler.compiler_test

// examples which are not working currently
// import examples.postfix
// import examples.image_processing
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

// import "../Tools/Bindings/imgui_binding"

// use import std.string
// use import std.printable
// io :: import std.io

// // Units :: generic[M: int, T: int] struct #copy {
// //     value : double
// // }

// // parse_arguments :: generic[T: type] (args: []string) -> Option[T] {
// //     return None
// // }

// // args := parse_arguments[MyArgs](["123", "456", "789"])

// // Same :: [V: int] Units[V, V]

// Foo :: generic[T: type] struct {
//     a : T
// }

// Foo2 :: struct(T: type) {
//     a : T
// }

// Bar :: Foo[int]

// // impl(T: type) Foo[T] {
// //     print :: (ref Self) {
// //         io.printfln("T {}", a)
// //     }
// // }

// // impl Foo[int] {
// //     print :: (ref Self) {
// //         io.printfln("int {}", a)
// //     }
// // }

// // impl Foo[string] {
// //     print :: (ref Self) {
// //         io.printfln("string {}", a)
// //     }
// // }

// Sum         :: generic[A: int, B: int] A + B
// ConstArray  :: generic[Size: int, T: type] [Size]T
// PI          :: generic[T: type] T(3.1415)

// Sum2        :: ($A: int, $B: int) -> int {
//     return A + B
// }
// PI2         :: ($T: type) -> T {
//     return T(3.1415)
// }

// Main :: () {
//     io.println(PI[float])
//     io.println(PI[double])
//     io.println(PI[int])
//     io.println(PI2(float))
//     io.println(PI2(double))
//     io.println(PI2(int))

//     Arr :: ConstArray[Sum[3, 2], float]
//     LOL :: Sum[6, 2]
//     io.println(LOL)
//     io.println(Sum[3, -5])

//     b := Bar(123)
//     z := Foo[string]("test")
//     x := Foo[string]("lol")

//     // b.print()
//     // z.print()
//     // x.print()
    
//     io.println("")
//     io.println(b.a)
//     io.println(z.a)
//     io.println(x.a)
// }

/*

use import std.string
use import std.printable
io :: import std.io

Foo :: struct(size: int) {
    arr : [size]int = default
}

Units :: struct(M: int, T: int) #copy {
    value : double
}

Meter :: Units[1, 0]
Time  :: Units[0, 1]
Speed :: Units[1, -1]

impl Printable for Units[1, 0] {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} m", value)
    }
}

impl Printable for Units[0, 1] {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} s", value)
    }
}

impl Printable for Units[1, -1] {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} m/s", value)
    }
}

impl Printable for Units[1, -2] {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} m/s^2", value)
    }
}

impl(M1: int, M2: int) Printable for Units[M1, M2] if #notyet {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("{} m^{} s^{}", (value, M1, M2))
    }
}

impl(M1: int, T1: int) Units[M1, T1] {
    add :: (Self, other: Units[M1, T1]) -> Units[M1, T1] #operator("+") {
        return Units[M1, T1](self.value + other.value)
    }

    sub :: (Self, other: Units[M1, T1]) -> Units[M1, T1] #operator("-") {
        return Units[M1, T1](self.value - other.value)
    }

    mul :: (Self, other: Units[$M2, $T2]) -> Units[M1 + M2, T1 + T2] #operator("*") {
        return Units[M1 + M2, T1 + T2](self.value * other.value)
    }

    div :: (Self, other: Units[$M2, $T2]) -> Units[M1 - M2, T1 - T2] #operator("/") {
        return Units[M1 - M2, T1 - T2](self.value / other.value)
    }
}

Main :: () {
    {
        distance := Meter(10)
        speed    := Speed(5)
        time     := distance / speed

        io.printfln("distance: {}", distance)
        io.printfln("speed: {}", speed)
        io.printfln("time: {}", time)
        io.println("")
    }

    {
        speed    := Speed(10)
        time     := Time(5)
        distance := time * speed
        acc      := speed / time

        io.printfln("speed: {}", speed)
        io.printfln("time: {}", time)
        io.printfln("distance: {}", distance)
        io.printfln("acc: {}", acc)
        io.println("")
    }

    {
        speed1 := Speed(3)
        speed2 := Speed(10)
        sum    := speed1 + speed2
        diff   := speed1 - speed2

        io.printfln("speed1: {}", speed1)
        io.printfln("speed2: {}", speed2)
        io.printfln("sum: {}", sum)
        io.printfln("diff: {}", diff)
        io.println("")
    }
}

// */

/*
#test_expect_output("")

// use import std.os.windows_functions
// use import std.os.windows_types
// use import std.os.windows_constants
// use import std.io.file
// use import std.io.fs
use import std.printable
use import std.string
use import std.array
use import std.rc
use import std.math
use import std.hash_table
mem :: import std.mem.allocator
io  :: import std.io
fmt :: import std.fmt
C   :: import std.c
util:: import std.util

use import compiler.lexer
use import compiler.error_handler
use import compiler.string_database
serpa :: import serpa.serpa

impl TextProvider for string {
    get_text :: (ref Self, filename: string) -> string {
        return self
    }
}

impl(T: type) serpa.IParser[Rc[T]] for Rc[T] if T : serpa.IParser[T] {
    parse :: (lexer: ref Lexer, error_handler: ErrorHandler) -> Option[Self] {
        return match T.parse(lexer, error_handler) {
            Some($i) -> Some(Rc[T].new(i))
            None -> None
        }
    }
}

impl(T: type) Printable for Rc[T] if T : Printable {
    print :: (ref Self, str: ref String, format: string) {
        str.appendf("Rc(count = {}, value = {})", (self.count(), Printable(self.get())))
    }
}

impl Printable for ComponentData {
    print :: (ref Self, str: ref String, format: string) {
        msg := fmt.format_any(any(type_info, &value.get()))
        str.append(msg)
    }
}

impl serpa.IParser[ComponentData] for ComponentData {
    parse :: (parser: ref serpa.Parser, lexer: ref Lexer, error_handler: ErrorHandler) -> Option[ComponentData] {
        eat_token :: (typ: TokenType) #macro {
            if (ok, t) := @link(lexer).expect_token(typ), ok {
                t
            } else {
                @link(error_handler).report_errorf(t.location, "Expected '{}', got {}", [typ, t.ttype])
                return None
            }
        }

        name_token := eat_token(TokenType.Identifier)
        struct_name := name_token.data.String

        // io.printfln("parsing component {}", struct_name)
        @for_trait_impls(Component, (T) => {
            // io.printfln("trying with type {}", @typename(T))
            if streq(@typename(T), struct_name) {
                result := mem.alloc(T)
                if !parser.parse_struct_into(result, lexer, error_handler) {
                    mem.free(result)
                    return None
                }

                ptr := Rc[T].from_pointer(result, true)
                return Some(ComponentData(
                    ptr.get()
                    ptr.change_type(())
                    @type_info(T)
                ))
            }
        })

        error_handler.report_errorf(name_token.location, "'{}' is not a valid component", [struct_name])
        return None
    }
}

vec3 :: Vector3[float]

Component :: trait {
    update :: (ref Self);
}

ComponentData :: struct {
    component : Component
    value     : Rc[()]
    type_info : &TypeInfo
}

Entity :: struct {
    name : string
    pos  : vec3
    coms : Array[ComponentData]
}

QuadComponent   :: struct {
    color : vec3
}
LolComponent    :: struct {
    lol : int
}
StringComponent :: struct {
    str : String
}

impl Component for QuadComponent {
    update :: (ref Self) {
        io.printfln("QuadComponent.update({}, {}, {})", (color.x, color.y, color.z))
    }
}
impl Component for LolComponent {
    update :: (ref Self) {
        io.printfln("LolComponent.update({})", lol)
    }
}
impl Component for StringComponent {
    update :: (ref Self) {
        io.printfln("StringComponent.update({})", str.slice())
    }
}

Main :: () {
    file := "
{
    name = `"entity`"
    pos  = {x = 9, y = 6, z = 3}
    coms = [
        QuadComponent {
            color = {
                x = 4
                y = 5
                z = 6
            }
        }
        LolComponent {lol = 147}
        StringComponent {str = `"wassup`"}
    ]
}
"

    console_error_handler := ConsoleErrorHandler.new(null)
    string_db := StringDatabase.new()
    lexer := Lexer.from_string(String.from_string(file), string_db)
    console_error_handler.text_provider = file

    parser := serpa.Parser(expect_struct_name=false)
    result := parser.parse(Entity, lexer, console_error_handler)

    io.println(@typename(@typeof(result)))
    io.println(fmt.format_any(result))

    match result {
        Some($entity) -> {
            io.println(entity.name)
            io.println(fmt.format_any(entity.pos))
            for cd : entity.coms {
                cd.component.update()
            }
        }
    }

    // loop {
    //     token := lexer.next_token()
    //     if int(token.ttype) == int(TokenType.EOF) then break

        
    // }
}
// */

/*
#test_expect_output("")

// use import std.os.windows_functions
// use import std.os.windows_types
// use import std.os.windows_constants
// use import std.io.file
// use import std.io.fs
// use import std.string
// use import std.array
// use import std.hash_table
// use import std.mem.allocator
io  :: import std.io
// fmt :: import std.fmt
C   :: import std.c

use import compiler.ast
use import compiler.lexer
use import compiler.parser
use import compiler.error_handler
use import compiler.string_database

Main :: () {
    file :: "uiae.che"

    console_error_handler := ConsoleErrorHandler.new(null)
    console_error_handler.code_color_error  = io.ConsoleColor.Green
    console_error_handler.code_color_normal = io.ConsoleColor.White
    string_db := StringDatabase.new()
    lexer := try_with(
        Lexer.from_file(file, string_db),
        {
            io.printfln("Failed to open file '{}'", file)
            return
        })

    pattern := IdExpr(id = 1, name = "foo")
    init    := IdExpr(id = 2, name = "bar")

    move := MoveExpr(id = 1, target = pattern, source = init)
    pipe := PipeExpr(id = 1, left = move, right = pattern)

    decl := DeclStmt(
        id       = 3
        is_const = true
        pattern  = pattern
        typ      = Some(init)
        init     = Some(pipe))
    io.println(pattern)
    io.println(init)
    io.println(decl)

    loop {
        token := lexer.next_token()
        if int(token.ttype) == int(TokenType.EOF) then break

        
    }
}
// */