// #load("examples/geometry_draw_thingy")
// #load("examples/trait_function_call_performance")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/library/stack_allocator")
// #load("tests/language/if_else")

#load("std:io/io")

fn macro_test(code: Code) #macro {
    while let k = 0, k < 3, k += 1 {

    }
}

fn Main() {
    while let i = 0, i < 3, i += 1 #label a {
        while let k = 0, k < 3, k += 1 #label b {

            if i == 1 {
                break b
            }
            printfln("{}, {}", [i, k])
        }
        // printfln("in loop: {}", [i])
        // macro_test({
        //     printfln("in code: {}", [i])
        // })
    }
}

/*
// #load("std:random")
// #load("std:io/io")
#load("std:c")

struct Products {
    pub to: int
}

struct Range {
    pub from: int
    pub to  : int
    pub inc : int
}

fn range_new(from: int, to: int, inc: int = 1) -> Range {
    return new {from, to, inc}
}

fn for_extension_range(range: Range, code: Code, reverse: bool = false) #for {
    let (start, end, inc) = if const reverse then
        (range.to, range.from, -range.inc)
    else
        (range.from, range.to, range.inc)

    while let (it, it_index) = (start, 0),
        if const reverse then it >= end else it <= end,
        it += inc; it_index += 1 {
        @insert(code)
    }
}

fn for_extension_products(prods: Products, code: Code) #for {
    let it_index = 0
    for a : range_new(1, prods.to) {
        for b : range_new(1, prods.to) {
            let it = a * b
            @insert(code, link=[a, b], _break={break a})
            it_index += 1

            break a
        }
    }
}

fn macro_test(code: Code) #macro {
    let test = "lol"
    @insert(code, link=[test])
}

fn test_random() #main {
    for :new Products{3} {
        //println(it)
        c_printf("%lld * %lld = %lld`n", a, b, it)
    }

    c_puts("")

    for :new Products{3} {
        if it > 5 {
            break
        }

        //println(it)
        c_printf("%lld * %lld = %lld`n", a, b, it)
    }

    c_puts("")

    for :new Products{3} {
        if it > 5 {
            continue
        }
        //println(it)
        c_printf("%lld * %lld = %lld`n", a, b, it)
    }
}
// */

/*

#load("std:io/io")
#load("std:array")

fn macro_test(a: int) #macro {
    // printfln("macro, a = {}, link(x) = {}", [a, @link(x)])
}

fn macro_test2() #macro {
    @link({
        let uiae = 10
    })
}

fn for_extension(arr: []$T, code: Code, reverse: bool = false) #for {
    while let it_index = 0, it_index < arr.length, it_index += 1 {
        if const reverse {
            let it_index_rev = arr.length - it_index - 1
            let it = arr[it_index_rev]
            @insert(code, link=[it_index_rev])
        } else {
            let it = arr[it_index]
            @insert(code)
        }
    }
}

fn test() #main {
    let arr = Array(string)::create()
    arr.add("Hello")
    arr.add(" ")
    arr.add("world")
    arr.add("!")

    for(by_reference=false) :arr {
        print(it)
    }
    println("")

    for(by_reference=false, reverse=true) word :arr {
        print(word)
        word = "lol "
    }
    println("")

    for(by_reference=true) :arr {
        print(it)
        it = "bruh "
    }
    println("")

    for :arr print(it)
    println("")

    /*
    let arr: []int = [9, 8, 7, 6, 5]

    for v, i :arr {
        printfln("[{}] = {}", [i, v])
    }
    println("")

    for :arr {
        printfln("[{}] = {}", [it_index, it])
    }
    println("")

    for(reverse = true) v, i :arr {
        printfln("[{0}/{2}] = {1}", [i, v, it_index_rev])
    }
    println("")

    for(reverse = true) :arr {
        printfln("[{0}/{2}] = {1}", [it_index, it, it_index_rev])
    }
    println("")
    // */

    // let uiae = "lol"
    // {
    //     let arr = [5, 3, 2]
    //     for_extension(arr, println(@sizeof(@link(T))))
    //     // macro_test3(arr, {
    //     //     printfln("arr[{}] = {}", [@link(it_index), @link(it)])
    //     //     // println(uiae)
    //     //     // println("test")
    //     // }, reverse = false)
    //     println("")
    // }

    // {
    //     let x = 123
    //     macro_test(x)
    //     macro_test(2 + 3 * x)
    // }

    // {
    //     macro_test2()
    //     println(uiae)
    // }

    // for i : arr {
    //     println(i)
    // }

    // for(count = 5) i, index : arr {
    //     println(i)
    //     println(index)
    // }

    // for #odd (count = 5) i, index : arr {
    //     println(i)
    //     println(index)
    // }
}

// */