// examples which should be working
// import examples.trait_function_call_performance
// import examples.glfw3_example
// import examples.graphyfier.graphyfier
// import examples.geometry_draw_thingy
// import examples.signed_distance_field_renderer
// import examples.snake.snake
// import examples.pathtracer
// import examples.pathtracer2.main
// import examples.command_line_parser
// import compiler.cli
// import compiler.compiler_test
// import examples.ShmupEngine.src.main

use import compiler.interpreter
use import json.json
use import clap.clap
use import dap.debug_adapter


use import std.array
use import std.hash_table
use import std.map
use import std.string
use import std.box
use import std.rc
use import std.thread

use import std.os.windows
use import std.os.windows_functions

io  :: import std.io
mem :: import std.mem.allocator
fmt :: import std.fmt
fs  :: import std.io.fs

LOG_PATH :: "P:/dev/CheezLang/data/log.txt"
CBC_FILE :: "p:/dev/debug_adapter_test/fac.cbc"

Breakpoint :: struct #copy {
    line : int
}

VariableRef :: trait {
    interp  : &Interpreter
    frame   : int
    name    : String
    hint    : String
    index   : int

    get_variables :: (ref Self) -> Array[Rc[VariableRef]];
}

ArgumentsScope :: struct VariableRef {

}

impl ArgumentsScope {
    new :: (interp: &Interpreter, frame: int) -> Rc[ArgumentsScope] {
        return Rc[ArgumentsScope].new(ArgumentsScope(interp, frame, "Arguments".to_string(), "arguments".to_string(), -1))
    }
}

impl VariableRef for ArgumentsScope {
    get_variables :: (ref Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := ref interp.get_stackframes()[self.frame]
        for name : stackframe.func.debug_info.parameters {
            value := stackframe.stack[stackframe.bp - it_index - 1]
            var := Variable.new(interp, frame, name.clone(), fmt.format("{}", [value]))
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

LocalsScope :: struct VariableRef {

}

impl LocalsScope {
    new :: (interp: &Interpreter, frame: int) -> Rc[LocalsScope] {
        return Rc[LocalsScope].new(LocalsScope(interp, frame, "Locals".to_string(), "locals".to_string(), -1))
    }
}

impl VariableRef for LocalsScope {
    get_variables :: (ref Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        stackframe := ref interp.get_stackframes()[self.frame]
        for name : stackframe.func.debug_info.locals {
            value := stackframe.stack[stackframe.bp + it_index]
            var := Variable.new(interp, frame, name.clone(), fmt.format("{}", [value]))
            result.add(var.clone().change_type(VariableRef))
        }
        return result
    }
}

RegistersScope :: struct VariableRef {

}

impl RegistersScope {
    new :: (interp: &Interpreter, frame: int) -> Rc[RegistersScope] {
        return Rc[RegistersScope].new(RegistersScope(interp, frame, "Registers".to_string(), "registers".to_string(), -1))
    }
}

impl VariableRef for RegistersScope {
    get_variables :: (ref Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()

        stackframe := ref interp.get_stackframes()[self.frame]

        ip := Variable.new(interp, frame, "ip".to_owned(), fmt.format("{}", [stackframe.ip]))
        result.add(ip.clone().change_type(VariableRef))
        sp := Variable.new(interp, frame, "sp".to_owned(), fmt.format("{}", [stackframe.sp]))
        result.add(sp.clone().change_type(VariableRef))
        bp := Variable.new(interp, frame, "bp".to_owned(), fmt.format("{}", [stackframe.bp]))
        result.add(bp.clone().change_type(VariableRef))

        return result
    }
}

Variable :: struct VariableRef {
    value : String
}

impl Variable {
    new :: (interp: &Interpreter, frame: int, name: String, value: String) -> Rc[Variable] {
        return Rc[Variable].new(Variable(interp, frame, name, String.empty(), -1, value))
    }
}

impl VariableRef for Variable {
    get_variables :: (ref Self) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()
        return result
    }
}

CheezDebugAdapter :: struct CommandHandler {
    interp  : &Interpreter
    mutex   : Mutex
    thread  : Thread
    running : bool
    _step   : bool

    breakpoints : Array[Breakpoint]

    break_when_fp_is_less_than  := 0
    ignore_breakpoints          := false

    variable_refs   : Array[Rc[VariableRef]]
}

impl CheezDebugAdapter {
    new :: () -> Rc[CommandHandler] {
        interp := {
            code : String = match fs.read_file(CBC_FILE) {
                Ok($content) -> content
                Err($err) -> {
                    // logger.log_error("{}", [err]) 
                    String.empty()
                }
            }

            prog := compile_program(code.slice(), CBC_FILE)
            if prog == null {
                // logger.log_error("failed to compile program")
                @assert(false)
            }
            prog.call("main")
            prog
        }

        debugger := mem.alloc(CheezDebugAdapter)
        <<debugger = CheezDebugAdapter(
            adapter = null
            interp  = interp
            mutex   = Mutex.new()
            thread  = Thread.create((p: &CheezDebugAdapter) => p.run(), debugger)
            running = false
            _step   = true
            adapter = null
            breakpoints = Array[Breakpoint].create()
            variable_refs   = Array[Rc[VariableRef]].create()
        )

        interp.printer = cast debugger.print

        debugger.thread.start()
        
        return Rc[CommandHandler].from_pointer(debugger, owned = true)
    }

    wait_for_mutex :: (ref Self) {
        mutex.lock()
        mutex.release()
    }

    print :: (ref Self, format: string, args: []&any = [], category: string = "console") {
        adapter.emit_output_event(fmt.format(format, args), category)
    }

    run :: (ref Self) {
        loop {
            if running {
                mutex.lock()
                loop {
                    if !ignore_breakpoints and breakpoints.count() > 0 {
                        frame := ref interp.get_stackframes()[interp.fp]
                        line := frame.func.debug_info.get_line_for_ip(frame.ip)
                        for breakpoint : breakpoints {
                            if breakpoint.line == line {
                                running = false
                                adapter.emit_stop_event("breakpoint")
                                break
                            }
                        }

                        if !running then break
                    } else {
                        ignore_breakpoints = false
                    }
                    if !running then break

                    match interp.step() {
                        .Done -> {
                            running = false
                            adapter.emit_terminated_event()
                            break
                        }
                    }

                    if _step {
                        running = false
                        adapter.emit_stop_event("step")
                        break
                    } else if interp.fp < break_when_fp_is_less_than {
                        break_when_fp_is_less_than = 0
                        running = false
                        adapter.emit_stop_event("step")
                        break
                    }
                }
                mutex.release()
            } else {
                Thread.sleep(10)
            }
        }
    }

    get_stackframes :: (ref Self) -> []StackFrame {
        running = false
        wait_for_mutex()
        return interp.get_stackframes()
    }

    clear_variable_refs :: (ref Self) {
        variable_refs.clear()
    }

    get_variable_reference :: (ref Self, index: int) -> ref VariableRef {
        @assert(index >= 1 and index <= variable_refs.count())
        return variable_refs[index - 1].get()
    }

    add_variable_ref :: (ref Self, var_ref: Rc[VariableRef]) -> int {
        index := variable_refs.count() + 1
        var_ref.get().index = index
        variable_refs.add(var_ref)
        return index
    }

    collect_scopes :: (ref Self, frame: int) -> Array[Rc[VariableRef]] {
        result := Array[Rc[VariableRef]].create()


        locals := LocalsScope.new(interp, frame)
        result.add(locals.clone().change_type(VariableRef))

        args := ArgumentsScope.new(interp, frame)
        result.add(args.clone().change_type(VariableRef))

        registers := RegistersScope.new(interp, frame)
        result.add(registers.clone().change_type(VariableRef))

        return result
    }
}

impl CommandHandler for CheezDebugAdapter {
    initialize :: (ref Self) -> Result[(), String] {
        adapter.emit_initialized_event()
        return Ok()
    }

    launch :: (ref Self) -> Result[(), String] {
        _step = false
        break_when_fp_is_less_than = 0
        ignore_breakpoints = false
        running = true
        return Ok()
    }

    threads :: (ref Self) -> Result[Array[DapThread], String] {
        adapter.logger.log("request threads")
        result := Array[DapThread].create()
        result.add(DapThread(0, "Main Thread".to_owned()))
        adapter.logger.log("{}", [result.slice()])
        return Ok(result)
    }

    set_breakpoints :: (ref Self, arguments: DapSetBreakpoints) -> Result[(), String] {
        self.breakpoints.clear()

        for br : arguments.breakpoints {
            self.breakpoints.add(Breakpoint(br.line - 1))
        }

        return Ok()
    }

    stacktrace :: (ref Self) -> Result[Array[DapStackFrame], String] {
        @assert(!running)

        frames := self.get_stackframes()

        stack_frames := Array[DapStackFrame].create()

        use_prev_ip := false
        for(by_ref=true, reverse=true) frame : frames {
            defer { use_prev_ip = true }
            ip := if use_prev_ip then frame.ip_prev else frame.ip
            line := frame.func.debug_info.get_line_for_ip(ip)

            adapter.logger.log("stackframe: line: {}, func: '{}', path: '{}'", [line, frame.func.name, frame.func.debug_info.path])

            stack_frames.add(DapStackFrame(
                id     = frames.length - it_index - 1
                name   = frame.func.name.clone()
                source = DapSource(
                    name = "fac.cbc".to_owned()
                    path = frame.func.debug_info.path.clone()
                )
                line   = line + 1
                column = 5 // @todo
            ))
        }

        return Ok(stack_frames)
    }

    scopes :: (ref Self, arguments: DapReqScopes) -> Result[Array[DapScope], String] {
        @assert(!running)

        frame_id := arguments.frame_id

        frame := ref self.get_stackframes()[frame_id]
        scopes_json := Array[DapScope].create()

        scopes := self.collect_scopes(frame_id)
        for scope : scopes {
            self.add_variable_ref(scope.clone().change_type(VariableRef))

            scopes_json.add(DapScope(
                variables_reference = scope.get().index
                name                = scope.get().name.clone()
                presentation_hint   = scope.get().hint.clone()
            ))
        }

        return Ok(scopes_json)
    }

    variables :: (ref Self, arguments: DapReqVariables) -> Result[Array[DapVariable], String] {
        @assert(!running)

        index := arguments.variables_reference
        variables_json := Array[DapVariable].create()

        var_ref := ref self.get_variable_reference(index)
        vars := var_ref.get_variables()
        for var : vars {
            self.add_variable_ref(var.clone())

            match ref var.get() {
                Variable($var) -> {

                    variables_json.add(DapVariable(
                        name = var.name.clone()
                        value = var.value.clone()
                        variables_reference = 0
                    ))
                }
                _ -> { @assert(false) }
            }
        }

        return Ok(variables_json)
    }

    pause :: (ref Self) -> Result[(), String] {
        running = false
        adapter.emit_stop_event("pause")
        return Ok()
    }

    resume :: (ref Self) -> Result[(), String] {
        self.clear_variable_refs()
        _step = false
        break_when_fp_is_less_than = 0
        ignore_breakpoints = true
        running = true
        return Ok()
    }

    next :: (ref Self) -> Result[(), String] {
        self.clear_variable_refs()
        running = false
        self.wait_for_mutex()
        _step = false
        break_when_fp_is_less_than = interp.fp + 1
        ignore_breakpoints = true
        running = true
        return Ok()
    }

    step_in :: (ref Self) -> Result[(), String] {
        self.clear_variable_refs()
        running = false
        self.wait_for_mutex()
        _step = true
        break_when_fp_is_less_than = 0
        ignore_breakpoints = true
        running = true
        return Ok()
    }

    step_out :: (ref Self) -> Result[(), String] {
        self.clear_variable_refs()
        running = false
        self.wait_for_mutex()
        _step = false
        break_when_fp_is_less_than = interp.fp
        ignore_breakpoints = true
        running = true
        return Ok()
    }
}

Main :: () {
    logger := Logger.new(LOG_PATH)
    logger.get().clear()

    handler := CheezDebugAdapter.new()
    adapter := DebugAdapter.new(handler, logger.get())

    adapter.get().run()

    // args_array := get_cmd_args()
    // io.formatln(args_array.slice())

    // if args_array.count() == 1 {
    //     io.println("missing arg")
    //     return
    // }

    // match fs.read_file(args_array[1].slice()) {
    //     Ok($file_content) -> {
    //         val := parse_json(JsonValue, file_content.slice())

    //         match ref val {
    //             Some($val) -> {
    //                 io.formatln("{:p}", [val])

    //                 io.println("========================")
    //                 // fs.write_file("../data/")
    //                 io.println(serialize_json_value(val))
    //             }
    //         }
    //     }

    //     Err($err) -> {
    //         io.formatln(err)
    //     }
    // }

}

// examples which are not working currently
// import examples.image_processing
// import examples.postfix
// import examples.clox.main
// import examples.lua_example

// tests
// import "tests/language/match"
// import tests.language.match3
// import tests.library.hash_table1
// import tests.other.test1
// import "examples/project_euler/018_maximum_path_sum_1"
// import bugs.bug1

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// io :: import std.io

// Foo :: struct {
//     x : int
//     y : int
//     z : int
// }

// Main :: () {
//     b := FooBuilder.new()
//     io.formatln(b)
//     f1 := FooBuilder.new().build()                      // compiler error, FooBuilder[Empty] has no method build
//     f2 := FooBuilder.new().z(1).build()                 // compiler error, FooBuilder[X] has no method build
//     f3 := FooBuilder.new().x(1).y(2).build()            // compiler error, FooBuilder[X or Y] has no method build
//     f4 := FooBuilder.new().x(1).y(2).z(3).build()       // works
//     // f4 := FooBuilder.new().y(1).x(2).z(3).x(-1).build() // works

//     // io.formatln(f4)
// }

// FooBuilder :: struct(Flags: int) {
//     _x : int = default
//     _y : int = default
//     _z : int = default
// }

// impl FooBuilder {
//     new :: () -> FooBuilder[0] {
//         return FooBuilder[0]()
//     }
// }

// impl(Flags: int) FooBuilder[Flags] {
//     x :: (Self, v: int) -> FooBuilder[@bin_or(Flags, 1)] {
//         return @expected()(v, _y, _z)
//     }
//     y :: (Self, v: int) -> FooBuilder[@bin_or(Flags, 2)] {
//         return @expected()(_x, v, _z)
//     }
//     z :: (Self, v: int) -> FooBuilder[@bin_or(Flags, 4)] {
//         return @expected()(_x, _y, v)
//     }
// }

// impl FooBuilder[7] {
//     build :: (Self) -> Foo {
//         return Foo(_x, _y, _z)
//     }
// }

// FooBuilderFlags :: enum #flags {
//     Empty, X, Y, Z
// }

// FooBuilder :: struct(Flags: FooBuilderFlags) {
//     _x : int = default
//     _y : int = default
//     _z : int = default
// }

// impl FooBuilder {
//     new :: () -> FooBuilder[FooBuilderFlags.Empty] {
//         return @expected()()
//     }
// }

// impl(Flags: FooBuilderFlags) FooBuilder[Flags] {
//     x :: (Self, v: int) -> FooBuilder[Flags or FooBuilderFlags.X] {
//         return @expected()(v, _y, _z)
//     }
//     y :: (Self, v: int) -> FooBuilder[Flags or FooBuilderFlags.Y] {
//         return @expected()(_x, v, _z)
//     }
//     z :: (Self, v: int) -> FooBuilder[Flags or FooBuilderFlags.Z] {
//         return @expected()(_x, _y, v)
//     }
// }

// impl FooBuilder[FooBuilderFlags.X or FooBuilderFlags.Y or FooBuilderFlags.Z] {
//     build :: (Self) -> Foo {
//         return Foo(_x, _y, _z)
//     }
// }

// use import std.string
// io   :: import std.io
// fmt  :: import std.fmt

// Expr :: trait {
//     id  : int
//     typ : string
//     eval :: (ref Self) -> int;
//     to_string :: (ref Self) -> String;
// }

// Const :: struct Expr {
//     value   : int
// }

// Binary :: struct Expr {
//     op      : enum #copy {Add, Sub, Mul, Div}
//     left    : &Expr
//     right   : &Expr
// }

// impl Expr for Const {
//     eval :: (ref Self) -> int {
//         return value
//     }

//     to_string :: (ref Self) -> String {
//         return fmt.format("{}:{}", [value, typ])
//     }
// }

// impl Expr for Binary {
//     eval :: (ref Self) -> int {
//         return match op {
//             .Add -> left.eval() + right.eval()
//             .Sub -> left.eval() - right.eval()
//             .Mul -> left.eval() * right.eval()
//             .Div -> left.eval() / right.eval()
//         }
//     }

//     to_string :: (ref Self) -> String {
//         l := left.to_string()
//         r := right.to_string()
//         o := match op {
//             .Add -> "+"
//             .Sub -> "-"
//             .Mul -> "*"
//             .Div -> "/"
//         }
//         return fmt.format("({}){}({}):{}", [l.slice(), o, r.slice(), typ])
//     }
// }

// Main :: () {
//     a := Const(id=0, typ="int", value=1)
//     b := Const(id=1, typ="int", value=2)
//     c := Const(id=2, typ="int", value=3)
//     d := Binary(id=3, typ="int", op = .Mul, left=&b, right=&c)
//     e := Binary(id=4, typ="int", op = .Add, left=&a, right=&d)

//     expr : &Expr = &e

//     io.println(expr.id)
//     io.println(expr.typ)
//     io.println(expr.to_string())
//     io.println(expr.eval())

// }

/*

use import std.string
use import std.printable
use import std.array
use import std.box
use import std.math
io   :: import std.io
fmt  :: import std.fmt
mem  :: import std.mem.allocator
util :: import std.util
C    :: import std.c

use import clap.clap2
use import clap.clap_printable

Command :: enum {
    #name("star")   Star
    #name("start")  Start
    #name("stop")   Stop
    #name("test")   Test    : Foo
    #name("switch") Switch  : Mode
}
Foo :: struct {
    mode   : Mode
    banana : int
    bazaza : String
    baz    : Baz
    array  := Array[string].create()
}
Baz :: struct {
    name : String
    age  : int
}
Mode :: enum {
    #name("on") On
    #name("off") Off
}

Main :: () {
    command := "test -mode of -baz -nam "
    args := Clap.tokenize(command)

    io.println("Arguments`n==========")
    for(by_ref=true) a : args {
        io.formatln(a)
    }
    io.println("==========")

    result := parse_args(@type_info(Command), args.slice())
    io.println("===")
    io.println(fmt.format_any(result))
    io.println("===")

    match ref result {
        Some($result) -> {
            match get_value(Command, result.get()) {
                Ok($result) -> io.formatln(result)
                Err($err)   -> print_error_message(command, err)
            }
        }
    }

    io.println("-------------------`n`n")

    for at : 0 .. (command.bytes.length + 1) {
        io.formatln(command)
        for 0 .. at do io.print(" ")
        io.println("^")
        auto_completions := get_auto_completions_at(@type_info(Command), result, at)
        for completion : auto_completions {
            io.formatln("> {}", [completion.slice()])
        }
        io.println("---`n")
    }
}

impl CustomParser for String {
    parse :: (args: []ClapToken, loc: Location) -> Option[Box[Expr]], []ClapToken {
        // io.println("String.parse")
        result := mem.alloc(CustomExpr)
        <<result = CustomExpr(@type_info(Self), loc, create_empty_expr(null, loc))
        if args.length == 0 {
            return Some(Box[Expr].from_pointer(cast result)), args
        }

        result.sub = create_raw_expr(result.typ, args[0])
        return Some(Box[Expr].from_pointer(cast result)), args[1..args.length]
    }

    validate :: (expr: ref CustomExpr) -> Result[(), ClapError] {
        // io.println("String.validate")
        return match ref expr.sub.get() {
            ValueExpr($v)   -> Ok(())
            EmptyExpr($v)   -> Err(ClapError(v.loc, fmt.format("Missing value for string argument", [])))
            _               -> @assert(false)
        }
    }

    get_value :: (result: &void, expr: ref CustomExpr) {
        // io.println("String.get_value")
        match ref expr.sub.get() {
            ValueExpr($v) -> {
                <<cast(&String)result = v.raw.clone()
            }

            _ -> @assert(false)
        }
    }
}

// */