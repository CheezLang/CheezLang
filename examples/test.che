// #load("examples/geometry_draw_thingy")
// #load("examples/trait_function_call_performance")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/library/stack_allocator")
// #load("tests/language/match2")

#load("std:io/io")
#load("std:array")

enum Type {
    None
    Bool
}

typedef Id = string

trait Expr {
    typ: Type
    parent: Expr
    fn debugprint(ref Self);
}

struct IdExpr {
    pub id : Id
    pub typ: Type
    pub parent: Expr
}

struct AddExpr {
    pub left: Expr
    pub parent: Expr
    pub right: Expr
    pub typ: Type
}

impl Expr for IdExpr {
    fn debugprint(ref Self) {
        print(id)
    }
}

impl Expr for AddExpr {
    fn debugprint(ref Self) {
        print("(")
        left.debugprint()
        print(" + ")
        right.debugprint()
        print(")")
    }
}

fn test() #main {
    let a = new IdExpr{typ=Type.Bool, id="a"}
    let b = new IdExpr{typ=Type.Bool, id="b"}
    let c = new AddExpr{typ=Type.Bool, left=a, right=b}
    a.parent = c
    b.parent = c


    let e: Expr = c

    a.debugprint()
    println("")
    b.debugprint()
    println("")
    c.debugprint()
    println("")

    println(int(a.typ))
    println(a.id)
    println("")

    println(int(b.typ))
    println(b.id)
    println("")

    e.debugprint()
    println("")

    println(int(e.typ))
    println("")
}

// // struct Types {
// // }

// // fn compare_ints(a: int, b: int) -> bool {
// //     return a == b
// // }

// // let pointers: Table(int, &Type)

// // impl Types {
// //     fn pointer(target: &Type) -> &Type {
// //         return match pointers.get(int(target)) {
// //             Some($v) -> v
// //             None -> {
// //                 let ptr = alloc(Type)
// //                 <<ptr = Type.Pointer(target)
// //                 pointers[int(target)] = ptr
// //                 ptr
// //             }
// //         }
// //     }
// // }

// // enum Type {
// //     Unknown
// //     Error
// //     Int     : (signed: bool, size: int)
// //     Float   : int
// //     Pointer : &Type
// // }

// // impl Printable for Type {
// //     fn print(ref Self, str: ref String, format: string) {
// //         use Self
// //         match self {
// //             Unknown -> str.append_string("<Unknown>")
// //             Error -> str.append_string("<Error>")
// //             Int(($sign, $size)) -> str.appendf("{}{}", [if sign then "i" else "u", size * 8])
// //             Float($size) -> str.appendf("f{}", [size * 8])
// //             Pointer($target) -> str.appendf("&{}", [<<target])
// //         }
// //     }
// // }

// // struct Expr {
// //     pub ty : &Type
// // }

// // fn Main() {


//     // pointers = Table(int, &Type)::create(compare_ints)
//     // let int16 = Type.Int(true, 2)
//     // let int32 = Type.Int(true, 4)
//     // let uint64 = Type.Int(false, 8)
//     // let float64 = Type.Float(8)
//     // let error = Type.Error

//     // let ptr_int16 = Types::pointer(&int16)

//     // println(int16)
//     // println(int32)
//     // println(<<ptr_int16)
//     // println(<<Types::pointer(&uint64))
//     // println(<<Types::pointer(&float64))
//     // println(<<Types::pointer(&error))
// // }