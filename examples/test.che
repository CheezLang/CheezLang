// #load("examples/geometry_draw_thingy")
// #load("examples/trait_function_call_performance")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/pathtracer")
// #load("tests/library/stack_allocator")
// #load("tests/language/match2")

#load("std:io/io")

impl Into(float) for int {
    fn into(ref Self) -> float {
        return float(self)
    }
}

// impl From(int) for float {
//     fn from(value: int) -> float {
//         return float(value)
//     }
// }

fn test2() #main {
    let a: int   = 5
    let b: float = float::from(a)
    let c: float = a::into()

    println(a)
    println(b)
    println(c)
}

trait Test {
    fn foo(ref Self);
    fn bar(Self);
    fn baz();
    fn test1(ref Self, other: Self);
    fn test2(ref Self) -> Self;
}

struct Str {
    pub a: int
}

impl Test for Str {
    fn foo(ref Self) {
        println("foo(ref Self)")
    }

    fn bar(Self) {
        println("bar(Self)")
    }

    fn baz() {
        println("baz()")
    }

    fn test1(ref Self, other: Self) {}
    fn test2(ref Self) -> Self {return new {}}
}

fn test() {
    let str = new Str{5}
    let test: Test = str

    str.foo()
    str.bar()
    // str.baz()

    println("")

    Str::foo(str)
    Str::bar(str)
    Str::baz()

    println("")

    test.foo()
    // test.bar()
    // test.baz()
    // test.test1()
    // test.test2()
}

// // struct Types {
// // }

// // fn compare_ints(a: int, b: int) -> bool {
// //     return a == b
// // }

// // let pointers: Table(int, &Type)

// // impl Types {
// //     fn pointer(target: &Type) -> &Type {
// //         return match pointers.get(int(target)) {
// //             Some($v) -> v
// //             None -> {
// //                 let ptr = alloc(Type)
// //                 <<ptr = Type.Pointer(target)
// //                 pointers[int(target)] = ptr
// //                 ptr
// //             }
// //         }
// //     }
// // }

// // enum Type {
// //     Unknown
// //     Error
// //     Int     : (signed: bool, size: int)
// //     Float   : int
// //     Pointer : &Type
// // }

// // impl Printable for Type {
// //     fn print(ref Self, str: ref String, format: string) {
// //         use Self
// //         match self {
// //             Unknown -> str.append_string("<Unknown>")
// //             Error -> str.append_string("<Error>")
// //             Int(($sign, $size)) -> str.appendf("{}{}", [if sign then "i" else "u", size * 8])
// //             Float($size) -> str.appendf("f{}", [size * 8])
// //             Pointer($target) -> str.appendf("&{}", [<<target])
// //         }
// //     }
// // }

// // struct Expr {
// //     pub ty : &Type
// // }

// // fn Main() {


//     // pointers = Table(int, &Type)::create(compare_ints)
//     // let int16 = Type.Int(true, 2)
//     // let int32 = Type.Int(true, 4)
//     // let uint64 = Type.Int(false, 8)
//     // let float64 = Type.Float(8)
//     // let error = Type.Error

//     // let ptr_int16 = Types::pointer(&int16)

//     // println(int16)
//     // println(int32)
//     // println(<<ptr_int16)
//     // println(<<Types::pointer(&uint64))
//     // println(<<Types::pointer(&float64))
//     // println(<<Types::pointer(&error))
// // }