// #load("examples/trait_function_call_performance")
// #load("examples/graphyfier/graphyfier")
// #load("examples/pathtracer2/main")
// #load("examples/geometry_draw_thingy")
// #load("examples/signed_distance_field_renderer")
// #load("compiler/main")
// #load("examples/snake/snake")
// #load("examples/pathtracer")
// #load("compiler/compiler_test")

// #load("tests/language/match3")
// #load("tests/library/arena_allocator1")
// #load("tests/other/test1")
// #load("examples/project_euler/005_smallest_multiple")


//*

#load("std:c")
#load("std:util")
#load("std:alloca")

Foo :: struct #copy {
    num : int
    bar : Bar
    baz : Baz
}

Bar :: struct #copy {
    str : string
    boo : bool
}

Baz :: enum #copy {
    A           = 353
    B : int     = 46
    C : &int    = 96
}

print_any :: (data: &void, typ: &TypeInfo) {
    match typ.kind {
        TypeInfoKind.Int($tint) -> {
            if tint.signed {
                ptr := cast(&int) data
                c_printf("%lld", <<ptr)
            } else {
                ptr := cast(&uint) data
                c_printf("%llu", <<ptr)
            }
        }

        TypeInfoKind.Float -> {
            if typ.size == 4 {
                ptr := cast(&float) data
                c_printf("%g", double(<<ptr))
            } else if typ.size == 8 {
                ptr := cast(&double) data
                c_printf("%g", <<ptr)
            } else {
                c_printf("<float: invalid size %lld>", typ.size)
            }
        }

        TypeInfoKind.Bool -> {
            ptr := cast(&bool) data
            if <<ptr then c_printf("true") else c_printf("false")
        }

        TypeInfoKind.Char -> {
            ptr := cast(&char) data
            c_printf("'%c'", <<ptr)
        }

        TypeInfoKind.Pointer($target) -> {
            ptr := cast(&&void) data
            c_printf("0x%llX", <<ptr)
        }

        TypeInfoKind.Slice($target) -> {
            if int(target.kind) == int(TypeInfoKind.Char) {
                if data == null {
                    c_printf("null")
                } else {
                    ptr := <<cast(&[]char) data
                    c_printf("`"%.*s`"", ptr.length, ptr.data)
                }
            } else {
                ptr := <<cast(&[]void) data
                c_printf("[")
                for i : 0..ptr.length {
                    if i > 0 then c_printf(", ")

                    elem := pointer_add(ptr.data, i * target.size)
                    print_any(elem, target)
                }
                c_printf("]")
            }
        }

        TypeInfoKind.Struct($tstruct) -> {
            ptr := cast(&void) data
            c_printf("%.*s", i32(tstruct.name.length), tstruct.name.data)

            c_printf("(")
            if tstruct.members.data != null {
                for i : 0..tstruct.members.length {
                    if i > 0 then c_printf(", ")
                    member_info := &tstruct.members[i]
                    member_ptr  := pointer_add(ptr, member_info.offset)
                    member_type := member_info.typ
                    c_printf("%.*s = ", i32(member_info.name.length), member_info.name.data)
                    print_any(member_ptr, member_type)
                }
            }
            c_printf(")")
        }

        TypeInfoKind.Enum($tenum) -> {
            ptr := cast(&void) data
            c_printf("%.*s.", i32(tenum.name.length), tenum.name.data)

            tag := match tenum.tag_type.size {
                1  -> int(<<cast(&u8) ptr)
                2  -> int(<<cast(&u16) ptr)
                4  -> int(<<cast(&u32) ptr)
                8  -> int(<<cast(&u64) ptr)
                $_ -> {
                    @panic("Unsupported tag size")
                    0
                }
            }

            for(by_ref=true) mem : tenum.members {
                if mem.tag == tag {
                    c_printf("%.*s", i32(mem.name.length), mem.name.data)

                    if mem.typ != null {
                        mem_val_ptr := pointer_add(ptr, tenum.tag_type.size)

                        c_printf("(")
                        print_any(mem_val_ptr, mem.typ)
                        c_printf(")")
                    }
                }
            }
        }

        $_ -> {
            c_printf("<unknown>")
        }
    }
}

print :: (data: any) {
    print_any(data.val, data.typ)
}

println :: (data: any) {
    print_any(data.val, data.typ)
    c_puts("")
}

Main :: () {
    bar := Bar("lol", true)
    foo := Foo(12345, bar, Baz.A)

    tchar      := @type_info(char)
    tint       := @type_info(int)
    tbool      := @type_info(bool)

    tstring    := @type_info(string)
    tint_slice := @type_info([]int)

    tBar       := @type_info(Bar)
    tFoo       := @type_info(Foo)

    a := 123
    b := true
    s : []int = [a, 353, 987]
    w := "lol"

    println(a)
    println(b)
    println(s)
    println(w)

    println(bar)
    println(foo)
    println(Foo(654, bar, Baz.B(420)))
    println(Foo(741, bar, Baz.C(&a)))

    println((struct{
        num       : int
        word      : string
        boolean   : bool
        floater   : double
        character : char
    })(1, "hi", false, 5.3, 'x'))

    // println(<<tBar)
}
// */