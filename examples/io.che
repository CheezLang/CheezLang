#load("string.che")
#load("memory.che")
#load("std/windows.che")
#load("string.che")

let NEW_LINE: byte = 10

fn PrintString(s: $T) {
    let s = (string)s
    let len = strlen(s)
    let bytesWritten: int
    WriteFile(__std_out_handle, s, len, &bytesWritten, 0)
}

fn PrintStringl(s: String&) {
    let bytesWritten: int
    WriteFile(__std_out_handle, (string)s.data, s.length, &bytesWritten, 0)
}

fn PrintChar(c: byte) { 
    let bytesWritten: int
    WriteFile(__std_out_handle, (string)&c, 1, &bytesWritten, 0)
}

fn PrintDigit(d: int) {
    PrintChar((byte)d + 48)
}

fn Bprinti(buffer: byte&, num: $T) {
    if (num == 0)
    {
        *buffer = 48
        return
    }

    let neg = false
    let minimum = false
    if num < 0 {
        neg = true
        num = -num

        if num < 0 {
            // num is minimum value
            num = -(num + 1)
            minimum = true
        }
    }

    let i: uint = 0
    while num != 0 {
        let lastDigit = num % 10
        if i == 0 and minimum {
            lastDigit = lastDigit + 1
        }

        num = num / 10
        buffer[i] = (byte)lastDigit + 48
        i = i - 1
    }

    if (neg) {
        buffer[i] = 45
        i = i - 1
    }
}

fn Sprint(buffer: String&, value: $T) {
    if @isbool(T) {
        if value {
            buffer.AppendString("true")
        } else {
            buffer.AppendString("false")
        }
    } else if @isint(T) {
        let v = value
        let len = 0

        if v < 0 {
            len = 1
            v = -v
        }

        while v != 0 {
            v = v / 10
            len = len + 1
        }

        let minLen = buffer.length + len
        if minLen > buffer.capacity {
            buffer.Reserve(minLen)
        }

        buffer.length = minLen

        Bprinti((byte&)((ulong)buffer.data + (ulong)minLen - 1), value)
    } else if @isstring(T) {
        buffer.AppendString(value)
    } else if @typeseq(String&, T) {
        buffer.Append(*value)
    } else if @typeseq(String, T) {
        buffer.Append(value)
    } else {
        @error("Can't print value of unknown type")
    }
}


fn SprintfData(buffer: String&, format: String, value: any) {
    if format.Equals("i8") {
        Sprint(buffer, (i8)value)
    }
    else if format.Equals("i16") {
        Sprint(buffer, (i16)value)
    }
    else if format.Equals("i32") {
        Sprint(buffer, (i32)value)
    }
    else if format.Equals("i64") {
        Sprint(buffer, (i32)value)
    }
    else if format.Equals("b") {
        Sprint(buffer, (bool)value)
    }
    else if format.Equals("s") {
        Sprint(buffer, (string)value)
    }
    else if format.Equals("S") {
        Sprint(buffer, (String&)value)
    }
}

fn Sprintf(buffer: String&, format: string, data: any) {
    let open = *"{"
    let close = *"}"

    let formatSpecifier = NewString()
    defer formatSpecifier.Dispose()
    formatSpecifier.Reserve(5)

    let len = (ulong)strlen(format)
    let i: ulong = 0
    let state = 0

    while (i < len) {
        let c = format[i]

        if state == 0 {
            if (c == open) {
                state = 1
            }
            else {
                buffer.AppendChar(c)
            }
        }
        else if state == 1 {
            if (c == close) {
                state = 0
                SprintfData(buffer, formatSpecifier, data)
                formatSpecifier.length = 0

            } else {
                formatSpecifier.data[formatSpecifier.length] = c
                formatSpecifier.length = formatSpecifier.length + 1
            }
        }

        i = i + 1
    }
}

// fn Printfn(format: string, args: any[]) {
//     let open = *"{"
//     let close = *"}"

//     let argIndex = 0

//     let formatSpecifier: byte& = Malloc(5)
//     defer Free(formatSpecifier)

//     let len = strlen(format)
//     let i = 0
//     let state = 0

//     while (i < len) {
//         let c = format[i]

//         if state == 0 {
//             if (c == open) {
//                 state = 1
//             }
//             else {
//                 PrintChar(c)
//             }
//         }
//         else if state == 1 {
//             if (c == close) {
//                 formatSpecifier[fi] = 0
//                 state = 0
//                 formatSpecifier.length = 0

//                 SprintfData(formatSpecifier, args[argIndex])
//                 argIndex = argIndex + 1
//             } else {
//                 formatSpecifier[formatSpecifier.length] = c
//                 formatSpecifier.length = formatSpecifier.length + 1
//             }
//         }


//         i = i + 1
//     }
// }

// fn Printlnf(format: string, data: any) {
//     Printf(format, data)
//     PrintChar(NEW_LINE)
// }

// fn Printlnfn(format: string, args: any[]) {
//     Printfn(format, args)
//     PrintChar(NEW_LINE)
// }

fn Println(v: $T) {
    Print(v)
    PrintChar(NEW_LINE)
}

fn Print(v: $T) {
    if @isbool(T) {
        if v {
            PrintString("true")
        } else {
            PrintString("false")
        }
    } else if @isint(T) {
        PrintInt(v)
    } else if @isstring(T) {
        PrintString(v)
    } else if @typeseq(String, T) {
        PrintStringl(&v)
    } else if @typeseq(String&, T) {
        PrintStringl(v)
    } else {
        @error("Can't print value of unknown type")
    }
}
