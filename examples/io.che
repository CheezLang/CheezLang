#load("string.che")
#load("memory.che")

fn GetStdHandle(h: int) -> int #stdcall;
fn WriteFile(handle: int, str: string, length: int, bw: int*, res: int) #stdcall;
fn ReadFile(hFile: int, lpBuffer: ubyte*, nNumberOfBytesToRead: int, lpNumberOfBytesRead: int*, lpOverlapped: ubyte*) #stdcall;
fn printf(format: string, num: int) #varargs;

// void * __enclave_config;
// need it because without it the program wont link
let #extern __enclave_config: ubyte*

let __std_in_handle: int = GetStdHandle(-10)
let __std_out_handle: int = GetStdHandle(-11)
let __std_err_handle: int = GetStdHandle(-12)

fn PrintString(s: string) {
    let len = strlen(s)
    let bytesWritten: int
    WriteFile(__std_out_handle, s, len, &bytesWritten, 0)
}

fn Println(s: string) {
    let len = strlen(s)
    let bytesWritten: int
    WriteFile(__std_out_handle, s, len, &bytesWritten, 0)
    WriteFile(__std_out_handle, "`n", 1, &bytesWritten, 0)
}

fn PrintChar(c: byte) { 
    let bytesWritten: int
    WriteFile(__std_out_handle, <string>&c, 1, &bytesWritten, 0)
}

fn clearmem(mem: byte*, len: int) {
    let i: int = 0
    while (i < len) {
        mem[i] = 0
        i = i + 1
    }
}

fn PrintDigit(d: int) {
    PrintChar(<byte>d + 48)
}

fn PrintInt(num: int) {
    if (num == 0)
    {
        PrintDigit(0)
        return
    }
    let bufferSize: int = 30
    let buff = <byte*>malloc(bufferSize)
    clearmem(buff, bufferSize)

    let neg = false
    if num < 0 {
        neg = true
        num = -num
    }

    let i: int = bufferSize - 2
    while i > 0 and num != 0 {
        let lastDigit = num % 10
        num = num / 10
        buff[i] = <byte>lastDigit + 48
        i = i - 1
    }

    if (neg) {
        buff[i] = 45
        i = i - 1
    }

    let str = <string>(<int>buff + i + 1)
    PrintString(str)

    free(<void*>buff)
}

fn PrintfData(formatSpecifier: string, data: void*) {
    let len = strlen(formatSpecifier)
    if streq(formatSpecifier, "i32") {
        let d: i32 = <i32>data
        PrintInt(d)
    }
    else if streq(formatSpecifier, "b") {
        let b = <bool><ulong>data
        if (b) {
            PrintString("true")
        } else {
            PrintString("false")
        }
    }
    else if streq(formatSpecifier, "s") {
        PrintString(<string>data)
    }
    else {
        PrintString("<Unknown format specifier: ")
        PrintString(formatSpecifier)
        PrintString(">")
    }
}

fn Printf(format: string, data: void*) {
    let open = *"{"
    let close = *"}"

    let formatSpecifier = <string>malloc(5)
    let fi: ulong = 0

    let len = <ulong>strlen(format)
    let i: ulong = 0
    let state = 0
    while (i < len) {
        let c = format[i]

        if state == 0 {
            if (c == open) {
                state = 1
            }
            else {
                PrintChar(c)
            }
        }
        else if state == 1 {
            if (c == close) {
                formatSpecifier[fi] = 0
                state = 0
                fi = 0

                PrintfData(formatSpecifier, data)

            } else {
                formatSpecifier[fi] = c
                fi = fi + 1
            }
        }


        i = i + 1
    }

    free(<void*>formatSpecifier)
}

fn Printlnf(format: string, data: void*) {
    Printf(format, data)
    Println("")
}
