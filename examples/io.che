#load("string.che")
#load("memory.che")
#load("std/windows.che")
#load("stdio.che")

let NEW_LINE: byte = 10

fn PrintString(s: $T) {
    let s = (string)s
    let len = strlen(s)
    let bytesWritten: int
    WriteFile(__std_out_handle, s, len, &bytesWritten, 0)
}

fn PrintStringl(s: String&) {
    let bytesWritten: int
    WriteFile(__std_out_handle, (string)s.data, s.length, &bytesWritten, 0)
}

fn PrintChar(c: byte) { 
    let bytesWritten: int
    WriteFile(__std_out_handle, (string)&c, 1, &bytesWritten, 0)
}

fn PrintDigit(d: int) {
    PrintChar((byte)d + 48)
}

fn PrintInt(val: $T) {
    let v = val
    let len = 0

    let neg = false
    if v < 0 {
        neg = true
        len = 1
        v = -v
    }
    else if v == 0 {
        len = 1
    }

    while v != 0 {
        v = v / 10
        len = len + 1
    }


    let buffer: String = NewString()
    defer buffer.Dispose()
    buffer.Reserve(len)

    buffer.length = len

    if (val == 0)
    {
        *buffer.data = 48
    }
    else {
        let minimum = false
        if neg and val < 0 {
            // val is minimum value
            val = -(val + 1)
            minimum = true
        }

        let i = len - 1
        while val != 0 {
            let lastDigit = val % 10
            if i == len - 1 and minimum {
                lastDigit = lastDigit + 1
            }

            val = val / 10
            buffer.data[i] = (byte)lastDigit + 48
            i = i - 1
        }

        if (neg) {
            buffer.data[i] = 45
            i = i - 1
        }
    }

    PrintStringl(&buffer)
}

fn Bprinti(buffer: String&, val: $T) {
    let v = val
    let len = 0

    let neg = false
    if v < 0 {
        neg = true
        len = 1
        v = -v
    }
    else if v == 0 {
        len = 1
    }

    while v != 0 {
        v = v / 10
        len = len + 1
    }

    if buffer.length + len > buffer.capacity {
        buffer.Reserve(buffer.length + len)
    }

    buffer.length = buffer.length + len
    
    if (val == 0)
    {
        buffer.data[buffer.length - 1] = 48
    }
    else {
        let minimum = false
        if neg and val < 0 {
            // val is minimum value
            val = -(val + 1)
            minimum = true
        }

        let i = buffer.length - 1
        while val != 0 {
            let lastDigit = val % 10
            if i == len - 1 and minimum {
                lastDigit = lastDigit + 1
            }

            val = val / 10
            buffer.data[i] = (byte)lastDigit + 48
            i = i - 1
        }

        if (neg) {
            buffer.data[i] = 45
            i = i - 1
        }
    }
}

fn Sprint(buffer: String&, value: $T) {
    if @isbool(T) {
        if value {
            buffer.AppendString("true")
        } else {
            buffer.AppendString("false")
        }
    } else if @isint(T) {
        Bprinti(buffer, value)
    } else if @isstring(T) {
        buffer.AppendString(value)
    } else if @typeseq(String&, T) {
        buffer.Append(*value)
    } else if @typeseq(String, T) {
        buffer.Append(value)
    } else {
        @error("Can't print value of unknown type")
    }
}


fn SprintfData(buffer: String&, format: String, value: any) {
    if format.Equals("i8") {
        Sprint(buffer, (i8)value)
    }
    else if format.Equals("i16") {
        Sprint(buffer, (i16)value)
    }
    else if format.Equals("i32") {
        Sprint(buffer, (i32)value)
    }
    else if format.Equals("i64") {
        Sprint(buffer, (i32)value)
    }
    else if format.Equals("b") {
        Sprint(buffer, (bool)value)
    }
    else if format.Equals("s") {
        Sprint(buffer, (string)value)
    }
    else if format.Equals("S") {
        Sprint(buffer, (String&)value)
    }
}

fn Sprintf(buffer: String&, format: string, data: any) {
    let open = *"{"
    let close = *"}"

    let formatSpecifier = NewString()
    defer formatSpecifier.Dispose()
    formatSpecifier.Reserve(5)

    let len = (ulong)strlen(format)
    let i: ulong = 0
    let state = 0

    while (i < len) {
        let c = format[i]

        if state == 0 {
            if (c == open) {
                state = 1
            }
            else {
                buffer.AppendChar(c)
            }
        }
        else if state == 1 {
            if (c == close) {
                state = 0
                SprintfData(buffer, formatSpecifier, data)
                formatSpecifier.length = 0

            } else {
                formatSpecifier.data[formatSpecifier.length] = c
                formatSpecifier.length = formatSpecifier.length + 1
            }
        }

        i = i + 1
    }
}

fn Printf(format: string, value: any) {
    let buffer = NewString()
    defer buffer.Dispose()
    buffer.Reserve(20)

    Sprintf(&buffer, format, value)
    PrintStringl(&buffer)
}

fn Println(v: $T) {
    Print(v)
    PrintChar(NEW_LINE)
}

fn Print(v: $T) {
    if @isbool(T) {
        if v {
            PrintString("true")
        } else {
            PrintString("false")
        }
    } else if @isint(T) {
        PrintInt(v)
    } else if @isstring(T) {
        PrintString(v)
    } else if @typeseq(String, T) {
        PrintStringl(&v)
    } else if @typeseq(String&, T) {
        PrintStringl(v)
    } else {
        @error("Can't print value of unknown type")
    }
}
